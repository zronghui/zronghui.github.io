<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java 虚拟机 - zronghui的博客</title><meta description="[toc]"><meta property="og:type" content="blog"><meta property="og:title" content="zronghui"><meta property="og:url" content="https://zronghui.github.io/"><meta property="og:site_name" content="zronghui"><meta property="og:description" content="[toc]"><meta property="og:image" content="https://i.loli.net/2020/03/01/Lxsrj19ucvzetiM.png# https://i.loli.net/2020/02/27/giKJ3UbFhv69o7T.jpg"><meta property="article:published_time" content="2020-01-28T02:01:33.000Z"><meta property="article:modified_time" content="2020-11-29T03:35:14.000Z"><meta property="article:author" content="removeif"><meta property="article:tag" content="Java"><meta property="article:tag" content="虚拟机"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/03/01/Lxsrj19ucvzetiM.png# https://i.loli.net/2020/02/27/giKJ3UbFhv69o7T.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zronghui.github.io/"},"headline":"zronghui","image":["https://i.loli.net/2020/03/01/Lxsrj19ucvzetiM.png#https://i.loli.net/2020/02/27/giKJ3UbFhv69o7T.jpg# https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/avatar.jpg"],"datePublished":"2020-01-28T02:01:33.000Z","dateModified":"2020-11-29T03:35:14.000Z","author":{"@type":"Person","name":"removeif"},"description":"[toc]"}</script><link rel="alternative" href="/atom.xml" title="zronghui的博客" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/wico.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://www.wntool.com/logo/image.php?output=png?fsize=35&amp;font=Snow.ttf&amp;text=zronghui&amp;mirror=No&amp;color=9933FF&amp;vcolor=3333FF&amp;bgcolor=FFFFFF&amp;alpha=yes&amp;output=png&amp;spacing=5&amp;shadow=no&amp;transparent=yes&amp;icon=no&amp;iconic=&amp;top_spacing=5&amp;left_spacing=6&amp;icon_size=48" alt="zronghui的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zronghui"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-28T02:01:33.000Z">2020-01-28</time><a class="commentCountImg" href="/java/%E5%9F%BA%E7%A1%80/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA.html#comment-container"><span class="display-none-class">73e543f5b57dbd37002e73ac806ffb49</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="73e543f5b57dbd37002e73ac806ffb49"> 99+</span>    </a><span class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/java/">java</a><span> / </span><a class="link-muted" href="/categories/java/%E5%9F%BA%E7%A1%80/">基础</a></span><span class="level-item">an hour 读完 (大约 12876 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java 虚拟机</h1><div class="content"><p>[toc]</p>
<a id="more"></a>

<h1 id="一、运行时数据区域-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-一、运行时数据区域"><a href="#一、运行时数据区域-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-一、运行时数据区域" class="headerlink" title="[一、运行时数据区域](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=一、运行时数据区域)"></a>[一、运行时数据区域](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=一、运行时数据区域)</h1><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png" alt="img" style="zoom:50%;" />



<h2 id="pc-register-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-程序计数器"><a href="#pc-register-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-程序计数器" class="headerlink" title="[pc register](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=程序计数器)"></a>[pc register](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=程序计数器)</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h2 id="JVM-stack-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-java-虚拟机栈"><a href="#JVM-stack-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-java-虚拟机栈" class="headerlink" title="[JVM stack](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=java-虚拟机栈)"></a>[JVM stack](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=java-虚拟机栈)</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png" alt="img" style="zoom:50%;" />



<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K, 而在 JDK 1.5+ 默认为1M:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展是如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h2 id="native-method-stack–本地方法栈-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-本地方法栈"><a href="#native-method-stack–本地方法栈-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-本地方法栈" class="headerlink" title="[native method stack–本地方法栈](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=本地方法栈)"></a>[native method stack–本地方法栈](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=本地方法栈)</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般使用其他语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本地硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png" alt="img" style="zoom:50%;" />



<h2 id="堆-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-堆"><a href="#堆-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-堆" class="headerlink" title="[堆](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=堆)"></a>[堆](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=堆)</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分带收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<h2 id="方法区-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-方法区"><a href="#方法区-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-方法区" class="headerlink" title="[方法区](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=方法区)"></a>[方法区](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=方法区)</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对累的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<p>？</p>
<h2 id="运行时常量池-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-运行时常量池"><a href="#运行时常量池-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-运行时常量池" class="headerlink" title="[运行时常量池](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=运行时常量池)"></a>[运行时常量池](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=运行时常量池)</h2><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译器生成的变量，还允许动态生成，例如Spring 类的 intern()</p>
<h2 id="直接内存-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-直接内存"><a href="#直接内存-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-直接内存" class="headerlink" title="[直接内存](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=直接内存)"></a>[直接内存](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=直接内存)</h2><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h1 id="二、垃圾收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-二、垃圾收集"><a href="#二、垃圾收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-二、垃圾收集" class="headerlink" title="[二、垃圾收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=二、垃圾收集)"></a>[二、垃圾收集](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=二、垃圾收集)</h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="判断一个对象是否可被回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-判断一个对象是否可被回收" class="headerlink" title="[判断一个对象是否可被回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=判断一个对象是否可被回收)"></a>[判断一个对象是否可被回收](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=判断一个对象是否可被回收)</h2><h3 id="1-引用计数算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-引用计数算法"><a href="#1-引用计数算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-引用计数算法" class="headerlink" title="[1. 引用计数算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-引用计数算法)"></a>[1. 引用计数算法](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-引用计数算法)</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对他们进行回收。正是<strong>因为循环引用的存在，因此Java虚拟机不使用引用计数算法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a与b引用的对象实例互相持有了对象的引用，因此当我们把对a对象与b对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个Test对象无法被回收。</p>
<h3 id="2-可达性分析算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-可达性分析算法"><a href="#2-可达性分析算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-可达性分析算法" class="headerlink" title="[2. 可达性分析算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-可达性分析算法)"></a>[2. 可达性分析算法](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-可达性分析算法)</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="img" style="zoom:50%;" />



<h3 id="3-方法区的回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-方法区的回收"><a href="#3-方法区的回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-方法区的回收" class="headerlink" title="[3. 方法区的回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-方法区的回收)"></a>[3. 方法区的回收](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-方法区的回收)</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要至少满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li><p>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收。</p>
</li>
<li><p>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</p>
</li>
</ul>
<h3 id="4-finalize-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-finalize"><a href="#4-finalize-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-finalize" class="headerlink" title="[4. finalize()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-finalize)"></a>[4. finalize()](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-finalize)</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h2 id="引用类型-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-引用类型"><a href="#引用类型-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-引用类型" class="headerlink" title="[引用类型](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=引用类型)"></a>[引用类型](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=引用类型)</h2><p>无论是通过引用计数算法判断对象的引用数量，还是用过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3 id="1-强引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-强引用"><a href="#1-强引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-强引用" class="headerlink" title="[1. 强引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-强引用)"></a>[1. 强引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-强引用)</h3><p>使用 new 一个新对象的方式来创建强引用。</p>
<p>被强引用关联的对象不会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h3 id="2-软引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-软引用"><a href="#2-软引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-软引用" class="headerlink" title="[2. 软引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-软引用)"></a>[2. 软引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-软引用)</h3><p>使用 SoftReference 类来创建软引用。</p>
<p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-弱引用"><a href="#3-弱引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-弱引用" class="headerlink" title="[3. 弱引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-弱引用)"></a>[3. 弱引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-弱引用)</h3><p>使用 WeakReference 类来创建弱引用。</p>
<p>被弱引用关联的对象一定会被回收，也就是说他只能存活到下一次垃圾回收发生之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-虚引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-虚引用"><a href="#4-虚引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-虚引用" class="headerlink" title="[4. 虚引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-虚引用)"></a>[4. 虚引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-虚引用)</h3><p>使用 PhantomReference 来创建虚引用。</p>
<p>虚引用又被称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象创建虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集算法"><a href="#垃圾收集算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集算法" class="headerlink" title="[垃圾收集算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集算法)"></a>[垃圾收集算法](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=垃圾收集算法)</h2><h3 id="1-标记-清除-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-标记-清除"><a href="#1-标记-清除-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-标记-清除" class="headerlink" title="[1. 标记 - 清除](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-标记-清除)"></a>[1. 标记 - 清除](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-标记-清除)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="img" style="zoom:50%;" />



<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会分割为 size 与 (block - size) 两部分，返回 size 大小的分块，并把大小为 block-size 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="2-标记-整理-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-标记-整理"><a href="#2-标记-整理-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-标记-整理" class="headerlink" title="[2. 标记 - 整理](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-标记-整理)"></a>[2. 标记 - 整理](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-标记-整理)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="img" style="zoom:50%;" />



<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3 id="3-复制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-复制"><a href="#3-复制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-复制" class="headerlink" title="[3. 复制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-复制)"></a>[3. 复制](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-复制)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="img" style="zoom:50%;" />

<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次整理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10%的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间 分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-分代收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-分代收集"><a href="#4-分代收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-分代收集" class="headerlink" title="[4. 分代收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-分代收集)"></a>[4. 分代收集](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-分代收集)</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记-清除算法 或者 标记-整理算法</li>
</ul>
<h2 id="垃圾收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集器"><a href="#垃圾收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集器" class="headerlink" title="[垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集器)"></a>[垃圾收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=垃圾收集器)</h2><p>?</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"  />



<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 是并行的，其他垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="1-Serial-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-serial-收集器"><a href="#1-Serial-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-serial-收集器" class="headerlink" title="[1. Serial 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-serial-收集器)"></a>[1. Serial 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-serial-收集器)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="img"  />



<p>特点：<strong>串行</strong> 单线程</p>
<p>优点：简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="2-ParNew-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-parnew-收集器"><a href="#2-ParNew-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-parnew-收集器" class="headerlink" title="[2. ParNew 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-parnew-收集器)"></a>[2. ParNew 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-parnew-收集器)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="img"  />

<p>它是 Serial 收集器的多线程版本。</p>
<p>特点：多线程 <strong>串行</strong></p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="3-Parallel-Scavenge-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-parallel-scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-parallel-scavenge-收集器" class="headerlink" title="[3. Parallel Scavenge 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-parallel-scavenge-收集器)"></a>[3. Parallel Scavenge 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-parallel-scavenge-收集器)</h3><p><strong>并行</strong></p>
<p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="4-Serial-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-serial-old-收集器"><a href="#4-Serial-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-serial-old-收集器" class="headerlink" title="[4. Serial Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-serial-old-收集器)"></a>[4. Serial Old 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-serial-old-收集器)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="img"  />



<p><strong>串行</strong></p>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="5-Parallel-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-parallel-old-收集器"><a href="#5-Parallel-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-parallel-old-收集器" class="headerlink" title="[5. Parallel Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-parallel-old-收集器)"></a>[5. Parallel Old 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_5-parallel-old-收集器)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img"  />



<p><strong>并行</strong></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-6-cms-收集器"><a href="#6-CMS-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-6-cms-收集器" class="headerlink" title="[6. CMS 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_6-cms-收集器)"></a>[6. CMS 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_6-cms-收集器)</h3><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img"  />



<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3 id="7-G1-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-7-g1-收集器"><a href="#7-G1-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-7-g1-收集器" class="headerlink" title="[7. G1 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_7-g1-收集器)"></a>[7. G1 收集器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_7-g1-收集器)</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img" style="zoom: 67%;" />



<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img" style="zoom:50%;" />



<p>将整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img"  />



<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h1 id="三、内存分配与回收策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-三、内存分配与回收策略"><a href="#三、内存分配与回收策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-三、内存分配与回收策略" class="headerlink" title="[三、内存分配与回收策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=三、内存分配与回收策略)"></a>[三、内存分配与回收策略](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=三、内存分配与回收策略)</h1><h2 id="Minor-GC-和-Full-GC-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-minor-gc-和-full-gc"><a href="#Minor-GC-和-Full-GC-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-minor-gc-和-full-gc" class="headerlink" title="[Minor GC 和 Full GC](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=minor-gc-和-full-gc)"></a>[Minor GC 和 Full GC](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=minor-gc-和-full-gc)</h2><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h2 id="内存分配策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-内存分配策略"><a href="#内存分配策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-内存分配策略" class="headerlink" title="[内存分配策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=内存分配策略)"></a>[内存分配策略](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=内存分配策略)</h2><h3 id="1-对象优先在-Eden-分配-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-对象优先在-eden-分配"><a href="#1-对象优先在-Eden-分配-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-对象优先在-eden-分配" class="headerlink" title="[1. 对象优先在 Eden 分配](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-对象优先在-eden-分配)"></a>[1. 对象优先在 Eden 分配](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-对象优先在-eden-分配)</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="2-大对象直接进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-大对象直接进入老年代" class="headerlink" title="[2. 大对象直接进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-大对象直接进入老年代)"></a>[2. 大对象直接进入老年代](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-大对象直接进入老年代)</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="3-长期存活的对象进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-长期存活的对象进入老年代" class="headerlink" title="[3. 长期存活的对象进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-长期存活的对象进入老年代)"></a>[3. 长期存活的对象进入老年代](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-长期存活的对象进入老年代)</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-动态对象年龄判定-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-动态对象年龄判定"><a href="#4-动态对象年龄判定-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-动态对象年龄判定" class="headerlink" title="[4. 动态对象年龄判定](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-动态对象年龄判定)"></a>[4. 动态对象年龄判定](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-动态对象年龄判定)</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-空间分配担保"><a href="#5-空间分配担保-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-空间分配担保" class="headerlink" title="[5. 空间分配担保](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-空间分配担保)"></a>[5. 空间分配担保](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_5-空间分配担保)</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="Full-GC-的触发条件-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-full-gc-的触发条件"><a href="#Full-GC-的触发条件-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-full-gc-的触发条件" class="headerlink" title="[Full GC 的触发条件](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=full-gc-的触发条件)"></a>[Full GC 的触发条件](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=full-gc-的触发条件)</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="1-调用-System-gc-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-调用-systemgc"><a href="#1-调用-System-gc-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-调用-systemgc" class="headerlink" title="[1. 调用 System.gc()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-调用-systemgc)"></a>[1. 调用 System.gc()](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-调用-systemgc)</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="2-老年代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-老年代空间不足"><a href="#2-老年代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-老年代空间不足" class="headerlink" title="[2. 老年代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-老年代空间不足)"></a>[2. 老年代空间不足](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-老年代空间不足)</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="3-空间分配担保失败-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-空间分配担保失败"><a href="#3-空间分配担保失败-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-空间分配担保失败" class="headerlink" title="[3. 空间分配担保失败](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-空间分配担保失败)"></a>[3. 空间分配担保失败](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-空间分配担保失败)</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3 id="4-JDK-1-7-及以前的永久代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-jdk-17-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-jdk-17-及以前的永久代空间不足" class="headerlink" title="[4. JDK 1.7 及以前的永久代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-jdk-17-及以前的永久代空间不足)"></a>[4. JDK 1.7 及以前的永久代空间不足](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-jdk-17-及以前的永久代空间不足)</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="5-Concurrent-Mode-Failure-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-concurrent-mode-failure"><a href="#5-Concurrent-Mode-Failure-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-concurrent-mode-failure" class="headerlink" title="[5. Concurrent Mode Failure](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-concurrent-mode-failure)"></a>[5. Concurrent Mode Failure](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_5-concurrent-mode-failure)</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="四、类加载机制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-四、类加载机制"><a href="#四、类加载机制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-四、类加载机制" class="headerlink" title="[四、类加载机制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=四、类加载机制)"></a>[四、类加载机制](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=四、类加载机制)</h1><p>类是在运行期间第一次使用是动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="类的生命周期-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类的生命周期"><a href="#类的生命周期-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类的生命周期" class="headerlink" title="[类的生命周期](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类的生命周期)"></a>[类的生命周期](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=类的生命周期)</h2><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png" alt="img" style="zoom: 50%;" />



<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="类加载过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载过程"><a href="#类加载过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载过程" class="headerlink" title="[类加载过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载过程)"></a>[类加载过程](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=类加载过程)</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="1-加载-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-加载"><a href="#1-加载-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-加载" class="headerlink" title="[1. 加载](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-加载)"></a>[1. 加载](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-加载)</h3><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h3 id="2-验证-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-验证"><a href="#2-验证-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-验证" class="headerlink" title="[2. 验证](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-验证)"></a>[2. 验证](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-验证)</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="3-准备-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-准备"><a href="#3-准备-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-准备" class="headerlink" title="[3. 准备](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-准备)"></a>[3. 准备](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-准备)</h3><p>类变量是被 static 修饰的变量，准备阶段<strong>为类变量分配内存并设置初始值</strong>，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-解析-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-解析"><a href="#4-解析-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-解析" class="headerlink" title="[4. 解析](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-解析)"></a>[4. 解析](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_4-解析)</h3><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。</p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类初始化时机-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类初始化时机"><a href="#类初始化时机-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类初始化时机" class="headerlink" title="[类初始化时机](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类初始化时机)"></a>[类初始化时机](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=类初始化时机)</h2><h3 id="1-主动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-主动引用"><a href="#1-主动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-主动引用" class="headerlink" title="[1. 主动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-主动引用)"></a>[1. 主动引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-主动引用)</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li>
</ul>
<h3 id="2-被动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-被动引用"><a href="#2-被动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-被动引用" class="headerlink" title="[2. 被动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-被动引用)"></a>[2. 被动引用](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-被动引用)</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h2 id="类与类加载器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类与类加载器"><a href="#类与类加载器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类与类加载器" class="headerlink" title="[类与类加载器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类与类加载器)"></a>[类与类加载器](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=类与类加载器)</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="类加载器分类-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载器分类"><a href="#类加载器分类-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载器分类" class="headerlink" title="[类加载器分类](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载器分类)"></a>[类加载器分类](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=类加载器分类)</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</li>
<li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" alt="img" style="zoom:50%;" />



<h3 id="1-工作过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-工作过程"><a href="#1-工作过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-工作过程" class="headerlink" title="[1. 工作过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-工作过程)"></a>[1. 工作过程](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_1-工作过程)</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h3 id="2-好处-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-好处"><a href="#2-好处-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-好处" class="headerlink" title="[2. 好处](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-好处)"></a>[2. 好处](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_2-好处)</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h3 id="3-实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-实现"><a href="#3-实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-实现" class="headerlink" title="[3. 实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-实现)"></a>[3. 实现](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=_3-实现)</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类加载器实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-自定义类加载器实现"><a href="#自定义类加载器实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-自定义类加载器实现" class="headerlink" title="[自定义类加载器实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=自定义类加载器实现)"></a>[自定义类加载器实现](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 虚拟机?id=自定义类加载器实现)</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="JVM的4种垃圾回收算法、垃圾回收机制与总结"><a href="#JVM的4种垃圾回收算法、垃圾回收机制与总结" class="headerlink" title="JVM的4种垃圾回收算法、垃圾回收机制与总结"></a><a href="https://aijishu.com/a/1060000000080557">JVM的4种垃圾回收算法、垃圾回收机制与总结</a></h1><p><a href="https://aijishu.com/t/java">Java</a><a href="https://aijishu.com/t/learning">学习分享</a></p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h4><h5 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1.标记清除"></a><strong>1.标记清除</strong></h5><p>标记-清除算法将垃圾回收分为两个阶段：<strong>标记阶段和清除阶段</strong>。</p>
<p>在标记阶段首先通过<strong>根节点(GC Roots)</strong>，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。</p>
<p><img src="https://aijishu.com/img/bVu7n" alt="img"></p>
<p><strong>适用场合：</strong></p>
<ul>
<li>存活对象较多的情况下比较高效</li>
<li>适用于年老代（即旧生代）</li>
</ul>
<p><strong>缺点：</strong></p>
<p>容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收<br>扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）</p>
<h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a><strong>2.复制算法</strong></h5><p>从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉</p>
<p><img src="https://aijishu.com/img/bVu7o" alt="img"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代。</p>
<p><strong>适用场合：</strong></p>
<ul>
<li>存活对象较少的情况下比较高效</li>
<li>扫描了整个空间一次（标记存活对象并复制移动）</li>
<li><strong>适用于年轻代（即新生代）：</strong>基本上98%的对象是”朝生夕死”的，存活下来的会很少</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要一块儿空的内存空间</li>
<li>需要复制移动对象</li>
</ul>
<h5 id="3-标记整理"><a href="#3-标记整理" class="headerlink" title="3.标记整理"></a><strong>3.标记整理</strong></h5><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。</p>
<p>这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p>
<p><img src="https://aijishu.com/img/bVu7p" alt="img"></p>
<p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。</p>
<p>首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<h4 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a><strong>4.分代收集算法</strong></h4><p><strong>分代收集算法就是目前虚拟机使用的回收算法</strong>，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。</p>
<p>在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。</p>
<p><img src="https://aijishu.com/img/bVu7q" alt="img"></p>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a><strong>垃圾回收机制</strong></h4><p>年轻代分为Eden区和survivor区（两块儿：from和to），且Eden:from:to==8:1:1。</p>
<p><img src="https://aijishu.com/img/bVu7r" alt="img"></p>
<p>jvm内存结构</p>
<p>1）新产生的对象优先分配在Eden区（除非配置了-XX:PretenureSizeThreshold，大于该值的对象会直接进入年老代）；</p>
<p>2）当Eden区满了或放不下了，这时候其中存活的对象会复制到from区。</p>
<p><img src="https://aijishu.com/img/bVu7s" alt="file"></p>
<p>3）之后产生的对象继续分配在Eden区，当Eden区又满了或放不下了，这时候将会把Eden区和from区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉Eden区和from区的所有内存。</p>
<p>4）如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：-XX:MaxTenuringThreshold来配置），就会进入年老代了。</p>
<p>5）当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）。</p>
<h4 id="垃圾回收有两种类型：Minor-GC-和-Full-GC。"><a href="#垃圾回收有两种类型：Minor-GC-和-Full-GC。" class="headerlink" title="垃圾回收有两种类型：Minor GC 和 Full GC。"></a><strong>垃圾回收有两种类型：Minor GC 和 Full GC。</strong></h4><h5 id="1-Minor-GC"><a href="#1-Minor-GC" class="headerlink" title="1.Minor GC"></a><strong>1.Minor GC</strong></h5><p>对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</p>
<h5 id="2-Full-GC"><a href="#2-Full-GC" class="headerlink" title="2.Full GC"></a><strong>2.Full GC</strong></h5><p>也叫<br>Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor<br>GC要慢，因此应该尽可能减少Full GC的次数，导致Full<br>GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p>
<p><img src="https://aijishu.com/img/bVmkZ" alt="file"></p>
<h4 id="垃圾回收算法总结"><a href="#垃圾回收算法总结" class="headerlink" title="垃圾回收算法总结"></a><strong>垃圾回收算法总结</strong></h4><h5 id="1-年轻代：复制算法"><a href="#1-年轻代：复制算法" class="headerlink" title="1.年轻代：复制算法"></a><strong>1.年轻代：复制算法</strong></h5><p>1) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>
<p>2)<br>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个<br>Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，<br>如此往复。</p>
<p>3) 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。</p>
<p>4) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p>
<h5 id="2-年老代：标记-清除或标记-整理"><a href="#2-年老代：标记-清除或标记-整理" class="headerlink" title="2.年老代：标记-清除或标记-整理"></a><strong>2.年老代：标记-清除或标记-整理</strong></h5><p>1) 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>2) 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<p>以上这种年轻代与年老代分别采用不同回收算法的方式称为”分代收集算法”，这也是当下企业使用的一种方式</p>
<ol>
<li>每一种算法都会有很多不同的垃圾回收器去实现，在实际使用中，根据自己的业务特点做出选择就好。</li>
</ol>
</div><div class="article-tags size-small is-uppercase mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zronghui.github.io/java/%E5%9F%BA%E7%A1%80/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA.html">Java 虚拟机</a></li><li><strong>本文作者：</strong><a href="https://zronghui.github.io">zronghui</a></li><li><strong>本文链接：</strong><a href="https://zronghui.github.io/java/%E5%9F%BA%E7%A1%80/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA.html">https://zronghui.github.io/java/基础/Java-虚拟机.html</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/Leetcode%20weekly%20contest/biweekly-contest-22.html" target="_blank">biweekly-contest-22</a><br></span><span>  2.<a class="is-size-6" href="/leetcode/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/%E9%9D%A2%E8%AF%95%E9%A2%98-01-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5.html" target="_blank">面试题 01.07 旋转矩阵</a><br></span><span>  3.<a class="is-size-6" href="/Chrome/chrome-%E6%8F%92%E4%BB%B6.html" target="_blank">chrome 插件</a><br></span><span>  4.<a class="is-size-6" href="/Leetcode%20weekly%20contest/biweekly-contest-23.html" target="_blank">biweekly-contest-23</a><br></span><span>  5.<a class="is-size-6" href="/Leetcode%20weekly%20contest/weekly-contest-180.html" target="_blank">weekly-contest-180</a><br></span></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://i.loli.net/2020/03/05/MeFCknt1wipKvRA.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://i.loli.net/2020/03/05/MVJrxG3gO6qHSiz.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/java/other/Dubbo%E9%9D%A2%E8%AF%9528%E9%A2%98%E7%AD%94%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AD%89.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Dubbo面试28题答案详解：核心功能+服务治理+架构设计等</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/java/%E5%9F%BA%E7%A1%80/Java-%E5%B9%B6%E5%8F%91.html"><span class="level-item">Java 并发</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.6.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '73e543f5b57dbd37002e73ac806ffb49',
            repo: 'blog_comment',
            owner: 'zronghui',
            clientID: 'f1c7f9da01111d2e7163',
            clientSecret: '3aaaf709bd8edda1f4c57484cceba5fad5218978',
            admin: ["zronghui"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" id="toc-item-一、运行时数据区域-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-一、运行时数据区域" href="#一、运行时数据区域-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-一、运行时数据区域"><span>[一、运行时数据区域](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;一、运行时数据区域)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-pc-register-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-程序计数器" href="#pc-register-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-程序计数器"><span>[pc register](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;程序计数器)</span></a></li><li><a class="is-flex" id="toc-item-JVM-stack-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-java-虚拟机栈" href="#JVM-stack-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-java-虚拟机栈"><span>[JVM stack](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;java-虚拟机栈)</span></a></li><li><a class="is-flex" id="toc-item-native-method-stack–本地方法栈-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-本地方法栈" href="#native-method-stack–本地方法栈-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-本地方法栈"><span>[native method stack–本地方法栈](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;本地方法栈)</span></a></li><li><a class="is-flex" id="toc-item-堆-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-堆" href="#堆-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-堆"><span>[堆](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;堆)</span></a></li><li><a class="is-flex" id="toc-item-方法区-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-方法区" href="#方法区-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-方法区"><span>[方法区](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;方法区)</span></a></li><li><a class="is-flex" id="toc-item-运行时常量池-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-运行时常量池" href="#运行时常量池-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-运行时常量池"><span>[运行时常量池](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;运行时常量池)</span></a></li><li><a class="is-flex" id="toc-item-直接内存-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-直接内存" href="#直接内存-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-直接内存"><span>[直接内存](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;直接内存)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-二、垃圾收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-二、垃圾收集" href="#二、垃圾收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-二、垃圾收集"><span>[二、垃圾收集](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;二、垃圾收集)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-判断一个对象是否可被回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-判断一个对象是否可被回收" href="#判断一个对象是否可被回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-判断一个对象是否可被回收"><span>[判断一个对象是否可被回收](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;判断一个对象是否可被回收)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-引用计数算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-引用计数算法" href="#1-引用计数算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-引用计数算法"><span>[1. 引用计数算法](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-引用计数算法)</span></a></li><li><a class="is-flex" id="toc-item-2-可达性分析算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-可达性分析算法" href="#2-可达性分析算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-可达性分析算法"><span>[2. 可达性分析算法](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-可达性分析算法)</span></a></li><li><a class="is-flex" id="toc-item-3-方法区的回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-方法区的回收" href="#3-方法区的回收-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-方法区的回收"><span>[3. 方法区的回收](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-方法区的回收)</span></a></li><li><a class="is-flex" id="toc-item-4-finalize-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-finalize" href="#4-finalize-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-finalize"><span>[4. finalize()](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-finalize)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-引用类型-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-引用类型" href="#引用类型-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-引用类型"><span>[引用类型](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;引用类型)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-强引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-强引用" href="#1-强引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-强引用"><span>[1. 强引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-强引用)</span></a></li><li><a class="is-flex" id="toc-item-2-软引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-软引用" href="#2-软引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-软引用"><span>[2. 软引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-软引用)</span></a></li><li><a class="is-flex" id="toc-item-3-弱引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-弱引用" href="#3-弱引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-弱引用"><span>[3. 弱引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-弱引用)</span></a></li><li><a class="is-flex" id="toc-item-4-虚引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-虚引用" href="#4-虚引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-虚引用"><span>[4. 虚引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-虚引用)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-垃圾收集算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集算法" href="#垃圾收集算法-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集算法"><span>[垃圾收集算法](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;垃圾收集算法)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-标记-清除-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-标记-清除" href="#1-标记-清除-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-标记-清除"><span>[1. 标记 - 清除](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-标记-清除)</span></a></li><li><a class="is-flex" id="toc-item-2-标记-整理-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-标记-整理" href="#2-标记-整理-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-标记-整理"><span>[2. 标记 - 整理](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-标记-整理)</span></a></li><li><a class="is-flex" id="toc-item-3-复制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-复制" href="#3-复制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-复制"><span>[3. 复制](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-复制)</span></a></li><li><a class="is-flex" id="toc-item-4-分代收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-分代收集" href="#4-分代收集-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-分代收集"><span>[4. 分代收集](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-分代收集)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-垃圾收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集器" href="#垃圾收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-垃圾收集器"><span>[垃圾收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;垃圾收集器)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-Serial-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-serial-收集器" href="#1-Serial-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-serial-收集器"><span>[1. Serial 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-serial-收集器)</span></a></li><li><a class="is-flex" id="toc-item-2-ParNew-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-parnew-收集器" href="#2-ParNew-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-parnew-收集器"><span>[2. ParNew 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-parnew-收集器)</span></a></li><li><a class="is-flex" id="toc-item-3-Parallel-Scavenge-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-parallel-scavenge-收集器" href="#3-Parallel-Scavenge-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-parallel-scavenge-收集器"><span>[3. Parallel Scavenge 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-parallel-scavenge-收集器)</span></a></li><li><a class="is-flex" id="toc-item-4-Serial-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-serial-old-收集器" href="#4-Serial-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-serial-old-收集器"><span>[4. Serial Old 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-serial-old-收集器)</span></a></li><li><a class="is-flex" id="toc-item-5-Parallel-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-parallel-old-收集器" href="#5-Parallel-Old-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-parallel-old-收集器"><span>[5. Parallel Old 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_5-parallel-old-收集器)</span></a></li><li><a class="is-flex" id="toc-item-6-CMS-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-6-cms-收集器" href="#6-CMS-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-6-cms-收集器"><span>[6. CMS 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_6-cms-收集器)</span></a></li><li><a class="is-flex" id="toc-item-7-G1-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-7-g1-收集器" href="#7-G1-收集器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-7-g1-收集器"><span>[7. G1 收集器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_7-g1-收集器)</span></a></li></ul></li></ul></li><li><a class="is-flex" id="toc-item-三、内存分配与回收策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-三、内存分配与回收策略" href="#三、内存分配与回收策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-三、内存分配与回收策略"><span>[三、内存分配与回收策略](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;三、内存分配与回收策略)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-Minor-GC-和-Full-GC-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-minor-gc-和-full-gc" href="#Minor-GC-和-Full-GC-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-minor-gc-和-full-gc"><span>[Minor GC 和 Full GC](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;minor-gc-和-full-gc)</span></a></li><li><a class="is-flex" id="toc-item-内存分配策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-内存分配策略" href="#内存分配策略-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-内存分配策略"><span>[内存分配策略](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;内存分配策略)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-对象优先在-Eden-分配-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-对象优先在-eden-分配" href="#1-对象优先在-Eden-分配-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-对象优先在-eden-分配"><span>[1. 对象优先在 Eden 分配](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-对象优先在-eden-分配)</span></a></li><li><a class="is-flex" id="toc-item-2-大对象直接进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-大对象直接进入老年代" href="#2-大对象直接进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-大对象直接进入老年代"><span>[2. 大对象直接进入老年代](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-大对象直接进入老年代)</span></a></li><li><a class="is-flex" id="toc-item-3-长期存活的对象进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-长期存活的对象进入老年代" href="#3-长期存活的对象进入老年代-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-长期存活的对象进入老年代"><span>[3. 长期存活的对象进入老年代](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-长期存活的对象进入老年代)</span></a></li><li><a class="is-flex" id="toc-item-4-动态对象年龄判定-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-动态对象年龄判定" href="#4-动态对象年龄判定-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-动态对象年龄判定"><span>[4. 动态对象年龄判定](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-动态对象年龄判定)</span></a></li><li><a class="is-flex" id="toc-item-5-空间分配担保-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-空间分配担保" href="#5-空间分配担保-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-空间分配担保"><span>[5. 空间分配担保](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_5-空间分配担保)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-Full-GC-的触发条件-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-full-gc-的触发条件" href="#Full-GC-的触发条件-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-full-gc-的触发条件"><span>[Full GC 的触发条件](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;full-gc-的触发条件)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-调用-System-gc-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-调用-systemgc" href="#1-调用-System-gc-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-调用-systemgc"><span>[1. 调用 System.gc()](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-调用-systemgc)</span></a></li><li><a class="is-flex" id="toc-item-2-老年代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-老年代空间不足" href="#2-老年代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-老年代空间不足"><span>[2. 老年代空间不足](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-老年代空间不足)</span></a></li><li><a class="is-flex" id="toc-item-3-空间分配担保失败-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-空间分配担保失败" href="#3-空间分配担保失败-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-空间分配担保失败"><span>[3. 空间分配担保失败](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-空间分配担保失败)</span></a></li><li><a class="is-flex" id="toc-item-4-JDK-1-7-及以前的永久代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-jdk-17-及以前的永久代空间不足" href="#4-JDK-1-7-及以前的永久代空间不足-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-jdk-17-及以前的永久代空间不足"><span>[4. JDK 1.7 及以前的永久代空间不足](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-jdk-17-及以前的永久代空间不足)</span></a></li><li><a class="is-flex" id="toc-item-5-Concurrent-Mode-Failure-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-concurrent-mode-failure" href="#5-Concurrent-Mode-Failure-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-5-concurrent-mode-failure"><span>[5. Concurrent Mode Failure](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_5-concurrent-mode-failure)</span></a></li></ul></li></ul></li><li><a class="is-flex" id="toc-item-四、类加载机制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-四、类加载机制" href="#四、类加载机制-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-四、类加载机制"><span>[四、类加载机制](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;四、类加载机制)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-类的生命周期-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类的生命周期" href="#类的生命周期-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类的生命周期"><span>[类的生命周期](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;类的生命周期)</span></a></li><li><a class="is-flex" id="toc-item-类加载过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载过程" href="#类加载过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载过程"><span>[类加载过程](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;类加载过程)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-加载-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-加载" href="#1-加载-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-加载"><span>[1. 加载](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-加载)</span></a></li><li><a class="is-flex" id="toc-item-2-验证-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-验证" href="#2-验证-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-验证"><span>[2. 验证](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-验证)</span></a></li><li><a class="is-flex" id="toc-item-3-准备-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-准备" href="#3-准备-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-准备"><span>[3. 准备](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-准备)</span></a></li><li><a class="is-flex" id="toc-item-4-解析-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-解析" href="#4-解析-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-4-解析"><span>[4. 解析](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_4-解析)</span></a></li><li><a class="is-flex" id="toc-item-5-初始化" href="#5-初始化"><span>5. 初始化</span></a></li></ul></li><li><a class="is-flex" id="toc-item-类初始化时机-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类初始化时机" href="#类初始化时机-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类初始化时机"><span>[类初始化时机](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;类初始化时机)</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-主动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-主动引用" href="#1-主动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-主动引用"><span>[1. 主动引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-主动引用)</span></a></li><li><a class="is-flex" id="toc-item-2-被动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-被动引用" href="#2-被动引用-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-被动引用"><span>[2. 被动引用](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-被动引用)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-类与类加载器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类与类加载器" href="#类与类加载器-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类与类加载器"><span>[类与类加载器](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;类与类加载器)</span></a></li><li><a class="is-flex" id="toc-item-类加载器分类-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载器分类" href="#类加载器分类-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-类加载器分类"><span>[类加载器分类](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;类加载器分类)</span></a></li><li><a class="is-flex" id="toc-item-双亲委派模型" href="#双亲委派模型"><span>双亲委派模型</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-1-工作过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-工作过程" href="#1-工作过程-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-1-工作过程"><span>[1. 工作过程](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_1-工作过程)</span></a></li><li><a class="is-flex" id="toc-item-2-好处-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-好处" href="#2-好处-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-2-好处"><span>[2. 好处](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_2-好处)</span></a></li><li><a class="is-flex" id="toc-item-3-实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-实现" href="#3-实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-3-实现"><span>[3. 实现](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;_3-实现)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-自定义类加载器实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-自定义类加载器实现" href="#自定义类加载器实现-https-cyc2018-github-io-CS-Notes-notes-Java-虚拟机-id-自定义类加载器实现"><span>[自定义类加载器实现](https:&amp;#x2F;&amp;#x2F;cyc2018.github.io&amp;#x2F;CS-Notes&amp;#x2F;#&amp;#x2F;notes&amp;#x2F;Java 虚拟机?id&amp;#x3D;自定义类加载器实现)</span></a></li></ul></li><li><a class="is-flex" id="toc-item-JVM的4种垃圾回收算法、垃圾回收机制与总结" href="#JVM的4种垃圾回收算法、垃圾回收机制与总结"><span>JVM的4种垃圾回收算法、垃圾回收机制与总结</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" id="toc-item-2-年老代：标记-清除或标记-整理" href="#2-年老代：标记-清除或标记-整理"><span>2.年老代：标记-清除或标记-整理</span></a></li></ul></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://i.loli.net/2020/02/27/giKJ3UbFhv69o7T.jpg" alt="zronghui"></figure><p class="title is-size-4 is-block line-height-inherit">zronghui</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">582</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">48</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zronghui" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zronghui"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-12-01T14:15:50.000Z">2020-12-01</time></p><p class="title is-6"><a class="link-muted" href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AMySQL8-cookbook%E3%80%8B-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html">《MySQL8 cookbook》 阅读笔记</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-29T14:16:28.000Z">2020-11-29</time></p><p class="title is-6"><a class="link-muted" href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B.html">《Redis 设计与实现》</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-29T14:16:13.000Z">2020-11-29</time></p><p class="title is-6"><a class="link-muted" href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AMongoDB-%E5%AE%9E%E6%88%98%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html">《MongoDB 实战》阅读笔记</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-29T14:15:56.000Z">2020-11-29</time></p><p class="title is-6"><a class="link-muted" href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ALinux-Shell-%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html">《Linux Shell 脚本攻略》阅读笔记</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-29T07:52:12.000Z">2020-11-29</time></p><p class="title is-6"><a class="link-muted" href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-MYSQL45%E8%AE%B2-%E7%AC%94%E8%AE%B0.html">极客时间-MYSQL45讲-笔记</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Chrome/"><span class="level-start"><span class="level-item">Chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Leetcode-weekly-contest/"><span class="level-start"><span class="level-item">Leetcode weekly contest</span></span><span class="level-end"><span class="level-item tag">41</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/blockchain/"><span class="level-start"><span class="level-item">blockchain</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/docker-k8s/"><span class="level-start"><span class="level-item">docker k8s</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/frontEnd/"><span class="level-start"><span class="level-item">frontEnd</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">40</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/java/Collections/"><span class="level-start"><span class="level-item">Collections</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag is-grey-lightest">35</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tree/"><span class="tag">Tree</span><span class="tag is-grey-lightest">34</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dynamic-Programming/"><span class="tag">Dynamic Programming</span><span class="tag is-grey-lightest">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Binary-Search/"><span class="tag">Binary Search</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hash-Table/"><span class="tag">Hash Table</span><span class="tag is-grey-lightest">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Depth-first-Search/"><span class="tag">Depth-first Search</span><span class="tag is-grey-lightest">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Math/"><span class="tag">Math</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Two-Pointers/"><span class="tag">Two Pointers</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linked-List/"><span class="tag">Linked List</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stack/"><span class="tag">Stack</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Backtracking/"><span class="tag">Backtracking</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Heap/"><span class="tag">Heap</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Breadth-first-Search/"><span class="tag">Breadth-first Search</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tricks/"><span class="tag">tricks</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Design/"><span class="tag">Design</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bit-Manipulation/"><span class="tag">Bit Manipulation</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sort/"><span class="tag">Sort</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Divide-and-Conquer/"><span class="tag">Divide and Conquer</span><span class="tag is-grey-lightest">5</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=zronghui&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="zronghui" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://www.wntool.com/logo/image.php?output=png?fsize=35&amp;font=Snow.ttf&amp;text=zronghui&amp;mirror=No&amp;color=9933FF&amp;vcolor=3333FF&amp;bgcolor=FFFFFF&amp;alpha=yes&amp;output=png&amp;spacing=5&amp;shadow=no&amp;transparent=yes&amp;icon=no&amp;iconic=&amp;top_spacing=5&amp;left_spacing=6&amp;icon_size=48" alt="zronghui的博客" height="28"></a><p class="size-small"><span>&copy; 2020 zronghui</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif" target="_blank">removeif</a> <br>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="https://zronghui.github.io/message/" target="_blank">留言</a>，立即处理]<br><script type="text/javascript" src="/js/statistics.js"></script><span id="statistic-times"></span><br></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zronghui"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-Hans");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://zronghui.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/comment-issue-data.js" defer></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>