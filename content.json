{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"}],"posts":[{"title":"test","text":"","link":"/test.html"},{"title":"Mac/Mac-config-backup-plan","text":"","link":"/Mac/Mac-config-backup-plan.html"},{"title":"frontEnd/Vue-js基础入门Vue实战黑马程序员VUE","text":"","link":"/frontEnd/Vue-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8Vue%E5%AE%9E%E6%88%98%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98VUE.html"},{"title":"frontEnd/es6","text":"","link":"/frontEnd/es6.html"},{"title":"Mac/mpv-配置","text":"","link":"/Mac/mpv-%E9%85%8D%E7%BD%AE.html"},{"title":"mac apps","text":"[toc] Port ManagerPort Manager for Mac — Manage ports from your menu bar 要翻墙？ Collection: System Tools Use your menu bar to find, open and kill ports in a couple of clicks. View all of your ports in one place, so you can go back to writing code. MouselessCollection: Productivity Apps Mouseless combines a searchable database of thousands of shortcuts (conveniently detecting what app you are currently using) and a training feature that helps you learn and remember those shortcuts. VISIT 待破解 @homeCollection: Security Apps This menu bar app keeps your Mac unlocked while you are at home. It knows when you are at home (based on your wireless network name) and prevents your computer from locking the screen. VISIT AirfloCollection: Misc &amp; Others This menu bar provides real-time air quality anywhere in the world. VISIT SimplePingCollection: System Tools Check your internet connection quality directly in the menu bar. The ping updates in realtime. VISIT Unite for MacOSCollection: Menu Bar Managers Unite 2 allows you to turn any website into a menu bar app, permitting easy access to any service whenever you need it. VISIT WATCH TypeetoCollection: Productivity Apps Typeeto enables you to use your Mac keyboard as a bluetooth keyboard for other devices such as iPad, iPhone, Apple TV, Android device, etc. VISIT VanishCollection: Productivity Apps Hide or close inactive apps after a period of time. Set a custom time for each application and this menu bar app will hide/close the application if it hasn’t been activated for that period of time. VISIT 类似软件：hocus focus? Speedtest for MacCollection: System Tools Launching a Speedtest straight from your Mac menu bar is the quickest way to check your connectivity. VISIT ClarityCollection: Design Apps Minimal Mac wallpapers right in your menu bar. VISIT PingBarCollection: System Tools PingBar keeps an eye on your server. It will ping your server periodically, and show you the delay in the menubar. App store BidbarCollection: System Tools With Bidbar, all your Terminal commands are at your finger tips, just a click of a button or a tap of a key away. VISIT WATCH 待破解 PingeyCollection: Menu Bar Managers Pingey sits in the menu bar. Click on the icon to see the status of all your websites. Or add separate menu bar items for your most important sites. VISIT RearviewCollection: Security Apps This menu bar app tells you if someone (behind your back) is staring at your screen. For instance a passenger reading your emails when travelling by train. It plays a sound when more than one face is detected. VISITMenu Launcher Collection: Files &amp; Folders/ Productivity Apps This menu bar app lets you launch any file, folder and apps from one single place. No more cluttered desktop, dock or system status menu bar. VISIT 待破解 Hacker PadCollection: Note Taking Apps Hacker Pad lives in the menu bar for quick access. It allows especially developers to quickly jot down ideas and snippets. VISIT Keyboard LockerCollection: Security Apps A menu bar app that locks and unlocks your keyboard and mouse. No more worrying about your cat messing up everything while you’re away. VISIT SuperbarCollection: Menu Bar Managers Superbar allows you to bring snippets, bookmarks, apps or system commands into your menu bar. VISIT AccessMenuBarAppsCollection: Menu Bar Managers AccessMenuBarApps removes the problem of viewing menu bar icons on laptop displays. This utility allows you to expand your menu bar when you need it. VISIT WATCH JettisonCollection: System Tools Jettison automatically ejects exter","link":"/Mac/mac-apps.html"},{"title":"frontEnd/front-end-tricks-202002","text":"","link":"/frontEnd/front-end-tricks-202002.html"},{"title":"jquery复习","text":"样式篇 第1章 初识jQuery1&lt;script type=\"text/javascript\" src=\"./static/lib/jquery.js\"&gt; 1234// $(document).ready() 的作用是等文档的节点都加载完毕后再执行后续的代码$(document).ready(function(){ $(\"div\").html(\"hello jquery\");}); 1-4 jQuery对象与DOM对象1234567// 标准js处理var p = document.getElementById('imooc');p.innerHTML = 'adsfas';p.style.color = 'red';// jquery处理var $p = $('#imooc');$p.html('adsfaf').css('color', 'red'); 1-5 jQuery对象转化成DOM对象12345678var $div = $('div')var div = $div[0] // jquery对象转dom对象// 或者 var div = $div.get(0)div.style.color = 'red'// 1-6 DOM对象转化成jQuery对象var $div = $(div); // $(dom)var $first = $div.first() 第2章 jQuery选择器jQuery 参考手册 - 选择器 2-1 id选择器1$(\"#id\") 2-2 类选择器1$(\".class\") 2-3 元素选择器12$(\"p\")document.getElementsByTagName('div') 2-4 全选择器（*选择器）1$(\"*\") 2-5 层级选择器12345678// 子元素选择器$(\"parent &gt; child\")// 后代元素选择器$(\"ancestor descendant\")// 相邻兄弟元素选择器$(\"prev + next\")// 一般兄弟元素选择器$(\"prev ~ siblings\") 2-7 基本筛选选择器1234567891011121314$(\".div:first\")$(\":first\") // 匹配第一个元素$(\":last\") // 匹配最后一个元素$(\":not(selector)\") //一个用来过滤的选择器,选择所有元素去除不匹配给定的选择器元素$(\":eq(index)\")// 在匹配的集合中选择索引值为 index的元素$(\":gt(index)\") // 选择匹配集合中所有大于给定 index(索引值)的元素$(\":even\") // 选择索引值为偶数的元素,从0开始计数$(\":odd\") // 选择索引值为奇数的元素,从O开始计数$(\":lt(index\")// 选择匹配集合中所有索引值小于给定 index参数的元素$(\":header\")// 选择所有标题元素,像h1h2,h3等$(\":lang(language)\")// 选择指定语言的所有元素$(\":root\") // 选择该文档的根元素$(\":animated\") // 选择所有正在执行动画效果的元素 2-8 内容筛选选择器1234567$(\":contains(text)\") //选择所有包含指定 文本 的元素$(\":parent\") // 选择所有含有子元素或者文本的元素(即非空)$(\":empty\") // 选择所有没有子元素的元素(包含文本节点)$(\":has(selector\")) // 选择元素中至少包含指定 选择器 的元素// 1) :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素// 2) 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。// 3):parent与:empty是相反的，两者所涉及的子元素，包括文本节点 2-9 可见性筛选选择器12$(\":visible\") // 选择所有现实的元素$(\":hidden\") // 选择所有隐藏的元素 2-10 属性筛选选择器12345678910$(\"[attribute]\") // 选择所有具有指定属性的元素$(\"[attribute='value']\") // 选择指定属性是给定值的元素$(\"[attribute^='value']\") // 选择指定属性是以给定字符串开始的元素$(\"[attribute$='value']\") //选择指定属性是以给定值结尾的元素,这个比较是区分大小写的$(\"[attribute!='value']\") // 选择不存在指定属性,或者指定的属性值不等于给定值的元素$(\"[attribute|=value]\") // 选择指定属性值等于给定字符串或以该文字串为前缀(该字符串后跟一个连字符\"-\")的元素$(\"[attribute*='value']\") // 选择指定属性具有包含一个给定的子字符串的元素(选择给定的属性是以包含某些值的元素)$(\"[attribute-='value']\") // 选择指定属性用空格分隔的值中包含一个给定值的元素$(\"[attributeFilter1][attributeFilterN]\") //选择匹配所有指定的属性筛选器的元素 2-11 子元素筛选选择器1234567// 选择所有父级元素的第一个子元素$(\":first-child\")$(\":last-child\")$(\":only-child\")$(\":nth-child(n)\")$(\":nth-last-child(n)\")// :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) 2-12 表单元素选择器12345678910$(\":input\") // 选择所有 input, textarea, select和 button元素$(\":text\") // 匹配所有文本框$(\":password\") // 匹配所有密码框$(\":radio\") // 匹配所有单选按钮$(\":checkbox\") // 匹配所有复选框$(\":submit\") // 匹配所有提交按钮$(\":image\")// 匹配所有图像域$(\":reset\") // 匹配所有重置按钮$(\":button\") // 匹配所有按钮$(\":file\") // 匹配所有文件域 2-13 表单对象属性筛选选择器1234$(\":enabled\") // 选取可用的表单元素$(\":disabled\") // 选取不可用的表单元素$(\":checked\") // 选取被选中的&lt;input&gt;元素$(\":selected\") // 选取被选中的&lt;option&gt;元素 第3章 jQuery的属性与样式12345678910111213141516171819202122232425262728293031323334// 3-1 .attr()与.remov...attr(key) 获取key属性值attr(key, value) 设置attr(attributes) // attrs: {key1: val1, key2:val2}.removeAttr(attributeName) // 3-2 html()及.text().html() 获取.html(htmlString) 设置.text().text(textString)// 3-3 .val()// 获取、设置表单元素的值.val().val(value)// 3-4 增加样式.addClass().addClass(className) // 为每个匹配元素增加一个或多个样式名// 3-5 删除样式.removeClass().removeClass([className]) // 每个匹配元素移除一个或多个用空格隔开的样式名// 3-6 切换样式.toggleCla....toggleClass(className) //如果存在（不存在）就删除（添加）一个类// 3-7 样式操作.css()// 获取.css(propertyName) // 获取匹配元素集合中的第一个元素的样式属性的计算值.css(propertyNames) // 传递一组数组，返回一个对象结果// 设置.css(propertyName, value ) // 设置CSS.css(properties) // 可以传一个对象，同时设置多个样式 DOM篇第2章 DOM节点的创建2-1 DOM创建节点及节点属性创建元素：document.createElement设置属性：setAttribute添加文本：innerHTML加入文档：appendChild 2-2 jQuery节点创建与属性的处理1$(\"&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;\") 第3章 DOM节点的插入3-1 DOM内部插入append()与appendTo()b加到a中: 12a.append(b) b.appendTo(a) 3-2 DOM外部插入after()与before()3-3 DOM内部插入prepend()与prependTo()3-4 DOM外部插入insertAfter()与insertBefore()第4章 DOM节点的删除4-1 DOM节点删除之empty()的基本用法1$('.hello').empty() 4-2 DOM节点删除之remove()的有参用法和无参用法12$('.hello').remove()$(\"p\").filter(\":contains('3')\").remove() 4-3 DOM节点删除之empty和remove区别 empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点 该节点与该节点所包含的所有后代节点将同时被删除; 提供传递一个筛选的表达式，删除指定合集中的元素 4-4 DOM节点删除之保留数据的删除操作detach()detach()不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 第5章 DOM节点的复制与替换5-1 DOM拷贝clone().clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。clone(ture) 不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了 5-2 DOM替换replaceWith()和replaceAll()二者方向相反 ```js$(“p:eq","link":"/frontEnd/jquery%E5%A4%8D%E4%B9%A0.html"},{"title":"frontEnd/nodejs-helloworld","text":"","link":"/frontEnd/nodejs-helloworld.html"},{"title":"frontEnd/js-script","text":"","link":"/frontEnd/js-script.html"},{"title":"vue.js2.5基础入门视频教程-慕课网","text":"1-1 课程介绍.mp4vue官方文档 2-1 创建第一个Vue实例.mp412345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;hello {{msg}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\" } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-2 挂载点，模版与实例.mp4挂载点、模板、实例之间的关系vue中的el确定挂载点。模板：挂载点里面的全部内容，可以直接写，也可以在Vue里面添加template 123456789101112131415&lt;!-- &lt;div id=\"root\"&gt;--&gt;&lt;!-- &lt;h1&gt;hello {{msg}}&lt;/h1&gt;--&gt;&lt;!-- &lt;/div&gt;--&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", template: '&lt;h1&gt;hello {{msg}}&lt;/h1&gt;', data: { msg: \"world\" } })&lt;/script&gt; 2-3 Vue实例中的数据,事件和方法.mp4插值表达式 a在 new Vue({data: {a: 123}}) 中定义 12345&lt;h1&gt;{{a}}&lt;/h1&gt;使用a-text也可实现同样的效果&lt;h1 a-text=\"a\"&gt;&lt;/h1&gt;或&lt;h1 a-html=\"content\"&gt;&lt;/h1&gt; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--添加点击事件--&gt; &lt;!--添加方法1--&gt; &lt;div id=\"root\" @click=\"handleClick\"&gt; &lt;!--添加方法2--&gt;&lt;!-- &lt;div id=\"root\" v-on:click=\"handleClick\"&gt;--&gt; {{msg}} &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\" }, methods:{ //定义方法 handleClick: function(){ this.msg=\"hello\"; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-4 Vue中的属性绑定和双向数据绑定.mp41234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div title=\"this is title1\"&gt;hello world&lt;/div&gt;&lt;!--属性绑定--&gt;&lt;!-- 方法1：--&gt;&lt;!-- &lt;div v-bind:title=\"title\"&gt;hello world&lt;/div&gt;--&gt;&lt;!-- 方法2（缩写，更常用）：--&gt; &lt;div :title=\"title\"&gt;hello world&lt;/div&gt;&lt;!-- 双向数据绑定--&gt;&lt;!-- 对比，单向：:value --&gt;&lt;!-- &lt;input :value=\"content\"&gt;--&gt;&lt;!-- 对比，双向 v-model --&gt; &lt;input v-model=\"content\"&gt; &lt;div&gt;{{content}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\", title: \"this is title2\", content: \"content\" }, methods:{ } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-5 Vue中的计算属性和侦听器.mp41234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; 姓: &lt;input v-model=\"firstName\"&gt; 名: &lt;input v-model=\"lastName\"&gt; &lt;div&gt;{{firstName}} {{lastName}}&lt;/div&gt; &lt;div&gt;{{fullName}}&lt;/div&gt; &lt;div&gt;{{count}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { firstName: '', lastName: '', count: 0, }, // 计算属性 computed:{ fullName: function () { return this.firstName + ' ' + this.lastName } }, // 监听器 watch: { lastName: function () { this.count ++; }, firstName: function () { this.count ++; } }, methods:{ } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-6 v-if, v-show与v-for指令.mp4123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;!-- v-if 删除或添加元素--&gt; &lt;div v-if=\"show\"&gt;hello world&lt;/div&gt;&lt;!-- v-show 隐藏或显示元素--&gt; &lt;div v-show=\"show\"&gt;hello world&lt;/div&gt; &lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;!-- v-for --&gt; &lt;ul&gt; &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt; &lt;li v-for=\"(item, index) of list\" key=\"index\"&gt;{{index}} {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { show: true, list: [1, 1, 3, 4, 5], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{ toggle: function () { this.show = !this.show } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3-1 todolist功能开发.mp41234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div&gt; &lt;input v-model=\"thing\"&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { thing: \"\", list: [], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{ submit: function () { if (this.thing.trim()===\"\") return; this.list.push(this.thing); // append 失败 // this.list.append(this.thing); this.thing = \"\"; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3-2 todolist组件拆分-1.5.mp4&lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt; &lt;div&gt; &lt;input v-model=\"thing\"&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 3. 属性传值 --&gt; &lt;todo-item v-for=\"(item, index) of list\" :key=\"index\" :content=\"item\"&gt;全局组件&lt;/todo-item&gt; &lt;!-- &lt;todo-item1&gt;局部组件&lt;/todo-item1&gt;--&gt; &lt;!-- &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt;--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; &lt;!--全局组件--&gt; // 注册后即可直接在HTML中使用 Vue.component('todo-item', { // 1. 定义属性 props: ['content'], // 2. 使用属性 template: '&lt;li&gt;{{content}}&lt;/li&gt;' }); //局部组件 // 声明后，在Vue中添加components // var todoItem = { // template: '&lt;li&gt;item&lt;/li&gt;' // }; new Vue({ el: \"#root\", // components: { // 'todo-item1': todoItem, // }, data: { thing: \"\", list: [], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{","link":"/frontEnd/vue-js2-5%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-%E6%85%95%E8%AF%BE%E7%BD%91.html"},{"title":"frontEnd/vue","text":"","link":"/frontEnd/vue.html"},{"title":"go/go入门及资源网址","text":"","link":"/go/go%E5%85%A5%E9%97%A8%E5%8F%8A%E8%B5%84%E6%BA%90%E7%BD%91%E5%9D%80.html"},{"title":"golang projects","text":"[toc] 一. 开发工具1)sql2go用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。http://stming.cn/tool/sql2go.html 2)toml2go用于将编码后的 toml 文本转换问 golang 的 struct.https://xuri.me/toml-to-go/ 3)curl2go用来将 curl 命令转化为具体的 golang 代码.https://mholt.github.io/curl-to-go/ 4)json2go用于将 json 文本转换为 struct.https://mholt.github.io/json-to-go/ 5)mysql 转 ES 工具http://www.ischoolbar.com/EsParser/ 6)golang模拟模板的工具，在支持泛型之前，可以考虑使用。https://github.com/cheekybits/genny 7)查看某一个库的依赖情况，类似于 go list 功能https://github.com/KyleBanks/depth 8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。https://github.com/mholt/archiver 9)go 内置命令go list 可以查看某一个包的依赖关系.go vet 可以检查代码不符合 golang 规范的地方。 10)热编译工具https://github.com/silenceper/gowatch 11)revivegolang 代码质量检测工具https://github.com/mgechev/revive 12)Go Callvisgolang 的代码调用链图工具https://github.com/TrueFurby/go-callvis 13)Realize开发流程改进工具https://github.com/oxequa/realize 14)Gotests自动生成测试用例工具https://github.com/cweill/gotests 二.调试工具1)perf代理工具，支持内存，cpu，堆栈查看，并支持火焰图.perf 工具和 go-torch 工具，快捷定位程序问题.https://github.com/uber-archive/go-torchhttps://github.com/google/gops 2)dlv 远程调试基于 goland+dlv 可以实现远程调式的能力.https://github.com/go-delve/delve提供了对 golang 原生的支持，相比 gdb 调试，简单太多。 3)网络代理工具goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.https://github.com/snail007/goproxy 4)抓包工具go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.基于这个工具，我们开发了 qapp 协议的抓包。https://github.com/40t/go-sniffer 5)反向代理工具，快捷开放内网端口供外部使用。ngrok 可以让内网服务外部调用https://ngrok.com/https://github.com/inconshreveable/ngrok 6)配置化生成证书从根证书，到业务侧证书一键生成.https://github.com/cloudflare/cfssl 7)免费的证书获取工具基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。https://github.com/Neilpang/acme.sh 8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。vagrant常被拿来同 docker 相比，值得拥有。https://github.com/hashicorp/vagrant 9)轻量级容器调度工具nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.https://github.com/hashicorp/nomad 10)敏感信息和密钥管理工具https://github.com/hashicorp/vault 11)高度可配置化的 http 转发工具，基于 etcd 配置。https://github.com/gojek/weaver 12)进程监控工具 supervisorhttps://www.jianshu.com/p/39b476e808d8 13)基于procFile进程管理工具. 相比 supervisor 更加简单。https://github.com/ddollar/foreman 14)基于 http，https，websocket 的调试代理工具，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.https://github.com/avwo/whistle 15)分布式调度工具https://github.com/shunfei/cronsun/blob/master/README_ZH.mdhttps://github.com/ouqiang/gocron 16)自动化运维平台 Gaiahttps://github.com/gaia-pipeline/gaia 三. 网络工具 四. 常用网站go 百科全书: https://awesome-go.com/json 解析: https://www.json.cn/出口 IP: https://ipinfo.io/redis 命令: http://doc.redisfans.com/ES 命令首页: https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.htmlUrlEncode: http://tool.chinaz.com/Tools/urlencode.aspxBase64: https://tool.oschina.net/encrypt?type=3Guid: https://www.guidgen.com/常用工具: http://www.ofmonkey.com/ 五. golang 常用库日志https://github.com/Sirupsen/logrushttps://github.com/uber-go/zap 配置兼容 json，toml，yaml，hcl 等格式的日志库.https://github.com/spf13/viper 存储mysql https://github.com/go-xorm/xormes https://github.com/elastic/elasticsearchredis [https://github.com/gomodule/redigo](https://link.zhihu.com/?target=https%3A//gith","link":"/go/golang-projects.html"},{"title":"go学习笔记1","text":"从Java到Golang快速入门flysnow.org/2016/12/28/from-java-to-golang.html Hello World12345package mainimport \"fmt\"func main() { fmt.Println(\"Hello, 世界\")} 整段代码非常简洁，关键字、函数、包等和Java非常相似，不过注意，go是不需要以;(分号)结尾的。 变量1var age int =10 最后面的赋值可以在声明的时候忽略，这样变量就有一个默认的值，称之为零值。零值是一个统称，以类型而定，比如int类型的零值为0，string类型的零值是”“空字符串。 1age := 10 使用这种方式，变量的类型由go根据值推导出来，比如这里默认是int。 常量1const age = 10 大小写标记访问权限在go中不能随便使用大小写的问题，是因为大小写具有特殊意义，在go中，大些字母开头的变量或者函数等是public的，可以被其他包访问；小些的则是private的，不能被其他包访问到。这样就省去了public和private声明的烦恼，使代码变的更简洁。 包包的规则和java很像，每个包都有自己独立的空间，所以可以用来做模块化，封装，组织代码等。 和java不同的是，go的包里可以有函数，比如我们常用的fmt.Println(),但是在在java中没有这种用法，java的方法必须是属于一个类或者类的实例的。 如果我们需要导入多个包的时候，可以像java一样，一行行导入，也可以使用快捷方式一次导入，这个是java所没有的。 123456import ( \"io\" \"log\" \"net\" \"strconv\") 类型转换go对于变量的类型有严格的限制，不同类型之间的变量不能进行赋值、表达式等操作，必须要要转换成同一类型才可以，比如int32和int64两种int类型的变量不能直接相加，要转换成一样才可以。 123var a int32 = 13var b int64 = 20c := int64(a) + b 这种限制主要是防止我们误操作，导致一些莫名其妙的问题。在java中因为有自动转型的概念，所以可以不同类型的可以进行操作，比如int可以和double相加，int类型可以通过+和字符串拼接起来，这些在go中都是不可行的。 mapmap类型，Java里是Map接口，go里叫做字典，因为其常用，在go中，被优化为一个语言上支持的结构，原生支持，就像一个关键字一样，而不是java里的要使用内置的sdk集合库，比如HashMap等。 12345678910ages := make(map[string]int)ages[\"linday\"] = 20ages[\"michael\"] = 30fmt.Print(ages[\"michael\"])delete(ages,\"michael\")for name,age := range ages { fmt.Println(\"name:\",name,\",age:\",age)} 函数方法在go中，函数和方法是不一样的，我们一般称包级别的(直接可以通过包调用的)称之为函数，比如fmt.Println()；把和一个类型关联起来的函数称之为方法，如下示例： 12345678910111213141516package libimport \"time\"type Person struct { age int name string}func (p Person) GetName() string { return p.name}func GetTime() time.Time{ return time.Now()} 其中GetTime()可以通过lib.GetTime()直接调用，称之为函数；而GetName()则属于Person这个结构体的函数，只能声明了Person类型的实例后才可以调用，称之为方法。 123func GetTime() (time.Time,error){ return time.Now(),nil} 多值返回也很简单，返回的值使用逗号隔开即可。如果要接受多值的返回，也需要以逗号分隔的变量，有几个返回值，就需要几个变量，比如这里： 123now,err:=GetTime()now,_:=GetTime() 指针Go的指针和C中的声明定义是一样的，其作用类似于Java引用变量效果。 1234var age int = 10var p *int = &amp;age*p = 11fmt.Println(age) 结构体1234type Person struct { age int name string} Go中的结构体是不能定义方法的，只能是变量，这点和Java不一样的,如果要访问结构体内的成员变量，通过.操作符即可。 123func (p Person) GetName() string { return p.name} 这就是通过.操作符访问变量的方式，同时它也是一个为结构体定义方法的例子，和函数不一样的是，在func关键字后要执行该方法的接收者，这个方法就是属于这个接收者，例子中是Person这个结构体。 在Go中如果想像Java一样，让一个结构体继承另外一个结构体怎么办？也有办法，不过在Go中称之为组合或者嵌入。 123456789type Person struct { age int name string Address}type Address struct { city string} 结构体Address被嵌入了Person中，这样Person就拥有了Address的变量和方法，就想自己的一样，这就是组合的威力。通过这种方式，我们可以把简单的对象组合成复杂的对象，并且他们之间没有强约束关系，Go倡导的是组合，而不是继承、多态。 接口Go的接口和Java类型，不过它不需要强制实现，在Go中，如果你这个类型（基本类型，结构体等都可以）拥有了接口的所有方法，那么就默认为这个类型实现了这个接口，是隐式的，不需要和java一样，强制使用implement强制实现。 1234567type Stringer interface { String() string}func (p Person) String() string { return \"name is \"+p.name+\",age is \"+strconv.Itoa(p.age)} 以上实例中可以看到，Person这个结构体拥有了fmt.Stringer接口的方法，那么就说明Person实现了fmt.Stringer接口。 接口也可以像结构体一样组合嵌套，这里不再赘述。 并发Go并发主要靠go goroutine支持，也称之为go协程或者go程，他是语言层面支持的，非常轻量级的多任务支持，也可以把他简单的理解为java语言的线程，不过是不一样的。 两个goroutine可以通过channel来通信，channel是一个特殊的类型，也是go语言级别上的支持，他类似于一个管道，可以存储信息，也可以从中读取信息。 12345678910111213141516package mainimport \"fmt\"func main() { result:=make(chan int) go func() { sum:=0 for i:=0;i&lt;10;i++{ sum=sum+i } result&lt;-sum }() fmt.Print(&lt;-result)} 以上示例使用一个单独的goroutine求和，当得到结果时，存放在result这个chan里，然后供main goroutine读取出来。当result没有被存储值的时候，读取result是阻塞的，所以会等到结果返回，协同工作，通过chan通信。 对于并发，go还提供了一套同步机制，都在sync包里，有锁，有一些常用的工具函数等，和java的concurrent框架差不多。 异常机制相比java的Exception来说，go有两种机制，不过最常用的还是error错误类型，panic只用于严重的错误。 123type error interface { Error() string} go内置的error类型非常简洁，只用实现Error方法即可，可以打印一些详细的错误信息，比如常见的函数多值返回，最后一个返回值经常是error，用于传递一些错误问题，这种方式要比java throw Exception的方法更优雅。 Defer代替finallygo中没有java的finally了，那么如果我们要关闭一些一些连接，文件流等怎么办呢，为此go为我们提供了defer关键字，这样就可以保证永远被执行到，也就不怕关闭不了连接了。 123f,err:=os.Open(filename)defer f.Close()readAll(f) 统一编码风格在编码中，我们有时为了是否空行，大括号是否独占一行等编码风格问题争论不休，到了Go这里就终止了，因为go是强制的，比如花括号不能独占一行，比如定义的变量必须使用，否则就不能编译通过。 第二种就是go fmt这个工具提供的非强制性规范，虽然不是强制的，不过也建议使用，这样整个团队的代码看着就像一个人写的。很多go代码编辑器都提供保存时自动gofmt格式的话，所以效率也非常高。 便捷的部署go最终生成的是一个可执行文件，不管你的程序依赖多少库，都会被打包进行，","link":"/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html"},{"title":"go/go学习笔记2","text":"","link":"/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.html"},{"title":"go/go换源加速下载","text":"","link":"/go/go%E6%8D%A2%E6%BA%90%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD.html"},{"title":"Java tricks","text":"[toc] 02-17AssertJ一分钟入门 - 简书 02-14PatMartin/Dex: Dex : The Data Explorer – A data visualization tool written in Java/Groovy/JavaFX capable of powerful ETL and publishing web visualizations. 02-09写 Excel wordJava POI Excel - Java代码实例™Java POI Word - Java代码实例™ 写pdfJava iText示例 - Java代码实例™ 读 PDF XML HTMLApache Tika示例 - Java代码实例™ 目录 文件处理Java目录 - Java代码实例™ 了解如何在Java编程中访问和操作目录。下面是有关Java编程中访问和操作目录最常用的例子 - 示例 如何递归创建目录？ 如何删除目录？ 如何确定一个目录是否为空？ 如何确定目录是否隐藏？ 如何打印目录层次结构？ 如何打印目录的最后修改时间？ 如何获取文件的父目录？ 如何搜索目录中的所有文件？ 如何获取目录的大小？ 如何遍历目录？ 如何查找当前工作目录？ 如何在系统中显示根目录？ 如何在目录中搜索文件？ 如何显示目录中的所有文件？ 如何显示目录中的所有目录？ Java文件 - Java代码实例™ 了解如何使用Java编程中的文件操作。下面是常用的一些例子 - 示例 如何比较两个文件的路径？ 如何创建新文件？ 如何获取文件的最后修改日期？ 如何在指定的目录中创建文件？ 如何检查文件是否存在？ 如何设置文件为只读？ 如何重命名文件？ 如何获取文件大小(以字节为单位)？ 如何更改文件的最后修改时间？ 如何创建一个临时文件？ 如何向现有文件中附加一个字符串？ 如何将一个文件复制到另一个文件？ 如何删除文件？ 如何读取一个文件？ 如何写入一个文件？ 2020年1月20日(星期一)JMeter 官网地址 ：https://jmeter.apache.org Apache JMeter是Apache组织开发的基于Java的压力测试工具 是的就是用来压测的，你怎么模拟很多请求呀，就用它就对了。 2020 年 1 月 15 日可以提高千倍效率的Java代码小技巧 - 51CTO.COM程序员必须搞懂的20个Java类库和API - 51CTO.COM一、日志相关类库Log4j 、 SLF4j 和 LogBack应该熟悉日志记录的利弊， 并且了解为什么 SLF4J 要比 Log4J 要好 二、JSON 解析库Jackson 和 Gson 三、单元测试库常见的单测框架有 JUnit , Mockito 和 PowerMock 。 四、通用类库例如 Apache Commons 和 Google Guava。 五、Http 库Apache HttpClient 和 HttpCore 等开源类库 六、XML 解析库市面上有很多 XML 解析的类库，如 Xerces , JAXB , JAXP , Dom4j , Xstream 等。Xerces2是下一代高性能，完全兼容的 XML 解析工具。Xerces2 定义了 Xerces Native Interface (XNI)规范，并提供了一个完整、兼容标准的 XNI 规范实现。该解析器是完全重新设计和实现的，更简单以及模块化。 七、Excel 读写库Apache POI API 八、字节码库javassist 、Cglib Nodep 、 ASM 。Javassist 使得 Java 字节码操作非常简单。它是一个为编辑 Java 字节码而生的类库。 九、数据库连接池库Commons Pool 和 DBCP 十、消息传递库Java 提供了 JMS Java 消息服务，但这不是 JDK 的一部分，你需要单独的引入 jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。 十一、PDF 处理库iText 和 Apache FOP 类库 十二、日期和时间库Java 8 自带 十三、集合类库虽然 JDK 有丰富的集合类，但还是有很多第三方类库可以提供更多更好的功能。如 Apache Commons Collections 、 Goldman Sachs collections 、 Google Collections 和 Trove 。Trove 尤其有用，因为它提供所有标准 Collections 类的更快的版本以及能够直接在原语(primitive)(例如包含 int 键或值的 Map 等)上操作的 Collections 类的功能。FastUtil是另一个类似的 API，它继承了 Java Collection Framework，提供了数种特定类型的容器，包括映射 map、集合 set、列表 list、优先级队列(prority queue)，实现了 java.util 包的标准接口(还提供了标准类所没有的双向迭代器)，还提供了很大的(64 位)的 array、set、list，以及快速、实用的二进制或文本文件的 I/O 操作类。 十四、邮件 APIjavax.mail 和 Apache Commons Email 提供了发送邮件的 API。它们建立在 JavaMail API 的基础上，提供简化的用法。 十五、HTML 解析库jsoup 可以解析 HTML，创建 HTML 文档 十六、加密库Apache Commons 家族中的 Commons Codec 就提供了一些公共的编解码实现，比如 Base64, Hex, MD5,Phonetic and URLs 等等。 十七、嵌入式 SQL 数据库库H2 是一种内存数据库，可以嵌入到 Java 应用中。在跑单测的时候如果需要一个数据库，用来验证 SQL 的话，H2 是个很好的选择。还有 Apache Derby 和 HSQL 可供选择。 十八、JDBC 故障诊断库有不错的 JDBC 扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。 P6Spy 分发包包括 P6Log，它是一个可记录任何 Java 应用程","link":"/java/Java-tricks.html"},{"title":"go/《go语言核心编程》阅读笔记1","text":"","link":"/go/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01.html"},{"title":"你真的会写java吗 阅读笔记","text":"[toc] beandomain 包名一个数据库表 应该对应一个 普通的 entity 对象，因此包名应为 com.xxx.entity DTO只要是用于网络传输的对象，都应该被当做 DTO 对象，若约定某对象是 DTO 对象，就把名称改为 XXDTO, 比如订单下发 OMS: OMSOrderInputDTO. DTO转化DTO 是系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转换成 BO 对象（？）或者普通 entity 对象，让 service 层处理。 场景12345678910111213141516@RequestMapping(\"/v1/api/user\")@RestControllerpublic class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); }} 使用工具网上有很多工具，支持浅拷贝或深拷贝的Utils. 举个例子，我们可以使用org.springframework.beans.BeanUtils#copyProperties对代码进行重构和优化 BeanUtils.copyProperties是一个浅拷贝方法，复制属性时，我们只需要把DTO对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做DTO转化的时候一直使用set进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! 1234567@PostMappingpublic User addUser(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user);} 转化的语义123456789101112@PostMapping public User addUser(UserInputDTO userInputDTO){ User user = convertFor(userInputDTO); return userService.addUser(user); } private User convertFor(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中 抽象接口定义当实际工作中，完成了几个api的DTO转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。如果接口被定义以后，那么convertFor这个方法的语义将产生变化，他将是一个实现类。 看一下抽象后的接口: 123public interface DTOConvert&lt;S,T&gt; { T convert(S s);} 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的java程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现: 12345678public class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; }} 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范: 1234567891011121314RequestMapping(\"/v1/api/user\")@RestControllerpublic class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); }} review code12345678910111213141516171819202122public class UserInputDTO { private String username; private int age; // getters and setters public User convertToUser(){ UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; } private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } }} 1234567// 然后api中的转化则由:// User user = new UserInputDTOConvert().convert(userInputDTO);// User saveUserResult = userService.addUser(user);// 变成了:User user = userInputDTO.convertToUser();User saveUserResult = userService.addUser(user); DTO对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 利用工具类优化GUAVA的源码，发现了com.google.common.base.Convert这样的定义: 12345public abstract class Converter&lt;A, B&gt; implements Function&lt;A, B&gt; { protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略} 从源码可以了解到，GUAVA中的Convert可以完成正向转化和逆向转化，继续修改我们DTO中转化的这段代码: 12345678private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; }} 修改后: 123456789101112131415private static class UserInputDTOConvert extends Converter&lt;UserInputDTO, User&gt; { @Override protected User doForward(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } @Override protected UserInputDTO doBackward(User user) { UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; } } 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的UserInputDTO和UserOutputDTO都转成UserDTO展示给大家: DTO： 1234567891011121314151617181920212223242526272829303132333435public class UserDTO { private String username; private int age; // getters and setters public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; } }} api: 1234567@PostMapping public UserDTO addUser(UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的DTO对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的: 12345678910111213private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } 看一下doBackward方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 关于异常处理的更详细介绍，可以参考我之前的文章:如何优雅的设计java异常 ，应该可以帮你更好的理解异常。 bean的验证应该保证任何数据的入参到方法体内都是合法的 4.5. 拥抱lombok4.5.1. 去掉Setter和Getter123@Setter@Getter// @Data,@AllArgsConstructor,@NoArgsConstructor 。。。 4.5.2. bean中的链式风格什么是链式风格？我来举个例子，看下面这个Student的bean: 123456789101112131415161718192021public class Student { private String name; private int age; public String getName() { return name; } public Student setName(String name) { this.name = name; return this; } public int getAge() { return age; } public Student setAge(int age) { return this; }} 仔细看一下set方法，这样的设置便是chain的style，调用的时候，可以这样使用: 123Student student = new Student() .setAge(24) .setName(\"zs\"); 相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用lombok进行改善呢，请使用 @Accessors(chain = true),看如下代码: 1234567@Accessors(chain = true)@Setter@Getterpublic class Student { private String name; private int age;} 这样就完成了一个对于bean来讲很友好的链式操作。 4.5.3. 静态构造方法静态构造方法的语义和简化程度真的高于直接去new一个对象。比如new一个List对象，过去的使用是这样的: 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 看一下guava中的创建方式: 1List&lt;String&gt; list = Lists.newArrayList(); Lists命名是一种约定(俗话说：约定优于配置)，它是指Lists是List这个类的一个工具类，那么使用List的工具类去产生List，这样的语义是不是要比直接new一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做Maps，那你是否想到了创建Map的方法呢： 1HashMap&lt;String, String&gt; objectObjectHashMap = Maps.newHashMap(); 好了，如果你理解了我说的语义，那么，你已经向成为java程序员更近了一步了。 再回过头来看刚刚的Student，很多时候，我们去写Student这个bean的时候，他会有一些必输字段，比如Student中的name字段，一般处理的方式是将name字段包装成一个构造方法，只有传入name这样的构造方法，才能创建一个Student对象。 接上上边的静态构造方法和必传参数的构造方法，使用lombok将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = \"ofName\")public class Student { @NonNull private String name; private int age;} 测试代码: 1Student student = Student.ofName(\"zs\"); 这样构建出的bean语义是否要比直接new一个含参的构造方法(包含 name的构造方法)要好很多。 当然，看过很多源码以后，我想相信将静态构造方法ofName换成of会先的更加简洁: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = \"of\")public class Student { @NonNull private String name; private int age;} 测试代码: 1Student student = Student.of(\"zs\"); 当然他仍然是支持链式调用的: 1Student student = Student.of(\"zs\").setAge(24); 这样来写代码，真的很简洁，并且可读性很强。 4.5.4. 使用builder （？）Builder模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。 今天其实要说的是一种变种的builder模式，那就是构建bean的builder模式，其实主要的思想是带着大家一起看一下lombok给我们带来了什么。 看一下Student这个类的原始builder状态: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public static Builder builder(){ return new Builder(); } public static class Builder{ private String name; private int age; public Builder name(String name){ this.name = name; return this; } public Builder age(int age){ this.age = age; return this; } public Student build(){ Student student = new Student(); student.setAge(age); student.setName(name); return student; } }} 调用方式: 1Student student = Student.builder().name(\"zs\").age(24).build(); 这样的builder代码，让我是在恶心难受，于是我打算用lombok重构这段代码: 12345@Builderpublic class Student { private String name; private int age;} 调用方式: 1Student student = Student.builder().name(\"zs\").age(24).build(); 4.5.5. 代理模式 （？）正如我们所知的，在程序中调用rest接口是一个常见的行为动作，如果你和我一样使用过spring 的RestTemplate,我相信你会我和一样，对他抛出的非http状态码异常深恶痛绝。 所以我们考虑将RestTemplate最为底层包装器进行包装器模式的设计: 123456789public abstract class FilterRestTemplate implements RestOperations { protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate){ this.restTemplate = restTemplate; } //实现RestOperations所有的接口} 然后再由扩展类对FilterRestTemplate进行包装扩展: ```Javapublic class ExtractRestTemplate extends FilterRestTemplate { private RestTemplate restTemplate; public ExtractRestTemplate(RestTemplate restTemplate) { super(restTemplate); this.restTemplate = restTemplate; } public &lt;T&gt; RestResponseDTO&lt;T&gt; postForEntityWithNoException(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException { RestResponseDTO&lt;T&gt; restResponseDTO = new RestResponseDTO&lt;T&gt;(); ResponseEntity&lt;T&gt; tResponseEntity; try { tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables); restResponseDTO.setData(tResponseEntity.getBody()); restResponseDTO.setMessage(tResponseEntity.getStatusCode().name()); restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue()); }catch (Exception e){ restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR); restResponseDTO.setMessage(e.getMessage()); restResponseDTO.setData(null)","link":"/java/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99java%E5%90%97-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"},{"title":"hexo","text":"hexo 安装、使用安装见 https://wuzequn.com/2018/04/27/blog-build-and-ipv6-tools http://www.dragonbaby308.com/hexo 初始化项目hexo init blog 配置修改 bog 项目下的_config.yml 文件，D:\\01 Code\\hexo_config.ymllanguage: zh-Hans 使用创建新文章hexo new new-article 重新发布hexo clean;hexo g;hexo s hexo clean hexo generate 或 hexo g hexo server 或 hexo s 部署到 github 服务器部署 （一） 本地 + github.io 白嫖部署 生成 github.io 仓库首先注册并登录 GitHub，创建新 public 仓库，仓库名称一定要是：YourGitHubName.github.io（YourGitHubName 是你的 GitHub 昵称，大小写敏感！） 本地安装 Hexo 的 git 部署插件在 Hexo 的目录下，输入 npm install –save hexo-deployer-git，会报一个 peerDependencies WARNING，可以忽略。 本地修改_config.yaml 文件在 Hexo 目录下，找到_config.yaml 文件，在#Deployment 做如下修改： Markdown # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的 github.io 的网址 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 部署hexo d部署成功后，浏览器输入 YourGitHubName.github.io 即可访问，其中 YourGitHubName 是你的 GitHub 昵称，且大小写敏感见 详见 http://www.dragonbaby308.com/hexo/ 发布hexo clean;hexo g;hexo d 输入 github 账号名，密码 hexo d 即 hexo deploy 其他配置Hexo+Next 个人博客主题优化 - 简书https://www.jianshu.com/p/efbeddc5eb19 主要配置了： Hexo 之 next 主题设置首页不显示全文(只显示预览) - 简书https://www.jianshu.com/p/393d067dba8d Hexo+Next个人博客主题优化 - 简书https://www.jianshu.com/p/efbeddc5eb19 Dragonstyle’s Home – 记录、分享、交流http://www.dragonstyle.win/ 修改文章宽度https://ihaoming.top/archives/9a935f57.html deploy 免账号密码 可将_config.yml 中的 repo 修改为如下标准格式：repo: https://用户名:密码@github.com/用户名/用户名.github.io.git这样做的好处就是每次 hexo deploy 提交时不需要输入账号密码。 hexo的首页只显示文章的部分内容让hexo的首页只显示文章的部分内容而不是全部 | 朱启的个人博客 1234567891011第二种方法在你写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。效果上面两种方式展示出来的效果是不一样的。第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。而第二种加上 &lt;!--more--&gt;展示出来的就是你原本文章的样式，最后不会有… 换电脑见 https://feijunjie.github.io/2018/10/10/20181010-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8F%A6%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%A7%E7%BB%ADhexo%E5%86%99%E5%8D%9A%E5%AE%A2/ 注意事项在标题开头使用如下形式[精]精华文章会报错 问题search一直加载解决办法： 查看search.xml的请求 打开新窗口，直接访问xml网址，查看哪一行解析失败，回到请求页面，查看是哪个文件 去vim查看异常字符 热度统计没生效Next 解决 Busuanzi 统计浏览失效 | G加菲 文章置顶Hexo文章置顶的方法 - 简书 侧边栏添加自定义文件夹【Hexo + Next】侧边栏添加自定义文件夹（如友链）_Spr Chan的博客-CSDN博客 Archive页面显示文章数量npm install hexo-generator-archive –save _config.yml中新增相关配置archive_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档index_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 tag_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 category_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 EIO: i/o error➜ hexo hexo dINFO Deploying: gitINFO Clearing .deploy_git folder…FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: EIO: i/o error, stat ‘/Volumes/Data/01 Code/hexo/.deploy_git/2019’➜ hexo open .在finder中，删除文件夹再hexo deploy hexo文章模板设置 | 拈花把酒偏折煞世人情狂 Hexo设置网站的图标Favicon | G加菲在线免费将图片转换成ico图标格式-转换成ico hexo中文版 ![fWXaVcbtCg8kMNo](https://i.loli.net/2020/01/14/fWXaVcbtCg8kMNo.png) jaredly/hexo-admin: An Admin Interface for Hexo 图片和描述123photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpgdescription: 03 junit 多环境撰文hexo与github pages共同搭建博客有一个麻烦的地方就在于多环境下要同步本地的博客内容很麻烦，唯一的方法就是你用要么一个硬盘云盘之类的要么就是用github之类的，每次有更新你就同时把本地的博客文件都同步上去，毫无疑问这非常麻烦。之前想要自己写一个自动化工具来做这个事情，这几天发现有人已经写好了，可以直接用，这里直接贴出链接，里面也有详细的说明，按照步骤来做就好了。hexo-git-backup SEO当我们搭建一个网站之后，如果没有做一些相关的搜索引擎优化SEO，那么我们的网站是很难获取来自搜索引擎的流量的，用户很难在搜索引擎上搜索到我们网站的内容，所以在这里我们要为Hexo网站做一些简单的搜索优化。上周刚搭建好博客的时候只有谷歌能搜索到自己的博客，百度直接搜域名都没有任何信息，主要原因是因为Github Pages屏蔽了百度爬虫，百度根据没办法知道我们博客的内容，所以我将博客同步到两个平台上，一个Github，一个国内的Gitcafe，目前搜索自己博客的相关信息基本都在第一条。 SiteMap首先安装hexo的sitemap网站地图生成插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码： 12345# hexo sitemap网站地图sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitem","link":"/other/hexo.html"},{"title":"other/job","text":"","link":"/other/job.html"},{"title":"other/markdown语法及编辑器","text":"","link":"/other/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%BC%96%E8%BE%91%E5%99%A8.html"},{"title":"other/rss","text":"","link":"/other/rss.html"},{"title":"other/you-get-自定义","text":"","link":"/other/you-get-%E8%87%AA%E5%AE%9A%E4%B9%89.html"},{"title":"other/图床","text":"","link":"/other/%E5%9B%BE%E5%BA%8A.html"},{"title":"python/10-python-tips","text":"","link":"/python/10-python-tips.html"},{"title":"other/快捷键","text":"","link":"/other/%E5%BF%AB%E6%8D%B7%E9%94%AE.html"},{"title":"Python tricks","text":"[toc] 02-28Personalize your python prompt | Arpit Bhayani 02-14Debugging in Python — A cakewalk with pdb - Python Features - Medium 02-13Pathlib (3.4+)12345from pathlib import Pathroot = Path('post_sub_folder')print(root)path = root / 'happy_user'print(path.resolve()) Type hinting (3.5+)123def sentence_has_animal(sentence: str) -&gt; bool: return \"animal\" in sentencesentence_has_animal(\"Donald had a farm without animals\") Enumerations (3.4+)Python3提供的Enum类让你很容就能实现一个枚举类型： 123456789from enum import Enum, autoclass Monster(Enum): ZOMBIE = auto() WARRIOR = auto() BEAR = auto()print(Monster.ZOMBIE)for monster in Monster: print(monster) Built-in LRU cache (3.2+)缓存是现在的软件领域经常使用的技术，Python3提供了一个lru_cache装饰器，来让你更好的使用缓存。 12345678910from functools import lru_cache@lru_cache(maxsize=512)def fib_memoization(number: int) -&gt; int: if number == 0: return 0 if number == 1: return 1 return fib_memoization(number-1) + fib_memoization(number-2)start = time.time()fib_memoization(40)print(f'Duration: {time.time() - start}s') Extended iterable unpacking (3.0+)*_用来抛弃元素 123456789101112131415head, *body, tail = range(5)print(head, body, tail)# 输出： 0 [1, 2, 3] 4py, filename, *cmds = \"python3.7 script.py -n 5 -l 15\".split()print(py)print(filename)print(cmds)# 输出：python3.7# script.py# ['-n', '5', '-l', '15']first, _, third, *_ = range(10)print(first, third)# 输出： 0 2 Data classes (3.7+)Python3提供data class装饰器来让我们更好的处理数据对象，而不用去实现 init() 和 repr() 方法。假设如下的代码: 1234567891011121314class Armor: def __init__(self, armor: float, description: str, level: int = 1): self.armor = armor self.level = level self.description = description def power(self) -&gt; float: return self.armor * self.levelarmor = Armor(5.2, \"Common armor.\", 2)armor.power()# 10.4print(armor)# &lt;__main__.Armor object at 0x7fc4800e2cf8&gt; 使用data class实现上面功能的代码，这么写: 12345678910111213141516from dataclasses import dataclass@dataclassclass Armor: armor: float description: str level: int = 1def power(self) -&gt; float: return self.armor * self.level armor = Armor(5.2, \"Common armor.\", 2)armor.power()# 10.4print(armor)# Armor(armor=5.2, description='Common armor.', level=2) Implicit namespace packages (3.3+)通常情况下，Python通过把代码打成包（在目录中加入init.py实现）来复用 在Python2里，每个目录都必须有init.py文件，以便其他模块调用目录下的python代码，在Python3里，通过 Implicit Namespace Packages可是不使用init.py文件 sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects echo.py surround.py reverse.py ... filters/ Subpackage for filters equalizer.py vocoder.py karaoke.py02-10neovim: 新时代的 vim，我在这个配置(https://github.com/PegasusWang/vim-config)上自定义了自己的配置，使用起来性能和反应速度上远超原生的老古董 vim meld/vimdiff: 文本比对工具。 tmux/tmuxp wemux: tmux 共享，https://github.com/zolrath/wemux sshfs: 本地挂在服务器文件夹 tmate: https://tmate.io 终端共享工具，结对编程。很多现代化编辑器 vscode, atom 提供结对编程的插件。 asciinema: 终端会话记录工具。https://asciinema.org/ devdocs.io: 文档查询工具 gitx(mac):方便查看代码提交历史，便于了解整个代码仓库是怎样一步步构建的。http://gitx.frim.nl/user_manual tig: text-mode interface for git. 喜欢命令行的可以尝试下。 https://github.com/jonas/tig EditorConfig: http://editorconfig.org/ 用来统一编辑器配置。如果成员用不同的操作系统和编辑器，建议使用。尤其是对于 python 这种使用缩进的语言 mac-setup: https://github.com/sb2nov/mac-setup mac 下各种编程语言开发环境配置指引 《使用vim+tmux+zsh+autojump高效工作》 prospector: 集成了众多python代码检测工具 mccabe: 圈复杂度检测工具。McCabe 是一种度量程序复杂度的方法，如果单个子程序复杂度过高，或许就需要拆分逻辑提高程序的易读性。 bandit: 用于Python代码的安全性分析，openstack 的项目 https://github.com/openstack/bandit rope，可以用来重构等，功能强大。笔者经常用rope自动帮我重新整理导入的包顺序。 Pyreverse: 代码 UML 生成工具, 帮助我们理解继承关系 (https://pythonhosted.org/theape/documentation/developer/explorations/explore_graphs/explore_pyreverse.html) Epydoc: Automatic API Documentation Generation for Python 2to3/python-modernize: python2 转 python3 工具。目前 Instagram 已经全面迁移到 python3 编写2/3兼容代码：http://python-future.org/compa pigar: 找出项目使用到的依赖库 buildout: 项目构建工具 pyenv/virtualenv/pipenv：多版本管理 bitbucket: 类似 github，好处是支持免费的私有仓库 cookiecutter: 一系列项目模板生成工具，懒人必备。https://github.com/audreyr/cookiecutter。笔者之前内部项目就直接用 flask-cookiecutter 直接生成的。 yeoman: http://yeoman.io/generators/ 前端项目模板生成工具 ant-design: 后端管理后台项目解决方案 https://ant.design/docs/react/p Api 工具 checklist: http://python.apichecklist.com/ 日志、异常收集工具 Sentry: 用来记录异常非常好用，能看到完善的栈信息，方便排错。 Fluentd 管理及运维、监控工具(devops很火) Supervisor.进程管理 Fabric.应用部署 docker.最近比较火的容器技术。很多采用微服务架构的公司使用 docker 作为容器部署服务，或者构建一致的开发环境 SaltStack和Ansible. 配置管理 StatsDGraphite等web监控 调试工具 ipdb/pdb: ipdb 支持自动补全，比原生的 pdb 要好用一些。 pdbpp: [https://pypi.org/project/pdbpp/](https://link.zhihu.com/?target=https%3A","link":"/python/Python-tricks.html"},{"title":"leetcode/leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal","text":"","link":"/leetcode/leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal.html"},{"title":"leetcode/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","text":"","link":"/leetcode/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html"},{"title":"python weekly","text":"[toc] Better Python tracebacks with Rich 类似于 pretty_errors JustPy 仅用 Python 写网页 vardbgA simple Python debugger and profiler that generates animated visualizations of program flow, useful for algorithm learning. 查看代码执行过程 类似于 http://pythontutor.com/visualize.html#mode=edit georgek42/inlinec: Effortlessly write inline C functions in Pythonmaxhumber/gif: ✨ Better animated Matplotlib gifs syncPlaylist在网易云音乐与 QQ 音乐之间同步歌单。易于使用、配置方便、代码简单，用到的技术：requests + beautifulsoup 以及 selenium + phantomjs GetSubtitles通过拖曳视频文件进终端，一步下载字幕 到视频对应文件夹，并重命名字幕名称为视频名称。Ubuntu 16.04、Windows 10上测试通过，同时兼容 Python2、3。Python 的魅力之一就是可以快速实现一个适合自己的小工具 Cool ✌️ pdir2Python 程序员需要一个更好的 dir() —— 以更加友好的显示 dir() 输出的结果 myclimycli 是一个带语法高亮、自动补全的 MySQL 命令行客户端工具。例如，连接数据库方法：mycli -h localhost -u 用户名 数据库 locust模拟用户行为的负载测试工具，包含友好的 Web 页面，如下图： flask-limiter一个 Flask 的扩展库，它可以根据访问者的 IP 限制其访问频率、次数等。 httpstathttpstat 美化了 curl 的结果，使得结果更加可读。同时它无依赖、兼容 Python3、一共才 300 多行。还可以显示 HTTP 请求的每个过程中消耗的时间，如下图： yakutils — yakutils 1.6.0 documentation read_csv¶ read_json¶ json_defaults¶ ? date_to_iso8601¶ datetime_to_iso8601¶ datetime_to_unixtimestamp¶ iso8601_to_datetime¶ md5¶ sha1¶ sha384¶ sha3_384¶ setup_logging¶ random_string¶ random_tolerance¶ update_qs¶ szsdk/quick: A real QUICK Qt5 based gUI generator for ClicK willmcgugan/rich: Rich is a Python library for rich text and beautiful formatting in the terminal. Rich print function Console Printing Console Logging Markdown Syntax Highlighting Tables Welcome to Rich’s documentation! — Rich 0.3.2 documentation scylla：一款高质量的免费代理 IP 池工具，仅支持 Python 3.6。中文文档，特性如下： 自动化的代理 IP 爬取与验证 易用的 JSON API 简单但美观的 web 用户界面，基于 TypeScript 和 React（例如，代理的地理分布） 最少仅用一行代码即可与 Scrapy 和 requests 进行集成 jiaaro/pydub: Manipulate audio with a simple and easy high level interfaceloguru：一个让 Python 记录日志变得简单的库 mahmoud/awesome-python-applications: 💿 Free software that works great, and also happens to be open-source Python. awslogs：一个简单的命令行工具，用于在本地查询 Amazon CloudWatch 日志，强大的支持多实例日志汇总查看。简单的查看命令：awslogs get /var/logs/syslog ALL -s1d 14、termtosvg：Python 写的终端记录器。通过命令 termtosvg 运行该工具，然后在终端执行你要展示的命令，最终输入 exit 命令结束录制，本地会生成一份 SVG 动画，可用于分享、展示终端操作。效果如下： 15、cx-extractor-python：这是一个对网页正文进行抽取的工具。 cx-extractor 算法的 python 版本，改进了原有算法，使其支持中英文，对新闻类网页正文抽取效果较好。示例代码： 123456from crawler.cx_extractor_Python import cx_extractor_Pythoncx = cx_extractor_Python()test_html = cx.getHtml('http://news.163.com/16/0101/10/BC84MRHS00014AED.html')content = cx.filter_tags(test_html)s = cx.getText(content)print(s) 2020年1月25日bullet：一个支持终端输入和菜单选择的 Python 库。可以让使用者在终端上用方向键移动、单选、复选、密码输入等，而且支持定制化格式和颜色。看下面的效果图你就知道它是干什么 TagUI-Python：一个 Python 自动化操作的库。比如：自动打开网页并截图，示例代码： 12345t.init()t.url('https://www.google.com')t.type('q', 'decentralization[enter]')t.snap('page', 'results.png')t.close() 2020年1月20日(星期一)[guanguans/favorite-link: ❤️","link":"/python/python-weekly.html"},{"title":"leetcode/leetcode-107-Binary-Tree-Level-Order-Traversal-II","text":"","link":"/leetcode/leetcode-107-Binary-Tree-Level-Order-Traversal-II.html"},{"title":"leetcode/leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","text":"","link":"/leetcode/leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.html"},{"title":"leetcode/leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree","text":"","link":"/leetcode/leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree.html"},{"title":"leetcode/leetcode-110-Balanced-Binary-Tree","text":"","link":"/leetcode/leetcode-110-Balanced-Binary-Tree.html"},{"title":"leetcode/leetcode-111-Minimum-Depth-of-Binary-Tree","text":"","link":"/leetcode/leetcode-111-Minimum-Depth-of-Binary-Tree.html"},{"title":"leetcode/leetcode-112-Path-Sum","text":"","link":"/leetcode/leetcode-112-Path-Sum.html"},{"title":"leetcode/leetcode-113-Path-Sum-II","text":"","link":"/leetcode/leetcode-113-Path-Sum-II.html"},{"title":"leetcode/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node-1","text":"","link":"/leetcode/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node-1.html"},{"title":"leetcode/leetcode-128-Longest-Consecutive-Sequence","text":"","link":"/leetcode/leetcode-128-Longest-Consecutive-Sequence.html"},{"title":"leetcode/leetcode-114-Flatten-Binary-Tree-to-Linked-List","text":"","link":"/leetcode/leetcode-114-Flatten-Binary-Tree-to-Linked-List.html"},{"title":"leetcode/leetcode-1143-Longest-Common-Subsequence","text":"","link":"/leetcode/leetcode-1143-Longest-Common-Subsequence.html"},{"title":"leetcode/leetcode-131-Palindrome-Partitioning","text":"","link":"/leetcode/leetcode-131-Palindrome-Partitioning.html"},{"title":"leetcode/leetcode-134-Gas-Station","text":"","link":"/leetcode/leetcode-134-Gas-Station.html"},{"title":"leetcode/leetcode-141-Linked-List-Cycle","text":"","link":"/leetcode/leetcode-141-Linked-List-Cycle.html"},{"title":"leetcode/leetcode-142-Linked-List-Cycle-II","text":"","link":"/leetcode/leetcode-142-Linked-List-Cycle-II.html"},{"title":"leetcode/leetcode-171-Excel-Sheet-Column-Number","text":"","link":"/leetcode/leetcode-171-Excel-Sheet-Column-Number.html"},{"title":"leetcode/leetcode-150-Evaluate-Reverse-Polish-Notation","text":"","link":"/leetcode/leetcode-150-Evaluate-Reverse-Polish-Notation.html"},{"title":"leetcode/leetcode-179-Largest-Number","text":"","link":"/leetcode/leetcode-179-Largest-Number.html"},{"title":"leetcode/leetcode-162-Find-Peak-Element","text":"","link":"/leetcode/leetcode-162-Find-Peak-Element.html"},{"title":"leetcode/leetcode-189-Rotate-Array","text":"","link":"/leetcode/leetcode-189-Rotate-Array.html"},{"title":"leetcode/leetcode-202-Happy Number","text":"","link":"/leetcode/leetcode-202-Happy%20Number.html"},{"title":"leetcode/leetcode-204-Count Primes","text":"","link":"/leetcode/leetcode-204-Count%20Primes.html"},{"title":"leetcode/leetcode-208-Implement-Trie-Prefix-Tree","text":"","link":"/leetcode/leetcode-208-Implement-Trie-Prefix-Tree.html"},{"title":"leetcode/leetcode-230-Kth-Smallest-Element-in-a-BST","text":"","link":"/leetcode/leetcode-230-Kth-Smallest-Element-in-a-BST.html"},{"title":"leetcode/leetcode-215-Kth Largest Element in an Array","text":"","link":"/leetcode/leetcode-215-Kth%20Largest%20Element%20in%20an%20Array.html"},{"title":"leetcode/leetcode-229-Majority-Element-II","text":"","link":"/leetcode/leetcode-229-Majority-Element-II.html"},{"title":"leetcode/leetcode-217-Contains Duplicate","text":"","link":"/leetcode/leetcode-217-Contains%20Duplicate.html"},{"title":"leetcode/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree","text":"","link":"/leetcode/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree.html"},{"title":"leetcode/leetcode-237-Delete-Node-in-a-Linked-List","text":"","link":"/leetcode/leetcode-237-Delete-Node-in-a-Linked-List.html"},{"title":"leetcode/leetcode-238-Product-of-Array-Except-Self","text":"","link":"/leetcode/leetcode-238-Product-of-Array-Except-Self.html"},{"title":"leetcode/leetcode-239-Sliding-Window-Maximum","text":"","link":"/leetcode/leetcode-239-Sliding-Window-Maximum.html"},{"title":"leetcode/leetcode-242-Valid-Anagram","text":"","link":"/leetcode/leetcode-242-Valid-Anagram.html"},{"title":"leetcode/leetcode-24-Swap-Nodes-in-Pairs","text":"","link":"/leetcode/leetcode-24-Swap-Nodes-in-Pairs.html"},{"title":"leetcode/leetcode-268-Missing-Number","text":"","link":"/leetcode/leetcode-268-Missing-Number.html"},{"title":"leetcode/leetcode-240-Search-a-2D-Matrix-II","text":"","link":"/leetcode/leetcode-240-Search-a-2D-Matrix-II.html"},{"title":"leetcode/leetcode-278-First-Bad-Version","text":"","link":"/leetcode/leetcode-278-First-Bad-Version.html"},{"title":"leetcode/leetcode-287-Find-the-Duplicate-Number","text":"","link":"/leetcode/leetcode-287-Find-the-Duplicate-Number.html"},{"title":"leetcode/leetcode-279-Perfect-Squares","text":"","link":"/leetcode/leetcode-279-Perfect-Squares.html"},{"title":"leetcode/leetcode-289-Game-of-Life","text":"","link":"/leetcode/leetcode-289-Game-of-Life.html"},{"title":"leetcode/leetcode-3-Longest-Substring-Without-Repeating-Characters","text":"","link":"/leetcode/leetcode-3-Longest-Substring-Without-Repeating-Characters.html"},{"title":"leetcode/leetcode-29-Divide-Two-Integers","text":"","link":"/leetcode/leetcode-29-Divide-Two-Integers.html"},{"title":"leetcode/leetcode-297-Serialize-and-Deserialize-Binary-Tree","text":"","link":"/leetcode/leetcode-297-Serialize-and-Deserialize-Binary-Tree.html"},{"title":"leetcode/leetcode-300-Longest-Increasing-Subsequence","text":"","link":"/leetcode/leetcode-300-Longest-Increasing-Subsequence.html"},{"title":"leetcode/leetcode-328-Odd-Even-Linked-List","text":"","link":"/leetcode/leetcode-328-Odd-Even-Linked-List.html"},{"title":"leetcode/leetcode-334-Increasing-Triplet-Subsequence","text":"","link":"/leetcode/leetcode-334-Increasing-Triplet-Subsequence.html"},{"title":"leetcode/leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array","text":"","link":"/leetcode/leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html"},{"title":"leetcode/leetcode-350-Intersection-of-Two-Arrays-II-1","text":"","link":"/leetcode/leetcode-350-Intersection-of-Two-Arrays-II-1.html"},{"title":"leetcode/leetcode-341-Flatten-Nested-List-Iterator","text":"","link":"/leetcode/leetcode-341-Flatten-Nested-List-Iterator.html"},{"title":"leetcode/leetcode-344-Reverse-String","text":"","link":"/leetcode/leetcode-344-Reverse-String.html"},{"title":"leetcode/leetcode-350-Intersection-of-Two-Arrays-II","text":"","link":"/leetcode/leetcode-350-Intersection-of-Two-Arrays-II.html"},{"title":"leetcode/leetcode-347-Top-K-Frequent-Elements","text":"","link":"/leetcode/leetcode-347-Top-K-Frequent-Elements.html"},{"title":"leetcode/leetcode-36-Valid-Sudoku","text":"","link":"/leetcode/leetcode-36-Valid-Sudoku.html"},{"title":"leetcode/leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix","text":"","link":"/leetcode/leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix.html"},{"title":"leetcode/leetcode-380-Insert-Delete-GetRandom-O-1","text":"","link":"/leetcode/leetcode-380-Insert-Delete-GetRandom-O-1.html"},{"title":"leetcode/leetcode-384-Shuffle-an-Array","text":"","link":"/leetcode/leetcode-384-Shuffle-an-Array.html"},{"title":"leetcode/leetcode-409-Longest-Palindrome","text":"","link":"/leetcode/leetcode-409-Longest-Palindrome.html"},{"title":"leetcode/leetcode-387-First-Unique-Character-in-a-String","text":"","link":"/leetcode/leetcode-387-First-Unique-Character-in-a-String.html"},{"title":"leetcode/leetcode-412-Fizz-Buzz","text":"","link":"/leetcode/leetcode-412-Fizz-Buzz.html"},{"title":"leetcode/leetcode-39-Combination-Sum","text":"","link":"/leetcode/leetcode-39-Combination-Sum.html"},{"title":"leetcode/leetcode-42-Trapping-Rain-Water","text":"","link":"/leetcode/leetcode-42-Trapping-Rain-Water.html"},{"title":"leetcode/leetcode-454-4Sum-II","text":"","link":"/leetcode/leetcode-454-4Sum-II.html"},{"title":"leetcode/leetcode-46-Permutations","text":"","link":"/leetcode/leetcode-46-Permutations.html"},{"title":"leetcode/leetcode-461-Hamming-Distance","text":"","link":"/leetcode/leetcode-461-Hamming-Distance.html"},{"title":"leetcode/leetcode-50-Pow-x-n","text":"","link":"/leetcode/leetcode-50-Pow-x-n.html"},{"title":"leetcode/leetcode-48-Rotate-Image","text":"","link":"/leetcode/leetcode-48-Rotate-Image.html"},{"title":"leetcode/leetcode-49-Group-Anagrams","text":"","link":"/leetcode/leetcode-49-Group-Anagrams.html"},{"title":"leetcode/leetcode-538-Convert-BST-to-Greater-Tree","text":"","link":"/leetcode/leetcode-538-Convert-BST-to-Greater-Tree.html"},{"title":"leetcode/leetcode-559-Maximum-Depth-of-N-ary-Tree","text":"","link":"/leetcode/leetcode-559-Maximum-Depth-of-N-ary-Tree.html"},{"title":"leetcode/leetcode-589-N-ary-Tree-Preorder-Traversal","text":"","link":"/leetcode/leetcode-589-N-ary-Tree-Preorder-Traversal.html"},{"title":"leetcode/leetcode-61-Rotate-List","text":"","link":"/leetcode/leetcode-61-Rotate-List.html"},{"title":"leetcode/leetcode-590-N-ary-Tree-Postorder-Traversal","text":"","link":"/leetcode/leetcode-590-N-ary-Tree-Postorder-Traversal.html"},{"title":"leetcode/leetcode-653-Two-Sum-IV-Input-is-a-BST","text":"","link":"/leetcode/leetcode-653-Two-Sum-IV-Input-is-a-BST.html"},{"title":"leetcode/leetcode-621-Task-Scheduler","text":"","link":"/leetcode/leetcode-621-Task-Scheduler.html"},{"title":"leetcode/leetcode-66-Plus-One","text":"","link":"/leetcode/leetcode-66-Plus-One.html"},{"title":"leetcode/leetcode-637-Average-of-Levels-in-Binary-Tree","text":"","link":"/leetcode/leetcode-637-Average-of-Levels-in-Binary-Tree.html"},{"title":"leetcode/leetcode-673-Number-of-Longest-Increasing-Subsequence","text":"","link":"/leetcode/leetcode-673-Number-of-Longest-Increasing-Subsequence.html"},{"title":"leetcode/leetcode-69-Sqrt-x","text":"","link":"/leetcode/leetcode-69-Sqrt-x.html"},{"title":"leetcode/leetcode-674-Longest-Continuous-Increasing-Subsequence","text":"","link":"/leetcode/leetcode-674-Longest-Continuous-Increasing-Subsequence.html"},{"title":"leetcode/leetcode-700-Search-in-a-Binary-Search-Tree","text":"","link":"/leetcode/leetcode-700-Search-in-a-Binary-Search-Tree.html"},{"title":"leetcode/leetcode-701-Insert-into-a-Binary-Search-Tree","text":"","link":"/leetcode/leetcode-701-Insert-into-a-Binary-Search-Tree.html"},{"title":"leetcode/leetcode-78-Subsets","text":"","link":"/leetcode/leetcode-78-Subsets.html"},{"title":"leetcode/leetcode-762-Prime-Number-of-Set-Bits-in-Binary-Representation","text":"","link":"/leetcode/leetcode-762-Prime-Number-of-Set-Bits-in-Binary-Representation.html"},{"title":"leetcode/leetcode-73-Set-Matrix-Zeroes","text":"","link":"/leetcode/leetcode-73-Set-Matrix-Zeroes.html"},{"title":"leetcode/leetcode-79-Word-Search","text":"","link":"/leetcode/leetcode-79-Word-Search.html"},{"title":"leetcode/leetcode-872-Leaf-Similar-Trees","text":"","link":"/leetcode/leetcode-872-Leaf-Similar-Trees.html"},{"title":"leetcode/leetcode-897-Increasing-Order-Search-Tree","text":"","link":"/leetcode/leetcode-897-Increasing-Order-Search-Tree.html"},{"title":"leetcode/leetcode-96-Unique-Binary-Search-Trees","text":"","link":"/leetcode/leetcode-96-Unique-Binary-Search-Trees.html"},{"title":"leetcode/leetcode-82-Remove-Duplicates-from-Sorted-List-II","text":"","link":"/leetcode/leetcode-82-Remove-Duplicates-from-Sorted-List-II.html"},{"title":"leetcode/leetcode-92-Reverse-Linked-List-II","text":"","link":"/leetcode/leetcode-92-Reverse-Linked-List-II.html"},{"title":"leetcode/leetcode-965-Univalued-Binary-Tree","text":"","link":"/leetcode/leetcode-965-Univalued-Binary-Tree.html"},{"title":"leetcode/leetcode-98-Validate-Binary-Search-Tree","text":"","link":"/leetcode/leetcode-98-Validate-Binary-Search-Tree.html"},{"title":"leetcode/leetcode-938-Range-Sum-of-BST","text":"","link":"/leetcode/leetcode-938-Range-Sum-of-BST.html"},{"title":"加密文章测试","text":"嗨，请准确无误地输入密码查看哟（密码：123456）！ 42401e656a30ed09e8e3b0fbe2fbd18ae1b8c2138de0b629bd1233cbc0cc80918b020088b54c79621b8ef9a9af7b0f06b4f358e8c86ef99d097fb161589581b453752da7da2e21aa4d35b94c835c62d1204ab327d5d9241d6be3c6b4b1e68d3697229826ffa52b53920e92cbe496af209269f803aa7450ba136338b0e891ba54f6fe48d0d23c1ba5b981305fdee3badd054b7ad20712af650adf010b25c3fa117b769979c2ef7a2ccccee14b24ed84530b911e7b68c43d9f4592ba8687b2c7fb","link":"/private/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html"},{"title":"leetcode/leetcode-99-Recover-Binary-Search-Tree","text":"","link":"/leetcode/leetcode-99-Recover-Binary-Search-Tree.html"},{"title":"leetcode/leetcode-993-Cousins-in-Binary-Tree","text":"","link":"/leetcode/leetcode-993-Cousins-in-Binary-Tree.html"},{"title":"theme/github-Issue-作为博客微型数据库的应用","text":"","link":"/theme/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html"},{"title":"theme/github-page网站cdn优化加速","text":"","link":"/theme/github-page%E7%BD%91%E7%AB%99cdn%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F.html"},{"title":"theme/博客图片上传picgo工具github图传使用","text":"","link":"/theme/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E5%9B%BE%E4%BC%A0%E4%BD%BF%E7%94%A8.html"},{"title":"theme/不蒜子统计常见问题","text":"","link":"/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"},{"title":"博客中gitalk最新评论的获取","text":"博客中，对于网友的评论以及每篇文章的评论数还是很重要的。但是基于静态的页面想要存储动态的评论数据是比较难的，一般博客主题中都内置了评论插件，但是博客主题中对于最新评论的支持显示还是很少的，至少目前我是没怎么发现。博客 Powered by Hexo &amp; Icarus，采用Gitalk评论，再次感谢此三位作者的辛勤码代码，才有了以下的内容。基于此背景基础上，聊聊最新评论的实现。 博客的使用， Hexo &amp; Icarus，采用Gitalk评论 的使用自行百度了。 使用场景 最新评论列表 最热文章列表（基于评论数判断是否最热，也比较片面，但是侧面也能反映，问题不大） 使用方法主要参考自官方文档 目前主要用到两个方法，一个是获取仓库下所有的issue，每个issue节点下有相关的评论数，以及对应issue下的评论的url;还有一个是根据issue下评论的URL获取相应的所有的评论 方法1：List issues for a repository1GET /orgs/:org/issues 参数列表 Name Type Description milestone integer or string If an integer is passed, it should refer to a milestone by its number field. If the string * is passed, issues with any milestone are accepted. If the string none is passed, issues without milestones are returned. state string Indicates the state of the issues to return. Can be either open, closed, or all. Default: open assignee string Can be the name of a user. Pass in none for issues with no assigned user, and * for issues assigned to any user. creator string The user that created the issue. mentioned string A user that’s mentioned in the issue. labels string A list of comma separated label names. Example: bug,ui,@high sort string What to sort results by. Can be either created, updated, comments. Default: created direction string The direction of the sort. Can be either asc or desc. Default: desc since string Only issues updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 以上参数，主要用到 sort 排序，page页数，per_page每页数量，其余的参数看个人需要使用。注意文档中的说明，排序的字段和返回的稍许不太一样。 方法2：List comments on an issue1GET /repos/:owner/:repo/issues/:issue_number/comments Issue Comments are ordered by ascending ID. 排序根据 ascending (上升的，增长的；升（序）的)ID.也就是说，从老到新。这个比较坑，对于我们获取最新评论来说。 参数如下 Name Type Description since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 根据尝试以及以上参数，试出不支持排序，但是支持分页，page,per_page参数，对于我们获取最新的评论来说可以根据评论数，算出分页数，拿到最后一条，即最新一条 123456//如果只有一页int page = 1;int per_page = 1;// 如果超出一页的话int page = 2;int per_page = commentsNumber-1;//commentsNumber:评论数 js代码中使用实例核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var timesSet = [];var timesBodyMap = {};var timesSetMap = {};var resultArr = [];// 方法1：sort=comments可以按评论数排序，此处更适合按更新时间排序,可以根据updated排序，但是0条评论的也会出来，所以此处还是根据评论数排序全部查出来，过滤掉0条评论的，拿到每个issue下最新的一条评论详情和时间，根据时间内存排序// per_page 每页数量，根据需求配置$.getJSON(\"https://api.github.com/repos/{用户名}/{仓库}/issues?per_page=100&amp;sort=comments\", function (result) { $.each(result, function (i, item) { var commentsCount = item.comments; if (commentsCount &gt; 0) { $.ajaxSettings.async = false; // 此处保证是最后一条，api没有排序参数，只能分页取最后一条，保证最少的数据量传输，快速处理 var page = 2; var pageSize = commentsCount - 1; if (commentsCount == 1) { page = 1; pageSize = 1; } // 方法2：的使用 $.getJSON(item.comments_url + \"?page=\" + page + \"&amp;per_page=\" + pageSize, function (commentResult) { var item1 = commentResult[0]; var contentStr = item1.body.trim(); if (contentStr.length &gt; 50) { contentStr = contentStr.substr(0, 60); contentStr += \"...\"; } timesSet.push(new Date(item1.created_at).getTime()); timesBodyMap[item1.created_at] = { \"title\": item.title.substr(0, item.title.indexOf(\"-\") - 1), \"url\": item.body.substr(0, item.body.indexOf(\"\\n\") - 1), \"content\": contentStr, \"date\": item1.created_at, \"userName\": item1[\"user\"].login, \"userUrl\": item1[\"user\"].html_url, \"commentCount\": commentsCount }; timesSetMap[new Date(item1.created_at).getTime()] = item1.created_at; }); } });});// 排序if (timesSet.length &gt; 0) { timesSet.sort();}// 根据需要取10条if (timesSet.length &gt; 10) { for (var i = timesSet.length - 1; i &gt;= 0 &amp;&amp; resultArr.length &lt; 10; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }}else { for (var i = timesSet.length - 1; i &gt;= 0; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }} 方法1：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues?per_page=100&amp;sort=comments 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"repository_url\": \"https://api.github.com/repos/removeif/blog_comment\", \"labels_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/labels{/name}\", \"comments_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/comments\", \"events_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/events\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3\", \"id\": 458985510, \"node_id\": \"MDU6SXNzdWU0NTg5ODU1MTA=\", \"number\": 3, \"title\": \"留言板 - 辣椒の酱\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"labels\": [ { \"id\": 1416043904, \"node_id\": \"MDU6TGFiZWwxNDE2MDQzOTA0\", \"url\": \"https://api.github.com/repos/removeif/blog_comment/labels/3306ea6632b94cc388b40cef9dda4a8f\", \"name\": \"3306ea6632b94cc388b40cef9dda4a8f\", \"color\": \"0e8a16\", \"default\": false }, { \"id\": 1415994590, \"node_id\": \"MDU6TGFiZWwxNDE1OTk0NTkw\", \"url\": \"https://api.github.com/repos/removeif/blog_comment/labels/Gitalk\", \"name\": \"Gitalk\", \"color\": \"5319e7\", \"default\": false } ], \"state\": \"open\", \"locked\": false, \"assignee\": null, \"assignees\": [ ], \"milestone\": null, \"comments\": 33, \"created_at\": \"2019-06-21T03:06:53Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"closed_at\": null, \"author_association\": \"OWNER\", \"body\": \"https://removeif.github.io/message/\\r\\n\\r\\n留言板信息。\" }, {...} ] 方法2：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/3/comments?per_page=32&amp;page=2 返回结果 123456789101112131415161718192021222324252627282930313233[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913\", \"issue_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"id\": 530767913, \"node_id\": \"MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"created_at\": \"2019-09-12T10:37:34Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"author_association\": \"OWNER\", \"body\": \"&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦\" }] 博客中目前有两个页面使用,根据个人的需要放到各自的位置吧。 首页热门推荐 还有个最新评论页： 扩展一个方法上面的实例程序，每个issue（因为我的每个issue关联一个文章链接）只取了一条最新的评论，假如每个issue下有两个都是最新的评论，而我也不管是不是同一个issue下的评论，获取所有的最新评论，还有一个方法比较好用。 List comments in a repository1GET /repos/:owner/:repo/issues/comments By default, Issue Comments are ordered by ascending ID. 和上面一样，但是以下参数就不一样了 Name Type Description sort string Either created or updated. Default: created direction string Either asc or desc. Ignored without the sort parameter. since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 多了排序字段和排序方式，也有per和per_page，这是相当的有用啊 扩展方法：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/comments?sort=updated&amp;direction=desc&amp;per_page=10&amp;page=1 返回结果 123456789101112131415161718192021222324252627282930313233343536[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913\", \"issue_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"id\": 530767913, \"node_id\": \"MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"created_at\": \"2019-09-12T10:37:34Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"author_association\": \"OWNER\", \"body\": \"&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦\" }, { ... } ] 总结此扩展方法优点：对于不在乎issue数量，只在乎最新评论的就比较适用，能够精准拿出前10条，很赞不足：一个issue下多个最新评论，如果想要显示的最新评论列表还包括文章标题，看起来可能不太好看，很多","link":"/theme/%E5%8D%9A%E5%AE%A2%E4%B8%ADgitalk%E6%9C%80%E6%96%B0%E8%AF%84%E8%AE%BA%E7%9A%84%E8%8E%B7%E5%8F%96.html"},{"title":"theme/博客换肤的一种实现方式思路","text":"","link":"/theme/%E5%8D%9A%E5%AE%A2%E6%8D%A2%E8%82%A4%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%80%9D%E8%B7%AF.html"},{"title":"博客源码分享","text":"写在前面 博客源码包括两个主题icarus和next，在主题基础之上参照各网友博客，以及自己的一些想法做出的一些修改以及增加部分新元素。因为修改了原作者源码，有什么问题请先联系我，不要去麻烦原作者了，能自己解决的问题就不要麻烦别人了，每个人的时间都很宝贵。膜拜和感谢所有模块的原作者,orz👻,辛苦了。 源码地址：欢迎围观，博主博客 一、icarus主题之上主要改动 新增gitalk最新评论widget 首页增加热门推荐 增加弹性配置影音（可加音乐、视频）模块 丰富弹性配置about页面 新增弹性配置友链模块 整体布局左右拉伸了一点，紧凑一些 文章页双栏模式、固定导航栏 引入可配置看板娘 归档页加入了一个文章贡献概览 置顶文章的设置 文章列表评论数显示 文章中推荐文章模块配置 增加深色主题切换 加入加密文章 碎碎念功能 透明无界样式 简化部分widget数据，加入查看全部按钮 gitalk评论增加评论开关，评论列表中标记博主 还有什么新的，好的feature欢迎大家随时提出来，有能力有时间就做出来 二、部分配置说明：本机环境：1234192:hexo-theme-icarus-removeif xx$ node -vv11.1.0192:hexo-theme-icarus-removeif xx$ npm -v6.4.1 克隆博客代码到本地1git clone https://github.com/removeif/hexo-theme-icarus-removeif.git 开始部分配置：敲黑板！！！！首先全局以及主题中的_config.yml配置成自己的对应参数。 1.热门推荐，最新评论：仅针对gitalk评论有效，如果配置完后显示本博客相关评论、推荐，请详细阅读这一条热门推荐，最新评论，文章评论数关联的js文件路径：themes/icarus/source/js/comment-issue-data.js以下引号里的地址改成自己对应的博客评论的issues的仓库相关的值。repoIssuesUrl改两个值（removeif和blog_comment改成自己对应的） themes/icarus/source/js/comment-issue-data.js12345// 评论issues仓库 by.removeif https://removeif.github.io/var repoIssuesUrl = \"https://api.github.com/repos/removeif/blog_comment/issues\"; // removeif：用户名，blog_comment：评论的issue仓库// 评论issues仓库 clientId、clientSecret怎么申请自行搜索，关于这暴露两个参数的安全问题，查看 https://removeif.github.io/2019/09/19/博客源码分享.html#1-热门推荐，最新评论：var clientId = \"46a9f3481b46ea0129d8\";var clientSecret = \"79c7c9cb847e141757d7864453bcbf89f0655b24\"; github api 详情可以参照官方api说明关于配置暴露client_id和client_secret安全性问题，gitalk作者有解释对应主题中的_config.yml要开启如下配置，xxx换成自己的，否则无效。 themes/icarus/_config.yml >folded1234567891011comment: type: gitalk owner: xxx # (required) GitHub user name repo: xxx # (required) GitHub repository name client_id: xxx # (required) OAuth application client id client_secret: xxx # (required) OAuth application client secret admin: xxx #此账户一般为用户名 GitHub user name 文章中能创建issue需要此用户登录才可以，点了创建issue后刷新一遍才能看到！！！！ create_issue_manually: true distraction_free_mode: true has_hot_recommend: true # 是否有热门推荐 has_latest_comment: true #是否有最新评论 说明： has_hot_recommend: true 是否开启首页热评，false-不开启，true-开启 has_latest_comment: true 是否开启最新评论，false-不开启，true-开启 热门推荐数据为评论数最多的文章，🔥后面的数字：根据文章的评论数*101 。 最新评论：为该仓库下，所有issue中的最新评论。 目前的最新评论有1分钟的本地缓存，评论后可能1分钟后才能看见最新评论，出于性能优化，每次请求接口处理还是挺耗时，comment-issue-data.js中可以自己去掉。 2.友链数据文件：文件路径：themes/icarus/source/js/friend.js相应格式增加自己需要的数据。 3.影音数据文件：文件路径：音乐：themes/icarus/source/json_data/music.json视频：themes/icarus/source/json_data/video.json相应格式增加自己需要的数据。 4.关于页面时间轴记录数据文件：文件路径：themes/icarus/source/json_data/record.json相应格式增加自己需要的数据。 5.看板娘配置主题中的_config.yml配置如下设置 1live2Dswitch: off #live2D开关 on为打开,off为关闭 6.置顶设置：.md文章头部数据中加入top值，top值越大越靠前，大于0显示置顶图标。修改依赖包中文件removeif/node_modules/hexo-generator-index/lib/generator.js如下： node_modules/hexo-generator-index/lib/generator.js >folded12345678910111213141516171819202122232425262728'use strict';const pagination = require('hexo-pagination');module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top == undefined){ a.top = 0; } if(b.top == undefined){ b.top = 0; } if(a.top == b.top){ return b.date - a.date; }else{ return b.top - a.top; } }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 7.配置文章中推荐文章模块根据配置的recommend值（必须大于0），值越大越靠前，相等取最新的，最多取5条。recommend（6.中top值也在下面示例）配置在.md文章头中，如下 123456789title: 博客源码分享top: 1toc: truerecommend: 1 keywords: categories-githubdate: 2019-09-19 22:10:43thumbnail: https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190919221611.pngtags: 工具教程categories: [工具教程,主题工具] 8.文章中某个代码块折叠的方法代码块头部加入标记 &gt;folded，如下代码块中使用。 main.java >folded123456789// 使用示例，.md 文件中头行标记\"&gt;folded\"// ```java main.java &gt;folded// import main.java// private static void main(){// // test// int i = 0;// return i;// }// \\\\``` 9.加入加密文章如下需要加密的文章头部加入以下代码 1234567891011121314---title: 2019成长记01top: -1toc: truekeywords: categories-java#以下为文章加密信息encrypt: truepassword: 123456 #此处为文章密码abstract: 咦，这是一篇加密文章，好像需要输入密码才能查看呢！message: 嗨，请准确无误地输入密码查看哟！wrong_pass_message: 不好意思，密码没对哦，在检查检查呢！wrong_hash_message: 不好意思，信息无法验证！--- 注：加密文章不会出现在最新文章列表widget中，也不会出现在文章中推荐列表中，首页列表中需要设置top: -1 让它排在最后比较合理一些。 10.碎碎念的使用在github中，创建碎碎念issue，并且打上对应的label（eg:666666）对应配置中为id，填写到source/self-talking/index.md文件中如下对应位置，其余配置","link":"/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html"},{"title":"theme/安装、部分配置icarus主题中文版","text":"","link":"/theme/%E5%AE%89%E8%A3%85%E3%80%81%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AEicarus%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87%E7%89%88.html"},{"title":"tricks-2020-02","text":"[toc] 3屏保软件LINE Screen savernemesit/SwiftBubble: recreation of the soap bubble screen saver from apple’s promotional videos for the new MacBook 12”pedrommcarrasco/Brooklyn: 🍎 Screensaver inspired by Apple’s Event on October 30, 2018 4git 操作详解图片 5MySQL思维导图v2-06e4f9b7dcf0d4b157196f5e0eeab0cc_r.jpg (2536×2969) https://img-blog.csdn.net/20180321211647612?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1gxODYyMTE0NDU3Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70 Git aliasZshrc 定义了许多 git alias alias | grep git 常用的： 123456789101112131415161718192021g=gitga='git add'gaa='git add -all'gcb='git branch -b'gcmsg='git commit -m'gco='git checkout'gl='git pull'ggpull='git pull origin \"$(git_current_branch)\"'gp='git push'ggpush='git push origin \"$(git_current_branch)\"'ggsup='git branch --set-upstream=origin/$(git_current_branch)'gloga='git log --oneline --decorate --graph --all'grm='git rm'grmc='git rm --cached'# 区别在于，gss 更简短，一行一个状态，以 M（modified） 或 ？？（untracked）开头gss='git status -s'gst='git status' 12cd ~/.oh-my-zsh/plugins/gitcat git.plugin.zsh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257## Functions## The name of the current branch# Back-compatibility wrapper for when this function was defined here in# the plugin, before being pulled in to core lib/git.zsh as git_current_branch()# to fix the core -&gt; git plugin dependency.function current_branch() { git_current_branch}# Pretty log messagesfunction _git_log_prettily(){ if ! [ -z $1 ]; then git log --pretty=$1 fi}compdef _git _git_log_prettily=git-log# Warn if the current branch is a WIPfunction work_in_progress() { if $(git log -n 1 2&gt;/dev/null | grep -q -c \"\\-\\-wip\\-\\-\"); then echo \"WIP!!\" fi}## Aliases# (sorted alphabetically)#alias g='git'alias ga='git add'alias gaa='git add --all'alias gapa='git add --patch'alias gau='git add --update'alias gav='git add --verbose'alias gap='git apply'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gbda='git branch --no-color --merged | command grep -vE \"^(\\+|\\*|\\s*(master|develop|dev)\\s*$)\" | command xargs -n 1 git branch -d'alias gbD='git branch -D'alias gbl='git blame -b -w'alias gbnm='git branch --no-merged'alias gbr='git branch --remote'alias gbs='git bisect'alias gbsb='git bisect bad'alias gbsg='git bisect good'alias gbsr='git bisect reset'alias gbss='git bisect start'alias gc='git commit -v'alias gc!='git commit -v --amend'alias gcn!='git commit -v --no-edit --amend'alias gca='git commit -v -a'alias gca!='git commit -v -a --amend'alias gcan!='git commit -v -a --no-edit --amend'alias gcans!='git commit -v -a -s --no-edit --amend'alias gcam='git commit -a -m'alias gcsm='git commit -s -m'alias gcb='git checkout -b'alias gcf='git config --list'alias gcl='git clone --recurse-submodules'alias gclean='git clean -id'alias gpristine='git reset --hard &amp;&amp; git clean -dfx'alias gcm='git checkout master'alias gcd='git checkout develop'alias gcmsg='git commit -m'alias gco='git checkout'alias gcount='git shortlog -sn'alias gcp='git cherry-pick'alias gcpa='git cherry-pick --abort'alias gcpc='git cherry-pick --continue'alias gcs='git commit -S'alias gd='git diff'alias gdca='git diff --cached'alias gdcw='git diff --cached --word-diff'alias gdct='git describe --tags $(git rev-list --tags --max-count=1)'alias gds='git diff --staged'alias gdt='git diff-tree --no-commit-id --name-only -r'alias gdw='git diff --word-diff'function gdv() { git diff -w \"$@\" | view - }compdef _git gdv=git-diffalias gf='git fetch'alias gfa='git fetch --all --prune'alias gfo='git fetch origin'alias gfg='git ls-files | grep'alias gg='git gui citool'alias gga='git gui citool --amend'function ggf() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force origin \"${b:=$1}\"}compdef _git ggf=git-checkoutfunction ggfl() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force-with-lease origin \"${b:=$1}\"}compdef _git ggfl=git-checkoutfunction ggl() { if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git pull origin \"${*}\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull origin \"${b:=$1}\" fi}compdef _git ggl=git-checkoutfunction ggp() { if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git push origin \"${*}\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push origin \"${b:=$1}\" fi}compdef _git ggp=git-checkoutfunction ggpnp() { if [[ \"$#\" == 0 ]]; then ggl &amp;&amp; ggp else ggl \"${*}\" &amp;&amp; ggp \"${*}\" fi}compdef _git ggpnp=git-checkoutfunction ggu() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull --rebase origin \"${b:=$1}\"}compdef _git ggu=git-checkoutalias ggpur='ggu'alias ggpull='git pull origin \"$(git_current_branch)\"'alias ggpush='git push origin \"$(git_current_branch)\"'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias gpsup='git push --set-upstream origin $(git_current_branch)'alias ghh='git help'alias gignore='git update-index --assume-unchanged'alias gignored='git ls-files -v | grep \"^[[:lower:]]\"'alias git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github master:svntrunk'alias gk='\\gitk --all --branches'alias gke='\\gitk --all $(git log -g --pretty=%h)'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p'alias glgg='git log --graph'alias glgga='git log --graph --decorate --all'alias glgm='git log --graph --max-count=10'alias glo='git log --oneline --decorate'alias glol=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\"alias glols=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --stat\"alias glod=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\"alias glods=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset' --date=short\"alias glola=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --all\"alias glog='git log --oneline --decorate --graph'alias gloga='git log --oneline --decorate --graph --all'alias glp=\"_git_log_prettily\"alias gm='git merge'alias gmom='git merge origin/master'alias gmt='git mergetool --no-prompt'alias gmtvim='git mergetool --no-prompt --tool=vimdiff'alias gmum='git merge upstream/master'alias gma='git merge --abort'alias gp='git push'alias gpd='git push --dry-run'alias gpf='git push --force-with-lease'alias gpf!='git push --force'alias gpoat='git push origin --all &amp;&amp; git push origin --tags'alias gpu='git push upstream'alias gpv='git push -v'alias gr='git remote'alias gra='git remote add'alias grb='git rebase'alias grba='git rebase --abort'alias grbc='git rebase --continue'alias grbd='git rebase develop'alias grbi='git rebase -i'alias grbm='git rebase master'alias grbs='git rebase --skip'alias grev='git revert'alias grh='git reset'alias grhh='git reset --hard'alias groh='git reset origin/$(git_current_branch) --hard'alias grm='git rm'alias grmc='git rm --cached'alias grmv='git remote rename'alias grrm='git remote remove'alias grs='git restore'alias grset='git remote set-url'alias grss='git restore --source'alias grt='cd \"$(git rev-parse --show-toplevel || echo .)\"'alias gru='git reset --'alias grup='git remote update'alias grv='git remote -v'alias gsb='git status -sb'alias gsd='git svn dcommit'alias gsh='git show'alias gsi='git submodule init'alias gsps='git show --pretty=short --show-signature'alias gsr='git svn rebase'alias gss='git status -s'alias gst='git status'# use the default stash push on git 2.13 and newerautoload -Uz is-at-leastis-at-least 2.13 \"$(git --version 2&gt;/dev/null | awk '{print $3}')\" \\ &amp;&amp; alias gsta='git stash push' \\ || alias gsta='git stash save'alias gstaa='git stash apply'alias gstc='git stash clear'alias gstd='git stash drop'alias gstl='git stash list'alias gstp='git stash pop'alias gsts='git stash show --text'alias gstall='git stash --all'alias gsu='git submodule update'alias gsw='git switch'alias gswc='git switch -c'alias gts='git tag -s'alias gtv='git tag | sort -V'alias gtl='gtl(){ git tag --sort=-v:refname -n -l \"${1}*\" }; noglob gtl'alias gunignore='git update-index --no-assume-unchanged'alias gunwip='git log -n 1 | grep -q -c \"\\-\\-wip\\-\\-\" &amp;&amp; git reset HEAD~1'alias gup='git pull --rebase'alias gupv='git pull --rebase -v'alias gupa='git pull --rebase --autostash'alias gupav='git pull --rebase --autostash -v'alias glum='git pull upstream master'alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'alias gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify --no-gpg-sign -m \"--wip-- [skip ci]\"' 临时禁用 alias 加 \\ , 如： \\ls 或 unalias ls 我的 alias1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/usr/bin/env bash# 文件过长，建议放~/.alias## 控制cd命令的行为## get rid of command not found ##alias cd..='cd ..'## a quick way to get out of current directory ##alias ..='cd ..'# zsh 自带以下alias#alias ...='cd ../../../'#alias ....='cd ../../../../'#alias .....='cd ../../../../'#alias .4='cd ../../../../'#alias .5='cd ../.././../..'## 命令加默认参数alias bc='bc -l' # 让计算器默认开启math库alias mkdir='mkdir -p' # 自动创建父目录alias mv='mv -i' # 移动，复制文件显示详细信息alias cp='cp -i'alias ln='ln -i'alias wget='wget -c' #默认断点续传alias df='df -H' # human df查看磁盘使用情况alias du='du -h' # du 查看当前目录各个文件、目录占用大小，-s （sum）总大小alias ping='ping -c 5' # ping 5次停止alias top='htop' # 用更好用的htop替换top## 命令缩写alias h='history -30'alias c='clear'## 创建一系列新命令alias path='echo -e ${PATH//:/\\\\n}' # 显示变量PATH,并将：替换为回车alias now='date +\"%T\"' # 时分秒alias nowtime=nowalias nowdate='date +\"%Y-%d-%m\"'# 年月日alias header='curl -I' # get web server headers #alias checknet='curl -I http://www.baidu.com' # 检查网络连通性alias checkproxy='curl -I http://www.youtube.com' # 检查 proxyalias psmem10='ps aux | sort -nr -k 4 | head' # mem占用前10alias pscpu10='ps aux | sort -nr -k 3 | head' # cpu占用前10alias speed='speedtest-cli --simple' #测速 （需安装speedtest-cli）alias ipe='curl ipinfo.io/ip' # 查看公网ip（???）alias ipi='ipconfig getifaddr en0' # 查看ip地址alias untar='tar -zxvf'alias getpass='openssl rand -base64 6' # 8位密码mcd() { mkdir -p \"$1\"; cd \"$1\";} # 创建目录并进入cls() { cd \"$1\"; ls;} # cd and ls## 以树形结构递归地显示目录结构,命令有问题，不实用sbs() { du -d 1 | sort -nr | perl -pe 's{([0-9]+)}{sprintf \"%.1f %s\", $1&gt;=2**30? ($1/2**30, \"G\"): $1&gt;=2**20? ($1/2**20, \"M\"): $1&gt;=2**10? ($1/2**10, \"K\"): ($1, \"\")}e';}# k8salias kdev=\"kubectl --cluster kubernetes-dev --user kubernetes-admin -n\"alias ktest=\"kdev data-test\"alias kprod=\"kubectl --cluster kubernetes --user dev -n data-prod\"alias kstaging=\"kubectl --cluster kubernetes --user dev -n data-staging\"# sshalias sshcpui='ssh -CAXY determined-cori.zhangronghui.brw@bj-a-internal.brainpp.cn'alias sshgpui='ssh -CAXY goofy-mestorf.zhangronghui.brc@bj-a-internal.brainpp.cn'alias sshcpu='ssh -CAXY determined-cori.zhangronghui.brw@bj-a.brainpp.cn'alias sshgpu='ssh -CAXY goofy-mestorf.zhangronghui.brc@bj-a.brainpp.cn'export cpui='determined-cori.zhangronghui.brw@bj-a-internal.brainpp.cn'export cpu='determined-cori.zhangronghui.brw@bj-a.brainpp.cn'export gpui='goofy-mestorf.zhangronghui.brc@bj-a-internal.brainpp.cn'export gpu='goofy-mestorf.zhangronghui.brc@bj-a.brainpp.cn'alias ytdl='cd \"/Users/zhangronghui/ytdl\"; python3 main.py'# alias ytdl=\"youtube-dl --proxy 'socks5://127.0.0.1:1086' --write-auto-sub --sub-lang en,cn -f bestvideo+bestaudio -o '%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s'\"# alias rm=rmtrashalias py=\"python3 main.py\"alias tabcopyToMdLink=\"python3 '/Volumes/Data/PycharmProjects/private/22 tabcopyToMdLink/main.py'\"# 常用命令的替代工具alias ls='exa'alias npm='cnpm'alias grep='ag'alias cat='bat'# mycli -uroot -pkang0322# 替代 mysql -uroot -p# 查看 json 文件# fx package-lock.jsonalias wget='axel -n 32'alias pip='pip3'# 关于 ssh 别名的注意事项不要创建 ssh 别名，代之以 ~/.ssh/config 这个 OpenSSH SSH 客户端配置文件。它的选项更加丰富。下面是一个例子： Host server10 Hostname 1.2.3.4 IdentityFile ~/backups/.ssh/id_dsa user foobar Port 30000 ForwardX11Trusted yes TCPKeepAlive yes然后你就可以使用下面语句连接 server10 了： $ ssh server10 如果有来生—— 三毛 如果有来生，要做一棵树， 站成永恒。没有悲欢的姿势， 一半在尘土里安详， 一半在风里飞扬； 一半洒落荫凉， 一半沐浴阳光。 非常沉默、非常骄傲。 从不依靠、从不寻找。 如果有来生，要化成一阵风， 一瞬间也能成为永恒。 没有善感的情怀，没有多情的眼睛。 一半在雨里洒脱， 一半在春光里旅行； 寂寞了，孤自去远行， 把淡淡的思念统统带走， 从不思念、从不爱恋； 如果有来生，要做一只鸟， 飞越永恒，没有迷途的苦恼。 东方有火红的希望， 南方有温暖的巢床， 向西逐退残阳，向北唤醒芬芳。 如果有来生， 希望每次相遇， 都能化为永恒。 5拆米袋线短的一边，在线与袋子的连接处，剪断。米袋一边 1 条线，一边 2 条线。从 2 条线的一边解开。 nfc 记录时间知道自己的时间花费之后能够让我们更好的做计划、平衡生活和自我提升。每次想记录时间就觉得过程十分复杂和枯燥，今天就和大家分享一个最近研究出来的，超高效的时间记录吧！ 出现&amp;提到的产品： ​ NFC电子标签 https://m.tb.cn/h.VYLOGi2 （如果贴在电脑上需要用抗金属贴） Toggl 时间记录 ​ 电脑 http://bit.ly/2tY3ps3 ​ 苹果手机 https://apple.co/2Ryd81l ​ 安卓手机 http://bit.ly/36Azjbm 批量重命名和批量替换字符串批量修改文件名假设要把所有以“disc-”开头的文件改为“dev-”开头，那么在linux下执行命令： 1rename 's/disc-/dev-/' * 批量修改文件内容1、假设我们要把文件中的“设计开发”改为“专业”，那么执行命令： 1sed -i \"s/设计开发/专业/g\" `grep 设计开发 -rl .` 2、假设我们要把文件中的http://7oxjrx.com1.z0.glb.clouddn.com改为http://cdn.voidking.com，那么执行命令： 123sed -i \"s/http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com/http:\\/\\/cdn.voidking.com/g\" `grep http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com -rl .`# 或者sed -i 's!http://7oxjrx.com1.z0.glb.clouddn.com!http://cdn.voidking.com!g' `grep http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com -rl .` 3、假设我们要把文件中的https://www.voidking.com/2018/06/11/dev-hexo-categories/改为https://www.voidking.com/dev-hexo-categories/，这个就比较难了，可以先进行调试： 12345grep -P '\\d{4}\\/\\d{2}\\/\\d{2}\\/' -rl .echo \"https://www.voidking.com/2018/06/11/dev-hexo-categories/\" | sed \"s/\\d{4}\\/\\d{2}\\/\\d{2}\\///g\"echo \"https://www.voidking.com/2018/06/11/dev-hexo-categories/\" | sed \"s/\\([0-9][0-9][0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\///g\" 因为grep和sed都不支持完全的正则表达式，所以grep要加P参数，sed要改写正则表达式。最后得到的命令为： 1sed -i \"s/\\([0-9][0-9][0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\///g\" `grep -P '\\d{4}\\/\\d{2}\\/\\d{2}\\/' -rl .` 在线分词工具微词云 - 制作 - 设计页 9京东口罩自动抢购并下单cycz/jdBuyMask: 京东监控口罩有货爬虫，自动下单爬虫，口罩爬虫Rlacat/jd-automask: 防护-京东口罩自动抢购并下单 黑苹果macOS取消4位数密码限制 可设置一位数密码 – 黑苹果屋 pwpolicy -clearaccountpolicies 未测试 黑苹果三码注入解决iMessage、FaceTime、APPStore、iCloud登录（陆）使用问题 – 黑苹果屋Clover引导如何简单隐藏多余启动磁盘 – 黑苹果屋设置Clover自动倒计时引导系统 – 黑苹果屋 关键字 免费 的搜索结果 - 精品MAC应用分享ReadKit 2.4.3 一站式阅读体验 - 精品MAC应用分享 Mpv 安装 export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; brew cask install mpv 装的过程有点久 去 IINA+ 将播放器设置为 mpv, 可解决播放视频没声音的问题 配置见本站其他博客 10推荐一个非常实用的学习 GitHub 的软件 | Laravel China 社区 用不上的网站： 再分享几个YouTube视频在线解析下载网站 – 楚盟网分享一个视频在线解析下载网站，秒杀youtube、Facebook视频 – 楚盟网 bilibili evolved : bilibili 优化 及 批量下载油猴插件 雨课堂一键完成预习【注意：此软件只适用于没有习题的课件】 蓝奏云：https://www.lanzous.com/i6voq6d Berrycast - 屏幕录制分享工具[Windows/macOS] - 小众软件小爱同学v2.8.01通用版 非小米手机可用 | 芊芊精典4k wallpaper 壁纸4k Wallpapers HD &amp; 8k Images for Desktop and MobileIncredible Wallpapers and Background pictures for mobile and desktop for free - WallpaperTAG Authy 两步验证利器 Authy 是一款两步验证软件，与 Google 身份验证器类似，支持 iOS、安卓、macOS、Windows、谷歌浏览器扩展。 Authy 可以同时管理多个平台的两步验证，支持多设备同时使用，也可以快速在设备之间迁移、抹除。 对于中国用户 Authy 偶尔会出现短信接受延迟等情况。 官网 https://authy.com iRightMouse 1.0.3 for Mac 超赞的Mac右键菜单扩展干净的Mac 破解软件下载macwkhttps://macstore.info/https://www.macappbox.com/ pushups 备份位置 12Mac 悬浮播放 YouTube 影片codeclown/FloatPlayer: FloatPlayer is a simple Mac app that plays a floating YouTube-video on your screen. 自动生成视频字幕raryelcostasouza/pyTranscriber: pyTranscriber can be used to generate automatic transcription / automatic subtitles for audio/video files through a friendly graphical user interface. AlternativeTo 寻找同类优秀软件AlternativeTo - Crowdsourced software recommendations Ma63d/leetcode-viewer: 用无后台、纯前端的单页应用来分享、呈现你的leetcode源码吧!13Mpv 录制直播streaming - Save video playing in mpv –ytdl to a file while playing - Super User 1234mpv --stream-record=video.mkv url# --record-file 过时了mpv --record-file=video.mkv url url 可以通过 iina+ + iina 播放直播，然后在播放列表里右键复制链接 Mac技巧之苹果电脑下载/录制 Bilibili 直播视频的软件：B站录播机 - 苹果fans博客未测试 Mpv 官方脚本User Scripts · mpv-player/mpv Wiki IFTTT（没学）4.打造你自己的个性化极速通知神器。如果你和我一样喜欢折腾，并且还没有用过IFTTT这款软件，那么请赶紧尝试吧~ ifttt是“if this then that”的缩写，事实上是让你的网络行为能够引发连锁反应、让你使用更为方便，其宗旨是“Put the internet to work for you”（让互联网为你服务）。ifttt旨在帮助人们利用各网站的开放API，将Facebook、Twitter等各个网站或应用衔接，完成任务，使“每个人都可以成为整个互联网不用编程的程序员”。 目前已经同时支持iOS、Android以及网页版：Put the internet to work for you.有了它可以实现非常多非常好玩有用的功能，爱折腾的同学肯定能自行研究出各种厉害的用法。入门介绍：iFTTT 入门介绍与简单使用设置教程 这里只介绍和RSS功能结合起来的基本应用：注册了IFTTT账号、在手机上下载客户端后，就能够在线编辑你想要的各种网络任务了。比如实现这个：“如果在交大BBS上有人出售ipad的话，在手机上弹窗通知我” 因为学校BBS上经常有抢手的二手货，每次等我看到的时候就被人秒掉了。自从有了RSS+IFTTT，遇到我关注的二手商品，我每次都能快人一步了XD。 另外PushBullet也是非常好的可以结合使用的应用，暂不详述。 cnfeat/Rime: 鼠须管 小鹤双拼 输入法配置及配色方案 sunzongzheng/music: electron跨平台音乐播放器；可搜网易云、QQ音乐、虾米音乐；支持QQ、微博、Github登录，云歌单; 支持一键导入音乐平台歌单13Chrome插件Zoom Text Only，实现浏览器中仅缩放文本大小-文章-扩展迷Share Extensions插件，一键分享你正在使用的Chrome扩展-文章-扩展迷最高增强六倍的VolumeControl插件，应该是浏览器上最好用的音量控制器-文章-扩展迷Scroll To Top Button插件，一键到达网页顶部或底部-文章-扩展迷牛客简历助手，闪填简历模板，自动同步招聘官网-文章-扩展迷SearchBar，快捷搜索插件，集合维基百科/Wolfram/eBay等多平台-文章-扩展迷AutoScroll，页面自动滚动插件，自定义滚动速度-文章-扩展迷colorize-change-color-for，浏览器颜色调整插件，打造谷歌搜索/YouTube新主题-文章-扩展迷Hippo Video，视频在线录制/编辑插件，支持屏幕录制-文章-扩展迷 Web Developer，开发者调试插件，集成多类web开发工具-文章-扩展迷 hr3lxphr6j/bililive-go: 一个直播录制工具全平台 CHKZL/DDTV2: 监控室老大爷多路直播监控——DDTV1.0的精神续作(，DDTV2.0。可进行B站直播开播提醒，自动录制，播放。油管，TC直播监控。 Win 平台 m-cli 命令行控制 Mac12345678910111213141516171819202122232425262728293031323334353637383940414243444546➜ ~ brew install m-cli➜ ~ m -h Swiss Army Knife for macOS ! usage: m [OPTIONS] COMMAND [help]OPTIONS --update update m-cli to the latest version --uninstall uninstall m-cliCOMMANDS: help battery bluetooth dir disk display dns dock finder firewall flightmode gatekeeper group hostname info itunes lock network nosleep notification ntp printer restart safeboot screensaver service shutdown sleep timezone trash update user volume vpn wallpaper wifi 14win baiduyun 破解下载 亿寻 — yixun繁体字幕转简体12345678910111213141516171819➜ subtitles pip install hanziconv➜ subtitles hanzi-convert -husage: hanzi-convert [-h] [-o OUTFILE] [-s] [-v] infileSimplified and Traditional Chinese Character ConversionVersion 0.3.2 (By Bernard Yue)Converting to Traditional Hanzi by defaultpositional arguments: infile filename | \"-\", corresponds to stdinoptional arguments: -h, --help show this help message and exit -o OUTFILE, --output OUTFILE filename to save output, default to stdout -s, --simplified convert to simplified -v, --version show program's version number and exit➜ subtitles hanzi-convert -o While.You.Were.Sleeping.E02.170927.1080p-NEXT.chs.srt -s While.You.Were.Sleeping.E02.170927.1080p-NEXT.cht.srt Todo: 简化操作123# hanzi-convert-s ....srt 转换一个字幕hanzi-convert-s(){hanzi-convert -o $1.chs.$2 -s $1.$2}# hanzi-convert-s-dir ./path 转换一个目录 有编码问题，不是所有字幕都能转换 电话骚扰 - 不死鸟 - 分享为王15agefans：动漫追番网站 - 不死鸟 - 分享为王每日图片：第176期 - 不死鸟 - 分享为王微信QQ最简单互传文件软件——open2share - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn用了很久的鼠标指针样式，用了很久了哦，超级喜欢 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn微信僵尸粉被删好友查找工具 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn 关于疫情防控期间开通WEBVPN访问校内网站资源的通知美剧星球 v1.1.4无广告免费看最新高清美剧 | 芊芊精典电影迷 Mod v1.6.0去广告推荐精简会员版+影迷天堂v1.2.9无广告免费看全网影视 | 芊芊精典抖音短视频v9.8.1去广告去水印版 | 芊芊精典 Enhancer for YouTube插件，YouTube播放器多功能增强控件-文章-扩展迷Auto Sci-Hub插件，将DOI号自动替换为Sci-Hub链接，一键下载文献-文章-扩展迷SearchBar，快捷搜索插件，集合维基百科/Wolfram/eBay等多平台-文章-扩展迷吐血推荐珍藏的IDEA插件Android 抖音短视频v9.8.1 去广告版 - 果核剥壳Sleepo「Sleepa」v1.6.2 for Android 破解高级版 —— 提升您睡眠质量、休息质量、放松和冥想 | 异星软件空间 SoundSource 4.2.1 音频控制软件 - 精品MAC应用分享超全的PanDownload搜索插件！ - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cnKlokki 1.1.3 任务管理 - 精品MAC应用分享DropDMG 3.5.9 轻松制作DMG文件 - 精品MAC应用分享最新版PC微信2.8.0.121正式版-防撤回 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cnbackiee 提供數千張 8K、5K、4K 與高畫質 Windows 免費桌布圖片的免費工具，支援一鍵設置功能 - 電腦王阿達Motion 可針對特定時間鎖定指定網站，來提升工作效率的免費擴充外掛 - 電腦王阿達FeedPop - RSS阅读器，更适合国人使用的优秀国产RSS阅读器-文章-扩展迷满速的百度网盘下载工具-亿寻，更新新版及官网-福利吧窗口最前工具WTOP - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn微搜v2.0.1 图片网盘等多功能搜索器 | 芊芊精典电影天堂v1.0去广告去升级版+Noad v8.0.2_清爽版『付费电影/直接免费看』 | 芊芊精典光影v1.5.0全网VIP支持倍速缓存 | 芊芊精典大象视频v1.3.6去广告版 全网VIP影视免费看 | 芊芊精典面试热点|理解TCP/IP传输层拥塞控制算法ZY Player(开源影视聚合播放器) v0.8.9 绿色版 - 果核剥壳Downie 3.9.9 视频下载工具 - 精品MAC应用分享 关于启动“雨课堂”教学平台开展在线教学的通知关于春季学期使用“爱课堂”网络教学平台开展在线教学的通知Wondershare Video Converter(万兴优转)v11.7.1.3 特别版 - 果核剥壳 Berrycast - 屏幕录制分享工具[Windows/macOS] - 小众软件All Windows Appear - MacMenuBar.com【2月8日更新】选择文件-右键-发送到蓝奏云盘【一键生成蓝奏云盘分享链接】 - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn 北京邮电大学研究生院 Unplug Alarm - MacMenuBar.com MacBook Pro 中app store购买过程中出错是为什么？ - 知乎在 Mac App Store 注销并重新登录。 16低端影视 - 超清在线视频站首页_海兔影院-中国版电视剧-6v电影-新版6v电影_免费电影_高清电影__最新电视剧下载（旧版66影视） 独播库哔嘀影视，热门电影，最新电影，最新电视剧，免费下载，免费在线观看 最新电影网_西瓜影音_碟调网_看看屋影视_看看影院_2018最新电影电视剧在线观看蛋蛋赞影院 | 最新最全高清在线影院 迅播影院-迅播高清-Gvod电影-迅雷电影下载-迅播22tu.cc酷绘视频 - 轻松随心看手机看大片,手机看电影,手机看电视,手机电影下载 - 我的电影网七七看片-七七影院_七七电影天堂_最新电影百度影音_BT天堂全集网 23.草民电影：https://www.cmdy5.com/24.私人官网：http://www.aishang118.cn/25.电影盒子：http://www.tv5box.com/26.全能影视：http://www.qnvod.net/27.影视分享：https://www.ysshare.com/28.94神马电影网：http://www.9rmb.com/29.好恐怖：http://www.hkb123.com/30.慢头影视：http://www.paojiaoys.com/31.影猫：http://www.mvcat.com/32.BT猫：https://www.btmao.cc/33.神马电影网：https://www.jlszyy.c34.达达兔电影院：https://www.dadatutu.com/35.西瓜影院：https://www.xigua2222.com/36.片吧：http://www.pianba.tv/37.片库网：https://www.pianku.tv/38.无双影视：https://53ys.cc/39.80s手机电影网：http://www.8080s.net/40.西瓜电影：https://www.xigua110.com/41.人人影视：http://www.yyetss.com/41.人人影视：http://www.yyetss.com/42.高清资源网：http://www.gaoqingzy.com/43.OK电影网：http://www.kk2w.cc/44.豆瓣电影资源采集网：http://www.douban666.com/45.87影院：https://www.87kk.tv/46.放映影院：https://www.t90dyy.tv/47.速影TV：https://suyingtv.com/48.嘀哆咪影视：https://www.haiduomi.cc/49.优片网：http://www.iupian.com/50.黑米影院：https://www.tv432.com/51.且听风吟：http://www.qtfy7.com/52.88影视网：https://www.88ys.com/53.嘀哩哩：http://www.dililitv.com/54.云播TV：https://www.yunbtv.com/55.田鸡影院：http://www.tianjiyy123.com/56.奈非影视：https://www.nfmovies.com/57.全集网：https://www.quanji789.com/58.全集网：http://quanji456.com/59.狗带TV：http://www.goudaitv1.com/60.五杀电影院：https://www.lol5s.com/61.蓝马影视：https://www.lanmays.com/62.奇葩影视：https://www.qpvod.com/63.迅雷哥：https://www.4142.cc/64.影视分享：https://www.ysshare.com/65.新视觉影院：http://www.yy6080.cn/66.v部落：http://www.vbuluo99.com/67.神驴影院：http://www.shenlvyy.com/68.美鱼剧场：http://www.hailiys.com/69.吼吼：http://hoho.tv/70.酷云影视：https://kuyun.tv/71.想看剧：https://www.xiangkanju.cc/72.去看TV：http://www.quk73.胖子视频：http://www.pangzi.ca/74.海外影院：https://www.haiwaiyy.com/75.好吧：http://hao8tv.com/76.日本影视：http://www.jp2468.com/77.TNT影视：http://www.tntdy2.vip/78.优乐电影网：http://www.youlebe.com/79.面包网：https://www.mianbao99.com/80.猫哈哈：http://www.maohaha.com/81.七七电视：https://www.77ds.vip/82.我乐电影：http://www.56dy.com/83.钉子电影：http://www.dingziyc.com/84.蓝鲸电影：https://www.ljmovie.com/85.葡萄影视：https://www.putaoys.com/86.太初电影：https://www.tcmove.com/87.完美看看：https://www.wanmeikk.me/88.吾爱看影视：http://www.5aikp.com/89播王：https://bowan.su/90.Gimy TV剧迷：https://gimy.tv/91.NO视频：http://www.novipnoad.com/92.枫林网：http://8maple.ru/93.91美剧：https://91mjw.com/94.美剧鸟：http://www.meijuniao.com/95.爱美剧：https://www.meiju.net/96.天天看美剧：http://www.ttkmj.tv/97.日剧TV：https://www.rijutv.com/98.韩剧集网：https://www.juji.tv/99.韩剧网：http://www.hanju.cc/100.韩剧TV：https://www.hanjutv.com/101.Zzzfun：http://www.zzzfun.com/102.妮可动漫：http://www.nicotv.me/103.吐槽弹幕网：http://www.tucao.one/104.动漫岛：http://www.dmd8.com/105.碟影视界：http://www.952780.com/106.皮皮影视网：https://www.taiks.com/107.ADC电影网：https://www.adcmove.com/108.欧西电影：https://www.ouxi.me/109.青鸟影视：https://www.qingniao.me/110.盐酥鸡：https://www.ysuzy.com/111.爱电影天堂：https://www.idytt.com/ 北京地铁满载率查询功能升级 可实时显示车厢满载率 - CNMO 17GitZipGitZip 可以帮助我们下载仓库中的部分文件，并且支持下载单个文件夹。 如何使用呢？ 鼠标定位到我们需要下载的某个项目子文件夹上，在空白区域双击： 然后点击下载即可！ clicli.me 超清动漫视频在线观看c站-clicli弹幕网_(⁄•⁄ω⁄•⁄) 社保~ clicli.me 分轨-上传文件，即刻分离人声和伴奏全国新冠肺炎疫情实时动态 - 丁香园·丁香医生首页 - 简单教程，简单编程 寻–优秀好玩的网址聚合 18免费宽带提速工具，支持部分地区及宽带 - 冰封娱乐网 19\\1. pdf2doc https://www.pdf2doc.com/\\2. 局域网共享精灵 http://lanshared.com/\\3. 造字APP http://myfont.me/\\4. copytranslator https://copytranslator.github.io/github项目https://github.com/CopyTranslator/CopyTranslator\\5. 较真查证平台 https://vp.fact.qq.com/home\\6. visulgo https://visualgo.net/en\\7. OneDrive直链获取工具 https://onedrive.gimhoy.com/\\8. 考试酷 https://www.examcoo.com/index/ku\\9. logo-crunch https://brandmark.io/logo-crunch/\\10. Soundgood https://play.soundsgood.co/ (被墙) desktop.telegram.orgdesktop 版本可以用 23电子书下载网站全览每日书单- 精品电子书下载 - azw3 - epub - mobi - kindle电子书水果派 美剧星球APP官网 -免费在线看最新高清美剧攀登 https://pan.baidu.com/s/1dI8S31Z4oE7kpuO-CfS_yw 提取码：p79k备用 提取码: v283 电影推荐 · MVCATTable Capture，Chrome表格复制插件，自动筛选复制HTML中的表格-文章-扩展迷Smart Tab Mute插件，让浏览器仅保留其中一个标签页的音频播放-文章-扩展迷 打不开“XXX”，因为它来自身份不明的开发者1.打开了 Terminal 终端后 ，在命令提示后输入 sudo spctl –master-disable 2.系统偏好设置&gt;&gt;安全与隐私&gt;&gt;允许安装未知来源 24Github中转下载Link Klipper插件，提取并导出网页链接插件，储存为CSV或者TXT格式文件-文章-扩展迷 可以用来导出所有链接，然后下载视频 25等门槛效应 一个人如果接受了他人的请求，为了避免认知上的失调，或者是出于想保持人设的心理，就有可能接受更大的请求 自我羊群效应 所谓自我羊群效应，指的是，即使影响你决策的情绪已经消失了，你日后的决策也会参考第一次的结果，从而持续受到最初那个情绪的影响。 比如说你女朋友生日前几天你刚好打麻将赢了不少，心情非常畅快，于是平时只舍得送露华浓的，这次居然买了香奈儿，而下次她生日的时候，即使你已经不记得赢钱这回事了，你也很大可能不会再送露华浓了。 所以啊，在面对新环境或者情绪很不稳定的时候，一定不要轻易下决定，因为一次决定并不是只影响一个结果。 ④逆向合理化效应 人是相当奇怪的自我合理化机器，这个效应指的是，当一件是你做久了之后，你就会为这件事找到一个合理的原因，以此来证明自己是正确的。 ⑤赋能效应 这张图你应该很熟悉了，就是所谓的艾宾浩斯遗忘曲线图，但实际上，还有一个非常重要的点你可能没有注意到，就是下面这张图： 不同内容的遗忘程度，也是不同的，艾宾浩斯总结出来，我们的大脑，最容易忘记那些没有意义的音节，有意义的东西，留存率会更高。 所以，在学习一个技能或者知识点之前，就要不断在心中赋予这个技能或知识点意义，比如说学了之后，能让自己轻松很多，能给客户更好的用户体验，能得到老板的赏识，走上人生巅峰等等。 ⑦生成效应 说的是相对于你故意去背诵的现成的知识点，你更能记住的是学习过程中，自己主动提取推导出来的知识点，这点运用在学习上非常有效。 ⑧踢猫效应 这个效应要多注意一下哦，指的是对比自己弱小或者等级比自己低的人发泄不满，进而产生了连锁反应，由塔尖一直扩散到最底层，最后那个成为最终受害者。 我们经常能看到，刚进团队的新人经常成为背锅侠；那些努力扎进高级圈子的人，最后都不正常了。 在一个环境里，如果只能当最弱一环，那还是赶紧离开的好。 ⑨人们会倾向于在当前的选项里做选择，而不是考虑有没有其他选项。 所以啊，如果你要约人，最好不要说“诶，你周六有没有空？”，因为如果对方原本就没有什么打算跟你出去，那ta会倾向于选择成本低的那个，没空；但如果你说“周六出去还是周日？”那ta无论选哪个，你的目的都得逞啦。 ⑩启动效应 所谓的启动效应，指的是当你看到某个事物的时候，大脑自动会触发你的行为或认知。 如果你想要坚持运动，就把瑜伽垫哑铃之类的放在显眼的地方，请了私教的话，就把他的朋友圈星标，聊天窗口置顶，这些东西就会触发你想运动这个认知； 如果你早上喝杯咖啡工作效率能提高不少，那咖啡对你来说也有启动效应。 把每一个启动效应都记下来，你的每天的成就感，至少能提升30% ⑪从来没有体验过失去的人，对于拥有是什么滋味的认知，往往也非常有限。 总是无条件地帮别人的忙，别人一喊你就到，长此以往，你的付出就会沦为应该，深藏不露，偶尔出手相助，反而能让大家记住你的好。 ⑫出丑效应 又称仰巴脚效应或缺点效应，是指太过完美的人，经常不太讨人喜欢，因为无论谁，站在你身边都无所适从，自愧不如，还怎么做朋友嘛。 最讨人喜欢的人，往往都是精明之中又带点小缺点的。 ⑬过度理由效应 之前在一个读本里看到一个故事： 一位老人在一个小乡村里休养，但附近却住着一些十分顽皮的孩子，他们天天互相追逐打闹，喧哗的吵闹声使老人无法好好休息。在屡禁不止的情况下，老人把孩子们都叫到一起，告诉他们谁叫的声音越大，谁得到的报酬就越多，他每次都根据孩子们吵闹的情况给予不同的奖励。到孩子们已经习惯于获取奖励的时候，老人开始逐渐减少所给的奖励，最后无论孩子们怎么吵，老人一分钱也不给。结果，孩子们认为受到的待遇越来越不公正，认为不给钱了谁还给你叫，再也不到老人所住的房子附近大声吵闹。 这其实就是过度理由效应，每个人都力图使自己和别人的行为看起来合理，因而总是为行为寻找原因。一旦找到足够的原因，人们就很少再继续找下去。 有时候反其道而行效果很不错。 ⑭破窗效应 一个屋子如果窗户破了，没有及时修补，隔段时间，其他的窗子也会被打破，这个现象就是破窗效应。 其实人也是这样的，一个坏习惯你放着不管，迟早会滋生出更多的坏习惯；对方如果一开始欺负你的时候，你没有反抗，后面就会变本加厉。 ⑮皮格马利翁效应 心理学家们发现，人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 用人话来讲，就是当一个人获得了别人的信任跟支持之后，ta就会不断调整自己去适应大家的期望，从而增强了自我的价值，变得自信，变得更加积极向上，并且尽力达到大家的期待，从而维持这种社会支持的连续性。 关于这个效有一个非常著名的实验，我记得是中学的时候了解到的。 1960年，哈佛大学的罗森塔尔博士告诉加州一所学校的两位教师，他们是本校最好的教师，他们班里的学生比同龄孩子智商要高，请他们务必与其他孩子一样正常对待。一年之后，这两个班级的学生成绩是全校中最优秀的，甚至比其他班学生的分数值高出好几倍。而其实这两位教师是被随机挑选出来的，所教的孩子们也与其他孩子无异。 26fan qiang API IDEA javadoc 安装插件 javadoc 在需要生成doc 的目录右键 generate javadoc，会为 Java","link":"/tricks/tricks-2020-02.html"},{"title":"tricks 2020 01","text":"tricks 2020 01 31 Introduction - 十大经典排序算法 Visualize Python, Java, JavaScript, C, C++, Ruby code execution 查看代码执行过程，找bug Java Tutor - Visualize Java code execution to learn Java online 30在线编辑网页生成代码: https://grapesjs.com/根据草图生成代码：https://sketch2code.azurewebsites.net/ 18个堪称神器的命令行工具 icdiff：分屏显示 diff常规 diff： icdiff： 比传统 diff 更明白些，是吧？效果比 sdiff 好不少，还可以配置到 git 里，变成默认的 git diff查看工具，比原来的 diff 漂亮不少吧？ pm：在 bash / zsh 中迅速切换项目目录将你常去的目录添加到 pm 中，然后一条命令进行切换： 12cd projects/awesome-projectpm add awesome-project 上面的 pm add + 名称，可以将当前目录存储到 pm 中，并取一个名字。 类似的方法再添加几个目录，然后用 pm list 查看一下现在添加了哪些： 123pm list# awesome-project# another-project 然后使用 pm go + 名字，迅速切换到该目录： 12pm go awesome-project# Current project: awesome-project 最后还有一个命令：pm remove + 名字，进行删除。 bro：以用例为主的帮助系统man 以外的帮助系统有很多，除去 cheat, tldr 外，还有一款有意思的帮助系统 – bro，它是以用例为主的帮助，所有用例都是由用户提供，并且由用户投票筛选出来的： 比如我们查看 cut 命令的帮助，就运行 “bro cut”，显示内容如图，查看按投票多少排序，你如果觉得哪条解释比较好，你可以投赞成票，或者反对票。 安装很简单，先安装 ruby 和 ruby-dev ，然后： 1gem install bropages 即可，相比由某些官方写的帮助文档，这种知乎式的帮助筛选方法，更容易将最好的帮助信息筛选出来。 2. 便捷的 ssh 管理将常用的ssh服务器配置好： 1234567891011$ cat ~/.ssh/config# Test hostHost test HostName 10.1.1.1 User adminHost * ServerAliveInterval 60 ControlMaster auto ControlPath ~/.ssh/%h-%p-%r ControlPersist yes 将以下内容添加到~/.bash_profile 或者 ~/.bashrc 文件中： 1234567# Auto complete ssh server defined in ~/.ssh/config#complete -W \"$(awk '/^Host/{if ($2!=\"*\") print $2}' ~/.ssh/config)\" ssh# Define ssh alias for server defined in ~/.ssh/configfor host in $(awk '/^Host/{if ($2!=\"*\") print $2}' ~/.ssh/config); do alias $host=\"ssh $host\"done 然后输入 test 命令就可以 ssh 到 test 服务器了 cat -A 命令可以显示”见不着”的字符，有时候很有用12$ echo xxx | cat -A$ cat -A xxx.txt 终端快捷键 ctrl+k 删除从光标到结尾处的命令文本 ctrl + a:光标移动到命令开头 ctrl + e：光标移动到命令结尾 alt f:光标向前移动一个单词 alt b：光标向后移动一个单词 ctrl w：删除一个词（以空格隔开的字符串） 将日志同时记录文件并打印到控制台在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？ 1$ ./test.sh |tee test.log 简介 · Linux 101 hacksElvish Shell Advanced Bash-Scripting Guide gtop 27申请订阅邮箱 可以在此留下邮箱地址 · Issue #26 · chenjiandongx/weekly-email-subscribe2020年1月25日Homebrew on Linux — Homebrew Documentation reverse-interview：如果当面试官问“你还有什么要问我的吗？”的时候你毫无头绪，那这个项目正是你所需要的。中文 pull：一个 GitHub App，它可以让 fork 的仓库自动同步，保持和原仓库同步的神器。很多同学参与开源时会 fork 项目，但无法取得原项目的最新更新。此 Github App 可以很好的解决这个问题，截至目前已有几万仓库使用，截至目前已经自动生成了 70 万个 PR，该数字还在持续增加。注意：如果 master 有更改需要备份后使用，具体见英文文档 使用 Pull app 自动从上游同步 Forks – 4563博客@每日更新,本地保留 GitHub Apps - Pull 2020年1月24日(星期五)subsync 有时，srt 字幕文件跟视频不同步，该工具可以自动让其同步。它的原理是，从视频里面检测出，何时有语音，然后将字幕与其对齐。 git-open：用 git 命令 push 完代码，想看仓库网页内容是否更新成功还需要再去打开网页查看。有了这个项目，直接输入 git open 命令浏览器就能自动打开对应的仓库的网页 antonmedv/fx: Command-line tool and terminal JSON viewer 🔥asciinema - Record and share your terminal sessions, the right wayshimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 2020年1月21日(星期二)Shuttle | A simple shortcut menu for macOS 在menu bar执行命令，如快速ssh等 matryer/bitbar: Put the output from any script or program in your Mac OS X Menu Bar 2020年1月20日(星期一)cloudconvert 在线文件格式转换工具，支持218种格式文件的转换。 哈利路亚 英文输入法dongyuwei/hallelujahIM: hallelujahIM(哈利路亚 英文输入法) is an intelligent English input method with auto-suggestions and spell check features, Mac only. exa ls的替代品 目录查看命令ls的替代品。 2020年1月19日(星期日)Mac 平台免费经典的音频内录插件 Soundflower 使用方法_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili forbesmyester/esqlate: Build minimum viable admin panels quickly with just SQL 快捷地创建sql插入，查询面板 danistefanovic/build-your-own-x: 🤓 Build your own (insert technology here) 2020年1月18日(星期六)typora theme–VueTexpad 1.8.14 专业的LaTeX的编辑器 - 精品MAC应用分享 PPLink - 帮电脑/手机搭建直连通道剪贴板同步快贴 - 真正的云剪贴板工具设置： 8 款免费的图片处理网页工具 在线抠图：remove.bg Emoji 填充图片 ：Emoji Mosaic 图片压缩：TinyPNG 图片立体像素画：voxelize-image 词云图制作：WordArt 「抖音风格」图片制作：PhotoMosh 全能的图片编辑器：iLoveIMG 右键服务 及 文件夹操作设置 - 少数派USB共享给Mac网络jwise/HoRNDIS: Android USB tethering driver for Mac OS X 12brew cask install horndissudo kextload /Library/Extensions/HoRNDIS.kext CockTail Mac优化软件Cocktail - A perfect mixture for macOS 下载注意Mac是10.14版本 在访达的标题栏中显示文件路径 为访达添加「Command + Q」 将隐藏应用的图标「虚化」 取消显示程序坞的延时 在程序坞右侧添加「最近使用的应用」堆栈 开启「专注模式」 去掉截图命名里的截图时间 文件备份还能怎么玩？试试这条命令 - 少数派路径最后需要以 / 结尾 在末位添加这–delete参数后，如果删除了源文件夹里的某些东西，备份中的对应文件也会乖乖消失 1rsync -av [源文件夹路径] [备份路径] --delete --exclude \"想要排除的文件或文件夹\" Automator 日历启动定时任务 laurent22/rsync-time-backup: 基于 rsync 二次开发的脚本，可在 Linux 上实现类 Time Machine 的备份 用终端命令删除「回收站」中的顽固文件丨一日一技 - 少数派\\1. 在应用程序中打开「终端」，或者使用 Spotlight 搜索启动「终端」； \\2. 在终端内键入 sudo rm -R 后按下空格； \\3. 打开回收站，选中无法删除的文件，将文件拖拽到「终端」窗口下，系统会自动帮你输入文件路径名称； \\4. 按下回车，并输入系统密码（密码不会以 * 方式显示在窗口内）； \\5. 之后你会发现之前无法删除的文件被删除了。 网络剪贴板可以生成在线纯文本文档，最多有效期3年，支持密码 2020-1-16 2020-1-13思维导图 + 流程图，免费在线工具 GitMind 一次搞定 - 少数派 2020-1-11变设龙智能抠图-免费在线抠图网站_告别PS繁琐抠图LoreFree-去中心化免费电子书共享社区单词发音| Howjsayweb前端资源_web前端导航_前端网址大全前端面试题库_前端面试宝典_各大企业面试宝典_前端面试题锦集占位图生成工具Markdown在线编辑器阅读酷 - 书源在线分享平台ASMR – ASMR分享 2020-1-4rss订阅Android 上的 RSS 阅读器怎么选？这 7 款好看好用的 App 不能错过 - 少数派RSSHub Radar — 订阅一个 RSS 源不应该这么难 - 少数派Mac 上的 RSS 阅读工具，你有这些好看实用的选择 - 少数派高效获取信息，你需要这份 RSS 入门指南 - 少数派 微软爱写作 - Aim Writing如何不写 SQL ，探索和分析数据库？ - 少数派 2020-1-3rss(19) Inoreader - Hello World! • xu3352’s Tech Blog feed 自定义Feed URL: https://feed43.com/6300252736338045.xmlEdit URL: https://feed43.com/feed.html?name=6300252736338045 Inoreader - Recent Commits to weekly:masterWallpapers | WallpaperHubBandizip 开始收费后，Peazip 或许是 Windows 压缩软件的下一个不错的选择 - 少数派一周 App 派评 ｜ 近期值得关注的 11 款应用 - 少数派通知滤盒：巧用「规则」来管理通知 ​ 小码短链接多了很多统计功能 有浏览器插件 通过 Mathpix API 将公式识别为 LaTeX - 少数派Mac 电脑终极选购指南 2019——双十一特刊 - 少数派Arya - 在线 Markdown 编辑器kootenpv/yagmail: Send email in Python conveniently for gmail using yagmailyou-get 教程下载 vip 视频 XML 弹幕文件转 ass 文件[开源工具] 本地播放B站会员视频及弹幕, 开源工具you-get使用攻略 - V2方圆 聚合网页应用，窗口管理工具：Slidepad | App+1 - 少数派有趣的搜索引擎 Magi用好这些隐藏「小开关」，让 Chrome 浏览器更好用 - 少数派给标签页进行分组chrome://flags/#tab-groups开启全局媒体播放控制chrome://flags/#global-media-controls 2020-1-1Java 2019 学习路线（视频） - 哔哩哔哩前端 2019 学习路线（视频） - 哔哩哔哩 [Chrome自带的长截屏功能 | G加菲](https://www.gmlyo.com/2018/06/10/Chrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95","link":"/tricks/tricks-2020-01.html"},{"title":"openProject","text":"[toc] dbohdan/structured-text-tools: A list of command line tools for manipulating structured text data dandavison/delta: A syntax-highlighter for git and diff outputwolverinn/Waking-Up: 计算机基础（计算机网络/操作系统/数据库/Git…）面试问题全面总结jackzhenguo/python-small-examples guanguans/favorite-link: 每日收集喜欢的开源项目 科技爱好者周刊 · 语雀 OXYGEN - hand drawn style diagrams generator 手绘风格流程图 Snip 将打印的数学公式转成 LaTex 代码的工具。 在线office编辑： http://yiqixie.com 在线latex编辑: Overleaf, Online LaTeX Editor 在线markdown编辑：http://zybuluo.com 在线json解析: http://json.cn 在线正则表达式解析: http://regex101.com 博客订阅：http://theoldreader.com 代码库：http://github.com 英文语法检查：https://grammarly.com 词典：http://youdao.com 图片编辑：http://pixlr.com/editor/ fyne-io/fyne: Cross platform GUI in Go based on Material Design GitHub Marketplace · Tools to improve your workflow程序员实用工具，推荐一款代码统计神器GitStats-云栖社区-阿里云推荐一个非常实用的学习 GitHub 的软件 | Laravel China 社区jlord/git-it-electron: Git-it is a (Mac, Win, Linux) Desktop App for Learning Git and GitHub 21、Best-App：苹果系统下的优秀软件、硬件、技巧、周边设备的集合 22、follow-me-install-kubernetes-cluster：部署 kubernetes 集群教程。该教程介绍使用二进制部署最新 kubernetes 集群的所有步骤，而不是使用 kubeadm 等自动化方式来部署集群。这样有助于理解系统各组件的交互原理，进而能够快速定位、解决实际中遇到的问题 vjtools/othertools.md at master · vipshop/vjtoolsScylla 中文文档 — Scylla 文档Git - Bookluhuisicnu/The-Flask-Mega-Tutorial-zh: hzlzh/Best-App: 收集&amp;推荐优秀的 Apps/硬件/技巧/周边等 ByteScout SQL Trainer 一个互动式的在线 SQL 语法教程，针对新手。答对一个问题，才能进入下一个。 发送短消息的 App 谷歌官方推出了一个网页应用，使你可以在浏览器上远程通过自己的手机发短消息。有人使用了它的底层 API，做成一个桌面 App，可以在电脑桌面上发短信。 localroast 一个根据 JSON 文件快速生成 API 的 Web 服务端，主要用了测试和开发环境。 DevTube 该网站收集 Youtube 上面的软件开发视频。 登录页设计 登录页的各种页面设计，可以免费下载模板。 crushcourse.club Crash Course 是一个 Youtube 的教育频道。B站上面有很多翻译小组。他们组成了一个联盟防止翻译重复，并提供了索引 Whaler 该软件可以从 Docker image 逆向还原出 Dockerfile。 skanehira/docui: TUI Client for Docker lazydocker A simple terminal UI for both docker and docker-compose, written in Go with the gocui library. docker.vim Manage docker containers and images in Vim color：Golang 的命令行色彩使用库。拥有丰富的色彩渲染输出、通用的 API 方法、兼容 Windows 系统 gitbatch：批量管理 Git 仓库的命令行工具 hutool：功能丰富的 Java 工具包。它帮助我们实现了常用的工具方法，从而减少代码的体积，提高开发效率。该项目最初是作者工作项目中的util模块，后来慢慢积累并加入更多非业务相关工具类方法。经过整理修改，最终形成丰富的开源工具集。 q：Golang debug 库，自动打印变量类型并且格式化输出 7、tldr：Golang tldr 客户端。对比之前推荐过的 Python 版本客户端，Golang 版本速度更快、交互友好、且支持选择搜索结果的展示样式。每当你想要用 tar 解压缩，但是记不住具体参数的时候，tldr 可以拯救世界 wonderfulsuccess/weixin_crawler: 高效微信公众号全部历史文章和阅读数据爬虫powered by scrapy 微信公众号爬虫 微信采集 公众号采集 微信爬虫 nginxconfig.io：在线生成 Nginx 配置文件网站，在线尝试 soar：SQL 自动优化和改写的工具。可以自动优化 MySQL 语法族，并且给出为什么要这样优化的理由。功能特点： 跨平台支持 目前只支持 MySQL 语法族协议的 SQL 优化 支持基于启发式算法的语句优化 支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT） 等等 1234567891011echo \"select title from sakila.film\" | ./soar # Query: 25807E6B94BEA72C★ ★ ★ ★ ☆ 80分SELECT titleFROM sakila. film## 最外层SELECT未指定WHERE条件* **Item:** CLA.001* **Severity:** L4* **Content:** SELECT语句没有WHERE子句，可能检查比预期更多的行(全表扫描)。对于SELECT COUNT(\\*)类型的请求如果不要求精度，建议使用SHOW TABLE STATUS或EXPLAIN替代。 athens：Go Modules 下载代理服务，解决国内 Go 装包的痛。妈妈再也不用担心我因为装不上依赖库而不吃饭，使用步骤： 1234567$ export GO111MODULE=on$ export GOPROXY=http://127.0.0.1:3000$ git clone https://github.com/athens-artifacts/walkthrough.git$ cd walkthrough$ go run .go: downloading github.com/athens-artifacts/samplelib v1.0.0The 🦁 says rawr! archiver：命令行压缩和解压缩工具。终于不用再记 tar -czvf 了，使用命令： 1234567# Syntax: arc archive [archive name] [input files...] 压缩$ arc archive test.tar.gz file1.txt images/file2.jpg folder/subfolder# Syntax: arc unarchive [archive name] [destination] 解压缩$ arc unarchive test.tar.gz Best-websites-a-programmer-should-visit：（英文）一些对程序员有用的网站，网站类别包含：新闻、查问题、学习、教程等 XChart：用于绘制数据的轻量级 Java 库。示例代码： 12345678910double[] xData = new double[] { 0.0, 1.0, 2.0 };double[] yData = new double[] { 2.0, 1.0, 0.0 };// Create ChartXYChart chart = QuickChart.getChart(\"Sample Chart\", \"X\", \"Y\", \"y(x)\", xData, yData);// Show itnew SwingWrapper(chart).displayChart();// Save itBitmapEncoder.saveBitmap(chart, \"./Sample_Chart\", BitmapFormat.PNG);// or save it in high-resBitmapEncoder.saveBitmapWithDPI(chart, \"./Sample_Chart_300_DPI\", BitmapFormat.PNG, 300); gitea：一个极易安装、运行快速、安装简单、使用体验良好的自建 Git 服务。采用 Go 作为后端语言，支持 Linux、 macOS、Windows 等，在线Demo。安装步骤如下： 1234$ git clone https://github.com/go-gitea/gitea$ cd gitea$ TAGS=\"bindata\" make generate all$ ./gitea web 521xueweihan/git-tips: Git的奇技淫巧 git-open：用 git 命令 push 完代码，想看仓库网页内容是否更新成功还需要再去打开网页查看。有了这个项目，直接输入 git open 命令浏览器就能自动打开对应的仓库的网页 Wei-Xia/most-frequent-technology-english-words: 程序员工作中常见的英语词汇 learn-go-with-tests：通过单元测试学习 Go 语言。下载仓库源码后，进入对应目录。每一个小文件夹就是一个对应的 Go 项目，在里面go test即可运行单元测试。由于是测试驱动开发，所以需要在你改动代码之后跑通单元测试才算学会通过。每一个对应的文件夹都有相应 Markdown 文字教程，比较浅显易懂。而且还有中文版 easyexcel：使用简单、上手快速、占用内存小且避免内存溢出的 Java 处理 Excel 工具 Project Showcase 该工具根据你的 GitHub 个人项目，自动生成一张个人介绍页面。 gitsome 一个 Git / GitHub 的命令行客户端，提供强大的自动补全功能 Gitless Git 的版本模型对新手来说，并不是很容易理解。Gitless 试图将 Git 变得更容易理解，它基于 Git，但是用自己的概念和命令替换了 Git，比如把 git add 改成 gl track antonmedv/fx: Command-line tool and terminal JSON viewer 🔥asciinema - Record and share your terminal sessions, the right wayshimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 Linux Crontab 生成器双拼输入法练习 在线练习双拼输入法的网站，漂亮的键位图，支持多种双拼方案。这里还有一个同类网站。 Online Utility to Generate Crontab Line Easily 通过 Web 界面生成 Crontab 配置。 Go by Example 通过示例学习 Go 语言的教程。 gitignore.io 生成 gitignore 文件的网站。 uncss 去除样式表里面没有用到的 CSS 规则的工具。 subsync 有时，srt 字幕文件跟视频不同步，该工具可以自动让其同步。它的原理是，从视频里面检测出，何时有语音，然后将字幕与其对齐。 Learn anything 一个学习资源的搜索引擎，可以搜索各种主题，返回相应的教程。 UserLAnd 安卓手机安装 Linux 发行版的 App。 easychen/howto-make-more-money: 程序员如何优雅的挣零花钱 trimstray/the-book-of-secret-knowledge: A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more. hujiulong/gcoord: 地理坐标系转换工具，支持WGS84/GCJ02/BD09等常用坐标系互转textmate/textmate: TextMate is a graphical text editor for macOS 10.12 or laternicolargo/glances: Glances an Eye on your system. A top/htop alternative for GNU/Linux, BSD, Mac OS and Windows operating systems.gold-miner/introducing-github-actions.md at master · xitu/gold-minerxitu/gold-miner: 🥇掘金翻译计划，可能是世界最大最好的英译中技术社区，最懂读者和译者的翻译平台：gold-miner/backend.md at master · xitu/gold-minergold-miner/front-end.md at master · xitu/gold-minercaicloud/kube-ladder: Learning Kubernetes, The Chinese Taoist Waythlorenz/doctoc: 📜 Generates table of contents for markdown files inside local git repository. Links are compatible with anchors generated by github or other sites. jaywcjlove/package.json: 文件 package.json 的说明文档。jakubroztocil/httpie 替代curl OverNote Shitaibin/golang_step_by_step: Golang入门教程的文章、示例代码 duke7553/files-uwp: “More than just a rewrite of Windows Explorer” No-Github/404-I-remember: 收集各种网站的404页面 styfle/awesome-online-ide: 🌩️ A list of awesome online development environments dyweb/awesome-resume-for-chinese: 适合中文的简历模板收集（LaTeX，HTML/JS and so on）由 @hoodiearon 维护dyweb/awesome-resume-for-chinese: 适合中文的简历模板收集（LaTeX，HTML/JS and so on）由 @hoodiearon 维护 [Github Explore] - 超实用工具，看老司机怎么把 Github 玩出花来 · Issue #1 · github-serendipity/github-serendipity.github.io Louiszhai/tool: 开发效率提升：Mac生产力工具链推荐 MacMenuBar.com - A curated directory of 400+ Mac menu bar apps jaywcjlove/linux-command: Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集。https://git.io/linux serhii-londar/open-source-mac-os-apps: 🚀 Awesome list of open source applications for macOS. dropcss 清理样式表里面无用的 CSS一个清理样式表里面无用的 CSS 代码的工具 mas Mac 应用商店的命令行界面可以用来从命令行安装 MacOS App。 gacp 定制 Git 的提交信息的命令行工具，支持 EmojiLorem Picsum 图片占位服务图片占位服务，可以返回指定大小的图片，并且提供多种定制参数。 Colorize 黑白照片自动上色黑白照片自动上色的服务。 RMind 在线的思维导图在线的思维导图工具，使用 React Hooks 与 flex 布局实现。（@Mongkii 投稿） Table Convert Online 在线表格转成其他数据格式一个网页工具，可以在线表格转成 Markdown、JSON、HTML、XML、YAML 等数据格式，并支持格式之间互相转化。(@Fechin 投稿) nodeppt Markdown 文档转成幻灯片将 Markdown 文档转成幻灯片，在浏览器演示的工具。（@JsonLeex 投稿） userrecon 看某个用户名是否还未注册 一次查询75个社交媒体，看看某个用户名是否还未注册。 3、SQL 风格指南 SQL 语句如何写得清晰明确，这个仓库列出了风格规则。 4、LaTex 教程 Overleaf 提供的 LaTex 新人教程，容易入门。 9、visitor-count-badge 一个开源服务，可以统计 GitHub 仓库的 Readme 文件的阅读次数，然后生成 badge 徽章，以便挂在仓库里。（@jwenjian 投稿） 5、lazydocker 命令行管理 Docker 服务的一个图形界面工具。 哈利路亚 英文输入法dongyuwei/hallelujahIM: hallelujahIM(哈利路亚 英文输入法) is an intelligent English input method with auto-suggestions and spell check features, Mac only. 10、docker-slim 一个 Docker 镜像文件的瘦身工具，据称最好情况下，可以让镜像文件体积缩小为原来的30分之一。 5、Eternal Terminal 一个类似 SSH 的服务器远程登录工具，但是可以自动重新连接而不会中断会话。 Happy Hues - Curated colors in context. 在线预览网站配色效果 1、EasyDB 一次性云端数据库，可以免费使用 24 小时。如果想永久保存数据，需要付费。 2、Sourcetrail 可视化源码浏览器，可以对 C、C ++、Java、Python 源代码进行静态分析，并以图形可视化的形式呈现。 3、texme 一个轻量级的 JavaScript 脚本，可以把 Markdown + LaTeX 文档直接渲染成网页。 6、resumd 在线的简历编辑器 可以分享给他人一个可编辑的简历，也可以导出 PDF。（@timqian 投稿） 8、KubeSphere 一个开源的容器管理平台，构建在 Kubernetes 之上，帮助企业管理容器环境。（@FeynmanZhou 投稿） 9、mdr 命令行的 Markdown 文件阅读器 暂时没看到Mac版本 1、 vy 一个命令行的极简风格的 IDE。 2、必收 一个收集和订阅外部内容的应用，有手机端和桌面端，可以收藏网址、微信文章、头条文章等。（@sinner-xing 投稿） 3、invidious Youtube 的开源前端，等于为 Youtube 换了皮肤，可以自己搭建实例。 4、p2 一个极简的 PDF 文件转 PNG 图片的开源服务器，我觉得挺好用，查看 Demo。 6、Joplin 一个笔记和待办事项软件，支持桌面、手机和命令行，可以多端同步。 7、code-surfer 一个以幻灯片的形式展示源码的工具。 9、远程浏览器 该网站提供免费的远程浏览器，用户可以在本地浏览器里面打开远程浏览器，再通过后者访问网站。该站的代码开源。 7、在线屏幕录制 一个浏览器里面的在线录屏小工具。（@w3yyb 投稿） 8、加密信息写入图片工具 这个在线工具可以把隐藏文本写入图片文件。图片依然可以正常使用，并且外观不发生变化，用户不会发现里面隐藏了加密信息。（@w3yyb 投稿） 10、marktext 一个跨平台的桌面 Markdown 编辑器。 2、Chrome remote desktop 谷歌推出了远程桌面软件，可以在手机和桌面浏览器里面，访问远程电脑的桌面，进行各种操作。 3、CustomAnim 这个网站可以将用户输入的文本，渲染成一段微粒的动画，支持中文。缺点就是后台资源有限，玩的人一多，就要排队等。 4、onefetch 这个命令行工具可以显示 Git 仓库的信息。 5、Daily-warm 一个 Go 语言脚本，每天向指定邮箱发送一封邮件，里面是天气、名言、诗歌。（@BarryYan 投稿） 7、snake-go Go 语言写的命令行贪吃蛇游戏。 8、dn 一个非常简单的命令行笔记脚本，可以写入/读取笔记。所有代码就是十几行 Bash 命令。 10、SearX SearX 是一个开源的搜索代理，可以自己架设谷歌实例，查看 demo 和实例列表。 1、OnionShare 匿名分享文件的工具，通过 Tor 网络下载文件。 2、dcp 一个在主机间分享文件的命令行工具，使用 Dat 协议，进行点对点拷贝。 10、bruno simon 这是很久以来，我见过的最酷主页，整个页面都是 3D 的。页面源码是开源的。 7、navi 一个命令行的交互式备忘工具，你可以查阅某个命令的作用。 8、Slouch stoppah 一个在线小工具，通过电脑摄像头，判断坐在屏幕前面的人的坐姿是否正确。 12、GitHub Mobile GitHub 首次发布官方的手机客户端，目前只有 iOS 的 App，安卓版将稍后发布。 3、crontab 编辑器 crontab 是 Linux 系统的定时任务执行器。这个在线工具可以可视化生成 crontab 的配置文件。 5、AltStore 苹果设备安装第三方应用商店的方法（不必越狱），看上去好像有效。 6、nanoid 一个极小的 uuid 生成的 JS 库。 10、imagededup 一个基于 Python 的找出重复图片的工具，支持多种查重算法。 1、git-quick-stats 查看 Git 仓库各种统计信息的命令行工具。 2、Regexper 将 JS 的正则表达式转成图形解释的在线工具。（@DoctorLai 投稿） 3、Write With Transformer 这个工具可以自动生成英语文本。你输入一句话，然后按 Tab 键，就得到一整段。 我输入：以前有一个男孩。得到：他名叫杰克，还有一个女孩名叫维奥莱特。 女孩穿黄色，男孩穿蓝色。杰克说他打算买一件新衣服，搭配她的衣服。 5、Publisheet Excel 表格转为网页表格的在线工具。 7、This is sand 一个手机 App，用来制作沙画。（@victor-fa 投稿） 8、folder-explorer 扫描一个目录，给出目录结构、文件大小等统计信息的桌面工具。（@FairyEver 投稿） 4、MarioHTML TypeScript 写的马里奥网页游戏。 5、Kate KDE 项目","link":"/tricks/openProject.html"},{"title":"tricks-2019-12","text":"tricks-2019-12 2019年1月17日(星期四)yAnXImIN/weiboPicDownloader: 免登录下载微博图片 爬虫 Download Weibo Images without Logging-ingui PPLink - 帮电脑/手机搭建直连通道日常干货在线工具网站分享平台 – SBKKOlinux下替换多个文件中的指定字符串 - 简书 2019-12-31iSlide Mac 玩转输入法每个输入法不一样，以搜狗为例：u 生僻字模式v 数字、小数、日期、算式自定义短语 小鹤双拼 除了搜狗输入法，还有这些好用的输入法。触宝输入法笔画过滤。首先用拼音拼出你想输入的字词，然后直接在键盘上手写笔画进行 QQ输入法快捷翻译 讯飞输入法语音识别，包括方言 百度输入法设置-&gt;高级设置-&gt;管理个性短语-&gt;编辑个性短语懒人短语，类似于“自定义短语” AutoDraw手画icon，ai智能识别 Markdown[TOC] 用来显示Markdown目录有道云笔记 默认支持Markdown印象笔记也支持，需要建立Markdown笔记 WPS有团队文件功能知页 - 用简单的方式，制作专业的简历下载收费 图表秀——免费在线图表制作工具,数据可视化工具PDF24 Tools在线格式转换 All2Allwin桌面分屏看微信文章WeRss - 微信公众号RSS订阅今天看啥 - 让阅读更高品质学习工具 – 微信公众账号和文章的导航及推荐 – 传送门 2019-12-30传输文件的网址：Send Large Files - Free Secure File Transfer - TransferNowP2P傳檔 – 免費資源網路社群 其他网址：国外网站推荐-分享互联网-外国网站大全歌曲大全-音乐聚合搜索引擎-音乐免费下载mp3-音乐免费下载办公资源网_海量办公资源及素材_精美创意模板下载国外网站推荐-分享互联网-外国网站大全PM25.in | 北京PM2.5及空气质量指数(AQI)互联网运营者必备之的修炼清单- eGouz上网导航失眠怎么办？你可以试试这些助眠神器- eGouz上网导航文案创作者必备的写作辅助工具推荐- eGouz上网导航值得收藏的找书网站大全- eGouz上网导航周读：提供免费电子书下载、分享。包括mobi、epud、pdf、txt格式，kindle电子书下载 - 周读DevFreeBooksConvert any URL or Web Page to PDF. Online API servicegitmoji | An emoji guide for your commit messagesgitmoji的使用 | 我的博客GitHub - carloscuesta/gitmoji: An emoji guide for your commit messages. 😜Base64 Image Encoder在线JSON校验格式化工具（Be JSON）CarbonCSS Reference - A free visual guide to CSS 2019-12-29mac slashgtd软件，为当前所做的任务计时 open web monitor优点：在每次监测网页前可以执行一系列操作，包括去登录页面点击和填写表单，以实现登录功能缺点：免费版只能添加3个监测任务 chrome插件 distill web monitor优点：监控页面变化，发出提醒，配置方便缺点：功能单一 知乎封神榜 - 您的知乎之旅从此开始APP影院-全网最全视频库🐒 渣男: 说话的艺术读知乎-精选每日知乎热门答案6个网站磁力搜索网站JsOCR介绍 | 文档中心Windows dock牛牛TV - 搜你想看老Y的免费VIP播放器 todo:权力的游戏 万能钥匙[Vue.js]—-基于 Vue.js 2.0 的 UI 组件库 Element UI讲解_哔哩哔哩 (゜-゜)つロ 干杯~-bilibilivue+elementUI+axios管理平台_哔哩哔哩 (゜-゜)つロ 干杯~-bilibilivue.js+element-ui数据增删查改实战_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili黑马2019新版java项目好客租房网上房源系统-SOA架构 源码+笔记_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 2019-12-28airpods 连接android声音小问题将耳机放入耳机盒，长按按钮15s重置耳机 2019-12-27airpods 连接Mac问题去除Android File Transfer自启动https://www.v2ex.com/t/567112 2019-12-25意志力训练冥想 （锻炼大脑）充足的休息意志力会消耗殆尽，所以重要的事情优先做 2019-12-17fakerPython最假的库：Faker - 知乎 1234from faker import Fakerfake = Faker(locale='zh_CN')fake.company()# '昂歌信息网络有限公司' js 数组中值的存在12[1, 2, 3, 4].indexOf(1)&gt;-1 // 存在value1 in [a, b, c] // 存在索引1 2019-12-14youtube视频下载插件 2019-12-11mock js官方API 可以打开控制台，随意地试验这些方法 mock js 基于Vue 2019-12-10[网页中插入好看的图表](https://www.highcharts.com/demo?__cf_chl_jschl_tk__=4c5fe947e5b10bc580a21ad9c8a2166bc43272ad-1575981882-0-AZJ0-yA5r1OtiKk9ZwZb3CFpiDh4Do1gQXIilagtvZF6xx47jQxtekJnSzJket48TsMxonyNJws","link":"/tricks/tricks.html"},{"title":"tricks/资源","text":"","link":"/tricks/%E8%B5%84%E6%BA%90.html"},{"title":"List Operations","text":"[toc] Converting Iterator to List12345678910111213141516171819202122232425// 有时会获得一个 IteratorIterator&lt;Integer&gt; iterator = Arrays.asList(1, 2, 3).iterator();// 怎么转成 List 呢List&lt;Integer&gt; actualList = new ArrayList&lt;&gt;();// 1. using a while loopwhile (iterator.hasNext()) { actualList.add(iterator.next());}// 2. using java 8 Iterator.forEachRemainingiterator.forEachRemaining(actualList::add);// 3. using java 8 streams API ?// 先把 iterator 转成 iterableIterable&lt;Integer&gt; iterable = () -&gt; iterator;List&lt;Integer&gt; actualList = StreamSupport .stream(iterable.spliterator(), false) .collect(Collectors.toList());// 4. Guava// 4.1 Immutable ListList&lt;Integer&gt; actualList = ImmutableList.copyOf(iterator);// 4.2 mutable listList&lt;Integer&gt; actualList = Lists.newArrayList(iterator);// 5. apache CommonsList&lt;Integer&gt; actualList = IteratorUtils.toList(iterator);assertThat(actualList, containsInAnyOrder(1, 2, 3)); Java – Get Random Item/Element From a List1234567891011List&lt;Integer&gt; givenList = Arrays.asList(1, 2, 3);// 2.1. Single Random ItemRandom rand = new Random();givenList.get(rand.nextInt(givenList.size()));// 2.2. in Multithread Environmentint randomElementIndex = THreadLocalRandom.current().nextInt(listSize) % givenList.size();// 2.4. Without Repetitions// 获取后 remove 元素即可givenList.remove(randomIndex);// 2.5. Select Random SeriesCollections.shuffle(givenList); Partition a List in Java1234567891011121314151617181920212223242526272829303132// 将一个 list 划分为指定长度的 sublistsList&lt;Integer&gt; intList = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9); // guava// 1. Guava// Keep in mind that the partitions are sublist views of the original collection// which means that changes in the original collection will be reflected in the partitions// 1.1. Use Guava to Partition the ListLists.partition(intList, 3);// 1.2. Use Guava to partition a Collection// 略// 2. Use Apache Commons Collections to Partition the List// the same caveat applies here as well – // the resulting partition are views of the original List.ListUtils.partition(intList, 3);// 3. Use Java8 to Partition the List// 3.1. Collectors partitioningBy// use Collectors.partitioningBy() to split the list into 2 sublistsMap&lt;Boolean, List&lt;Integer&gt;&gt; groups = intList.stream().collect(Collectors.partitioningBy(s -&gt; s &gt; 6));List&lt;List&lt;Integer&gt;&gt; subSets = new ArrayList&lt;List&lt;Integer&gt;&gt;(groups.values());// 3.2. Collectors groupingBy// use Collectors.groupingBy() to split our list to multiple partitionsMap&lt;Integer, List&lt;Integer&gt;&gt; groups = intList.stream().collect(Collectors.groupingBy(s -&gt; (s - 1) / 3));List&lt;List&lt;Integer&gt;&gt; subSets = new ArrayList&lt;List&lt;Integer&gt;&gt;(groups.values());// 3.3. Split the List by Separator// use Java8 to split our List by separatorint[] indexes = Stream.of(IntStream.of(-1), IntStream.range(0, intList.size()) .filter(i -&gt; intList.get(i) == 0), IntStream.of(intList.size())) .flatMapToInt(s -&gt; s).toArray();List&lt;List&lt;Integer&gt;&gt; subSets = IntStream.range(0, indexes.length - 1) .mapToObj(i -&gt; intList.subList(indexes[i] + 1, indexes[i + 1])) .collect(Collectors.toList()); Removing all nulls from a List in Java1234567891011121314151617181920212223242526List&lt;Integer&gt; list = Lists.newArrayList(null, 1, null);// 1. plain javawhile (list.remove(null));// 或者list.removeAll(Collections.singleton(null)); // ?// 2. Guava// 2.1 via predicates (modify original list)Iterables.removeIf(list, Predicates.isNull());// 2.2 do not modify original listList&lt;Integer&gt; listWithoutNulls = Lists.newArrayList( Iterables.filter(list, Predicates.notNull()));assertThat(list, hasSize(1));// 3. Commons// (modify original list)CollectionUtils.filter(list, PredicateUtils.notNullPredicate());// 4. java8 lambdas// 4.1 parallel (do not modify original list)list.parallelStream() .filter(Objects::nonNull) .collect(Collectors.toList());// 4.2 serial (do not modify original list)list.stream() .filter(Objects::nonNull) .collect(Collectors.toList());// 4.3 (modify original list)list.removeIf(Objects::isNull); Removing all duplicates from a List in Java1234567891011List&lt;Integer&gt; list = Lists.newArrayList(0, 1, 2, 3, 0, 0);// 以下做法均类似于 Python 的 list(set(l))// 1. plain java// using setList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(list));// 2. GuavaLists.newArrayList(Sets.newHashSet(list));// 3. java 8 streamlist.stream().distinct().collect(Collectors.toList());assertThat(listWithoutDuplicates, hasSize(4)); Check If Two Lists are Equal in Java1234567891011121314151617List&lt;String&gt; list1 = Arrays.asList(\"1\", \"2\", \"3\", \"4\");List&lt;String&gt; list2 = Arrays.asList(\"1\", \"2\", \"3\", \"4\");List&lt;String&gt; list3 = Arrays.asList(\"1\", \"2\", \"4\", \"3\");// 1. JUnitAssert.assertEquals(list1, list2);Assert.assertNotSame(list1, list2);Assert.assertNotEquals(list1, list3);// 2. TestNG (用法类似)Assert.assertEquals(list1, list2);Assert.assertNotSame(list1, list2);Assert.assertNotEquals(list1, list3);// 3. AssertJassertThat(list1) .isEqualTo(list2) .isNotEqualTo(list3);assertThat(list1.equals(list2)).isTrue;assertThat(list1.equals(list3)).isFalse; How to Find an Element in a List with Java12345678910111213// contains indexOf loop// 略// java 8 stream api// invoke stream() on the list// call the filter() method with a proper Predicate// call the findAny() construct which returns the first element // that matches the filter predicate wrapped in an Optional if such an element existscustomers.stream() .filter(customer -&gt; \"James\".equals(customer.getName())) .findAny() .orElse(null);// guava / commons// 写的很晦涩，略 Java List UnsupportedOperationException1234List&lt;String&gt; flowerList = Arrays.asList(flowers);// Arrays.asList() 返回的 list 大小固定，不可增删（修改呢？）// 改进, 若要修改new ArrayList(Arrays.asList(flowers)); Copy a List to Another List in Java1234567891011121314151617181920// 1. 利用构造函数List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);// 2. addAllList&lt;Integer&gt; copy = new ArrayList&lt;&gt;();copy.addAll(list);// 但是: 这 2 种方法只是复制了引用，修改一个会影响另一个// 3. Collections.copy// src dest 长度一样，dest 会被覆盖List&lt;Integer&gt; source = Arrays.asList(1,2,3);List&lt;Integer&gt; dest = Arrays.asList(4,5,6);Collections.copy(dest, source);// dest 留出前三个位置List&lt;Integer&gt; source = Arrays.asList(1, 2, 3);List&lt;Integer&gt; dest = Arrays.asList(5, 6, 7, 8, 9, 10);Collections.copy(dest, source);// 4. java 8 streamlist.stream().collect(Collectors.toList()); Remove All Occurrences of a Specific Value from a List// list.remove(1) 若 1 是 int, 会被当成索引，不是 value，是 integer 才行 // void removeAll(List&lt;Integer&gt; list, int element) { void removeAll(List&lt;Integer&gt; list, Integer element) { while (list.contains(element)) { list.remove(element); } } // 或者 void removeAll(List&lt;Integer&gt; list, Integer element) { int index; while ((index = list.indexOf(element)) &gt;= 0) { list.remove(index); } } // 但以上方法都很慢 // for loop, 但需要考虑到同时删除相邻元素时的问题 // 因此，因为 for-each loop 没有解决同时删除相邻元素时的问题，test failed void removeAll(List&lt;Integer&gt; list, int element) { for (int i = 0; i &lt; list.size();) { if (Objects.equals(element, list.get(i))) { list.remove(i); } else { i++; } } } // using an Iterator void removeAll(List&lt;Integer&gt; list, int element) { for (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();) { Integer number = i.next(); if (Objects.equals(number, element)) { i.remove(); } } } // 建立一个新 list List&lt;Integer&gt; removeAll(List&lt;Integer&gt; list, int element) { List&lt;Integer&gt; remainingElements = new ArrayList&lt;&gt;(); for (Integer number : list) { if (!Objects.equals(number, element)) {","link":"/java/Collections/02-List-Operations.html"},{"title":"java/Collections/01-List-Implementations","text":"","link":"/java/Collections/01-List-Implementations.html"},{"title":"java/Collections/04-Map-Implementations","text":"","link":"/java/Collections/04-Map-Implementations.html"},{"title":"java/Collections/03-Set-Implementations","text":"","link":"/java/Collections/03-Set-Implementations.html"},{"title":"java/Collections/Apache-Commons-Collections","text":"","link":"/java/Collections/Apache-Commons-Collections.html"},{"title":"java/Collections/05-Map-Operations","text":"","link":"/java/Collections/05-Map-Operations.html"},{"title":"java/Collections/Convert-Collections","text":"","link":"/java/Collections/Convert-Collections.html"},{"title":"java/Collections/Java-Collections-Baeldung","text":"","link":"/java/Collections/Java-Collections-Baeldung.html"},{"title":"java/Collections/Operations-on-Collection","text":"","link":"/java/Collections/Operations-on-Collection.html"},{"title":"java/module test/01-json解析","text":"","link":"/java/module%20test/01-json%E8%A7%A3%E6%9E%90.html"},{"title":"java/Collections/Guava-Collections","text":"","link":"/java/Collections/Guava-Collections.html"},{"title":"java/Collections/Other-Collections","text":"","link":"/java/Collections/Other-Collections.html"},{"title":"java/module test/02-log","text":"","link":"/java/module%20test/02-log.html"},{"title":"java/Collections/Queues","text":"","link":"/java/Collections/Queues.html"},{"title":"java/module test/03-junit","text":"","link":"/java/module%20test/03-junit.html"},{"title":"java/module test/06-joda-time","text":"","link":"/java/module%20test/06-joda-time.html"},{"title":"04 guava","text":"[toc] Google Guava官方教程（中文版） | 并发编程网 – ifeve.comGuava教程™ maven12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;28.2-jre&lt;/version&gt;&lt;/dependency&gt; OptionalOptional 被 Java 自带的替代 12345678910111213141516171819202122232425262728package guava;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Optional;public class aOptional { private static Logger logger = LoggerFactory.getLogger(aOptional.class); public static void add(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) { logger.info(String.valueOf(a.isPresent())); logger.info(String.valueOf(b.isPresent())); logger.info(String.valueOf(a.orElse(0) + b.orElse(0))); // 获取值 // a.get() a 为 null 报错 // a.orElse(x) a 为 null 返回 x } public static void main(String[] args) { // 构造 // Optional.empty() // Optional.of(x) // Optional.ofNullable(x) 若为 null，返回代表 null 的 Optional : Optional.empty() Optional&lt;Integer&gt; a = Optional.ofNullable(10); Optional&lt;Integer&gt; b = Optional.of(10); add(a, b); }} Preconditions1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package guava;import com.google.common.base.Preconditions;import org.slf4j.Logger;import org.slf4j.LoggerFactory;// Preconditions.checkArgument// Preconditions.checkNotNull// Preconditions.checkElementIndexpublic class bPreconditions { private static Logger logger = LoggerFactory.getLogger(bPreconditions.class); public static double sqrt(double input) throws IllegalArgumentException { Preconditions.checkArgument(input &gt; 0.0, \"Illegal Argument passed: Negative value %s.\", input); return Math.sqrt(input); } public static int sum(Integer a, Integer b) { a = Preconditions.checkNotNull(a, \"Illegal Argument passed: First parameter is Null.\"); b = Preconditions.checkNotNull(b, \"Illegal Argument passed: Second parameter is Null.\"); return a + b; } public static int getValue(int input) { int[] data = {1, 2, 3, 4, 5}; Preconditions.checkElementIndex(input, data.length, \"Illegal Argument passed: Invalid index.\"); return 0; } public static void main(String[] args) { try { System.out.println(sqrt(-3.0)); } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } try { System.out.println(sum(null, 3)); } catch (NullPointerException e) { System.out.println(e.getMessage()); } try { System.out.println(getValue(6)); } catch (IndexOutOfBoundsException e) { System.out.println(e.getMessage()); } }} Guava Ordering类1234567891011121314151617181920212223242526272829303132333435package guava;import com.google.common.collect.Ordering;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;public class cOrdering { public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); Collections.addAll(integers, 6, 3, 2, 7, 9); // sort Ordering&lt;Comparable&gt; ordering = Ordering.natural(); Collections.sort(integers, ordering); // reverse sort Collections.sort(integers, ordering.reverse()); // isOrdered System.out.println(ordering.reverse().isOrdered(integers)); System.out.println(integers); System.out.println(Collections.max(integers)); System.out.println(Collections.min(integers)); // max min System.out.println(ordering.max(integers)); System.out.println(ordering.min(integers)); integers.add(null); // nullsFirst nullsLast Collections.sort(integers, ordering.reverse().nullsFirst()); System.out.println(integers); }} Guava Objects类123456789101112131415161718192021222324252627282930313233343536373839404142package guava;import com.google.common.base.Objects;import com.google.common.collect.ComparisonChain;import lombok.Data;import lombok.Getter;import lombok.Setter;public class dObjects {}@Setter@Getter@Dataclass Student implements Comparable&lt;Student&gt; { private int id; private String name; @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return id == student.id &amp;&amp; Objects.equal(name, student.name); } @Override public int hashCode() { // Objects.hashCode(field-1, field-2, …, field-n) return Objects.hashCode(id, name); } @Override public int compareTo(Student o) { return ComparisonChain.start() .compare(this.name, o.name) .compare(this.id, o.id) .result(); }} Guava集合工具不可变集合不可变集合可以用如下多种方式创建： copyOf方法，如ImmutableSet.copyOf(set); of方法，如ImmutableSet.of(“a”, “b”, “c”)或 ImmutableMap.of(“a”, 1, “b”, 2); Builder工具 细节：关联可变集合和不可变集合 可变集合接口 属于**JDK还是Guava** 不可变版本 Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet/NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable Guava Multiset接口允许 set 重复，并统计每个值的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.Set;import com.google.common.collect.HashMultiset;import com.google.common.collect.Multiset;public class GuavaTester { public static void main(String args[]){ // HashMultiset.create() Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(\"a\"); multiset.add(\"b\"); multiset.add(\"c\"); multiset.add(\"d\"); multiset.add(\"a\"); multiset.add(\"b\"); multiset.add(\"c\"); multiset.add(\"b\"); multiset.add(\"b\"); multiset.add(\"b\"); // multiset.count(\"b\") multiset.size() multiset.elementSet() System.out.println(\"Occurrence of 'b' : \"+multiset.count(\"b\")); System.out.println(\"Total Size : \"+multiset.size()); Set&lt;String&gt; set = multiset.elementSet(); System.out.println(\"Set [\"); for (String s : set) { System.out.println(s); } System.out.println(\"]\"); //display all the elements of the multiset using iterator Iterator&lt;String&gt; iterator = multiset.iterator(); System.out.println(\"MultiSet [\"); while(iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(\"]\"); //display the distinct elements of the multiset with their occurrence count System.out.println(\"MultiSet [\"); for (Multiset.Entry&lt;String&gt; entry : multiset.entrySet()) { System.out.println(\"Element: \"+entry.getElement() +\", Occurrence(s): \" + entry.getCount()); } System.out.println(\"]\"); //remove extra occurrences multiset.remove(\"b\",2); //print the occurrence of an element System.out.println(\"Occurence of 'b' : \"+multiset.count(\"b\")); } } Guava Bimap接口可以 inverse，获得 value: key 的 map 12345678910111213141516import com.google.common.collect.BiMap;import com.google.common.collect.HashBiMap;public class GuavaTester { public static void main(String args[]){ BiMap&lt;Integer, String&gt; empIDNameMap = HashBiMap.create(); empIDNameMap.put(new Integer(101), \"Mahesh\"); empIDNameMap.put(new Integer(102), \"Sohan\"); empIDNameMap.put(new Integer(103), \"Ramesh\"); //Emp Id of Employee \"Mahesh\" System.out.println(empIDNameMap.inverse().get(\"Mahesh\")); } } BiMap的各种实现 键–值实现 值–键实现 对应BiMap实现 HashMap HashMap HashBiMap ImmutableMap ImmutableMap ImmutableBiMap EnumMap EnumMap EnumBiMap EnumMap HashMap EnumHashBiMap Guava Table接口类似于 map 的 map，table(r, c, v) (row, col, value) (r, c) 确定 value 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Map;import java.util.Set;import com.google.common.collect.HashBasedTable;import com.google.common.collect.Table;public class GuavaTester { public static void main(String args[]){ //Table&lt;R,C,V&gt; == Map&lt;R,Map&lt;C,V&gt;&gt; /* * Company: IBM, Microsoft, TCS * IBM -&gt; {101:Mahesh, 102:Ramesh, 103:Suresh} * Microsoft -&gt; {101:Sohan, 102:Mohan, 103:Rohan } * TCS -&gt; {101:Ram, 102: Shyam, 103: Sunil } * * */ //create a table Table&lt;String, String, String&gt; employeeTable = HashBasedTable.create(); //initialize the table with employee details employeeTable.put(\"IBM\", \"101\",\"Mahesh\"); employeeTable.put(\"IBM\", \"102\",\"Ramesh\"); employeeTable.put(\"IBM\", \"103\",\"Suresh\"); employeeTable.put(\"Microsoft\", \"111\",\"Sohan\"); employeeTable.put(\"Microsoft\", \"112\",\"Mohan\"); employeeTable.put(\"Microsoft\", \"113\",\"Rohan\"); employeeTable.put(\"TCS\", \"121\",\"Ram\"); employeeTable.put(\"TCS\", \"122\",\"Shyam\"); employeeTable.put(\"TCS\", \"123\",\"Sunil\"); //get Map corresponding to IBM Map&lt;String,String&gt; ibmEmployees = employeeTable.row(\"IBM\"); System.out.println(\"List of IBM Employees\"); for(Map.Entry&lt;String, String&gt; entry : ibmEmployees.entrySet()){ System.out.println(\"Emp Id: \" + entry.getKey() + \", Name: \" + entry.getValue()); } //get all the unique keys of the table Set&lt;String&gt; employers = employeeTable.rowKeySet(); System.out.print(\"Employers: \"); for(String employer: employers){ System.out.print(employer + \" \"); } System.out.println(); //get a Map corresponding to 102 Map&lt;String,String&gt; EmployerMap = employeeTable.column(\"102\"); for(Map.Entry&lt;String, String&gt; entry : EmployerMap.entrySet()){ System.out.println(\"Employer: \" + entry.getKey() + \", Name: \" + entry.getValue()); } } } Multimap很少会直接使用Multimap接口，更多时候你会用ListMultimap或SetMultimap接口，它们分别把键映射到List或Set。 Multimap的各种实现Multimap提供了多种形式的实现。在大多数要使用Map&lt;K, Collection&gt;的地方，你都可以使用它们： 实现 键行为类似 值行为类似 ArrayListMultimap HashMap ArrayList HashMultimap HashMap HashSet LinkedListMultimap* LinkedHashMap* LinkedList* LinkedHashMultimap** LinkedHashMap LinkedHashMap TreeMultimap TreeMap TreeSet ImmutableListMultimap ImmutableMap ImmutableList ImmutableSetMultimap ImmutableMap ImmutableSet Guava 集合工具123456789101112131415161718192021222324252627282930// 用工厂方法模式，我们可以方便地在初始化时就指定起始元素。List theseElements = Lists.newArrayList(\"alpha\", \"beta\", \"gamma\");// 此外，通过为工厂方法命名（Effective Java第一条），我们可以提高集合初始化大小的可读性：List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100);List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100);Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100);// IterablesIterable&lt;Integer&gt; concatenated = Iterables.concat( Ints.asList(1, 2, 3), Ints.asList(4, 5, 6)); // concatenated包括元素 1, 2, 3, 4, 5, 6String lastAdded = Iterables.getLast(myLinkedHashSet);String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);List countUp = Ints.asList(1, 2, 3, 4, 5);// 注: 如果List是不可变的，考虑改用ImmutableList.reverse()。List countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}List&lt;List&gt; parts = Lists.partition(countUp, 2);//{{1,2}, {3,4}, {5}}Set&lt;String&gt; wordsWithPrimeLength = ImmutableSet.of(\"one\", \"two\", \"three\", \"six\", \"seven\", \"eight\");Set&lt;String&gt; primes = ImmutableSet.of(\"two\", \"three\", \"five\", \"seven\");SetView&lt;String&gt; intersection = Sets.intersection(primes,wordsWithPrimeLength);// intersection包含\"two\", \"three\", \"seven\"Map&lt;String, Integer&gt; map = ImmutableMap.of(\"a\", 1, \"b\", 1, \"c\", 2);SetMultimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);// multimap：[\"a\" =&gt; {1}, \"b\" =&gt; {1}, \"c\" =&gt; {2}]Multimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, HashMultimap&lt;Integer, String&gt;.create());// inverse：[1 =&gt; {\"a\",\"b\"}, 2 =&gt; {\"c\"}] Iterables 常规方法 concat(Iterable) 串联多个iterables的懒视图* concat(Iterable...) [frequency(Iterable, Object)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#frequency(java.lang.Iterable, java.lang.Object)) 返回对象在iterable中出现的次数 与Collections.frequency (Collection, Object)比较；``Multiset [partition(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#partition(java.lang.Iterable, int)) 把iterable按指定大小分割，得到的子集都不能进行修改操作 [Lists.partition(List, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Lists.html#partition(java.util.List, int))；[paddedPartition(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#paddedPartition(java.lang.Iterable, int)) [getFirst(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getFirst(java.lang.Iterable, T)) 返回iterable的第一个元素，若iterable为空则返回默认值 与Iterable.iterator(). next()比较;FluentIterable.first() getLast(Iterable) 返回iterable的最后一个元素，若iterable为空则抛出NoSuchElementException [getLast(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getLast(java.lang.Iterable, T))； FluentIterable.last() [elementsEqual(Iterable, Iterable)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#elementsEqual(java.lang.Iterable, java.lang.Iterable)) 如果两个iterable中的所有元素相等且顺序一致，返回true 与List.equals(Object)比较 unmodifiableIterable(Iterable) 返回iterable的不可变视图 与Collections. unmodifiableCollection(Collection)比较 [limit(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#limit(java.lang.Iterable, int)) 限制iterable的元素个数限制给定值 FluentIterable.limit(int) getOnlyElement(Iterable) 获取iterable中唯一的元素，如果iterable为空或有多个元素，则快速失败 [getOnlyElement(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getOnlyElement(java.lang.Iterable, T)) 与Collection方法相似的工具方法通常来说，Collection的实现天然支持操作其他Collection，但却不能操作Iterable。 下面的方法中，如果传入的Iterable是一个Collection实例，则实际操作将会委托给相应的Collection接口方法。例如，往Iterables.size方法传入是一个Collection实例，它不会真的遍历iterator获取大小，而是直接调用Collection.size。 方法 类似的**Collection**方法 等价的**FluentIterable**方法 [addAll(Collection addTo, Iterable toAdd)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#addAll(java.util.Collection, java.lang.Iterable)) Collection.addAll(Collection) [contains(Iterable, Object)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#contains(java.lang.Iterable, java.lang.Object)) Collection.contains(Object) FluentIterable.contains(Object) [removeAll(Iterable removeFrom, Collection toRemove)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#removeAll(java.lang.Iterable, java.util.Collection)) Collection.removeAll(Collection) [retainAll(Iterable removeFrom, Collection toRetain)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#retainAll(java.lang.Iterable, java.util.Collection)) Collection.retainAll(Collection) size(Iterable) Collection.size() FluentIterable.size() [toArray(Iterable, Class)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#toArray(java.lang.Iterable, java.lang.Class)) Collection.toArray(T[]) FluentIterable.toArray(Class) isEmpty(Iterable) Collection.isEmpty() FluentIterable.isEmpty() [get(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#get(java.lang.Iterable, int)) List.get(int) [FluentIterable.get(int)](http://docs.guava-libraries.googlecode.com/git- history/release12/javadoc/com/google/common/collect/FluentIterable.html#get(int)) toString(Iterable) Collection.toString() FluentIterable.toString() Sets 方法 [union(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#union(java.util.Set, java.util.Set)) [intersection(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#intersection(java.util.Set, java.util.Set)) [difference(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#difference(java.util.Set, java.util.Set)) [symmetricDifference(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#symmetricDifference(java.util.Set, java.util.Set)) Guava缓存工具暂时用不到 12 Guava字符串工具Guava Joiner类Joiner 提供了各种方法来处理字符串加入操作，对象等。 1234// useForNull(String) 给定某个字符串来替换null// skipNulls() 直接忽略nullJoiner joiner = Joiner.on(\"; \").skipNulls();return joiner.join(\"Harry\", null, \"Ron\", \"Hermione\"); Guava Spiltter类1234Splitter.on(',') .trimResults() .omitEmptyStrings() .split(\"foo,bar,, qux\"); Guava CharMatcher类1234567// only the digitsSystem.out.println(CharMatcher.DIGIT.retainFrom(\"mahesh123\"));// trim whitespace at ends, and replace/collapse whitespace into single spacesSystem.out.println(CharMatcher.WHITESPACE.trimAndCollapseFrom(\" Mahesh Parashar \", ' '));// star out all digitsSystem.out.println(CharMatcher.JAVA_DIGIT.replaceFrom(\"mahesh123\", \"*\"));System.out.println(CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(\"mahesh123\")); Guava CaseFormat类12 Guava原语工具Java的原生类型就是指基本类型：byte、short、int、long、float、double、char和boolean。 原生类型数组是处理原生类型集合的最有效方式（从内存和性能双方面考虑）。Guava为此提供了许多工具方法。 方法签名 描述 类似方法 可用性 List asList(prim… backingArray) 把数组转为相应包装类的List Arrays.asList 符号无关* prim[] toArray(Collection collection) 把集合拷贝为数组，和collection.toArray()一样线程安全 Collection.toArray() 符号无关 prim[] concat(prim[]… arrays) 串联多个原生类型数组 Iterables.concat 符号无关 boolean contains(prim[] array, prim target) 判断原生类型数组是否包含给定值 Collection.contains 符号无关 int indexOf(prim[] array, prim target) 给定值在数组中首次出现处的索引，若不包含此值返回-1 List.indexOf 符号无关 int lastIndexOf(prim[] array, prim target) 给定值在数组最后出现的索引，若不包含此值返回-1 List.lastIndexOf 符号无关 prim min(prim… array) 数组中最小的值 Collections.min 符号相关* prim max(prim… array) 数组中最大的值 Collections.max 符号相关 String join(String separator, prim… array) 把数组用给定分隔符连接为字符串 Joiner.on(separator).join 符号相关 Comparator&lt;prim[]&gt; lexicographicalComparator() 按字典序比较原生类型数组的Comparator Ordering.natural().lexicographical() 符号相关 *符号无关方法存在于Bytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans。而UnsignedInts, UnsignedLongs, SignedBytes, 或UnsignedBytes不存在。 *符号相关方法存在于SignedBytes, UnsignedBytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans, UnsignedInts, UnsignedLongs。而Bytes不存在。 Guava Ints类 方法及说明 static int compare(int a, int b) 比较两个指定的int值。 static boolean contains(int[] array, int target) 返回true，如果target是否存在在任何地方数组元素。 static int[] ensureCapacity(int[] array, int minLength, int padding) 返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。 static String join(String separator, int… array) 返回包含由分离器分离所提供的整型值的字符串。 static int saturatedCast(long value) 返回最接近的int值。 static Converter stringConverter() 返回使用字符串和整数之间的一","link":"/java/module%20test/04-guava.html"},{"title":"java/module test/05-Apache-Commons","text":"","link":"/java/module%20test/05-Apache-Commons.html"},{"title":"07 AssertJ","text":"[toc] AssertJ一分钟入门 - 简书AssertJ / Fluent assertions for java maven12345&lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;version&gt;3.11.1&lt;/version&gt;&lt;/dependency&gt; code123456789101112131415161718package AssertJ;import java.util.ArrayList;import java.util.Collections;import java.util.List;//import static org.assertj.core.api.Assertions.*;import static org.assertj.core.api.Assertions.assertThat;public class AssertJTest { public static void main(String[] args) { assertThat(\"aa\".equals(\"aa\")); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 1, 2, 3); assertThat(list).contains(1); assertThat(list).containsOnly(1, 2, 3); }} Basic tips :Java 8 assertions, see release notes : 3.8.0 / 3.7.0 / 3.6.0 / 3.5.0 / 3.4.0 / 3.3.0 /3.2.0 / 3.1.0 / 3.0.0IDE configuration to directly get assertThat in code completionDescribe your assertion using as(String description, Object… args)call as() before the assertion 123assertThat(frodo.getAge()).as(\"check %s's age\", frodo.getName()).isEqualTo(100);// The error message starts with the given description in [] :// [check Frodo's age] expected:&lt;100&gt; but was:&lt;33&gt; Exception assertions guideUsing String assertions on the content of a fileIterable and arrays assertions :Combining filtering and assertions on iterables or arrays1234567891011121314151617181920212223242526// Filtering can be done on arrays or iterables. Filter criteria are expressed by :// - a Java 8 Predicate// using simple predicate(谓语？), best expressed with a lambdaassertThat(fellowshipOfTheRing).filteredOn( character -&gt; character.getName().contains(\"o\") ) .containsOnly(aragorn, frodo, legolas, boromir);// - Filtering on a property or a fieldassertThat(fellowshipOfTheRing).filteredOn(\"race\", MAN) .filteredOn(\"name\", not(\"Boromir\")) .containsOnly(aragorn);// - Filtering with a Conditionimport org.assertj.core.api.Condition;Condition&lt;Player&gt; mvpStats= new Condition&lt;Player&gt;() { @Override public boolean matches(Player player) { return player.pointsPerGame() &gt; 20 &amp;&amp; (player.assistsPerGame() &gt;= 8 || player.reboundsPerGame() &gt;= 8); }};List&lt;Player&gt; players;players.add(rose); // Derrick Rose : 25 ppg - 8 assists - 5 reboundsplayers.add(lebron); // Lebron James : 27 ppg - 6 assists - 9 reboundsplayers.add(noah); // Joachim Noah : 8 ppg - 5 assists - 11 reboundsassertThat(players).filteredOn(mvpStats) .containsOnly(rose, lebron); Assertions on extracted properties/fields of iterable/array elements123456789101112assertThat(fellowshipOfTheRing).extracting(\"name\") .contains(\"Boromir\", \"Gandalf\", \"Frodo\", \"Legolas\") .doesNotContain(\"Sauron\", \"Elrond\");// when checking several properties/fields you have to use tuples :import static org.assertj.core.api.Assertions.tuple;// extracting name, age and and race.name nested propertyassertThat(fellowshipOfTheRing).extracting(\"name\", \"age\", \"race.name\") .contains(tuple(\"Boromir\", 37, \"Man\"), tuple(\"Sam\", 38, \"Hobbit\"), tuple(\"Legolas\", 1000, \"Elf\")); Flat(map) extracting1234567891011121314151617List&lt;Player&gt; reallyGoodPlayers = list(jordan, magic);// check all team mates by specifying the teamMates property (Player has a getTeamMates() method):assertThat(reallyGoodPlayers).flatExtracting(\"teamMates\") .contains(pippen, kukoc, jabbar, worthy);// alternatively, you can implement an Extractor to extract the team mates:assertThat(reallyGoodPlayers).flatExtracting(teamMates) .contains(pippen, kukoc, jabbar, worthy);// where teamMates is an instance of PlayerTeammatesExtractor:public class PlayerTeammatesExtractor implements Extractor&lt;Player, List&lt;Player&gt;&gt; { @Override public List&lt;Player&gt; extract(Player input) { return input.getTeamMates(); }} Assertions on results of a method call on iterable/array elements12345678910111213141516// Like extracting but instead of extracting properties/fields// ** it extracts the result of a given method invocation on the elements of the Iterable/Array under test and puts the results into a new Iterable/Array which becomes the object under test.// WesterosHouse class has a method: public String sayTheWords()List&lt;WesterosHouse&gt; greatHouses = new ArrayList&lt;WesterosHouse&gt;();greatHouses.add(new WesterosHouse(\"Stark\", \"Winter is Coming\"));greatHouses.add(new WesterosHouse(\"Lannister\", \"Hear Me Roar!\"));greatHouses.add(new WesterosHouse(\"Greyjoy\", \"We Do Not Sow\"));greatHouses.add(new WesterosHouse(\"Baratheon\", \"Our is the Fury\"));greatHouses.add(new WesterosHouse(\"Martell\", \"Unbowed, Unbent, Unbroken\"));greatHouses.add(new WesterosHouse(\"Tyrell\", \"Growing Strong\"));// let's verify the words of the great houses of Westeros:// 对每个对象调用 sayTheWords 方法assertThat(greatHouses).extractingResultOf(\"sayTheWords\") .contains(\"Winter is Coming\", \"We Do Not Sow\", \"Hear Me Roar\") .doesNotContain(\"Lannisters always pay their debts\"); Advanced tips :Gather all errors message with soft assertions```java// Using soft assertions, AssertJ collects all assertion errors instead of stopping at the first one.// use SoftAssertions instead of direct assertThat methodsSoftAssertions softly = new SoftAssertions();softly.assertThat(mansion.guests()).as(“Living Guests”).isEqualTo(7);softly.assertThat(mansion.kitchen()).as(“Kitchen”).isEqualTo(“clean”);softly.assertThat(mansion.library()).as(“Library”).isEqualTo(“clean”);softly.assertThat(mansion.revolverAmmo()).as(“Revolver Ammo”).isEqualTo(6);softly.assertThat(mansion.candlestick()).as(“Candlestick”).isEqualTo(“pristine”);softly.assertThat(mansion.colonel()).as(“Colonel”).isEqualTo(“well kempt”);softly.assertThat(mansion.professor()).as(“Prof","link":"/java/module%20test/07-AssertJ.html"},{"title":"Dubbo面试28题答案详解：核心功能+服务治理+架构设计等","text":"[toc] Dubbo面试28题答案详解：核心功能+服务治理+架构设计等Java学习分享 1.Dubbo是什么？RPC 指的是远程调用协议，也就是说两个服务器交互数据。 Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案，可以和 Spring 框架无缝集成。 2.Dubbo的由来？互联网的快速发展，Web 应用程序规模的不断扩大，一般会经历如下四个发展阶段。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起即可。 垂直应用架构**当访问量逐渐增大，单一应用按照有业务线拆成多个应用，以提升效率。 此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速地响应多变的市场需求。 此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 3.Dubbo的主要应用场景？透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 4.Dubbo的核心功能？主要就是如下3个核心功能： Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。 Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 5.Dubbo的核心组件？ Provider Consumer Registry Monitor Container 6.Dubbo服务注册与发现的流程？ 流程说明： Provider 绑定指定端口并启动服务 Provider 连接注册中心，并发送 本机IP、端口、应用信息和提供服务信息 至 Registry 存储 Consumer 连接注册中心 ，并发送应用信息、所求服务信息至注册中心 Registry 根据 Consumer 所求服务信息匹配对应的 Provider 列表发送至 Consumer 应用缓存。 Consumer 在发起远程调用时基于缓存的 Provider 列表择其一发起调用。 Provider 状态变更会实时通知Registry、再由Registry实时推送至Consumer 设计的原因： Consumer 与Provider 解偶，双方都可以横向增减节点数。 Registry 对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台 去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用 服务提供者无状态，任意一台宕掉后，不影响使用 7.Dubbo的架构设计？ Dubbo框架设计一共划分了10个层： 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心。 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton。 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心。 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心。 监控层（Monitor）：RPC调用次数和调用时间监控。 远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心。 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心。 8.Dubbo的服务调用流程？ 9.Dubbo支持哪些协议，每种协议的应用场景，优缺点？ dubbo： 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化； rmi： 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。 多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞； webservice： 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用； http： 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用； hessian： 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； memcache： 基于memcached实现的RPC协议 redis： 基于redis实现的RPC协议 10.dubbo推荐用什么协议？默认使用dubbo协议 11.Dubbo有些哪些注册中心？ Multicast注册中心： Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现； Zookeeper注册中心： 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更； redis注册中心： 基于redis实现，采用key/Map存储，住key存储服务名和类型，Map中key存储服务URL，value服务过期时间。基于redis的发布/订阅模式通知数据变更； Simple注册中心 12.Dubbo的服务治理？ 过多的服务URL配置困难 负载均衡分配节点压力过大的情况下也需要部署集群 服务依赖混乱，启","link":"/java/other/Dubbo%E9%9D%A2%E8%AF%9528%E9%A2%98%E7%AD%94%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AD%89.html"},{"title":"java/other/分布式消息Kafka的原理、基础架构、使用场景","text":"","link":"/java/other/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AFKafka%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{"title":"java/other/学习JVM是如何从入门到放弃的？","text":"","link":"/java/other/%E5%AD%A6%E4%B9%A0JVM%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%9A%84%EF%BC%9F.html"},{"title":"java/taotao/淘淘商城-01","text":"","link":"/java/taotao/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E-01.html"},{"title":"java/taotao/淘淘商城-02","text":"","link":"/java/taotao/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E-02.html"},{"title":"Java 并发","text":"CS-Notes [一、使用线程](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=一、使用线程) [实现 Runnable 接口](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现-runnable-接口) [实现 Callable 接口](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现-callable-接口) 12345public class myCallable implements Callable&lt;Integer&gt;{ public Integer call(){ return 123; }} 123FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(new myCallable());new Thread(new FutureTask&lt;Integer&gt;(ft).start();sout(ft.get()); [继承 Thread 类](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=继承-thread-类) [实现接口 VS 继承 Thread](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现接口-vs-继承-thread) 用接口好一些 [二、基础线程机制](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=二、基础线程机制) [Executor](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=executor) 三种executor： CachedThreadPool–不限数量 FixedThreadPool–固定数量 SingleThreadExecutor–数量为一 1234567public static void main(String[] args){ ExecutorService executorService = Executors.newCachedThreadPool(); for (int i=0; i&lt;5; i++){ executorService.execute(new myRunnable()); } executorService.shutdown();} [Daemon](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=daemon) [sleep()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=sleep) Sleep 可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。 [yield()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=yield) [三、中断](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=三、中断) [InterruptedException](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=interruptedexception) 无法中断IO阻塞和synchronized阻塞 [interrupted()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=interrupted) 如果一个线程的run()方法执行一个无限循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用interrupt()方法就无法使线程提前结束。 但是调用interrupt()方法会设置线程的中断标记，此时调用interrupted()方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。 1234567891011121314151617public class InterruptExample{ private static class MyThread2 extends Thread { @Override public void run() { while(!interrupted()){ // ... } sout(\"thread end\"); } } public static void main(String[] args) throws InterruptedException{ Thread thread = MyThread2(); thread2.start(); thread.interrupt(); }} [Executor 的中断操作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=executor-的中断操作) 12executorService.shutdown();executorService.shutdownNow(); 若要中断某个线程： 使用submit替代execute 1234Future&lt;?&gt; future = executorService.submit(() -&gt; { // ...});future.cancel(true); [四、互斥同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=四、互斥同步) [synchronized](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=synchronized) [ReentrantLock](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=reentrantlock) [比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=比较) synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能大致相同 ReentrantLock可中断，而synchronized不行。 一个ReentrantLock可以同时绑定多个condition对象。 [使用选择](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=使用选择) 除非使用ReentrantLock的高级功能，否则优先使用synchronized。这是因为synchronized是JVM实现的一种锁机制，JVM原生地支持它，而ReentrantLock不是所有的JDK版本都支持。并且使用synchronized不用担心没有释放锁而导致死锁问题，因为JVM会确保锁的释放。 [五、线程之间的协作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=五、线程之间的协作) [join()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=join) 将当前线程挂起，直到目标线程结束。 [wait() notify() notifyAll()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=wait-notify-notifyall) 它们都是Object的方法 而sleep是Thread的静态方法 [await() signal() signalAll()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=await-signal-signalall) java.util.concurrent类库提供Condition类库来实现线程间的协调 condition.await() conditon.signal() condition.signalAll() 12345678910111213141516171819202122232425262728293031323334public class AwaitSignalExample { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() { lock.lock(); try { System.out.println(\"before\"); condition.signalAll(); } finally { lock.unlock(); } } public void after() { lock.lock(); try { condition.await(); System.out.println(\"after\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before()); }} [六、线程状态](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=六、线程状态) [新建（NEW）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=新建（new）) [可运行（RUNABLE）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=可运行（runable）) [阻塞（BLOCKED）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=阻塞（blocked）) [无限期等待（WAITING）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=无限期等待（waiting）) [限期等待（TIMED_WAITING）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=限期等待（timed_waiting）) [死亡（TERMINATED）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=死亡（terminated）) [七、J.U.C - AQS](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=七、juc-aqs) [CountDownLatch](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=countdownlatch) 用来控制一个或多个线程等待多个线程 [CyclicBarrier](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=cyclicbarrier) 多个线程互相等待 [Semaphore](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=semaphore) 类似于操作系统的信号量，可以控制对互斥资源的访问线程数。 12345678910111213141516171819202122public class SemaphoreExample { public static void main(String[] args) { final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) { executorService.execute(()-&gt;{ try { semaphore.acquire(); System.out.print(semaphore.availablePermits() + \" \"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }); } executorService.shutdown(); }} [八、J.U.C - 其它组件](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=八、juc-其它组件) [FutureTask](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=futuretask) [BlockingQueue](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=blockingqueue) java.util.concurrent.BlockingQueue接口有以下阻塞队列的实现 FIFO队列： LinkedBlockingQueue ArrayBlockingQueue(固定长度) 优先级队列：PriorityBlockingQueue 提供了阻塞的take put 方法：如果队列为空 take 将阻塞，直到有内容；如果队列为满put将阻塞，直到队列有空闲位置 使用BlockingQueue实现生产者消费者问题 12345678910111213141516171819202122232425262728293031323334353637383940public class ProducerConsumer{ private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread { @Override public void run(){ try{ queue.put(\"product\"); }catch (InterruptedException e){ e.printStackTrace(); } sout(\"produce..\"); } } private static class Consumer extends Thread { @Override public void run(){ try{ String product = queue.take(); } catch (InterruptedException e) { e.printStackTrace(); } sout(\"consume...\"); } } public static void main(Stirng[] args) { for (int i = 0; i &lt; 2; i++) { Producer producer = new Producer(); producer.start(); } for (int i = 0; i &lt; 5; i++) { Consumer consumer = new Consumer(); consumer.start(); } for (int i = 0; i &lt; 3; i++) { Producer producer = new Producer(); producer.start(); } }} 1produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. [ForkJoin](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=forkjoin) ？ [九、线程不安全示例](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=九、线程不安全示例) [十、Java 内存模型](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十、java-内存模型) [主内存与工作内存](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=主内存与工作内存) [内存间交互操作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=内存间交互操作) [内存模型三大特性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=内存模型三大特性) [1. 原子性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-原子性) [2. 可见性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-可见性) [3. 有序性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-有序性) volatile满足可见性，有序性，不能满足原子性。 synchronized满足三者 [先行发生原则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=先行发生原则) [1. 单一线程原则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-单一线程原则) [2. 管程锁定规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-管程锁定规则) [3. volatile 变量规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-volatile-变量规则) [4. 线程启动规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_4-线程启动规则) [5. 线程加入规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_5-线程加入规则) [6. 线程中断规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_6-线程中断规则) [7. 对象终结规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_7-对象终结规则) [8. 传递性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_8-传递性) [十一、线程安全](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十一、线程安全) [不可变](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=不可变) [互斥同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=互斥同步) [非阻塞同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=非阻塞同步) [1. CAS](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-cas) [2. AtomicInteger](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-atomicinteger) [3. ABA](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-aba) [无同步方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=无同步方案) [1. 栈封闭](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-栈封闭) [2. 线程本地存储（Thread Local Storage）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-线程本地存储（thread-local-storage）) 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} get() 方法类似。 12345678910111213public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();} - [3. 可重入代码（Reentrant Code）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-可重入代码（reentrant-code）) [十二、锁优化](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十二、锁优化) [自旋锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=自旋锁) 在jdk1.6中引入了自适应的自旋锁，自适应意味着自选的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 [锁消除](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=锁消除) 锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 [锁粗化](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=锁粗化) 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 锁粗化–把加锁的范围扩展（粗化）到整个操作序列的外部 [轻量级锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=轻量级锁) [偏向锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=偏向锁) [十三、多线程开发良","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E5%B9%B6%E5%8F%91.html"},{"title":"Java 虚拟机","text":"[toc] [一、运行时数据区域](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=一、运行时数据区域) [pc register](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=程序计数器)记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 [JVM stack](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=java-虚拟机栈)每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K, 而在 JDK 1.5+ 默认为1M: 1java -Xss2M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展是如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 [native method stack–本地方法栈](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=本地方法栈)本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般使用其他语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本地硬件和操作系统的程序，对待这些方法需要特别处理。 [堆](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=堆)所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分带收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava [方法区](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=方法区)用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对累的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 ？ [运行时常量池](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=运行时常量池)运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 除了在编译器生成的变量，还允许动态生成，例如Spring 类的 intern() [直接内存](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=直接内存)在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在堆内存和堆外内存来回拷贝数据。 [二、垃圾收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=二、垃圾收集)垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 [判断一个对象是否可被回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=判断一个对象是否可被回收)[1. 引用计数算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-引用计数算法)为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。 在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对他们进行回收。正是因为循环引用的存在，因此Java虚拟机不使用引用计数算法。 1234567891011121314public class Test { public Object instance = null; public static void main(String[] args) { Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); }} 在上述代码中，a与b引用的对象实例互相持有了对象的引用，因此当我们把对a对象与b对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个Test对象无法被回收。 [2. 可达性分析算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-可达性分析算法)以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 [3. 方法区的回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-方法区的回收)因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要至少满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 [4. finalize()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-finalize)类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 [引用类型](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=引用类型)无论是通过引用计数算法判断对象的引用数量，还是用过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 [1. 强引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-强引用)使用 new 一个新对象的方式来创建强引用。 被强引用关联的对象不会被回收。 1Object obj = new Object(); [2. 软引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-软引用)使用 SoftReference 类来创建软引用。 被软引用关联的对象只有在内存不够的情况下才会被回收。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 [3. 弱引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-弱引用)使用 WeakReference 类来创建弱引用。 被弱引用关联的对象一定会被回收，也就是说他只能存活到下一次垃圾回收发生之前。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; [4. 虚引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-虚引用)使用 PhantomReference 来创建虚引用。 虚引用又被称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象创建虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; [垃圾收集算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集算法)[1. 标记 - 清除](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-标记-清除) 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会分割为 size 与 (block - size) 两部分，返回 size 大小的分块，并把大小为 block-size 的块返回给空闲链表。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 [2. 标记 - 整理](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-标记-整理) 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 [3. 复制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-复制) 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次整理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10%的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间 分配担保，也就是借用老年代的空间存储放不下的对象。 [4. 分代收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-分代收集)现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记-清除算法 或者 标记-整理算法 [垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集器)? 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 是并行的，其他垃圾收集器都是以串行的方式执行。 [1. Serial 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-serial-收集器) 特点：串行 单线程 优点：简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 [2. ParNew 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-parnew-收集器) 它是 Serial 收集器的多线程版本。 特点：多线程 串行 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 [3. Parallel Scavenge 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-parallel-scavenge-收集器)并行 与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 [4. Serial Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-serial-old-收集器) 串行 是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 [5. Parallel Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-parallel-old-收集器) 并行 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 [6. CMS 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_6-cms-收集器) CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 [7. G1 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_7-g1-收集器)G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 将整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 [三、内存分配与回收策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=三、内存分配与回收策略)[Minor GC 和 Full GC](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=minor-gc-和-full-gc) Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 [内存分配策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=内存分配策略)[1. 对象优先在 Eden 分配](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-对象优先在-eden-分配)大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 [2. 大对象直接进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-大对象直接进入老年代)大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 [3. 长期存活的对象进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-长期存活的对象进入老年代)为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 [4. 动态对象年龄判定](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-动态对象年龄判定)虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 [5. 空间分配担保](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-空间分配担保)在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 [Full GC 的触发条件](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=full-gc-的触发条件)对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： [1. 调用 System.gc()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-调用-systemgc)只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 [2. 老年代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-老年代空间不足)老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 [3. 空间分配担保失败](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-空间分配担保失败)使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。 [4. JDK 1.7 及以前的永久代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-jdk-17-及以前的永久代空间不足)在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 [5. Concurrent Mode Failure](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-concurrent-mode-failure)执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 [四、类加载机制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=四、类加载机制)类是在运行期间第一次使用是动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。 [类的生命周期](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类的生命周期) 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） [类加载过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载过程)包含了加载、验证、准备、解析和初始化这 5 个阶段。 [1. 加载](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-加载)加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 [2. 验证](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-验证)确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 [3. 准备](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-准备)类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; [4. 解析](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-解析)将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 5. 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 () 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” } static int i = 1;} 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent { public static int A = 1; static { A = 2; }}static class Sub extends Parent { public static int B = A;}public static void main(String[] args) { System.out.println(Sub.B); // 2} 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 [类初始化时机](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类初始化时机)[1. 主动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-主动引用)虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； [2. 被动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-被动引用)以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); [类与类加载器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类与类加载器)两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 [类加载器分类](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载器分类)从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 [1. 工作过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-工作过程)一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。 [2. 好处](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-好处)使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 [3. 实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-实现)以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader { // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); }} [自定义类加载器实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=自定义类加载器实现)以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader { private String rootDir; public FileSystemClassLoader(String rootDir) { this.rootDir = rootDir; } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { String path = classNameToPath(className); try { InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; }} JVM的4种垃圾回收算法、垃圾回收机制与总结Java学习分享 垃圾回收算法1.标记清除标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。 在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。 适用场合： 存活对象较多的情况下比较高效 适用于年老代（即旧生代） 缺点： 容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象） 2.复制算法从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉 现在的商业虚拟机都采用这种收集算法来回收新生代。 适用场合： 存活对象较少的情况下比较高效 扫描了整个空间一次（标记存活对象并复制移动） 适用于年轻代（即新生代）：基本上98%的对象是”朝生夕死”的，存活下来的会很少 缺点： 需要一块儿空的内存空间 需要复制移动对象 3.标记整理复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。 这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。 首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 4.分代收集算法分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。 在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。 垃圾回收机制年轻代分为Eden区和survivor区（两块儿：from和to），且Eden:from:to==8:1:1。 jvm内存结构 1）新产生的对象优先分配在Eden区（除非配置了-XX:PretenureSizeThreshold，大于该值的对象会直接进入年老代）； 2）当Eden区满了或放不下了，这时候其中存活的对象会复制到from区。 3）之后产生的对象继续分配在Eden区，当Eden区又满了或放不下了，这时候将会把Eden区和from区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉Eden区和from区的所有内存。 4）如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：-XX:MaxTenuringThreshold来配置），就会进入年老代了。 5）当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）。 垃圾回收有两种类型：Minor GC 和 Full GC。1.Minor GC对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。 2.Full GC也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比MinorGC要慢，因此应该尽可能减少Full GC的次数，导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。 垃圾回收算法总结1.年轻代：复制算法1) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 2)新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，如此往复。 3) 当survivor1区不足以存放 ed","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA.html"},{"title":"Java 集合","text":"[toc] 集合大家族 - Java 提高篇 - 极客学院Wiki 点击查看图片 ![1Ysxl73BwkfSpvM](https://i.loli.net/2020/01/16/1Ysxl73BwkfSpvM.jpg) 一、Collection 接口Collection 接口是最基本的集合接口 二、List 接口List 接口为 Collection 直接接口。List 所代表的是有序的 Collection实现 List 接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 2.1、ArrayListArrayList 是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括 null。每一个 ArrayList 都有一个初始容量（10）。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。O(1)： size、isEmpty、get、set、iterator 和 listIteratorO(n)： addArrayList 擅长于随机访问。同时 ArrayList 是非同步的。 构造函数ArrayList 提供了三个构造函数：ArrayList()：默认构造函数，提供初始容量为 10 的空列表。ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表 新增add(E e)：将指定的元素添加到此列表的尾部add(int index, E element)：将指定的元素插入此列表中的指定位置。addAll(Collection&lt;? extends E&gt; c)addAll(int index, Collection&lt;? extends E&gt; c)set(int index, E element) 删除remove(int index)、remove(Object o)、removeRange(int fromIndex, int toIndex)、removeAll() 查找get(int index) 扩容ensureCapacity()，该方法就是 ArrayList 的扩容方法当我们清楚知道业务数据量或者需要插入大量元素前，我可以使用 ensureCapacity 来手动增加 ArrayList 实例的容量，以减少递增式再分配的数量 2.2、LinkedListLinkedList 是一个双向链表可以通过较低的代价在 List 中进行插入和删除操作。与 ArrayList 一样，LinkedList 也是非同步的。如果多个线程同时访问一个 List，则必须自己实现访问同步。一种解决方法是在创建 List 时构造一个同步的 List： 1List list = Collections.synchronizedList(new LinkedList(…)); 构造方法LinkedList 提供了两个构造方法：LinkedList() 和 LinkedList(Collection&lt;? extends E&gt; c) 增加方法add(E e)add(int index, E element)addAll(Collection&lt;? extends E&gt; c)addAll(int index, Collection&lt;? extends E&gt; c)addFirst(E e)addLast(E e) 移除方法clear()： 从此列表中移除所有元素。remove()/removeFirst()：获取并移除此列表的第一个元素remove(int index)：移除此列表中指定位置处的元素。remove(Objec o)/removeFirstOccurrence(Object o)：从此列表中移除首次出现的指定元素（如果存在）。removeLast()：移除并返回此列表的最后一个元素。removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 查找方法get(int index)getFirst()getLast()indexOf(Object o)lastIndexOf(Object o) 2.3、Vector与 ArrayList 相似，但是 Vector 是同步的。所以说 Vector 是线程安全的动态数组。它的操作与 ArrayList 几乎一样。 2.4、StackStack 继承自 Vectorpush pop peek empty/isEmpty search 三、Set 接口与 List 一样，它同样允许 null 的存在，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致 e1.equals(e2)==true，则必定会产生某些问题（？）。实现了 Set 接口的集合有：EnumSet、HashSet、TreeSet。 3.1、EnumSet是枚举的专用 Set。所有的元素都是枚举类型。 3.2、HashSetHashSet 堪称查询速度最快的集合，因为其内部是以 HashCode 来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。HashSet 底层使用了 HashMap 实现 3.3、TreeSet基于 TreeMap，生成一个总是处于排序状态的 set，内部以 TreeMap 来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建 Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 四、Map 接口实现 map 的有：HashMap、TreeMap、HashTable、Properties、EnumMap。 4.1、HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个 hash 表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看 HashMap.Entry 的源码它是一个单链表结构。 二、构造函数HashMap 提供了三个构造函数：HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。HashMap(int initialCapacity)HashMap(int initialCapacity, float loadFactor) 三、数据结构table 数组 + 链表HashMap 底层实现还是数组，只是数组的每一项都是一条链。其中参数 initialCapacity 就代表了该数组的长度 4.2、TreeMap键以某种排序规则排序，内部以 red-black（红-黑）树数据结构实现，实现了 SortedMap 接口 4.3、HashTable也是以哈希表数据结构实现的，解决冲突时与 HashMap 也一样也是采用了散列链表的形式，不过性能比 HashMap 要低 五、Queue队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括 ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 六、异同点出处：http://blog.csdn.net/softwave/article/details/4166598 6.1、Vector 和 ArrayList1，vector 是线程同步的，所以它也是线程安全的，而 arraylist 是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用 arraylist 效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector 增长率为目前数组长度的 100%,而 arraylist 增长率为目前数组长度的 50%.如过在集合中使用数据量比较大的数据，用 vector 有一定的优势。3，如果查找一个指定位置的数据，vector 和 arraylist 使用的时间是相同的，都是 0(1),这个时候使用 vector 和 arraylist 都可以。而如果移动一个指定位置的数据花费的时间为 0(n-i)n 为总长度，这个时候就应该考虑到使用 linklist,因为它移动一个指定位置的数据所花费的时间为 0(1),而查询一个指定位置的数据时花费的时间为 0(i)。 6.3、HashMap 与 TreeMap1、HashMap 通过 hashcode 对其内容进行快速查找，而 TreeMap 中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用 TreeMap（HashMap 中元素的排列顺序是不固定的）2、在 Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。使用 HashMap 要求添加的键类明确定义了 hashCode() 和 equals() 的实现。 这个 TreeMap 没有调优选项，因为该树总处于平衡状态。","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%88.html"},{"title":"Java-集合-总结与面试题","text":"[toc] 原文地址 https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484172&amp;idx=1&amp;sn=4e9ea26b6b4b88dd9619c34ea07ba45c&amp;chksm=ebd7420ddca0cb1b798bb6bce3b91216f242e7bc18c2170d26455ea632e4e14b9b250b8d1e8b&amp;scene=21###wechat_redirect 前言 声明，本文用的是 jdk1.8 花了一个星期，把 Java 容器核心的知识过了一遍，感觉集合已经无所畏惧了！！(哈哈哈….)，现在来总结一下吧~~ 回顾目录： Collection 总览 List 集合就这么简单【源码剖析】 Map 集合、散列表、红黑树介绍 HashMap 就是这么简单【源码剖析】 LinkedHashMap 就这么简单【源码剖析】 TreeMap 就这么简单【源码剖析】 ConcurrentHashMap 基于 JDK1.8 源码剖析 Set 集合就这么简单！ Java 容器可分为两大类： Collection List ArrayList LinkedList Vector(了解，已过时) Set TreeSet HashSet LinkedHashSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable(了解，，已过时) 着重标出的那些就是我们用得最多的容器。 一、ArrayList 和 Vector 的区别共同点： 这两个类都实现了 List 接口，它们都是有序的集合 (存储有序)，底层是数组。我们可以按位置索引号取出某个元素，允许元素重复和为 null。 区别： 同步性： ArrayList 是非同步的 Vector 是同步的 即便需要同步的时候，我们可以使用 Collections 工具类来构建出同步的 ArrayList 而不用 Vector 扩容大小： Vector 增长原来的一倍，ArrayList 增长原来的 0.5 倍 二、HashMap 和 Hashtable 的区别共同点： 从存储结构和实现来讲基本上都是相同的，都是实现 Map 接口~ 区别： 同步性： HashMap 是非同步的 Hashtable 是同步的 需要同步的时候，我们往往不使用，而使用 ConcurrentHashMapConcurrentHashMap 基于 JDK1.8 源码剖析 是否允许为 null： HashMap 允许为 null Hashtable 不允许为 null contains 方法 这知识点是在牛客网刷到的，没想到这种题还会有 (我不太喜欢)…. Hashtable 有 contains 方法 HashMap 把 Hashtable 的 contains 方法去掉了，改成了 containsValue 和 containsKey 继承不同： HashMap extends AbstractMap public class Hashtable ​ extends Dictionary 五、Collection 和 Collections 的区别 Collection 是集合的上级接口，继承它的有 Set 和 List 接口 Collections 是集合的工具类，提供了一系列的静态方法对集合的搜索、查找、同步等操作 六、说出 ArrayList,LinkedList 的存储性能和特性ArrayList 的底层是数组，LinkedList 的底层是双向链表。 ArrayList 它支持以角标位置进行索引出对应的元素 (随机访问)，而 LinkedList 则需要遍历整个链表来获取对应的元素。因此一般来说 ArrayList 的访问速度是要比 LinkedList 要快的 ArrayList 由于是数组，对于删除和修改而言消耗是比较大 (复制和移动数组实现)，LinkedList 是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说 LinkedList 的增删速度是要比 ArrayList 要快的 6.1 扩展：ArrayList 的增删未必就是比 LinkedList 要慢。 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。(我测试过) 如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上 (底层调用的是 arraycopy() 方法，是 native 方法)。 LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的 如果数据量有百万级的时，还是 ArrayList 要快。(我测试过) 七、Enumeration 和 Iterator 接口的区别这个我在前面的文章中也没有详细去讲它们，只是大概知道的是：Iterator 替代了 Enumeration，Enumeration 是一个旧的迭代器了。 与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。 我们在做练习的时候，迭代时会不会经常出错，抛出 ConcurrentModificationException 异常，说我们在遍历的时候还在修改元素。 这其实就是 fail-fast 机制~ 具体可参考博文：https://blog.csdn.net/panweiwei1994/article/details/77051261 区别有三点： Iterator 的方法名比 Enumeration 更科学 Iterator 有 fail-fast 机制，比 Enumeration 更安全 Iterator 能够删除元素，Enumeration 并不能删除元素 八、ListIterator 有什么特点 ListIterator 继承了 Iterator 接口，它用于遍历 List 集合的元素。 ListIterator 可以实现双向遍历, 添加元素，设置元素 看一下源码的方法就知道了： 九、并发集合类是什么？Java1.5 并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。 迭代器被设计为 fail-fast 的，会抛出 ConcurrentModificationException。 一部分类为： CopyOnWriteArrayList Concurren","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%88-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{"title":"java/基础/Java基础-2","text":"","link":"/java/%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80-2.html"},{"title":"Java 集合2","text":"[toc] hashCode对于 hashCode，我们应该遵循如下规则：在一个应用程序执行期间，如果一个对象的 equals 方法做比较所用到的信息没有被修改的话，则对该对象调用 hashCode 方法多次，它必须始终如一地返回同一个整数。如果两个对象根据 equals(Object o) 方法是相等的，则调用这两个对象中任一对象的 hashCode 方法必须产生相同的整数结果。如果两个对象根据 equals(Object o) 方法是不相等的，则调用这两个对象中任一个对象的 hashCode 方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。即：如果 x.equals(y) 返回“true”，那么 x 和 y 的 hashCode() 必须相等。如果 x.equals(y) 返回“false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等。 TreeMap一、红黑树简介红黑树是一颗自平衡的排序二叉树。平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。 对于一棵有效的红黑树二叉树而言我们必须增加如下规则： 1、每个节点都只能是红色或者黑色 2、根节点是黑色 3、每个叶节点（NIL 节点，空节点）是黑色的。 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 下图为一颗典型的红黑二叉树。 对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。 左旋 右旋 1、红黑树系列集锦 2、红黑树数据结构剖析 3、红黑树 二、TreeMap 数据结构TreeMap 中同时也包含了如下几个重要的属性： 123456789101112//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制private final Comparator&lt;? super K&gt; comparator;//TreeMap红-黑节点，为TreeMap的内部类private transient Entry&lt;K,V&gt; root = null;//容器大小private transient int size = 0;//TreeMap修改次数private transient int modCount = 0;//红黑树的节点颜色--红色private static final boolean RED = false;//红黑树的节点颜色--黑色private static final boolean BLACK = true; 对于叶子节点 Entry 是 TreeMap 的内部类，它有几个重要的属性： 123456789101112//键K key;//值V value;//左孩子Entry&lt;K,V&gt; left = null;//右孩子Entry&lt;K,V&gt; right = null;//父亲Entry&lt;K,V&gt; parent;//颜色boolean color = BLACK; 三、TreeMap put() delete() 方法略 TreeSetceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 nullhigher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 nulllower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。 iterator：返回在此 set 中的元素上按升序进行迭代的迭代器descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器descendingSet：返回此 set 中所包含元素的逆序视图 pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 nullpollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。first：返回此 set 中当前第一个（最低）元素last：返回此 set 中当前最后一个（最高）元素 remove size isEmpty Java 集合细节（二）：asList 的缺陷一、避免使用基本数据类型数组转换为列表123456789101112public static void main(String[] args) { Integer[] ints = {1,2,3,4,5}; List list = Arrays.asList(ints); System.out.println(\"list'size：\" + list.size()); System.out.println(\"list.get(0) 的类型:\" + list.get(0).getClass()); System.out.println(\"list.get(0) == ints[0]：\" + list.get(0).equals(ints[0]));}----------------------------------------outPut:list'size：5list.get(0) 的类型:class java.lang.Integerlist.get(0) == ints[0]：true 二、asList 产生的列表不可操作asList 返回的列表只不过是一个披着 list 的外衣，它并没有 list 的基本特性（变长）。该 list 是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。 Java 集合细节（三）：subList 的缺陷一、subList 返回仅仅只是一个视图subList 返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上 二、subList 生成子列表后，不要试图去操作原列表对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表： 123456//通过subList生成一个与list1一样的列表 list3List&lt;Integer&gt; list3 = list1.subList(0, list1.size());//对list1设置为只读状态list1 = Collections.unmodifiableList(list1); 生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常 三、推荐使用 subList 处理局部列表在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在 1000 条记录，我们需要删除 100-200 位置处的数据 1list1.subList(100, 200).clear(); Java 集合细节（四）：保持 compareTo 和 equals 同步Collections.binarySearch(list, student);在 sorted list 中获取指定元素的索引 12345678910111213141516public static void main(String[] args){ List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(\"1\", \"chenssy1\", 24)); list.add(new Student(\"2\", \"chenssy1\", 26)); Collections.sort(list); //排序 Student student = new Student(\"2\", \"chenssy1\", 26); //检索student在list中的位置 int index1 = list.indexOf(student); int index2 = Collections.binarySearch(list, student); System.out.println(\"index1 = \" + index1); System.out.println(\"index2 = \" + index2);} 运行结果： 12index1 = 0index2 = 1 因为 indexOf 和 binarySearch 的实现机制不同indexOf 是基于 equals 来实现的, 只要 equals 返回 TRUE 就认为已经找到了相同的元素。binarySearch 是基于 compareTo 方法的，","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%882.html"},{"title":"Java提高篇","text":"[toc] 理解 Java 的三大特性之封装用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象（如 setter getter）封装可以使容易地修改类的内部实现，而无需修改使用了该类的客户代码封装里面也可以写一些逻辑判断 理解 Java 的三大特性之继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。继承所描述的是“is-a”的关系子类拥有父类非 private 的属性和方法。 构造器于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用 super() 即可。子类默认调用父类的默认构造器，如果父类没有默认的构造器，子类的构造方法的第一句必须调用父类的构造器 谨慎继承继承存在如下缺陷：1、父类变，子类就必须变。2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。3、继承是一种强耦合关系。《Think in Java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。 理解 Java 的三大特性之多态子类向上转型为父类，调用子类重写的方法。 Java 的四舍五入12.5 的四舍五入值：13-12.5 的四舍五入值：-12 12345678910// 方法一double f = 111231.5585;BigDecimal b = new BigDecimal(f);double f1 = b.setScale(2, RoundingMode.HALF_UP).doubleValue();// 方法二java.text.DecimalFormat df =new java.text.DecimalFormat(”#.00″);df.format(3.1415926);// 方法三double d = 3.1415926;String result = String.format(”%.2f”); 抽象类与接口抽象类1、抽象类不能被实例化2、子类必须重写抽象方法3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类4、抽象类中可以包含具体的方法，也可以不包含抽象方法。5、子类中的抽象方法不能与父类的抽象方法同名。6、abstract 不能与 final 并列修饰同一个类。7、abstract 不能与 private、static、final 或 native 并列修饰同一个方法 接口1、方法默认是 public2、成员变量默认是 public static final 二者的差别主要体现在：抽象层次不同。抽象类是对整个类的抽象，接口仅仅对行为抽象 使用序列化实现对象的拷贝1234567891011121314151617181920212223public class CloneUtils { @SuppressWarnings(\"unchecked\") public static &lt;T extends Serializable&gt; T clone(T obj){ T cloneObj = null; try { //写入字节流 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream obs = new ObjectOutputStream(out); obs.writeObject(obj); obs.close(); //分配内存，写入原始对象，生成新对象 ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ios); //返回生成的新对象 cloneObj = (T) ois.readObject(); ois.close(); } catch (Exception e) { e.printStackTrace(); } return cloneObj; } } 使用该工具类的对象必须要实现 Serializable 接口实现 Serializable 接口的必须显示地声明 serialVersionUID 字段 12345678910111213public class Person implements Serializable{ private static final long serialVersionUID = 2631590509760908280L; .................. //去除clone()方法}public class Email implements Serializable{ private static final long serialVersionUID = 1267293988171991494L; ....................} 使用 123456Person person1 = new Person(\"张三\",email);Person person2 = CloneUtils.clone(person1);person2.setName(\"李四\");Person person3 = CloneUtils.clone(person1);person3.setName(\"王五\");person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\"); 关键字 static 静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 static 修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以 static 方法必须实现，也就是说他不能是抽象方法 abstract。 被 static 修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。 局限1、它只能调用 static 变量。2、它只能调用 static 方法。3、不能以任何形式引用 this、super。4、static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。 详解内部类特点使用内部类最大的优点就在于它能够非常好的解决多重继承的问题内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。创建内部类对象的时刻并不依赖于外围类对象的创建。内部类提供了更好的封装，除了该外围类，其他类都不能访问。 成员内部类在成员内部类中要注意两点第一：成员内部类中不能存在任何 static 的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 点击查看代码 1234public class OuterClass { public void display(){ System.out.println(\"OuterClass...\"); } public class InnerClass{ public OuterClass getOuterClass(){ return OuterClass.this; } } public static void main(String[] args) { OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display();} 12345## }Output:OuterClass... OuterClassName.this，这样就能够产生一个正确引用外部类的引用了 局部内部类有这样一种内部类，它是嵌套在方法和作用域内的定义在方法里： 点击查看代码 ```Java public class Parcel5 { public Destionation destionation(String str){ class PDestionation implements Destionation{ private String label; private PDestionation(String whereTo){ label = whereTo; } public String readLabel(){ return label; } } return new PDestionation(str); } public static void main(String[] args) { Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(&quot;chenssy&quot;);","link":"/java/%E5%9F%BA%E7%A1%80/Java%E6%8F%90%E9%AB%98%E7%AF%87.html"},{"title":"Java基础","text":"Java 基础 [toc] 2018 年如何快速学 Java学习 JavaWeb 的路线如下：Tomcat(简单过一下)XML/注解(简单过一下)Servlet(重点理解)HTTP 协议(重点理解)Filter 过滤器(重点理解)Listener 监听器(简单过一下)JSP(简单过一下)AJAX、JSON(简单过一下) 泛型就这么简单为什么需要泛型 首先，我们来试想一下：没有泛型，集合会怎么样Collection、Map 集合对元素的类型是没有任何限制的。本来我的 Collection 集合装载的是全部的 Dog 对象，但是外边把 Cat 对象存储到集合中，是没有任何语法错误的。把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是 Object。因此在 get()的时候，返回的是 Object。外边获取该对象，还需要强制转换有了泛型以后：代码更加简洁【不用强制转换】程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现 ClassCastException 异常】可读性和稳定性【在编写集合的时候，就限定了类型】 3.1 泛型类1234567891011public class ObjectTool&lt;T&gt; { private T obj; public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; }} 3.2 泛型方法1234567891011121314151617//定义泛型方法..public &lt;T&gt; void show(T t) { System.out.println(t);}// 使用// 用户传递进来的是什么类型，返回值就是什么类型了public static void main(String[] args) { //创建对象 ObjectTool tool = new ObjectTool(); //调用方法,传入的参数是什么类型,返回值就是什么类型 tool.show(\"hello\"); tool.show(12); tool.show(12.5);} 3.4 类型通配符有个需求：方法接收一个集合参数，遍历集合并把集合元素打印出来 123456789101112// 1. 未指定类型// public void test(List list){// 2. 只能接收装着object的list// public void test(List&lt;Object&gt; list){// 3. ? 表示任意类型public void test(List&lt;?&gt; list){ for(int i=0;i&lt;list.size();i++){ System.out.println(list.get(i)); }} 注意： 使用？时，只能调用与类型无关的方法 3.4.1 类型通配符的上限需求：接收一个 List 集合，它只能操作数字类型的元素【Float、Integer、Double、Byte 等数字类型都行】，怎么做？？？设定通配符上限List&lt;? extends Number&gt; 123public static void test(List&lt;? extends Number&gt; list) {} 3.4.2 类型通配符的上限//传递进来的只能是 Type 或 Type 的父类 1&lt;? super Type&gt; 3.5 通配符和泛型方法通配符 和 泛型方法 实现的功能很接近，怎么选择？原则：通配符要求参数之间没有依赖关系 四、泛型的应用baseDAO 点击查看代码 1public abstract class BaseDao&lt;T&gt; { //模拟hibernate.... private Session session; private Class clazz; //哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要）public BaseDao(){ Class clazz = this.getClass(); //拿到的是子类 ParameterizedType pt = (ParameterizedType) clazz.getGenericSuperclass(); //BaseDao clazz = (Class) pt.getActualTypeArguments()[0]; System.out.println(clazz);}public void add(T t){ session.save(t);}public T find(String id){ return (T) session.get(clazz, id);}public void update(T t){ session.update(t);}public void delete(String id){ T t = (T) session.get(clazz, id); session.delete(t);} 12} CategoryDao 12public class CategoryDao extends BaseDao&lt;Category&gt; {} BookDao 12public class BookDao extends BaseDao&lt;Book&gt; {} 注解就这么简单二、为什么我们需要用到注解？注解可以给类、方法上注入信息 三、基本 Annotationjava.lang 包下存在着 5 个基本的 Annotation 3.1@Overridemailto:3.1@Override重写 3.2@Deprecatedmailto:3.2@Deprecated过时在程序中调用它的时候，在 IDE 上会出现一条横杠，说明该方法是过时的 3.3@SuppressWarningsmailto:3.3@SuppressWarnings抑制编译器警告 3.4@SafeVarargsmailto:3.4@SafeVarargsJava 7“堆污染”警告 ？什么是堆污染呢？？当把一个不是泛型的集合赋值给一个带泛型的集合的时候，这种情况就很容易发生堆污染…. 3.5@FunctionalInterfacemailto:3.5@FunctionalInterface@FunctionalInterface 用来指定该接口是函数式接口 四、自定义注解基础4.1 标记 Annotation没有任何成员变量的注解：标记注解。如@Overrided 12public @interface MyAnnotation{} 4.2 元数据 Annotation带有成员变量的注解：元数据 annotation。注解中声明成员变量类似于声明方法 1234public @interface MyAnnotation{ String username(); int age();} 注意：在注解上定义的成员变量只能是 String、数组、Class、枚举类、注解 4.3 使用自定义注解4.3.1 常规使用有一个 add 的方法，需要 username 和 age 参数，我们通过注解来让该方法拥有这两个变量 1234@MyAnnotation(username=\"Adam\", age=16)public void add(String username, int age){} 4.3.2 默认值注解可以声明默认值 1234public @Interface MyAnnotation{ String username() default \"abc\"; int age() default 11;} 修饰的时候就不用给出具体的值 123@MyAnnotation()public void add(String username, int age){} 4.3.3 注解属性为 value若注解中只有一个属性 value，则可以不指定 value，直接赋值 123@MyAnnotation(\"abd\")public void add(String value){} 4.4 把自定义注解的基本信息注入到方法上? 五、JDK 的元 Annotation5.1@Retentionmailto:5.1@Retention只能用于修饰其他的 Annotation, 用于指定被修饰的 Annotation 被保留多长时间。?5.2@Targetmailto:5.2@Target只能用于修饰其他的 Annotation, 用于指定被修饰的 Annotation 用于修饰哪些程序单元5.3@Documentedmailto:5.3@Documented@Documented 用于指定被该 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。5.4@Inheritedmailto:5.4@Inherited@Inherited 也是用来修饰其他的 Annotation 的，被修饰过的 Annotation 将具有继承性。。。 六、注入对象到方法或成员变量上6.1 把对象注入到方法上?6.2 把对象注入到成员变量? Object 对象你真理解了吗？一、Object 对象简介主要有一下方法registerNatives()【底层实现、不研究】hashCode()equals(Object obj)clone()toString()notify()notifyAll()wait(long timeout)【还有重载了两个】finalize() 二、equals 和 hashCode 方法重写 equals()方法，就必须重写 hashCode()的方法？equals()方法默认是比较对象的地址，使用的是 == 等值运算符hashCode()方法对底层是散列表的对象有提升性能的功能同一个对象(如果该对象没有被修改)：那么重复调用 hashCode()那么返回的 int 是相同的！hashCode()方法默认是由对象的地址转换而来的 2.1 equals 和 hashCode 方法重写一般来说，比较的是对象地址是没有意义的 2.2 String 实现的 equals 和 hashCode 方法String 已经实现了 equals 和 hashCode 方法了，可以直接使用 String.equals()来判断两个字符串是否相等！ 三、toString 方法四、clone 方法4.1 clone 用法如何克隆对象呢？无论是浅拷贝还是深拷贝都是这两步：1.克隆的对象要实现 Cloneable 接口2.重写 clone 方法，最好修饰成 public 1.浅拷贝12345678public class Person implements Cloneable{ private Date date; @Override public Object clone() throws ClonNotSupportedException { return super.clone(); }} 2.深拷贝12345678910public class Person implements Cloneable{ private Date date; @Override public Object clone() throws CloneNotSupportedException { Person person = (Person)super.clone(); person.date = (Date)date.clone(); return person; }} 五、wait 和 notify 方法无论是 wait、notify 还是 notifyAll()都需要由监听器对象(锁对象)来进行调用简单来说：他们都是在同步代码块中调用的，否则会抛出异常！notify()唤醒的是在等待队列的某个线程(不确定会唤醒哪个)，notifyAll()唤醒的是等待队列所有线程 导致 wait()的线程被唤醒可以有 4 种情况该线程被中断wait()时间到了被 notify()唤醒被 notifyAll()唤醒 调用 wait()的线程会释放掉锁 5.1 为什么 wait 和 notify 在 Object 方法上？锁对象是任意的，所以这些方法必须定义在 Object 类中 5.2 notify 方法调用后，会发生什么？5.3 sleep 和 wait 有什么区别？主要的区别在于 Object.wait()在释放 CPU 同时，释放了对象锁的控制。而 Thread.sleep()没有对锁释放 六、finalize()方法finalize()方法将在垃圾回收器清除对象之前调用，但该方法不知道何时调用，具有不定性。一般我们都不会重写它~一个对象的 finalize()方法只会被调用一次 JDK10都发布了，nio你了解多少？前言Java IO，硬骨头也能变软 - 知乎按操作方式分类结构图：按操作对象分类结构图 二、NIO 快速入门3 个核心部分buffer channel selector 2.1buffer 缓冲区和 Channel 管道Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区Channel–&gt; 运输Buffer–&gt; 数据相对于传统 IO 而言，流是单向的 2.1.1buffer 缓冲区核心要点Buffer 是抽象类ByteBuffer 是使用最多的实现类核心方法：put getBuffer 类有 4 个核心属性Capacity 容量缓冲区能够容纳的数据元素的最大数量Limit 上界缓冲区数据总数Position 位置下一个读写的位置Mark 标记记录上一次读写的位置 2.1.2buffer 代码演示1234567891011121314151617181920212223public static void main(String[] args) { // 创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 看一下初始时4个核心变量的值 System.out.println(\"初始时--&gt;limit---&gt;\"+byteBuffer.limit()); System.out.println(\"初始时--&gt;position---&gt;\"+byteBuffer.position()); System.out.println(\"初始时--&gt;capacity---&gt;\"+byteBuffer.capacity()); System.out.println(\"初始时--&gt;mark---&gt;\" + byteBuffer.mark()); System.out.println(\"--------------------------------------\"); // 添加一些数据到缓冲区中 String s = \"Java3y\"; byteBuffer.put(s.getBytes()); // 看一下初始时4个核心变量的值 System.out.println(\"put完之后--&gt;limit---&gt;\"+byteBuffer.limit()); System.out.println(\"put完之后--&gt;position---&gt;\"+byteBuffer.position()); System.out.println(\"put完之后--&gt;capacity---&gt;\"+byteBuffer.capacity()); System.out.println(\"put完之后--&gt;mark---&gt;\" + byteBuffer.mark()); } flip() 后，写模式转换为读模式clear() 后，读模式转换为写模式 2.1.3FileChannel 通道核心要点Channel 通道只负责传输数据、不直接操作数据的获取 channel 12345678// 1. 通过本地IO的方式来获取通道 FileInputStream fileInputStream = new FileInputStream(\"F:\\\\3yBlog\\\\JavaEE常用框架\\\\Elasticsearch就是这么简单.md\"); // 得到文件的输入通道 FileChannel inchannel = fileInputStream.getChannel(); // 2. jdk1.7后通过静态方法.open()获取通道 FileChannel.open(Paths.get(\"F:\\\\3yBlog\\\\JavaEE常用框架\\\\Elasticsearch就是这么简单2.md\"), StandardOpenOption.WRITE); channel 与 buffer 使用示例 2.1.4 直接与非直接缓冲区？ 2.1.5scatter 和 gather、字符集分散读取(scatter)：将一个通道中的数据分散读取到多个缓冲区中聚集写入(gather)：将多个缓冲区中的数据集中写入到一个通道中scatter gather 代码见原文 三、IO 模型理解3.0 学习 I/O 模型需要的基础3.1 阻塞 I/O 模型3.2 非阻塞 I/O 模型3.3I/O 复用模型3.4I/O 模型总结 四、使用 NIO 完成网络通信4.1NIO 基础继续讲解NIO 被叫为 no-blocking io，其实是在网络这个层次中理解的，对于 FileChannel 来说一样是阻塞。通常使用 NIO 是在网络中使用的，网上大部分讨论 NIO 都是在网络通信的基础之上的！说 NIO 是非阻塞的 NIO 也是网络中体现的 在网络中使用 NIO 往往是 I/O 模型的多路复用模型！Selector 选择器就可以比喻成麦当劳的广播。通过 selector，一个线程能够管理多个 Channel 的状态 4.2NIO 阻塞形态4.3NIO 非阻塞形态在客户端上要想获取得到服务端的数据，也需要注册在 register 上(监听读事件) 点击查看代码 1public class NoBlockClient2 { public static void main(String[] args) throws IOException { // 1. 获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666)); // 1.1切换成非阻塞模式 socketChannel.configureBlocking(false); // 1.2获取选择器 Selector selector = Selector.open(); // 1.3将通道注册到选择器中，获取服务端返回的数据 socketChannel.register(selector, SelectionKey.OP_READ); // 2. 发送一张图片给服务端吧 FileChannel fileChannel = FileChannel.open(Paths.get(&quot;X:\\\\Users\\\\ozc\\\\Desktop\\\\新建文件夹\\\\1.png&quot;), StandardOpenOption.READ); // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢 ByteBuffer buffer = ByteBuffer.allocate(1024); // 4.读取本地文件(图片)，发送到服务器 while (fileChannel.read(buffer) != -1) { // 在读之前都要切换成读模式 buffer.flip(); socketChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); } // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) { // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) { SelectionKey selectionKey = iterator.next(); // 8. 读事件就绪 if (selectionKey.isReadable()) { // 8.1得到对应的通道 SocketChannel channel = (SocketChannel) selectionKey.channel(); ByteBuffer responseBuffer = ByteBuffer.allocate(1024); // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收 int readBytes = channel.read(responseBuffer); if (readBytes &gt; 0) { // 切换读模式 responseBuffer.flip(); System.out.println(new String(responseBuffer.array(), 0, readBytes)); } } // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); } }} 12} 服务端 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NoBlockServer { public static void main(String[] args) throws IOException { // 1.获取通道 ServerSocketChannel server = ServerSocketChannel.open(); // 2.切换成非阻塞模式 server.configureBlocking(false); // 3. 绑定连接 server.bind(new InetSocketAddress(6666)); // 4. 获取选择器 Selector selector = Selector.open(); // 4.1将通道注册到选择器上，指定接收“监听通道”事件 server.register(selector, SelectionKey.OP_ACCEPT); // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) { // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) { SelectionKey selectionKey = iterator.next(); // 接收事件就绪 if (selectionKey.isAcceptable()) { // 8. 获取客户端的链接 SocketChannel client = server.accept(); // 8.1 切换成非阻塞状态 client.configureBlocking(false); // 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件) client.register(selector, SelectionKey.OP_READ); } else if (selectionKey.isReadable()) { // 读事件就绪 // 9. 获取当前选择器读就绪状态的通道 SocketChannel client = (SocketChannel) selectionKey.channel(); // 9.1读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建) FileChannel outChannel = FileChannel.open(Paths.get(\"2.png\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); while (client.read(buffer) &gt; 0) { // 在读之前都要切换成读模式 buffer.flip(); outChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); } } // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); } } }} 4.4 管道和 DataGramChannelCOW 奶牛！Copy On Write 机制了解一下一、Linux 下的 copy-on-write1.1 简单来用用 forkfork 用于创建子进程 1.2 再来看看 exec()函数exec 函数的作用就是：装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务 1.3 回头来看 Linux 下的 COW 是怎么一回事二、解释一下 Redis 的 COW三、文件系统的 COW？ 给女朋友讲解什么是 Optional【JDK 8 特性】一、基础铺垫1.1Lambda 简化代码例子创建线程：123456789101112public static void main(String[] args) { // 用匿名内部类的方式来创建线程 new Thread(new Runnable() { @Override public void run() { System.out.println(\"公众号：Java3y---回复1进群交流\"); } }); // 使用Lambda来创建线程 new Thread(() -&gt; System.out.println(\"公众号：Java3y---回复1进群交流\"));} 遍历 Map 集合：12345678910111213public static void main(String[] args) { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(\"公众号\", \"Java3y\"); hashMap.put(\"交流群\", \"回复1\"); // 使用增强for的方式来遍历hashMap for (Map.Entry&lt;String, String&gt; entry : hashMap.entrySet()) { System.out.println(entry.getKey()+\":\"+entry.getValue()); } // 使用Lambda表达式的方式来遍历hashMap hashMap.forEach((s, s2) -&gt; System.out.println(s + \":\" + s2));} 在 List 中删除某个元素12345678910111213141516171819202122public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"Java3y\"); list.add(\"3y\"); list.add(\"光头\"); list.add(\"帅哥\"); // 传统的方式删除\"光头\"的元素 ListIterator&lt;String&gt; iterator = list.listIterator(); while (iterator.hasNext()) { if (\"光头\".equals(iterator.next())) { iterator.remove(); } } // Lambda方式删除\"光头\"的元素 list.removeIf(s -&gt; \"光头\".equals(s)); // 使用Lambda遍历List集合 list.forEach(s -&gt; System.out.println(s));} 1.1 函数式接口函数式接口的特点：有@FunctionalInterface 注解，接口有且仅有一个抽象方法！如 1234@FunctionalInterfacepublic interface Runnable { public abstract void run();} 二、Optional 类2.1 创建 Optional 容器创建 Optional 容器有两种方式：调用 ofNullable()方法，传入的对象可以为 null调用 of()方法，传入的对象不可以为 null，否则抛出 NullPointerException 2.2Optional 容器简单的方法1234567891011121314151617// 得到容器中的对象，如果为null就抛出异常public T get() { if (value == null) { throw new NoSuchElementException(\"No value present\"); } return value;}// 判断容器中的对象是否为nullpublic boolean isPresent() { return value != null;}// 如果容器中的对象存在，则返回。否则返回传递进来的参数public T orElse(T other) { return value != null ? value : other;} 2.3O ptional 容器进阶用法2.3.1 ifPresent 方法123456789public void ifPresent(Consumer&lt;? super T&gt; consumer) { if (value != null) consumer.accept(value);}@FunctionalInterfacepublic interface Consumer&lt;T&gt; { void accept(T t);} 用法 123456789101112131415public static void main(String[] args) { User user = new User(); user.setName(\"Java3y\"); test(user);}public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果存在user，则打印user的name optional.ifPresent((value) -&gt; System.out.println(value.getName())); // 旧写法 if (user != null) { System.out.println(user.getName()); }} 2.3.2 orElseGet 和 orElseThrow 方法123456789101112131415public static void main(String[] args) { User user = new User(); user.setName(\"Java3y\"); test(user);}public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果存在user，则直接返回，否则创建出一个新的User对象 User user1 = optional.orElseGet(() -&gt; new User()); // 旧写法 if (user != null) { user = new User(); }} 2.3.3 filter 方法12345public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果容器中的对象存在，并且符合过滤条件，返回装载对象的Optional容器，否则返回一个空的Optional容器 optional.filter((value) -&gt; \"Java3y\".equals(value.getName()));} 2.3.4 map 方法```Javapublic static void test(User user) { Optional optional = Optional.ofNullable(user); // 如果容器的对象存在，则对其执行调用mapping函数得到返回值。然后创建包含mapping返回值的Optional，否则返回空Optional。 optional.map(user1 -&gt; user1.getName()).orElse(“Unknown”);}//","link":"/java/%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80.html"},{"title":"java/基础/bio-nio","text":"","link":"/java/%E5%9F%BA%E7%A1%80/bio-nio.html"},{"title":"Java提高篇2","text":"[toc] 详解匿名内部类1、匿名内部类中不能存在任何的静态成员变量和静态方法2、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法3、当所在的方法的形参需要被内部类里面使用时，该形参必须为 final4、我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。 1234567891011121314151617181920212223242526272829303132public class OutClass { public InnerClass getInnerClass(final int age,final String name){ return new InnerClass() { int age_ ; String name_; //构造代码块完成初始化工作 { if(0 &lt; age &amp;&amp; age &lt; 200){ age_ = age; name_ = name; } } public String getName() { return name_; } public int getAge() { return age_; } }; } public static void main(String[] args) { OutClass out = new OutClass(); InnerClass inner_1 = out.getInnerClass(201, \"chenssy\"); System.out.println(inner_1.getName()); InnerClass inner_2 = out.getInnerClass(23, \"chenssy\"); System.out.println(inner_2.getName()); }} 代码块静态代码块主要目的就是对静态属性进行初始化 12345public class Test { static{ System.out.println(\"静态代码块\"); }} 构造代码块12345public class Test { { System.out.println(\"执行构造代码块...\"); }} 静态代码块、构造代码块、构造函数执行顺序1、静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。2、构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。3、构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。 equals() 方法总结数组域 : 使用 Arrays.equals在 equals() 中使用 getClass 进行类型判断我们在覆写 equals() 方法时，一般都是推荐使用 getClass 来进行类型判断，不是使用 instanceof 异常(二) - Java 提高篇 - 极客学院Wiki结论一：尽可能的减小 try 块结论二：保证所有资源都被正确释放。充分运用 finally 关键词。结论三：catch 语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的 Exception 类。 不要一个 Exception 试图处理所有可能出现的异常。结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。 1234567public void test() throws XxxException{ try { //do something:可能抛出异常信息的代码块 } catch (Exception e) { throw new XxxException(e); }} 详解 Java 定时任务一、简介Timer 是一种定时器工具，用来在一个后台线程计划执行指定任务，而 TimerTask 一个抽象类，它的子类代表一个可以被 Timer 计划的任务 Timer 类Timer 类可以保证多个线程可以共享单个 Timer 对象而无需进行外部同步，所以 Timer 类是线程安全的 Timer 提供了 schedule 方法，该方法有多中重载方式来适应不同的情况，如下：schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务schedule(TimerTask task, Date firstTime, long period) ：安排指定的任务在指定的时间开始进行重复的固定延迟执行schedule(TimerTask task, long delay) ：安排在指定延迟后执行指定的任务。schedule(TimerTask task, long delay, long period) ：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)：安排指定的任务在指定的时间开始进行重复的固定速率执行。scheduleAtFixedRate(TimerTask task, long delay, long period)：安排指定的任务在指定的延迟后开始进行重复的固定速率执行。 [scheduleWithFixedDelay 和 scheduleAtFixedRate 的区别 - 简书](https://www.jianshu.com/p/2bed76de59a9) ScheduledExecutorService#scheduleAtFixedRate() 指的是“以固定的频率”执行，period（周期）指的是两次成功执行之间的时间 比如，scheduleAtFixedRate(command, 5, 2, second)，第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后 而 ScheduledExecutorService#scheduleWithFixedDelay() 指的是“以固定的延时”执行，delay（延时）指的是一次执行终止和下一次执行开始之间的延迟scheduleWithFixedDelay(command, 5, 2, second)，第一次开始执行是 5s 后，假如执行耗时 1s，执行完成时间是 6s 后，那么下次开始执行是 8s 后，再下次开始执行是 11s 后 TimerTaskTimerTask 类是一个抽象类，有一个抽象方法 run() 方法还有两个非抽象的方法：boolean cancel()：取消此计时器任务。long scheduledExecutionTime()：返回此任务最近实际执行的安排执行时间 分析 schedule 和 scheduleAtFixedRateschedule 方法侧重保存间隔时间的稳定，而 scheduleAtFixedRate 方法更加侧重于保持执行频率的稳定 三、Timer 的缺陷3.1、Timer 的缺陷如果 TimerTask 抛出未检查的异常，Timer 将会停止整个线程 对于 Timer 的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer 是基于绝对时间的，对系统时间比较敏感，而 ScheduledThreadPoolExecutor 则是基于相对时间；Timer 是内部是单一线程，而 ScheduledThreadPoolExecutor 内部是个线程池，所以可以支持多个任务并发执行。 3.2、用 ScheduledExecutorService 替代 Timer对于 Timer 的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer 是基于绝对时间的，对系统时间比较敏感，而 ScheduledThreadPoolExecutor 则是基于相对时间；Timer 是内部是单一线程，而 ScheduledThreadPoolExecutor 内部是个线程池，所以可以支持多个任务并发执行。 旧方案 123456789101112131415161718public class TimerTest03 { Timer timer; public TimerTest03(){ timer = new Timer(); timer.schedule(new TimerTaskTest03(), 1000, 2000); } public static void main(String[] args) { new TimerTest03(); }}public class TimerTaskTest03 extends TimerTask{ @Override public void run() { Date date = new Date(this.scheduledExecutionTime()); System.out.println(\"本次执行该线程的时间为：\" + date); }} 新方案 ```Java public class ScheduledExecutorTest { private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest(){ this.scheduE","link":"/java/%E5%9F%BA%E7%A1%80/Java%E6%8F%90%E9%AB%98%E7%AF%872.html"},{"title":"java/基础/java并发编程之美","text":"","link":"/java/%E5%9F%BA%E7%A1%80/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E.html"},{"title":"nowcoder-examination-java","text":"2019-12-05 06 07static不能用来修饰类除非类是内部类，此时该类作为外部类的成员变量，可以用static来修饰 类方法&lt;-&gt;静态方法静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用 对象空间被收集前执行finalize（）方法而不是对象空间被收集之后再执行，如果这样的话执行finalize（）就没有意义了。 关于继承和实现1.类与类之间的关系为继承，只能单继承，但可以多层继承。2.类与接口之间的关系为实现，既可以单实现，也可以多实现。3.接口与接口之间的关系为继承，既可以单继承，也可以多继承。 面向对象方法的多态性是指相同类型的变量、调用同一个方法时呈现出多种不同的行为特征 Hashtable 和 HashMap 的区别是HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口Hashtable 线程安全的，而 HashMap 是线程不安全的Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 Hashtable：（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。（2）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。（3）HashTable直接使用对象的hashCode。HashMap：（1）由数组+链表组成的，基于哈希表的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。（3）HashMap重新计算hash值 java中将ISO8859-1字符串转成GB2312编码，语句为 ？new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”) java如何接受request域中的参数？request.getParameter() JAVA的跨平台特性表述为“一次编译，到处运行”Java的跨平台特性是因为JVM的存在， 它可以执行.class字节码文件，而不是.java源代码 下列关于JAVA多线程的叙述正确的是（）正确答案: B C 你的答案: A B D (错误)调用start()方法和run()都可以启动一个线程CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程Callable类的call()方法可以返回值和抛出异常新建的线程调用start()方法就能立即进行运行状态 A，start是开启线程，run是线程的执行体，run是线程执行的入口。B，CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。C，Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。D，start是把线程从new变成了runnable 2019-12-04下面的程序输出的结果是( )123456789101112public class A implements B{public static void main(String args[]){ int i; A a1=new A(); i =a1.k; System.out.println(\"i=\"+i); }}interface B{ int k=10；} 正确答案: i=10 在接口里面的变量默认都是public static final 的，它们是公共的,静态的,最终的常量.相当于全局常量，可以直接省略修饰符。实现类可以直接访问接口中的变量 以下叙述正确的是正确答案: D 你的答案: B (错误)实例方法可直接调用超类的实例方法实例方法可直接调用超类的类方法、实例方法可直接调用子类的实例方法实例方法可直接调用本类的实例方法 A错误，类的实例方法是与该类的实例对象相关联的，不能直接调用，只能通过创建超类的一个实例对象，再进行调用B错误，当父类的类方法定义为private时，对子类是不可见的，所以子类无法调用C错误，子类具体的实例方法对父类是不可见的，所以无法直接调用， 只能通过创建子类的一个实例对象，再进行调用D正确，实例方法可以调用自己类中的实例方法 下面代码的执行结果是 :12345678910111213class Chinese{ private static Chinese objref =new Chinese(); private Chinese(){} public static Chinese getInstance() { return objref; }}public class TestChinese { public static void main(String [] args) { Chinese obj1 = Chinese.getInstance(); Chinese obj2 = Chinese.getInstance(); System.out.println(obj1 == obj2);}} 正确答案: true 饿汉式单例模式，在类创建时，就已经实例化完成，在调用Chinese.getInstance()时，直接获取静态对象 JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：HttpSessionAttributeListener 以下哪几种方式可用来实现线程间通知和唤醒：( )12Object.wait/notify/notifyAllCondition.await/signal/signalAll wait()、notify()和notifyAll()是 Object类 中的方法 ；Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、 notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。 2019-12-03ArrayList是可改变大小的数组，而LinkedList是双向链接串列 命令javac-d参数的用途是？指定编译后类层次的根目录 -d destination 目的地-s source 起源地javac -d 指定放置生成的类文件的位置javac -s 指定放置生成的源文件的位置 以下代码执行后输出结果为（ ）public class Test { 123456789101112 public static void main(String[] args) { System.out.println(\"return value of getValue(): \" + getValue()); } public static int getValue() { try { return 0; } finally { return 1; } }} 当try，catch和finally中都有return时，先执行try中return，并暂存，再执行finnally中并返回最新的值 在jdk1.5之后，下列 java 程序输出结果为__。1234int i=0;Integer j = new Integer(0);System.out.println(i==j);System.out.println(j.equals(i)); true,true 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；2、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 说明输出结果。123456789101112ackage test;import java.util.Date; public class SuperTest extends Date{ private static final long serialVersionUID = 1L; private void test(){ System.out.println(super.getClass().getName()); } public static void main(String[]args){ new SuperTest().test(); } } test.SuperTest super.getClass().getName()返回的是test.SuperTest，与Date类无关要返回Date类的名字需要写super.getClass().getSuperclass() 以下哪些类是线程安全的（）正确答案: A D E 你的答案: 空 (错误)VectorHashMapArrayListStringBufferProperties A，Vector相当于一个线程安全的ListB，HashMap是非线程安全的，其对应的线程安全类是HashTableC，Arraylist是非线程安全的，其对应的线程安全类是VectorD，StringBuffer是线程安全的，相当于一个线程安全的StringBuilderE，Properties实现了Map接口，是线程安全的 2019-12-01javac的作用是（ ）。将源程序编译成字节码 12javac helloworld.javajava helloworld HashMap的数据结构是怎样的数组+链表 JDK8以后，HashMap的数据结构是数组+链表+红黑树HashMap内部包含了一个默认大小为 16 Entry 类型的数组 table,其中每个Entry 是一个链表，当链表长度大于等于 8 时会将链表转换为红黑树。HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 下面关于垃圾收集的描述哪个是错误的？a 使用垃圾收集的程序不需要明确释放对象b 现代垃圾收集能够处理循环引用问题c 垃圾收集能提高程序员效率d 使用垃圾收集的语言没有内在泄漏问题也会有内存泄露问题，例如访问资源文件，流不关闭，访问数据库等连接不关闭 重载的方法就是形参列表的不同，和返回值无关用户不能调用构造方法，只能通过new关键字自动调用。【X】 在类内部可以用户可以使用关键字this.构造方法名()调用（参数决定调用的是本类对应的构造方法）在子类中用户可以通过关键字super.父类构造方法名()调用（参数决定调用的是父类对应的构造方法。）反射机制对于任意一个类，都能够知道这个类的所有属性和方法，包括类的构造方法。 下面有关JSP内置对象的描述，说法错误的是？正确答案: C 你的答案: 空 (错误)session对象：session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止request对象：客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应application对象：多个一个application对象实现了用户间数据的共享，可存放全局变量response对象：response对象包含了响应客户请求的有关信息 volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性java程序内存泄露的最直接表现是（ ）正确答案: C 你的答案: 空 (错误)频繁FullGcjvm崩溃程序抛内存控制的Exceptionjava进程异常消失 java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.最终超出内存界限，抛出OutOfMemoryExpection 下面有关webservice的描述，错误的是？正确答案: B 你的答案: 空 (错误)Webservice是跨平台，跨语言的远程调用技术Webservice通信机制实质就是json数据交换Webservice采用了soap协议（简单对象协议）进行通信WSDL是用于描述 Web Services 以及如何对它们进行访问 Web service顾名思义是基于web的服务，它是一种跨平台，跨语言的服务。我们可以这样理解它，比如说我们可以调用互联网上查询天气信息的web服务，把它嵌入到我们的B/S程序中，当用户从我们的网点看到天气信息时，会认为我们为他提供很多的服务，但其实我们什么也没做，只是简单的调用了一下服务器上的一端代码而已。Web service 可以将你的服务发布到互联网上让别人去调用，也可以调用别人发布的web service，和使用自己的代码一样。它是采用XML传输格式化的数据，它的通信协议是SOAP(简单对象访问协议). java用（）机制实现了进程之间的同步执行正确答案: A 你的答案: C (错误)监视器虚拟机多个CPU异步调用 首先jvm中没有进程的概念 ，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。那这道题的问的就是jvm中线程如何异步执行 。 在jvm中 是使用监视器锁来实现不同线程的异步执行， 在语法的表现就是synchronized。 关于访问权限说法正确的是？类定义前面可以修饰public,protected和private内部类前面可以修饰public,protected和private局部内部类前面可以修饰public,protected和private以上说法都不正确 对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。1.成员内部类（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量 或 外部类.this.成员方法】；（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。2.局部内部类（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。3.匿名内部类（1）一般使用匿名内部类的方法来编写事件监听代码；（2）匿名内部类是不能有访问修饰符和static修饰符的；（3）匿名内部类是唯一一种没有构造器的类；（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。4.内部静态类（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；（2）不能使用外部类的非static成员变量或者方法。 throw thorws1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理。 以下可以正确获取结果集的有正确答案: A D 你的答案: 空 (错误) 12345678910Statement sta=con.createStatement();ResultSet rst=sta.executeQuery(“select * from book”);Statement sta=con.createStatement(“select * from book”); ResultSet rst=sta.executeQuery();PreparedStatement pst=con.prepareStatement();ResultSet rst=pst.executeQuery(“select * from book”);PreparedStatement pst=con.prepareStatement(“select * from book”);ResultSet rst=pst.executeQuery(); 创建Statement是不传参的，PreparedStatement是需要传入sql语句1、PreparedStatement 继承 Statement，PreparedStatement 实例包含已编译的 SQL 语句， 所以其执行速度要快于 Statement 对象。2、作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。三种方法execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数3、PreparedStatement尽最大可能提高性能. 最重要的一点是极大地提高了安全性. final、f","link":"/java/%E5%9F%BA%E7%A1%80/nowcoder-examination-java.html"},{"title":"计算机基础/操作系统/计算机操作系统-CS-Notes","text":"","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CS-Notes.html"},{"title":"计算机基础/计算机网络/HTTP-CS-Notes","text":"","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-CS-Notes.html"},{"title":"计算机网络 CS-Notes","text":"[toc] [概述](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 概述)ISP互联网服务提供商（Internet Service Provider），ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等互联设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 主机之间的通信方式C-S 客户端-服务器 模式 P2P 电路交换与分组交换电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路，因此电路交换对线路的利用率很低，往往不到 10%。 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一封邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 时延总时延=排队时延+处理时延+传输时延+传播时延 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 传输时延主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 传播时延电磁波在信道中传输所需要的花费的时间，电磁波传播的速度接近光速。 delay = l / v 其中 l 表示信道长度(m)，v 表示电磁波速度(m/s) 计算机网络体系结构 五层协议应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文 传输层：为进程提供数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两层协议：TCP UDP。TCP: 传输控制协议，提供面向连接、可靠的数据传输服务，数据单位为报文段。UDP: 用户数据报协议，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供即时性服务。 网络层：为主机提供数据传输服务。网络层把数据层传递下来的报文段或用户数据报封装成分组。 数据链路层：网络层针对的是主机之间的数据传输服务，而主机之间可以有许多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层：考虑怎么在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI表示层和会话层，五层协议中没有这 2 层，而是将这些功能留给应用程序开发者处理。 TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 [物理层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 物理层)通信方式根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制模拟信号是连续的信号，数字信号是离散的信号。而带通调制把数字信号转换为模拟信号。 [链路层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 链路层)基本问题1. 封装成帧2. 透明传输帧使用首部和尾部进行定界，透明传输就是将与首部尾部相同的内容转义。接收端处理后还原出原始数据，用户察觉不到转移字符的存在，这个过程是透明传输。 3. 差错检测数据链路层使用循环冗余校验(CRC)来检查比特差错。 信道分类1. 广播信道一对多通信 有 2 种方法避免所有节点发送的数据，一个是信道复用技术，一是使用 CSMA/CD 协议。 2. 点对点信道使用 PPP 协议 信道复用技术1. 频分复用2. 时分复用由于计算机数据的突发性之，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。 3. 统计时分复用4. 波分复用5. 码分复用CSMA/CD 协议Carrier Sense Multiple Access with Collision Detection 载波监听多点接入/碰撞检测 载波监听：主机不停地监听信道，在发送前，如果监听到信道正在使用，就必须等待。 多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上。？ 碰撞检测：发送中，若监听到信道已有其他主机正在发送数据，就表示发生了碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，2τ 为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 MAC 地址Mac 地址是链路层地址，长度是 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网以太网目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 虚拟局域网[网络层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 网络层)概述IP协议 地址解析协议 ARP（Address Resolution Protocol） 网络控制报文协议 ICMP（Internet Control Message Protocol） 网络组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 地址解析协议 ARP由 IP 地址得到 MAC 地址 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。 1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 虚拟专用网 VPN网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 [传输层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 传输层)网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始 与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 2. 快重传 与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 [应用层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层)域名系统DNS 提供主机名和 IP 地址之间相互转换的服务。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名 文件传送协议FTP 使用 TCP 进行连接，它需要 2 个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传送服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 [1. SMTP](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_1-smtp)SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 [2. POP3](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_2-pop3)POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 [3. IMAP](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_3-imap)IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP Web 页面请求过程1. DHCP 配置主机信息假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 **主机生成一个包含目的地址为网关路","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS-Notes.html"},{"title":"计算机基础/计算机网络/socket-CS-Notes","text":"","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket-CS-Notes.html"},{"title":"天书/CNCF-×-Alibaba云原生技术公开课/第 1 2讲","text":"","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC%201%202%E8%AE%B2.html"},{"title":"第3讲：Kubernetes 核心概念 实践","text":"初识 K8s，创建一个guestbook留言簿应用 【K8s | from zero to hero】木环 2019-11-07 876浏览量 简介： 本文介绍一个简单的K8s上手应用，希望通过这个简单的实践让大家对K8s的核心概念有更深入的理解。这个案例要在 Kubernetes 集群上部署一个名叫 guestbook 的 CURD 应用。guestbook 是 Kubernetes 社区的一个经典的应用示例，它有一个 Web 界面来让用户进行 CURD 操作，然后向一个 Redis 主节点写入数据，从多个 Redics 从节点读去数据。 课后实践：Kubernetes 核心概念1. 目标概述本文介绍一个简单的K8s上手应用，希望通过这个简单的实践让大家对K8s的核心概念有更深入的理解。 巩固 Kubernetes 的基本概念 学会使用 Kubernetes 部署一个标准的“多层（multi-tier）”应用 了解 Kubernetes 里如何通过 Pod，Deployment，Service 等 API 原语描述“应用” 2. 实验概览完成此实验后，可以掌握的能力有： 本实验主要在 Kubernetes 集群上部署一个名叫 guestbook 留言簿的 CURD (增查改删)应用。guestbook 是 Kubernetes 社区的一个经典的应用示例，它有一个 Web 界面来让用户进行 CURD 操作，然后向一个 Redis 主节点写入数据，从多个 Redics 从节点读去数据。 实验分以下几个步骤： 创建 Redis 主节点 创建 Redis 从节点集群 创建 guestbook 应用 将 guestbook 应用通过 Service 暴露出来并进行访问 水平扩展 guestbook 应用 3. 所需资源：一个完备的 Kubernetes 集群。您可以选择阿里云容器服务Kubernetes（ACK）进行上手操作。 可以用 Minikube 快速启动一个单节点集群（国内建议使用Minikube 中国版），也可以用云上的 Kubernetes 集群。本次实验演示将使用阿里云容器服务提供的 Kubernetes 集群，版本为 1.12。 你可以使用使用 kubectl version 查看你的集群版本同实验版本一致。 4. 实验详情4.1 创建 Redis 主节点在这里，我们使用一个叫做 Deployment 的 API 对象，来描述单实例的Redis 主节点。 1234567891011121314151617181920212223242526272829apiVersion: apps/v1kind: Deploymentmetadata: name: redis-master labels: app: redisspec: selector: matchLabels: app: redis role: master tier: backend replicas: 1 template: metadata: labels: app: redis role: master tier: backend spec: containers: - name: master image: registry.cn-hangzhou.aliyuncs.com/kubeapps/redis resources: requests: cpu: 100m memory: 100Mi ports: - containerPort: 6379 我们需要把这个上述内容保存为本地 YAML文件，名叫：redis-master-deployment.yaml。这个文件主要定义了两个东西：第一，Pod 里的容器的镜像是 redis；第二，这个 Deployment 的实例数（replicas）是 1，即指启动一个 Pod。 然后，我们使用 Kubernetes 的客户端，执行如下操作： 12$ kubectl apply -f redis-master-deployment.yamldeployment.apps/redis-master created 这一步完成后，Kubernetes 就会按照这个 YAML 文件里的描述为你创建对应的 Pod。这种使用方式就是声明式 API 的典型特征。 接下来，我们可以查看到这个 Pod： 123$ kubectl get podsNAME READY STATUS RESTARTS AGEredis-master-68979f4ddd-pg9cv 1/1 Running 0 49s 可以看到，Pod 已经进入了 Running 状态，表示一切正常。这时，我们就可以查看这个 Pod 里的 Redis 的日志： 12345678$ kubectl logs -f redis-master-68979f4ddd-pg9cv1:C 26 Apr 2019 18:49:29.303 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 26 Apr 2019 18:49:29.303 # Redis version=5.0.4, bits=64, commit=00000000, modified=0, pid=1, just started1:C 26 Apr 2019 18:49:29.303 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf1:M 26 Apr 2019 18:49:29.304 * Running mode=standalone, port=6379.1:M 26 Apr 2019 18:49:29.304 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.1:M 26 Apr 2019 18:49:29.304 # Server initialized1:M 26 Apr 2019 18:49:29.304 * Ready to accept connections 4.2 为 Redis 主节点创建 ServiceKubernetes 里要访问 Pod 最好通过 Service 的方式，这样客户端就不需要记录 Pod 的 IP 地址了。我们的 guestbook 网站需要访问 Redis 主节点的 Pod，所以也要通过 Service 来做。这个 Service API 对象的定义如下所示： 12345678910111213141516apiVersion: v1kind: Servicemetadata: name: redis-master labels: app: redis role: master tier: backendspec: ports: - port: 6379 targetPort: 6379 selector: app: redis role: master tier: backend 这个 Service 名叫 redis-master，它声明用自己的 6379 端口代理 Pod 的 6379端口。 我们还是把上述内容保存成文件然后让 Kubernetes 为我们创建它： 12$ kubectl apply -f redis-master-service.yamlservice/redis-master created 然后我们可以查看一下这个 Service： 1234$ kubectl get serviceNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 181dredis-master ClusterIP 10.107.220.208 &lt;none&gt; 6379/TCP 9s 这时候，你就可以通过 10.107.220.208:6379 访问到这个 Redis 主节点。 4.3 创建 Redis 从节点集群我们这个示例中，有多个 Redis 从节点来共同响应读请求。同样的，我们还是通过 Deployment 来描述”一个服务由多个相同的 Pod 实例副本组成”这种语义。 1234567891011121314151617181920212223242526272829303132apiVersion: apps/v1kind: Deploymentmetadata: name: redis-slave labels: app: redisspec: selector: matchLabels: app: redis role: slave tier: backend replicas: 2 template: metadata: labels: app: redis role: slave tier: backend spec: containers: - name: slave image: registry.cn-hangzhou.aliyuncs.com/kubeapps/gb-redisslave:v1 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: env ports: - containerPort: 6379 在这个 Deployment 中，我们指定了 replicas: 2，即这个 Deployment 会启动两个相同 Pod（Redis 从节点）。 此外，gb-redisslave:v1 这个镜像，会自动读取 REDIS_MASTER_SERVICE_HOST 这个环境变量的值，也就是 Redis 主节点的 Service 地址，然后用它来组建集群。这个环境变量是Kubernetes 自动根据 redis-master 这个 Service 名字，自动注入到集群的每一个 Pod 当中的。 然后，我们创建 Redis 从节点： 12$ kubectl apply -f redis-slave-deployment.yamldeployment.apps/redis-slave created 这时候，我们就可以查看这些从节点的状态： 12345$ kubectl get podsNAME READY STATUS RESTARTS AGEredis-master-68979f4ddd-pg9cv 1/1 Running 0 17mredis-slave-78b464f5cd-2kn7w 0/1 ContainerCreating 0 37sredis-slave-78b464f5cd-582bk 0/1 ContainerCreating 0 37s 4.4 为 Redis 从节点创建 Service类似的，为了让 guestbook 应用访问上述 Redis 从节点，我们还需要为它们创建一个 Service。在Kubernetes 里，Service 可以通过 selector 选择代理多个 Pod，并且负责","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC3%E8%AE%B2%EF%BC%9AKubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%AE%9E%E8%B7%B5.html"},{"title":"第2讲：容器基本概念 实践","text":"你的第一个容器镜像，构建、分发、运行 [ K8s | from zero to hero ]木环 2019-11-07 106浏览量 简介： 再也不要当容器小白了！Build ship and run！ 什么是容器？因为虚拟机（vm）存在一定不足，容器技术的诞生后才如此受欢迎。以传统的Java应用架构而言，将一个应用程序生成一个war包，放到一个tomcat容器当中并在一台虚拟机（VM）中启动运行，然后配置nginx的负载均衡策略，将来自用户的请求转发到某个tomcat应用上，这种基于主机或虚拟机部署的应用会存在以下问题：可移植性差、可维护性差、可扩展性差、无法资源隔离。扩展阅读 而容器是什么呢？它就是一个视图隔离、资源可限制、独立文件系统的进程集合。所谓“视图隔离”就是能够看到部分进程以及具有独立的主机名等；控制资源使用率则是可以对于内存大小以及 CPU 使用个数等进行限制。容器就是一个进程集合，它将系统的其他资源隔离开来，具有自己独立的资源视图。 容器具有一个独立的文件系统，因为使用的是系统的资源，所以在独立的文件系统内不需要具备内核相关的代码或者工具，我们只需要提供容器所需的二进制文件、配置文件以及依赖即可。只要容器运行时所需的文件集合都能够具备，那么这个容器就能够运行起来。扩展阅读《详解 K8s 容器基本概念》 什么是容器镜像？从一个比较具体的角度去看，镜像就是一个多层存储的文件，相较于普通的ISO系统镜像来说，分层存储会带来两个优点： 一个是分层存储的镜像比较容易扩展，比如我们可以基于一个Ubuntu镜像去构建我们的Nginx镜像，这样我们只需要在Ubuntu镜像的基础上面做一些Nginx的安装配置工作。一个Nginx镜像工作就算制作完成了，我们不需要从头开始去制作各种镜像。 另一点是可以优化镜像存储空间，假如我们有两个镜像，Tag1.0镜像和 Tag2.0镜像，我们如果以传统方式去传这两个镜像，每个镜像大概130多兆，但如果我们以分层的方式去存储两个镜像，我们通过下面两个紫色的才能共享，可以节约大量的空间，两个镜像加起来只需要140多兆的空间就可以存下来。这样一是节省了存储空间，二是可以减少网络上的开销，比如我们已经把下面镜像下载了，我们要去下载上面镜像的时候，我们只需要去下10M的部分。 如果从抽象的角度去看，Docker镜像其实是Docker提供的一种标准化的交付手段，传统应用在交付的时候其实是交付一个可执行文j件。问题在于传统方式的这个可执行文件不包括它的运行环境，我们可能会因为32位系统或64位系统，或者开发测试使用1.0软件，结果交付时候发现用户的环境是2.0等各种各样的问题，导致我们要去花时间去排查；但是，如果我们以Docker镜像的标准化形式去交付，我们就会避免掉这些问题。 扩展阅读《Docker 镜像优化与最佳实践》 *好了，闲话少叙。下面开始实验时间。* 1. 实验概述本实验会使用 Dockerfile 将下面 golang 代码构建成镜像，并通过阿里云镜像服务将镜像分发到阿里云虚拟机，运行该镜像。 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &quot;Hello! World\\n&quot;) }) fmt.Println(&quot;start to serve...&quot;) http.ListenAndServe(&quot;:80&quot;, nil)} 2. 实验目标完成此实验后，可以掌握的能力有： Dockerfile 编写和使用 使用阿里云镜像服务来分发镜像。 NOTE: 学前建议: 了解 docker 的基本操作命令 以及 如何使用 ECS 实例。 3. 实验详情3.1 准备应用代码和 Dockerfile首先在本地生成一个文件夹 demo，并将 golang 代码拷贝到 demo 文件夹下的 main.go. 12345678910111213141516171819202122$ pwd/tmp/demo$ lsmain.go$ cat main.gopackage mainimport ( &quot;fmt&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &quot;Hello! World\\n&quot;) }) fmt.Println(&quot;start to serve...&quot;) http.ListenAndServe(&quot;:80&quot;, nil)} 在当前 demo 目录下编写 Dockerfile ，如下所示 1234567891011121314$ cat DockerfileFROM golang:1.12-alpine# change current working dirWORKDIR /go/src/app# copy main.go into /go/src/appCOPY . .# go build and install the appRUN go install -v ./...# run the app by defaultCMD [&quot;app&quot;] 3.2 构建镜像通常情况下，使用以下命令即可构建镜像 12345678910111213141516171819202122232425$ pwd/tmp/demo# demo:v1 表示镜像名字demo和标签v1$ docker build . -t demo:v1Sending build context to Docker daemon 3.072kBStep 1/5 : FROM golang:1.12-alpine ---&gt; 8ff3fd35cf82Step 2/5 : WORKDIR /go/src/appRemoving intermediate container ffd88a948413 ---&gt; 1056ea513b89Step 3/5 : COPY . . ---&gt; 9fc4655c973aStep 4/5 : RUN go install -v ./... ---&gt; Running in 928fc776a6e1appRemoving intermediate container 928fc776a6e1 ---&gt; a93f17a3a726Step 5/5 : CMD [&quot;app&quot;] ---&gt; Running in 9e3463aa81f6Removing intermediate container 9e3463aa81f6 ---&gt; 8697c7279c74Successfully built 8697c7279c74Successfully tagged demo:v1 NOTE: 在国内访问 Docker Hub 速度比较慢，可以在Docker引擎中设置镜像加速器加速对Docker Hub的访问。 更新 /etc/docker/daemon.json，添加如下参数，并重启Docker引擎。 123{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]} 1构建完毕之后，可以在本地运行验证下是否符合预期 映射容器内 80 端到宿主机上的 8000 端口$ docker run -d -p 8000:80 demo:v1 curl 一下查看结果$ curl localhost:8000Hello! World 123456789101112131415如果看到 `Hello! World` 字样，我们就可以进入下一个环节了。#### 3.3 推送镜像至阿里云容器镜像服务在推送之前，需要注册阿里云账号和开通阿里云容器镜像服务&gt; 阿里云注册链接： [注册阿里云](https://account.aliyun.com/register/register.htm)&gt; &gt; 阿里云登录链接： [登录阿里云](https://account.aliyun.com/login/login.htm)&gt; &gt; 阿里云容器镜像服务页面： [访问阿里云容器镜像服务](https://cr.console.aliyun.com) &gt; &gt; 容器镜像服务（Container Registry）提供安全的应用镜像托管能力，精确的镜像安全扫描功能，稳定的国内外镜像构建服务，便捷的镜像授权功能，方便用户进行镜像全生命周期管理。当我们拥有阿里云容器镜像服务账号之后呢，可以使用 docker 客户端来登陆服务。 $ docker login -username=**** registry.cn-hangzhou.aliyuncs.comPassword:Login Succeeded 1在推送到镜像之前，需要将本地镜像修改为对应的镜像仓库地址： mydemo 可以替换成自己的命名空间$ docker tag demo:v1 registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 $ docker push registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 123#### 3.4 登陆阿里云 ECS 机器来下载 demo:v1 镜像登陆 ECS 实例，通过 docker pull 来下载镜像 mydemo 请替换成 3.3 步骤中指定的命令空间$ docker pull registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 1下载完毕之后，我们就可以直接运行该镜像 $ docker run -d -p 8000:80 registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 ```并查看","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC2%E8%AE%B2%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%AE%9E%E8%B7%B5.html"},{"title":"Chrome/chrome-插件","text":"","link":"/Chrome/chrome-%E6%8F%92%E4%BB%B6.html"},{"title":"Mac/mac-屏保","text":"","link":"/Mac/mac-%E5%B1%8F%E4%BF%9D.html"},{"title":"python/01-烦人的网页编码问题","text":"","link":"/python/01-%E7%83%A6%E4%BA%BA%E7%9A%84%E7%BD%91%E9%A1%B5%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html"},{"title":"other/爬取-SP-图片","text":"","link":"/other/%E7%88%AC%E5%8F%96-SP-%E5%9B%BE%E7%89%87.html"},{"title":"Mac/01-bitbar","text":"","link":"/Mac/01-bitbar.html"},{"title":"Mac/02-aria2","text":"","link":"/Mac/02-aria2.html"},{"title":"Mac/03-ssh-config-editor","text":"","link":"/Mac/03-ssh-config-editor.html"},{"title":"Mac/mac-tricks","text":"","link":"/Mac/mac-tricks.html"},{"title":"Mac/有意思的Mac软件","text":"","link":"/Mac/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84Mac%E8%BD%AF%E4%BB%B6.html"},{"title":"阿里云/阿里云","text":"","link":"/%E9%98%BF%E9%87%8C%E4%BA%91/%E9%98%BF%E9%87%8C%E4%BA%91.html"},{"title":"tricks/tricks-2020-03","text":"","link":"/tricks/tricks-2020-03.html"},{"title":"Mac/04-cocktail","text":"","link":"/Mac/04-cocktail.html"},{"title":"研究生课程/信息和网络安全","text":"","link":"/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.html"},{"title":"Mac/power-manager","text":"","link":"/Mac/power-manager.html"},{"title":"研究生课程/信息系统实训","text":"","link":"/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD.html"},{"title":"研究生课程/软件测试实训","text":"","link":"/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%AE%AD.html"},{"title":"Mac/05-iterm","text":"","link":"/Mac/05-iterm.html"},{"title":"Mac/cli","text":"","link":"/Mac/cli.html"},{"title":"Mac/mac-设置","text":"","link":"/Mac/mac-%E8%AE%BE%E7%BD%AE.html"},{"title":"Mac/06-tmux","text":"","link":"/Mac/06-tmux.html"},{"title":"tricks/git-tricks","text":"","link":"/tricks/git-tricks.html"}],"tags":[{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"tricks","slug":"tricks","link":"/tags/tricks/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"weekly","slug":"weekly","link":"/tags/weekly/"},{"name":"加密文章","slug":"加密文章","link":"/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"nowcoder","slug":"nowcoder","link":"/tags/nowcoder/"},{"name":"examination","slug":"examination","link":"/tags/examination/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"frontEnd","slug":"frontEnd","link":"/categories/frontEnd/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"private","slug":"private","link":"/categories/private/"},{"name":"theme","slug":"theme","link":"/categories/theme/"},{"name":"tricks","slug":"tricks","link":"/categories/tricks/"},{"name":"Collections","slug":"java/Collections","link":"/categories/java/Collections/"},{"name":"module test","slug":"java/module-test","link":"/categories/java/module-test/"},{"name":"other","slug":"java/other","link":"/categories/java/other/"},{"name":"基础","slug":"java/基础","link":"/categories/java/%E5%9F%BA%E7%A1%80/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"天书","slug":"天书","link":"/categories/%E5%A4%A9%E4%B9%A6/"},{"name":"CNCF-×-Alibaba云原生技术公开课","slug":"天书/CNCF-×-Alibaba云原生技术公开课","link":"/categories/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/"}]}