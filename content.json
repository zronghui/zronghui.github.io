{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"}],"posts":[{"title":"test","text":"","link":"/test.html"},{"title":"Mac config backup plan","text":"[toc] 浏览器油猴导出的是个压缩包 导入： 将所有文件打包，导入即可 magic actions for youtubestylishone tab简悦chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/options/options.html#plugins search allMPV 配置iina 配置 快捷键clipy备份 及 还原 脚本~目录下不大的话全部保存？pycharm 配置 idea 配置","link":"/Mac/Mac-config-backup-plan.html"},{"title":"Vue.js基础入门Vue实战黑马程序员VUE","text":"开发工具vscode + live server 在挂载点及其子节点中生效123el: \"#app\" // idel: \".app\" // classel: \"app\" // 标签 可以使用其他双标签，但是不能使用html body v-text设置标签的文本值v-text=”message+’|’”“”中可以使用字符串的拼接等表达式 v-html设置元素的innerHtml v-on为元素绑定事件v-on:clickv-on:mouseenterv-en:dbclick@简写@click@mouseenter@dbclick v-bind设置元素的属性 src title classv-bind:src 简写为 :src 1234&lt;img :src=\"imgsrc\"&gt;&lt;img :title=\"imgtitle\"&gt;// 增删class&lt;img :class=\"{active:isActive}\"&gt; v-on 补充回车出发事件：@keyup.enter=”sayHi” v-model 双向数据绑定axios功能强大的网络请求库 12345&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;axios.get(url).then(function(response){}, function(err){})axios.post(url, {key1:value,key2:value}).then(function(response){}, function(err){}) axios回调函数中的this已经改变，无法访问到data中的数据把this保存起来，回调函数中直接使用保存的this","link":"/frontEnd/Vue-js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8Vue%E5%AE%9E%E6%88%98%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98VUE.html"},{"title":"es6","text":"","link":"/frontEnd/es6.html"},{"title":"mpv 配置","text":"[toc] Mpv 配置完，使用与 iina 差不多 安装brew cask install mpv 配置文件位置mpv的所有配置文件以及脚本均在：~/.config/mpv下面，常见的如下几个： mpv.conf – mpv 基本配置文件。详细帮助文档见：http://mpv.io/manual/stable/ 。 input.conf – 用户自定义的按键绑定（快捷键）。 lua-settings/osc.conf – 该文件用于定义 OSC 样式。例如，layout 一项可以更换的值包括：box，slimbox，bottombar 以及 topbar。 scripts/autoload.lua – 该脚本会查找文件夹内的相似文件，并自动创建播放列表。 scripts/vo_battery.lua – 该脚本会在应用启动时判断有没有连接电源，有连接电源则开启效果更好也更耗电的 vo。 以上配置文件可以去https://github.com/cocokui/mpv下载 open ~/.config/mpv/ 已经有一个图形界面的配置工具： mpv Configurator ：haasnhoff/mpvconfigurator 把配置好的文件存储为：~/.config/mpv/mpv.conf 具体配置说明见官网：mpv.io 快捷键配置见：MPV播放器快捷键文档翻译 - Family Blog 快捷键配置保存在：~/.config/mpv/input.conf mpv.conffrom https://github.com/cocokui/mpv 以下是另外一个配置，但是用它软件会卡住，因为有详细注释，先留在这 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# 关闭窗口装饰（无边框）no-border# 隐藏快进快退时候的白条--osd-level=0# 设定程序启动后的默认音量volume=100# 使字幕输出在黑边上sub-ass-force-margins=yes# 一套预设的高质量渲染设置profile=gpu-hq# gpu-hq contains:# scale=spline36# cscale=spline36# dscale=mitchell# dither-depth=auto# correct-downscaling=yes# linear-downscaling=yes# sigmoid-upscaling=yes# deband=yes# 开启色彩管理icc-profile-autoblend-subtitles=video# 将画面拉伸算法更改为 EWA Lanczosscale=ewa_lanczossharp#启用 interpolation 来消除帧率问题造成的卡顿video-sync=display-resampleinterpolationtscale=oversample# 关闭软解hwdec=no# 高优先级priority=high# gpu-api的选择？# macOS： 只有opengl可选# Linux： vulkan或者opengl，推荐vulkan# Windows：vulkan、d3d11及opengl都可选。三者理论上vulkan性能最好，实际使用上可能差别不大。# 三者无法并存，去掉行首的'#'启用，加上'#'禁用#----------------------------------------# 使用d3d11 （mpv对于windows的默认。显卡一定要开自适应电源模式，否则性能比vulkan差）# gpu-api=d3d11# ----------------------------------------# 使用vulkan# gpu-api=vulkan# ----------------------------------------# 使用openglgpu-api=opengl# 对windows，使用angle后端# gpu-context=angle # 记忆上次播放的位置# 需要mpv.conf所在文件夹有用户写入权限，或者用watch-later-directory=路径来手动指定。save-position-on-quit# may help with 4K videosopengl-pbo=yes# 画面抖动处理，默认6。会稍微延缓mpv启动temporal-ditherdither-size-fruit=7 # smooth motioninterpolation# 启用校色，默认64x64x64。会稍微延缓mpv启动icc-profile-autoicc-3dlut-size=256x256x256# 在mpv.conf所在目录下建一个 shaders_cache 空文件夹，以存放编译好的GPU shaders，加速启动。# 如果不放APPDATA下，确保该文件夹有用户写入权限。gpu-shader-cache-dir=\"~~/shaders_cache\"# WASAPI音频输出（Windows）# 其他系统请相应更改音频输出方式ao=wasapi# 如果双声道系统播放多声道影片时有的声道声音没出现，尝试强制设定为双声道#audio-channels=stereo# 规格化：#audio-normalize-downmix=yes# 多声道音轨downmix成双声道时，如果觉得背景音过响，角色台词声音小，尝试看看这个：https://github.com/mpv-player/mpv/issues/656# 字幕配置sub-auto=fuzzysub-file-paths=subsslang=chi,zh-CN,sc,chs# 字幕显示出来和xy-subfilter不一样？尝试启用下面的设置#sub-ass-vsfilter-aspect-compat=no # 关乎字幕是否随视频拉伸#sub-ass-vsfilter-blur-compat=no # 关乎字幕模糊的设定# 即使都用上了也不一致？那不是这两个选项的问题，重新注释掉这两行，回帖问吧。（多半是vsfilter/libass其中一个的bug）# 音轨配置audio-file-auto=fuzzyalang=jpn,ja,eng,en# 截图配置screenshot-template=~/Desktop/mpv-screenshot-%f-%pscreenshot-format=pngscreenshot-tag-colorspace=yesscreenshot-high-bit-depth=yes# 根据视频是否是HDR以及视频aspect ratio决定是否启用blend-subtitles的profile# 目前HDR-&gt;SDR建议关闭blend-subtitles，见https://github.com/mpv-player/mpv/issues/6368# 如果hdr-compute-peak将来继续改进可能可以兼容blend-subtitles[HDR_or_21:9]profile-desc=cond:(p[\"video-params/primaries\"]==\"bt.2020\" or p[\"video-params/aspect\"]&gt;=2.0)blend-subtitles=no input.conf用这个替换上面仓库的 input.conf mpv/input.conf at master · mpv-player/mpv 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# z x cz set speed 1.0x add speed -0.2c add speed 0.2# 全屏切换(回车键及小键盘确认键)Enter cycle fullscreenKP_ENTER cycle fullscreen# 双击左键 播放/暂停MBTN_LEFT_DBL cycle pause# 滚轮上下滑动调节音量WHEEL_UP add volume 5WHEEL_DOWN add volume -5# 滚轮左右滑动调节进度条WHEEL_LEFT seek -3WHEEL_RIGHT seek 3# 左右方向键调节进度条RIGHT seek 3 relative+exactLEFT seek -3 relative+exactCtrl+RIGHT seek 30 relative+exactCtrl+LEFT seek -30 relative+exactShift+RIGHT seek 60 relative+exactShift+LEFT seek -60 relative+exact# 上下方向键调节音量UP add volume 5DOWN add volume -5# 空格键 播放/暂停SPACE cycle pause# 禁用默认 暂停/播放 快捷键p ignore# 逐帧前进后退f frame-stepd frame-back-step# 字幕校正, add sub-delay -0.1. add sub-delay +0.1# 静音# m cycle mute# 文件信息TAB script-binding stats/display-stats# 禁用鼠标左右键单击MBTN_LEFT ignoreMBTN_RIGHT ignore# 禁用一系列快捷键9 ignore/ ignore0 ignore* aignore1 ignore2 ignore3 ignore4 ignore5 ignore6 ignore7 ignore8 ignorei ignore","link":"/Mac/mpv-%E9%85%8D%E7%BD%AE.html"},{"title":"mac apps","text":"[toc] Port ManagerPort Manager for Mac — Manage ports from your menu bar 要翻墙？ Collection: System Tools Use your menu bar to find, open and kill ports in a couple of clicks. View all of your ports in one place, so you can go back to writing code. MouselessCollection: Productivity Apps Mouseless combines a searchable database of thousands of shortcuts (conveniently detecting what app you are currently using) and a training feature that helps you learn and remember those shortcuts. VISIT 待破解 @homeCollection: Security Apps This menu bar app keeps your Mac unlocked while you are at home. It knows when you are at home (based on your wireless network name) and prevents your computer from locking the screen. VISIT AirfloCollection: Misc &amp; Others This menu bar provides real-time air quality anywhere in the world. VISIT SimplePingCollection: System Tools Check your internet connection quality directly in the menu bar. The ping updates in realtime. VISIT Unite for MacOSCollection: Menu Bar Managers Unite 2 allows you to turn any website into a menu bar app, permitting easy access to any service whenever you need it. VISIT WATCH TypeetoCollection: Productivity Apps Typeeto enables you to use your Mac keyboard as a bluetooth keyboard for other devices such as iPad, iPhone, Apple TV, Android device, etc. VISIT VanishCollection: Productivity Apps Hide or close inactive apps after a period of time. Set a custom time for each application and this menu bar app will hide/close the application if it hasn’t been activated for that period of time. VISIT 类似软件：hocus focus? Speedtest for MacCollection: System Tools Launching a Speedtest straight from your Mac menu bar is the quickest way to check your connectivity. VISIT ClarityCollection: Design Apps Minimal Mac wallpapers right in your menu bar. VISIT PingBarCollection: System Tools PingBar keeps an eye on your server. It will ping your server periodically, and show you the delay in the menubar. App store BidbarCollection: System Tools With Bidbar, all your Terminal commands are at your finger tips, just a click of a button or a tap of a key away. VISIT WATCH 待破解 PingeyCollection: Menu Bar Managers Pingey sits in the menu bar. Click on the icon to see the status of all your websites. Or add separate menu bar items for your most important sites. VISIT RearviewCollection: Security Apps This menu bar app tells you if someone (behind your back) is staring at your screen. For instance a passenger reading your emails when travelling by train. It plays a sound when more than one face is detected. VISITMenu Launcher Collection: Files &amp; Folders/ Productivity Apps This menu bar app lets you launch any file, folder and apps from one single place. No more cluttered desktop, dock or system status menu bar. VISIT 待破解 Hacker PadCollection: Note Taking Apps Hacker Pad lives in the menu bar for quick access. It allows especially developers to quickly jot down ideas and snippets. VISIT Keyboard LockerCollection: Security Apps A menu bar app that locks and unlocks your keyboard and mouse. No more worrying about your cat messing up everything while you’re away. VISIT SuperbarCollection: Menu Bar Managers Superbar allows you to bring snippets, bookmarks, apps or system commands into your menu bar. VISIT AccessMenuBarAppsCollection: Menu Bar Managers AccessMenuBarApps removes the problem of viewing menu bar icons on laptop displays. This utility allows you to expand your menu bar when you need it. VISIT WATCH JettisonCollection: System Tools Jettison automatically ejects external disks from your Mac before your computer goes to sleep. VISIT Jettison 1.7.5 外部磁盘智能弹出 - 精品MAC应用分享 PliimCollection: Display Apps Plimm puts your Mac into presentation mode. This menu bar hides all the mess on your desktop and even disables notifications. VISIT Web PingCollection: System Tools This menu bar app will ping all your websites straight from your computer and notify you when something is wrong with any of them, or when a broken website is back online. VISIT MuzzleCollection: Productivity Apps Muzzle runs quietly in the menu bar. When you start sharing your screen, it automatically enables ‘Do Not Disturb’ so that no notifications appear on your screen and interrupt or embarrass you during a meeting. VISIT LuLuCollection: Security Apps LuLu is the free, open firewall for Macs that can protect your network connections and detect malicious activity. It blocks any unknown outgoing connections, until approved by the user. VISIT Butler for MacCollection: Menu Bar Managers Butler for Mac is a do-it-all utility for your Mac: Launcher, iTunes controller, macros, pop-up folders, multiple clipboards, and more. VISIT WATCH Quitter for Mac Collection: Productivity Apps Quitter automatically hides or quits apps after periods of inactivity. VISIT WATCH SelfControlCollection: Productivity Apps SelfControl saves you from the meaningless waste of time of websites like Facebook, Twitter or any other website you stick for hours. Simply add the websites which distract you from your work, set the timer and turn it on. VISIT WATCH 缺点：无法拦截代理 替代软件：Focus 1.11 帮助你拦截那些会使你分心的网站 - 精品MAC应用分享 TripModeCollection: Security Apps With TripMode you can prevent apps from connecting to the internet when you are using a mobile hotspot. This prevents unexpected bills for high data usage on your mobile plan. VISIT WATCH Hocus FocusCollection: Window Managers Hocus Focus automatically hides application windows that have been inactive for a certain period of time. VISIT WATCH SoundSourceCollection: Audio Apps With SoundSource you can change the volume and output device for individual apps, right from your menu bar. VISIT WATCH Ping ManCollection: System Tools A Mac menu bar app to check your ping and monitor your bandwidth usage. VISIT WATCH BarsoomCollection: Menu Bar Managers Barsoom lets you hide any third-party icon in your menu bar. You can also rearrange your menu bar items in any order you want, similar to how Apple’s own icons work by default. Or hide items that you don’t want to see. With Barsoom arrange your items in groups. VISIT WATCH Barsoom 3.0 菜单栏管理 - 精品MAC应用分享 Videoder -免费和最快速的优酷视频下载SuperBar - 自定义 macOS 菜单栏，书签、命令行、代码片段… - 小众软件Background Music – 当开始播放视频时，自动暂停背景音乐，视频结束音乐起[macOS] - 小众软件HOME | SuperbarRaccoon - 从 Play 商店下载 Android 应用安装文件 .apk - 小众软件Tern - 字幕组机翻小助手：自动翻译英文字幕为中英双语字幕[Win/macOS] - 小众软件 menu bar 自定义textbar 等待破解TextBar：彻底玩转你的 Menubar – Mac玩儿法Today Scripts：打造个性化 Yosemite 通知栏插件 – Mac玩儿法[Mac] TextBar : 强大的菜单栏自定义内容显示工具 - Mac电报TextBar - Mac Apprichie5um/TextBar-Recipes: TextBar Recipes Bitbar监控疫情、看天气、查汇率…… Mac 菜单栏「万能」工具箱：BitBar - 少数派Releases · matryer/bitbarBitBar - Put anything in your Mac OS X menu bar","link":"/Mac/mac-apps.html"},{"title":"front end tricks 202002","text":"[toc] JavaScript 倒计时关闭页面-蚂蚁部落123456789101112131415&lt;script type=\"text/javascript\"&gt; var otimer;var second=10;function timer(){ otimer.innerHTML=second; if(second&gt;0){ second=second-1; return false; } window.close();} window.onload=function(){ otimer=document.getElementById(\"timer\"); setInterval(timer,1000);} 以上代码实现了我们想要的功能，可以倒计时10秒之后关闭页面。 原理非常的简单，利用定时器setInterval()方法，不断调用timer()函数，每调用一次秒数减一，直到秒数变为零就执行window.close()，将页面关闭。同时每次调用函数都会将当前的剩余秒数写入div中，于是实现了倒计时效果。 相关阅读： （1）.innerHTML属性参阅JavaScript innerHTML一章节。 （2）.setInterval()方法参阅JavaScript setInterval()一章节。 JavaScript 获取倒数第二个li元素-蚂蚁部落12345678&lt;script type=\"text/javascript\"&gt;window.onload=function(){ var obox=document.getElementById(\"box\"); var oshow=document.getElementById(\"show\"); var lis=obox.getElementsByTagName(\"li\"); oshow.innerHTML=lis[lis.length-2].innerHTML;}&lt;/script&gt; JavaScript 获取网页脚本代码内容-蚂蚁部落12345678910111213141516171819function evalscript(s){ if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)){ var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1){ appendscript(arr1[1], '', arr1[2], arr1[3]); } else{ p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); } } return s;} 给出了核心代码，直接套用即可。 JavaScript 替换字符串全部指定内容-蚂蚁部落将字符串中所有的字符”n”替换为字符”b” 12345String.prototype.replaceAll=function(str,repaceStr) { return this.replace(new RegExp(str,\"gmi\"),repaceStr) // \"gmi\" ? }var str=\"antzone\";console.log(str.replaceAll(\"n\",\"b\")); 正则表达式删除字符串两端空格-蚂蚁部落12345678String.prototype.trim=function(){ var reExtraSpace=/^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace,\"$1\");}var str=\" antzone \";console.log(str.length);var strNew=str.trim();console.log(strNew.length); CSS 紧邻下一个兄弟元素-蚂蚁部落123.antzone+li{ color:red;} 代码将class属性值为antzone的li元素的紧邻下一个兄弟li元素的字体颜色设置为红色。 +选择器可以参阅CSS的相邻选择符(E+F)一章节。 CSS 获取所有紧邻兄弟元素-蚂蚁部落123.ant ~ li{ color:red;} 将class属性值为”ant”元素后面的li元素字体颜色设置为红色，具体参阅CSS E~F 兄弟选择器一章节。","link":"/frontEnd/front-end-tricks-202002.html"},{"title":"jquery复习","text":"样式篇 第1章 初识jQuery1&lt;script type=\"text/javascript\" src=\"./static/lib/jquery.js\"&gt; 1234// $(document).ready() 的作用是等文档的节点都加载完毕后再执行后续的代码$(document).ready(function(){ $(\"div\").html(\"hello jquery\");}); 1-4 jQuery对象与DOM对象1234567// 标准js处理var p = document.getElementById('imooc');p.innerHTML = 'adsfas';p.style.color = 'red';// jquery处理var $p = $('#imooc');$p.html('adsfaf').css('color', 'red'); 1-5 jQuery对象转化成DOM对象12345678var $div = $('div')var div = $div[0] // jquery对象转dom对象// 或者 var div = $div.get(0)div.style.color = 'red'// 1-6 DOM对象转化成jQuery对象var $div = $(div); // $(dom)var $first = $div.first() 第2章 jQuery选择器jQuery 参考手册 - 选择器 2-1 id选择器1$(\"#id\") 2-2 类选择器1$(\".class\") 2-3 元素选择器12$(\"p\")document.getElementsByTagName('div') 2-4 全选择器（*选择器）1$(\"*\") 2-5 层级选择器12345678// 子元素选择器$(\"parent &gt; child\")// 后代元素选择器$(\"ancestor descendant\")// 相邻兄弟元素选择器$(\"prev + next\")// 一般兄弟元素选择器$(\"prev ~ siblings\") 2-7 基本筛选选择器1234567891011121314$(\".div:first\")$(\":first\") // 匹配第一个元素$(\":last\") // 匹配最后一个元素$(\":not(selector)\") //一个用来过滤的选择器,选择所有元素去除不匹配给定的选择器元素$(\":eq(index)\")// 在匹配的集合中选择索引值为 index的元素$(\":gt(index)\") // 选择匹配集合中所有大于给定 index(索引值)的元素$(\":even\") // 选择索引值为偶数的元素,从0开始计数$(\":odd\") // 选择索引值为奇数的元素,从O开始计数$(\":lt(index\")// 选择匹配集合中所有索引值小于给定 index参数的元素$(\":header\")// 选择所有标题元素,像h1h2,h3等$(\":lang(language)\")// 选择指定语言的所有元素$(\":root\") // 选择该文档的根元素$(\":animated\") // 选择所有正在执行动画效果的元素 2-8 内容筛选选择器1234567$(\":contains(text)\") //选择所有包含指定 文本 的元素$(\":parent\") // 选择所有含有子元素或者文本的元素(即非空)$(\":empty\") // 选择所有没有子元素的元素(包含文本节点)$(\":has(selector\")) // 选择元素中至少包含指定 选择器 的元素// 1) :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素// 2) 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。// 3):parent与:empty是相反的，两者所涉及的子元素，包括文本节点 2-9 可见性筛选选择器12$(\":visible\") // 选择所有现实的元素$(\":hidden\") // 选择所有隐藏的元素 2-10 属性筛选选择器12345678910$(\"[attribute]\") // 选择所有具有指定属性的元素$(\"[attribute='value']\") // 选择指定属性是给定值的元素$(\"[attribute^='value']\") // 选择指定属性是以给定字符串开始的元素$(\"[attribute$='value']\") //选择指定属性是以给定值结尾的元素,这个比较是区分大小写的$(\"[attribute!='value']\") // 选择不存在指定属性,或者指定的属性值不等于给定值的元素$(\"[attribute|=value]\") // 选择指定属性值等于给定字符串或以该文字串为前缀(该字符串后跟一个连字符\"-\")的元素$(\"[attribute*='value']\") // 选择指定属性具有包含一个给定的子字符串的元素(选择给定的属性是以包含某些值的元素)$(\"[attribute-='value']\") // 选择指定属性用空格分隔的值中包含一个给定值的元素$(\"[attributeFilter1][attributeFilterN]\") //选择匹配所有指定的属性筛选器的元素 2-11 子元素筛选选择器1234567// 选择所有父级元素的第一个子元素$(\":first-child\")$(\":last-child\")$(\":only-child\")$(\":nth-child(n)\")$(\":nth-last-child(n)\")// :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) 2-12 表单元素选择器12345678910$(\":input\") // 选择所有 input, textarea, select和 button元素$(\":text\") // 匹配所有文本框$(\":password\") // 匹配所有密码框$(\":radio\") // 匹配所有单选按钮$(\":checkbox\") // 匹配所有复选框$(\":submit\") // 匹配所有提交按钮$(\":image\")// 匹配所有图像域$(\":reset\") // 匹配所有重置按钮$(\":button\") // 匹配所有按钮$(\":file\") // 匹配所有文件域 2-13 表单对象属性筛选选择器1234$(\":enabled\") // 选取可用的表单元素$(\":disabled\") // 选取不可用的表单元素$(\":checked\") // 选取被选中的&lt;input&gt;元素$(\":selected\") // 选取被选中的&lt;option&gt;元素 第3章 jQuery的属性与样式12345678910111213141516171819202122232425262728293031323334// 3-1 .attr()与.remov...attr(key) 获取key属性值attr(key, value) 设置attr(attributes) // attrs: {key1: val1, key2:val2}.removeAttr(attributeName) // 3-2 html()及.text().html() 获取.html(htmlString) 设置.text().text(textString)// 3-3 .val()// 获取、设置表单元素的值.val().val(value)// 3-4 增加样式.addClass().addClass(className) // 为每个匹配元素增加一个或多个样式名// 3-5 删除样式.removeClass().removeClass([className]) // 每个匹配元素移除一个或多个用空格隔开的样式名// 3-6 切换样式.toggleCla....toggleClass(className) //如果存在（不存在）就删除（添加）一个类// 3-7 样式操作.css()// 获取.css(propertyName) // 获取匹配元素集合中的第一个元素的样式属性的计算值.css(propertyNames) // 传递一组数组，返回一个对象结果// 设置.css(propertyName, value ) // 设置CSS.css(properties) // 可以传一个对象，同时设置多个样式 DOM篇第2章 DOM节点的创建2-1 DOM创建节点及节点属性创建元素：document.createElement设置属性：setAttribute添加文本：innerHTML加入文档：appendChild 2-2 jQuery节点创建与属性的处理1$(\"&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;\") 第3章 DOM节点的插入3-1 DOM内部插入append()与appendTo()b加到a中: 12a.append(b) b.appendTo(a) 3-2 DOM外部插入after()与before()3-3 DOM内部插入prepend()与prependTo()3-4 DOM外部插入insertAfter()与insertBefore()第4章 DOM节点的删除4-1 DOM节点删除之empty()的基本用法1$('.hello').empty() 4-2 DOM节点删除之remove()的有参用法和无参用法12$('.hello').remove()$(\"p\").filter(\":contains('3')\").remove() 4-3 DOM节点删除之empty和remove区别 empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点 该节点与该节点所包含的所有后代节点将同时被删除; 提供传递一个筛选的表达式，删除指定合集中的元素 4-4 DOM节点删除之保留数据的删除操作detach()detach()不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 第5章 DOM节点的复制与替换5-1 DOM拷贝clone().clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。clone(ture) 不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了 5-2 DOM替换replaceWith()和replaceAll()二者方向相反 12$(\"p:eq(1)\").replaceWith('&lt;a style=\"color:red\"&gt;替换第二段的内容&lt;/a&gt;')$('&lt;a style=\"color:red\"&gt;替换第二段的内容&lt;/a&gt;').replaceAll('p:eq(1)') 5-3 DOM包裹wrap()方法.wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构 1$('p').wrap('&lt;div&gt;&lt;/div&gt;') 5-4 DOM包裹unwrap()方法去除1层父级元素 1$('p').unwrap(); 5-5 DOM包裹wrapAll()方法给所有p元素增加一个div包裹 1$('p').wrapAll('&lt;div&gt;&lt;/div&gt;') 5-6 DOM包裹wrapInner()方法将合集中的元素内部所有的子元素用其他元素包裹起来 1$('div').wrapInner('&lt;p&gt;&lt;/p&gt;') 替换前 12&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt; 替换后 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 第6章 jQuery遍历6-1 children()方法$(“div”).children(“.selected”) 6-2 find()方法.find()和.children()方法是相似的1.children只查找第一级的子节点2.find查找范围包括子节点的所有后代节点 6-3 parent()方法因为是父元素，这个方法只会向上查找一级;parent()无参数 6-4 parents()方法类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点 6-5 closest()方法从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素$(“div”).closet(“li’)注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素 6-6 next()方法next()无参数允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象 6-7 prev()方法6-8 siblings()siblings()无参数取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素 6-9 add()方法123$('li').add('p')$('li').add(document.getElementsByTagName('p')[0])$('li').add('&lt;p&gt;新的p元素&lt;/p&gt;').appendTo(目标位置) 6-10 each()12345$(\"li\").each(function(index, element) { index 索引 0,1 element是对应的li节点 li,li this 指向的是li}) 更多jQuery基础(五)一Ajax应用与常用插件-慕课网 jQuery基础修炼圣典—动画篇 12341. // $div是一个变量名？不加$?var $div = $('div')var div = $div[0] // jquery对象转dom对象","link":"/frontEnd/jquery%E5%A4%8D%E4%B9%A0.html"},{"title":"nodejs-helloworld","text":"七天学会NodeJS","link":"/frontEnd/nodejs-helloworld.html"},{"title":"js script","text":"js script 回文十进制数求用十进制、二进制、八进制表示都是回 文数的所有数字中， 大于十进制数 10 的最 小值。 1234567891011121314151617/* 为字符串类型添加返回逆序字符串的方法 */ String.prototype.reverse = function (){ return this.split(\"\").reverse().join(\"\"); }/* 从 11 开始搜索 */ var num = 11; while (true){if ( (num.toString() == num.toString().reverse()) &amp;&amp; (num.toString(8) == num.toString(8).reverse()) &amp;&amp; (num.toString(2) == num.toString(2).reverse())){ console.log(num); break; } /* 只搜索奇数，每次加 2 */ num += 2;}","link":"/frontEnd/js-script.html"},{"title":"vue.js2.5基础入门视频教程-慕课网","text":"1-1 课程介绍.mp4vue官方文档 2-1 创建第一个Vue实例.mp412345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;hello {{msg}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\" } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-2 挂载点，模版与实例.mp4挂载点、模板、实例之间的关系vue中的el确定挂载点。模板：挂载点里面的全部内容，可以直接写，也可以在Vue里面添加template 123456789101112131415&lt;!-- &lt;div id=\"root\"&gt;--&gt;&lt;!-- &lt;h1&gt;hello {{msg}}&lt;/h1&gt;--&gt;&lt;!-- &lt;/div&gt;--&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", template: '&lt;h1&gt;hello {{msg}}&lt;/h1&gt;', data: { msg: \"world\" } })&lt;/script&gt; 2-3 Vue实例中的数据,事件和方法.mp4插值表达式 a在 new Vue({data: {a: 123}}) 中定义 12345&lt;h1&gt;{{a}}&lt;/h1&gt;使用a-text也可实现同样的效果&lt;h1 a-text=\"a\"&gt;&lt;/h1&gt;或&lt;h1 a-html=\"content\"&gt;&lt;/h1&gt; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--添加点击事件--&gt; &lt;!--添加方法1--&gt; &lt;div id=\"root\" @click=\"handleClick\"&gt; &lt;!--添加方法2--&gt;&lt;!-- &lt;div id=\"root\" v-on:click=\"handleClick\"&gt;--&gt; {{msg}} &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\" }, methods:{ //定义方法 handleClick: function(){ this.msg=\"hello\"; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-4 Vue中的属性绑定和双向数据绑定.mp41234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div title=\"this is title1\"&gt;hello world&lt;/div&gt;&lt;!--属性绑定--&gt;&lt;!-- 方法1：--&gt;&lt;!-- &lt;div v-bind:title=\"title\"&gt;hello world&lt;/div&gt;--&gt;&lt;!-- 方法2（缩写，更常用）：--&gt; &lt;div :title=\"title\"&gt;hello world&lt;/div&gt;&lt;!-- 双向数据绑定--&gt;&lt;!-- 对比，单向：:value --&gt;&lt;!-- &lt;input :value=\"content\"&gt;--&gt;&lt;!-- 对比，双向 v-model --&gt; &lt;input v-model=\"content\"&gt; &lt;div&gt;{{content}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ //el确定挂载点 el: \"#root\", data: { msg: \"world\", title: \"this is title2\", content: \"content\" }, methods:{ } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-5 Vue中的计算属性和侦听器.mp41234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; 姓: &lt;input v-model=\"firstName\"&gt; 名: &lt;input v-model=\"lastName\"&gt; &lt;div&gt;{{firstName}} {{lastName}}&lt;/div&gt; &lt;div&gt;{{fullName}}&lt;/div&gt; &lt;div&gt;{{count}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { firstName: '', lastName: '', count: 0, }, // 计算属性 computed:{ fullName: function () { return this.firstName + ' ' + this.lastName } }, // 监听器 watch: { lastName: function () { this.count ++; }, firstName: function () { this.count ++; } }, methods:{ } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-6 v-if, v-show与v-for指令.mp4123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;!-- v-if 删除或添加元素--&gt; &lt;div v-if=\"show\"&gt;hello world&lt;/div&gt;&lt;!-- v-show 隐藏或显示元素--&gt; &lt;div v-show=\"show\"&gt;hello world&lt;/div&gt; &lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;!-- v-for --&gt; &lt;ul&gt; &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt; &lt;li v-for=\"(item, index) of list\" key=\"index\"&gt;{{index}} {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { show: true, list: [1, 1, 3, 4, 5], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{ toggle: function () { this.show = !this.show } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3-1 todolist功能开发.mp41234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div&gt; &lt;input v-model=\"thing\"&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: \"#root\", data: { thing: \"\", list: [], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{ submit: function () { if (this.thing.trim()===\"\") return; this.list.push(this.thing); // append 失败 // this.list.append(this.thing); this.thing = \"\"; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3-2 todolist组件拆分-1.5.mp412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div&gt; &lt;input v-model=\"thing\"&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 3. 属性传值 --&gt; &lt;todo-item v-for=\"(item, index) of list\" :key=\"index\" :content=\"item\"&gt;全局组件&lt;/todo-item&gt;&lt;!-- &lt;todo-item1&gt;局部组件&lt;/todo-item1&gt;--&gt;&lt;!-- &lt;li v-for=\"item of list\"&gt;{{item}}&lt;/li&gt;--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; &lt;!--全局组件--&gt; // 注册后即可直接在HTML中使用 Vue.component('todo-item', { // 1. 定义属性 props: ['content'], // 2. 使用属性 template: '&lt;li&gt;{{content}}&lt;/li&gt;' }); //局部组件 // 声明后，在Vue中添加components // var todoItem = { // template: '&lt;li&gt;item&lt;/li&gt;' // }; new Vue({ el: \"#root\", // components: { // 'todo-item1': todoItem, // }, data: { thing: \"\", list: [], }, // 计算属性 computed:{ }, // 监听器 watch: { }, methods:{ submit: function () { if (this.thing.trim()===\"\") return; this.list.push(this.thing); // append 失败 // this.list.append(this.thing); this.thing = \"\"; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3-3 组件与实例的关系.mp4组件也是实例, 也可以添加methods data等属性new Vue(){} 实例中的template属性没有定义时，为挂载点下的HTML 12345678910111213&lt;!--全局组件--&gt; // 注册后即可直接在HTML中使用 Vue.component('todo-item', { // 1. 定义属性 props: ['content'], // 2. 使用属性 template: '&lt;li @click=\"itemClicked\"&gt;{{content}}&lt;/li&gt;', methods: { itemClicked: function () { alert('clicked'); } } }); 3-4 实现todolist的删除功能.mp4组件之间通过属性传递值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue 入门&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt; &lt;div&gt; &lt;input v-model=\"thing\"&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt; &lt;/div&gt; &lt;ul&gt;&lt;!-- @delete 或 v-on:delete 监听子组件--&gt; &lt;todo-item v-for=\"(item, index) of list\" :key=\"index\" :content=\"item\" :index=\"index\" @delete=\"handleDelete\" &gt;全局组件&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; Vue.component('todo-item', { props: ['content', 'index'], template: '&lt;li @click=\"itemClicked\"&gt;{{content}}&lt;/li&gt;', methods: { itemClicked: function () { // 子组件被点击，通知父组件删除 this.$emit(\"delete\", this.index); } } }); new Vue({ el: \"#root\", // components: { // 'todo-item1': todoItem, // }, data: { thing: \"\", list: [], }, computed:{ }, watch: { }, methods:{ submit: function () { if (this.thing.trim()===\"\") return; this.list.push(this.thing); this.thing = \"\"; }, handleDelete: function (index) { // delete 失败 // delete this.list[index] // 从index开始删除1项 this.list.splice(index, 1); } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4-1 vue-cli的简介与使用-1.5.mp4https://cli.vuejs.org/zh/npm install -g @vue/clinpm install -g @vue/cli-init 12345678910111213➜ WebstormProjects vue init webpack todolist? Project name todolist? Project description A Vue.js project? Author? Vue build standalone? Install vue-router? No? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) npm To get started: cd todolist npm run dev components: {App} // {‘App’: App} 键值相等可简写单文件组件app.vuetemplate script style 3个标签template 下只可有一个元素 网页自动刷新 4-2 使用vue-cli开发TodoList.mp4npm run dev 执行的命令定义在package.json scripts中 12 4-3 全局样式与局部样式.mp41234scoped : 局部的样式&lt;style scoped&gt;&lt;/style&gt; 4-4 课程总结-1.5.mp412","link":"/frontEnd/vue-js2-5%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-%E6%85%95%E8%AF%BE%E7%BD%91.html"},{"title":"vue","text":"引入json文件import data from ‘static/h5Static.json’此时，data已经被解析为字典 Vue对list的增删改查删除123456789delete(id) { for (const v of this.list) { if (v.id === id) { const index = this.list.indexOf(v) this.list.splice(index, 1, this.temp) break } }} 新增1this.list.push(car)","link":"/frontEnd/vue.html"},{"title":"go入门及资源网址","text":"Go 指南The Go programming language is an open source project to make programmers more productive. 目录 基础学习 进阶学习 社区论坛 基础学习 官方文档 Go wiki How to Write Go Code Package Documentation: The documentation for the Go standard library. Package builtin Command Documentation: The documentation for the Go tools. Language Specification: The official Go Language specification. Go 文档 Go 指南 在线练习 Go 语言教程 - 菜鸟教程 Go by Example 在线运行 The Go Play Space 进阶学习 GoDoc: Search for Go Packages. Awesome Go: A curated list of awesome Go frameworks, libraries and software. Go 语言学习资料与社区索引 Go入门指南 Golang标准库 Go for PHPer web 开发 Go 语言包管理 XORM: 简单而强大的 Go 语言ORM框架 Go开源项目速查表 社区论坛 Golang 中国: 国内较早的 Go 社区，汇聚各类信息与服务 Study Golang: 国内 Go 社区先驱，同样汇聚各类信息与服务 Revel 交流论坛: Revel 框架的中文社区 Go Forum: Go 语言爱好者英文交流论坛 golang-nuts 邮件列表: Go 语言官方指定邮件列表讨论区 Go+ 社区: Go 语言官方指定 G+ 社区","link":"/go/go%E5%85%A5%E9%97%A8%E5%8F%8A%E8%B5%84%E6%BA%90%E7%BD%91%E5%9D%80.html"},{"title":"golang projects","text":"[toc] 一. 开发工具1)sql2go用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。http://stming.cn/tool/sql2go.html 2)toml2go用于将编码后的 toml 文本转换问 golang 的 struct.https://xuri.me/toml-to-go/ 3)curl2go用来将 curl 命令转化为具体的 golang 代码.https://mholt.github.io/curl-to-go/ 4)json2go用于将 json 文本转换为 struct.https://mholt.github.io/json-to-go/ 5)mysql 转 ES 工具http://www.ischoolbar.com/EsParser/ 6)golang模拟模板的工具，在支持泛型之前，可以考虑使用。https://github.com/cheekybits/genny 7)查看某一个库的依赖情况，类似于 go list 功能https://github.com/KyleBanks/depth 8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。https://github.com/mholt/archiver 9)go 内置命令go list 可以查看某一个包的依赖关系.go vet 可以检查代码不符合 golang 规范的地方。 10)热编译工具https://github.com/silenceper/gowatch 11)revivegolang 代码质量检测工具https://github.com/mgechev/revive 12)Go Callvisgolang 的代码调用链图工具https://github.com/TrueFurby/go-callvis 13)Realize开发流程改进工具https://github.com/oxequa/realize 14)Gotests自动生成测试用例工具https://github.com/cweill/gotests 二.调试工具1)perf代理工具，支持内存，cpu，堆栈查看，并支持火焰图.perf 工具和 go-torch 工具，快捷定位程序问题.https://github.com/uber-archive/go-torchhttps://github.com/google/gops 2)dlv 远程调试基于 goland+dlv 可以实现远程调式的能力.https://github.com/go-delve/delve提供了对 golang 原生的支持，相比 gdb 调试，简单太多。 3)网络代理工具goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.https://github.com/snail007/goproxy 4)抓包工具go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.基于这个工具，我们开发了 qapp 协议的抓包。https://github.com/40t/go-sniffer 5)反向代理工具，快捷开放内网端口供外部使用。ngrok 可以让内网服务外部调用https://ngrok.com/https://github.com/inconshreveable/ngrok 6)配置化生成证书从根证书，到业务侧证书一键生成.https://github.com/cloudflare/cfssl 7)免费的证书获取工具基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。https://github.com/Neilpang/acme.sh 8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。vagrant常被拿来同 docker 相比，值得拥有。https://github.com/hashicorp/vagrant 9)轻量级容器调度工具nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.https://github.com/hashicorp/nomad 10)敏感信息和密钥管理工具https://github.com/hashicorp/vault 11)高度可配置化的 http 转发工具，基于 etcd 配置。https://github.com/gojek/weaver 12)进程监控工具 supervisorhttps://www.jianshu.com/p/39b476e808d8 13)基于procFile进程管理工具. 相比 supervisor 更加简单。https://github.com/ddollar/foreman 14)基于 http，https，websocket 的调试代理工具，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.https://github.com/avwo/whistle 15)分布式调度工具https://github.com/shunfei/cronsun/blob/master/README_ZH.mdhttps://github.com/ouqiang/gocron 16)自动化运维平台 Gaiahttps://github.com/gaia-pipeline/gaia 三. 网络工具 四. 常用网站go 百科全书: https://awesome-go.com/json 解析: https://www.json.cn/出口 IP: https://ipinfo.io/redis 命令: http://doc.redisfans.com/ES 命令首页: https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.htmlUrlEncode: http://tool.chinaz.com/Tools/urlencode.aspxBase64: https://tool.oschina.net/encrypt?type=3Guid: https://www.guidgen.com/常用工具: http://www.ofmonkey.com/ 五. golang 常用库日志https://github.com/Sirupsen/logrushttps://github.com/uber-go/zap 配置兼容 json，toml，yaml，hcl 等格式的日志库.https://github.com/spf13/viper 存储mysql https://github.com/go-xorm/xormes https://github.com/elastic/elasticsearchredis https://github.com/gomodule/redigomongo https://github.com/mongodb/mongo-go-driverkafka https://github.com/Shopify/sarama 数据结构https://github.com/emirpasic/gods 命令行https://github.com/spf13/cobra 框架https://github.com/grpc/grpc-gohttps://github.com/gin-gonic/gin 并发https://github.com/Jeffail/tunnyhttps://github.com/benmanns/goworker现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.https://github.com/rafaeldias/async 工具定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.https://github.com/asaskevich/govalidatorhttps://github.com/bytedance/go-tagexpr protobuf 文件动态解析的接口，可以实现反射相关的能力。https://github.com/jhump/protoreflect 表达式引擎工具https://github.com/Knetic/govaluatehttps://github.com/google/cel-go 字符串处理https://github.com/huandu/xstrings ratelimit 工具https://github.com/uber-go/ratelimithttps://blog.csdn.net/chenchongg/article/details/85342086https://github.com/juju/ratelimit golang 熔断的库熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.https://github.com/afex/hystrix-gohttps://github.com/sony/gobreaker 表格https://github.com/chenjiandongx/go-echarts tail 工具库https://github.com/hpcloud/taglshi","link":"/go/golang-projects.html"},{"title":"go学习笔记1","text":"从Java到Golang快速入门flysnow.org/2016/12/28/from-java-to-golang.html Hello World12345package mainimport \"fmt\"func main() { fmt.Println(\"Hello, 世界\")} 整段代码非常简洁，关键字、函数、包等和Java非常相似，不过注意，go是不需要以;(分号)结尾的。 变量1var age int =10 最后面的赋值可以在声明的时候忽略，这样变量就有一个默认的值，称之为零值。零值是一个统称，以类型而定，比如int类型的零值为0，string类型的零值是”“空字符串。 1age := 10 使用这种方式，变量的类型由go根据值推导出来，比如这里默认是int。 常量1const age = 10 大小写标记访问权限在go中不能随便使用大小写的问题，是因为大小写具有特殊意义，在go中，大些字母开头的变量或者函数等是public的，可以被其他包访问；小些的则是private的，不能被其他包访问到。这样就省去了public和private声明的烦恼，使代码变的更简洁。 包包的规则和java很像，每个包都有自己独立的空间，所以可以用来做模块化，封装，组织代码等。 和java不同的是，go的包里可以有函数，比如我们常用的fmt.Println(),但是在在java中没有这种用法，java的方法必须是属于一个类或者类的实例的。 如果我们需要导入多个包的时候，可以像java一样，一行行导入，也可以使用快捷方式一次导入，这个是java所没有的。 123456import ( \"io\" \"log\" \"net\" \"strconv\") 类型转换go对于变量的类型有严格的限制，不同类型之间的变量不能进行赋值、表达式等操作，必须要要转换成同一类型才可以，比如int32和int64两种int类型的变量不能直接相加，要转换成一样才可以。 123var a int32 = 13var b int64 = 20c := int64(a) + b 这种限制主要是防止我们误操作，导致一些莫名其妙的问题。在java中因为有自动转型的概念，所以可以不同类型的可以进行操作，比如int可以和double相加，int类型可以通过+和字符串拼接起来，这些在go中都是不可行的。 mapmap类型，Java里是Map接口，go里叫做字典，因为其常用，在go中，被优化为一个语言上支持的结构，原生支持，就像一个关键字一样，而不是java里的要使用内置的sdk集合库，比如HashMap等。 12345678910ages := make(map[string]int)ages[\"linday\"] = 20ages[\"michael\"] = 30fmt.Print(ages[\"michael\"])delete(ages,\"michael\")for name,age := range ages { fmt.Println(\"name:\",name,\",age:\",age)} 函数方法在go中，函数和方法是不一样的，我们一般称包级别的(直接可以通过包调用的)称之为函数，比如fmt.Println()；把和一个类型关联起来的函数称之为方法，如下示例： 12345678910111213141516package libimport \"time\"type Person struct { age int name string}func (p Person) GetName() string { return p.name}func GetTime() time.Time{ return time.Now()} 其中GetTime()可以通过lib.GetTime()直接调用，称之为函数；而GetName()则属于Person这个结构体的函数，只能声明了Person类型的实例后才可以调用，称之为方法。 123func GetTime() (time.Time,error){ return time.Now(),nil} 多值返回也很简单，返回的值使用逗号隔开即可。如果要接受多值的返回，也需要以逗号分隔的变量，有几个返回值，就需要几个变量，比如这里： 123now,err:=GetTime()now,_:=GetTime() 指针Go的指针和C中的声明定义是一样的，其作用类似于Java引用变量效果。 1234var age int = 10var p *int = &amp;age*p = 11fmt.Println(age) 结构体1234type Person struct { age int name string} Go中的结构体是不能定义方法的，只能是变量，这点和Java不一样的,如果要访问结构体内的成员变量，通过.操作符即可。 123func (p Person) GetName() string { return p.name} 这就是通过.操作符访问变量的方式，同时它也是一个为结构体定义方法的例子，和函数不一样的是，在func关键字后要执行该方法的接收者，这个方法就是属于这个接收者，例子中是Person这个结构体。 在Go中如果想像Java一样，让一个结构体继承另外一个结构体怎么办？也有办法，不过在Go中称之为组合或者嵌入。 123456789type Person struct { age int name string Address}type Address struct { city string} 结构体Address被嵌入了Person中，这样Person就拥有了Address的变量和方法，就想自己的一样，这就是组合的威力。通过这种方式，我们可以把简单的对象组合成复杂的对象，并且他们之间没有强约束关系，Go倡导的是组合，而不是继承、多态。 接口Go的接口和Java类型，不过它不需要强制实现，在Go中，如果你这个类型（基本类型，结构体等都可以）拥有了接口的所有方法，那么就默认为这个类型实现了这个接口，是隐式的，不需要和java一样，强制使用implement强制实现。 1234567type Stringer interface { String() string}func (p Person) String() string { return \"name is \"+p.name+\",age is \"+strconv.Itoa(p.age)} 以上实例中可以看到，Person这个结构体拥有了fmt.Stringer接口的方法，那么就说明Person实现了fmt.Stringer接口。 接口也可以像结构体一样组合嵌套，这里不再赘述。 并发Go并发主要靠go goroutine支持，也称之为go协程或者go程，他是语言层面支持的，非常轻量级的多任务支持，也可以把他简单的理解为java语言的线程，不过是不一样的。 两个goroutine可以通过channel来通信，channel是一个特殊的类型，也是go语言级别上的支持，他类似于一个管道，可以存储信息，也可以从中读取信息。 12345678910111213141516package mainimport \"fmt\"func main() { result:=make(chan int) go func() { sum:=0 for i:=0;i&lt;10;i++{ sum=sum+i } result&lt;-sum }() fmt.Print(&lt;-result)} 以上示例使用一个单独的goroutine求和，当得到结果时，存放在result这个chan里，然后供main goroutine读取出来。当result没有被存储值的时候，读取result是阻塞的，所以会等到结果返回，协同工作，通过chan通信。 对于并发，go还提供了一套同步机制，都在sync包里，有锁，有一些常用的工具函数等，和java的concurrent框架差不多。 异常机制相比java的Exception来说，go有两种机制，不过最常用的还是error错误类型，panic只用于严重的错误。 123type error interface { Error() string} go内置的error类型非常简洁，只用实现Error方法即可，可以打印一些详细的错误信息，比如常见的函数多值返回，最后一个返回值经常是error，用于传递一些错误问题，这种方式要比java throw Exception的方法更优雅。 Defer代替finallygo中没有java的finally了，那么如果我们要关闭一些一些连接，文件流等怎么办呢，为此go为我们提供了defer关键字，这样就可以保证永远被执行到，也就不怕关闭不了连接了。 123f,err:=os.Open(filename)defer f.Close()readAll(f) 统一编码风格在编码中，我们有时为了是否空行，大括号是否独占一行等编码风格问题争论不休，到了Go这里就终止了，因为go是强制的，比如花括号不能独占一行，比如定义的变量必须使用，否则就不能编译通过。 第二种就是go fmt这个工具提供的非强制性规范，虽然不是强制的，不过也建议使用，这样整个团队的代码看着就像一个人写的。很多go代码编辑器都提供保存时自动gofmt格式的话，所以效率也非常高。 便捷的部署go最终生成的是一个可执行文件，不管你的程序依赖多少库，都会被打包进行，生成一个可执行文件，所以相比java庞大的jar库来说，他的部署非常方便，执行运行这个可执行文件就好了。","link":"/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html"},{"title":"go学习笔记2","text":"笨鸟学Go——最简单的Go教程https://www.slowbirdgogogo.com/syntax 阅读笔记https://note.youdao.com/ynoteshare1/index.html?id=f58aa20a530e9e08a71250d411ff6831&amp;type=note 接口接口的理解：struct实现interface的所有方法后，方法返回struct可以将类型写成实现的那个interface名。如：error是个接口，有Error方法 123type error interface { Error() string} 12345678910111213141516171819type MyError struct { When time.Time What string}func (e *MyError) Error() string { return fmt.Sprintf(\"at %v, %s\", e.When, e.What)}func run() error { return &amp;MyError{ time.Now(), \"it didn't work\", }}func main() { if err := run(); err != nil { fmt.Println(err) }}","link":"/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.html"},{"title":"go换源加速下载","text":"阿里云Go Module代理服务http://mirrors.aliyun.com/goproxy/ GOPROXY.IO - 一个为 Go 模块而生的全球代理https://goproxy.io/zh/ Go切换国内镜像源-教程-华夏梦客https://www.4gml.com/thread-144.htm","link":"/go/go%E6%8D%A2%E6%BA%90%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD.html"},{"title":"Java tricks","text":"[toc] 02-17AssertJ一分钟入门 - 简书 02-14PatMartin/Dex: Dex : The Data Explorer – A data visualization tool written in Java/Groovy/JavaFX capable of powerful ETL and publishing web visualizations. 02-09写 Excel wordJava POI Excel - Java代码实例™Java POI Word - Java代码实例™ 写pdfJava iText示例 - Java代码实例™ 读 PDF XML HTMLApache Tika示例 - Java代码实例™ 目录 文件处理Java目录 - Java代码实例™ 了解如何在Java编程中访问和操作目录。下面是有关Java编程中访问和操作目录最常用的例子 - 示例 如何递归创建目录？ 如何删除目录？ 如何确定一个目录是否为空？ 如何确定目录是否隐藏？ 如何打印目录层次结构？ 如何打印目录的最后修改时间？ 如何获取文件的父目录？ 如何搜索目录中的所有文件？ 如何获取目录的大小？ 如何遍历目录？ 如何查找当前工作目录？ 如何在系统中显示根目录？ 如何在目录中搜索文件？ 如何显示目录中的所有文件？ 如何显示目录中的所有目录？ Java文件 - Java代码实例™ 了解如何使用Java编程中的文件操作。下面是常用的一些例子 - 示例 如何比较两个文件的路径？ 如何创建新文件？ 如何获取文件的最后修改日期？ 如何在指定的目录中创建文件？ 如何检查文件是否存在？ 如何设置文件为只读？ 如何重命名文件？ 如何获取文件大小(以字节为单位)？ 如何更改文件的最后修改时间？ 如何创建一个临时文件？ 如何向现有文件中附加一个字符串？ 如何将一个文件复制到另一个文件？ 如何删除文件？ 如何读取一个文件？ 如何写入一个文件？ 2020年1月20日(星期一)JMeter 官网地址 ：https://jmeter.apache.org Apache JMeter是Apache组织开发的基于Java的压力测试工具 是的就是用来压测的，你怎么模拟很多请求呀，就用它就对了。 2020 年 1 月 15 日可以提高千倍效率的Java代码小技巧 - 51CTO.COM程序员必须搞懂的20个Java类库和API - 51CTO.COM一、日志相关类库Log4j 、 SLF4j 和 LogBack应该熟悉日志记录的利弊， 并且了解为什么 SLF4J 要比 Log4J 要好 二、JSON 解析库Jackson 和 Gson 三、单元测试库常见的单测框架有 JUnit , Mockito 和 PowerMock 。 四、通用类库例如 Apache Commons 和 Google Guava。 五、Http 库Apache HttpClient 和 HttpCore 等开源类库 六、XML 解析库市面上有很多 XML 解析的类库，如 Xerces , JAXB , JAXP , Dom4j , Xstream 等。Xerces2是下一代高性能，完全兼容的 XML 解析工具。Xerces2 定义了 Xerces Native Interface (XNI)规范，并提供了一个完整、兼容标准的 XNI 规范实现。该解析器是完全重新设计和实现的，更简单以及模块化。 七、Excel 读写库Apache POI API 八、字节码库javassist 、Cglib Nodep 、 ASM 。Javassist 使得 Java 字节码操作非常简单。它是一个为编辑 Java 字节码而生的类库。 九、数据库连接池库Commons Pool 和 DBCP 十、消息传递库Java 提供了 JMS Java 消息服务，但这不是 JDK 的一部分，你需要单独的引入 jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。 十一、PDF 处理库iText 和 Apache FOP 类库 十二、日期和时间库Java 8 自带 十三、集合类库虽然 JDK 有丰富的集合类，但还是有很多第三方类库可以提供更多更好的功能。如 Apache Commons Collections 、 Goldman Sachs collections 、 Google Collections 和 Trove 。Trove 尤其有用，因为它提供所有标准 Collections 类的更快的版本以及能够直接在原语(primitive)(例如包含 int 键或值的 Map 等)上操作的 Collections 类的功能。FastUtil是另一个类似的 API，它继承了 Java Collection Framework，提供了数种特定类型的容器，包括映射 map、集合 set、列表 list、优先级队列(prority queue)，实现了 java.util 包的标准接口(还提供了标准类所没有的双向迭代器)，还提供了很大的(64 位)的 array、set、list，以及快速、实用的二进制或文本文件的 I/O 操作类。 十四、邮件 APIjavax.mail 和 Apache Commons Email 提供了发送邮件的 API。它们建立在 JavaMail API 的基础上，提供简化的用法。 十五、HTML 解析库jsoup 可以解析 HTML，创建 HTML 文档 十六、加密库Apache Commons 家族中的 Commons Codec 就提供了一些公共的编解码实现，比如 Base64, Hex, MD5,Phonetic and URLs 等等。 十七、嵌入式 SQL 数据库库H2 是一种内存数据库，可以嵌入到 Java 应用中。在跑单测的时候如果需要一个数据库，用来验证 SQL 的话，H2 是个很好的选择。还有 Apache Derby 和 HSQL 可供选择。 十八、JDBC 故障诊断库有不错的 JDBC 扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。 P6Spy 分发包包括 P6Log，它是一个可记录任何 Java 应用程序的所有 JDBC 事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。 十九、序列化库Google Protocol Buffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。 二十、网络库一些有用的网络库主要有 Netty 的和 Apache Mina 。如果您正在编写一个应用程序，你需要做的底层网络任务，可以考虑使用这些库。 Java 性能瓶颈分析工具1. Java Mission ControlguiOracle Java 官方项目 2. Tprofilercli命令行TProfiler 是淘宝开源的一个可以在生产环境长期使用的性能分析工具。 3. JprofilerguiJProfiler 是由 ej-technologies 公司开发的一款性能瓶颈分析工具。 4. ArthasArthas 是阿里最近刚刚开源的 Java 生成环境诊断工具。Arthas 支持在 Linux/Unix/Mac 等平台上进行一键安装，现在处于试用于反馈阶段，感兴趣的同学可以自己研究试用。","link":"/java/Java-tricks.html"},{"title":"《go语言核心编程》阅读笔记1","text":"第一章 基础知识 函数以func开头，{必须在函数头所在行尾部 字符串用双引号 -&gt;go build hello.go -&gt;./hello 标识符 包括fallthrough go也有+= -= … ++ – 字符串 字符串是常量 12var a = \"hello\"b:= a[0] 字符串转换成切片[]byte(s)要慎用，每转换一次都复制一次内容 1b := []byte(s) 字符串的切片 与原字符串指向同一底层数组，一样不能修改，字符串的切片操作返回的仍是string，而非slice 字符串可以转换为字节数组，也可以转换为字数组 12b := []byte(s)c := []rune(s) 字符串的运算 12c := a+blen(c) 指针 数组 go不支持指针的运算 数组的初始化 1234a := [3]int{1,2,3}a := [...]int{1,2,3}a := [3]int{1:1, 2:3} // 没有初始化的位置为零值a := [...]int{1:1, 2:3} // 数组长度由提供的最大索引决定 数组创建完长度就固定了，不可再追加元素 切片 切片的创建 123456789// 1. 通过数组创建array := [...]int{1,2,3,4,5,6,7,8,9}slice := array[1:3] // 同Python，Java 左闭右开// 2. 通过make创建a := make(int[], 10) // len==cap==10b := make(int[], 10, 20) // len=10, cap=20// 直接声明切片的类型变量是没有意义的var a []intfmt.Printf(\"%v\\n\", a) // [] 切片支持的操作：len() cap() append() copy() 1234// 将c添加到b中 （返回新的slice，不改变b）b = append(b, c...)// 将d拷贝到c中 (不改变c)copy(c, d) // copy 只会复制c d中较短的 map map的创建 123456// 1. 使用自变量创建ma := map[string]int{\"a\":1, \"b\":2}// 2. 使用make创建mb := make(map[string]int)// 删除delete(ma, \"b\") go内置的map不是线程安全的，标准包sync中的map是 修改map中元素的值，最好整体替换 123456//如, 不要使用：ma[1].age = 19// 改为a := ma[1]a.age = 19ma[1] = a struct初始化 123456789// 1. 按照类型声明顺序，逐个赋值// 不推荐, 一旦struct增加字段，整个初始化语句会报错a := Person{\"Tom\", 21}// 推荐的初始化方式// 2. 使用field名字初始化，没有指定字段的为零值p := &amp;Person{ Name: \"tata\", Age: 21,} ifgo没有a?b:c 12345if [;] {}else if {}else{} switchfallthough强制执行下一个case子句（不判断下一个case条件）当所有case不符合时执行default， 且default语句可以放到任意位置。 标签和跳转1234567891011L1:for i:=0; ; i++{ for :j=0; ; j++{ if i&gt;=5{ break L1 } if j&gt;10{ break } }} 1234567891011L1:for i:=0; ; i++{ for j:=; ; j++{ if i&gt;=5{ continue L1 } if j&gt;10{ continue } }} 第二章 函数不定参数不定参数必须是函数的最后一个参数不定参数名在函数体内相当于切片切片可以作为参数传给不定参数， func(slice…) 12345678910111213func sum(a, arr ...int) (sum int){ sum = a for _, v := range arr{ sum += v } return }func main(){ slice := []int{1,2,3,4} array := [...]int{1,2,3,4} // 数组不可作为参数给不定参数 sum(0, slice...)} 函数签名fmt.Printf 的%T 格式化参数打印函数类型2个函数相同的条件是，拥有相同的形参列表和返回值列表，形参名可以不同 1fmt.Printf(\"%T\\n\", add) // func(int, int) int 12345678910111213141516171819package mainimport \"fmt\"func add(a, b int) int { return a + b}func sub(a, b int) int { return a - b}type Op func(int, int)int //定义一个函数类型,输入的是两个int类型 //返回值是一个int类型func do (f Op, a, b int) int { //定义一个函数,第一个参数是函数类型Op return f(a,b)//函数类型变量可以直接用来进行函数调用}func main() { a := d(ad,1,2)//函数名a可以当作相同函数类型形参,不需要强制类型转换 fmt.Println(a)//3 s := do(sub, 1, 2) fmt.Println(s)//-1} 1f := sum //函数可以直接赋值给变量 匿名函数作为返回值 1234567891011121314func wrap(op string) fun(int, int) int{ switch op{ case \"add\": return func(a, b int) int{ return a+b } case \"sub\": return func(a, b int) int{ return a-b } default: return nil }} deferdefer注册多个延迟调用，先进先出主动调用os.Exit(int) 退出进程时，defer将不再执行（即使defer已经提前注册）一般defer语句放错误检查语句之后，不然有可能产生panic，如： 12345dst, err := os.Create(dst)if err != nil { return}defer dst.close() 闭包闭包最初的目的是减少全局变量,在函数调用的过程中隐式地传递共享变量,有其有用的面;但是这种隐秘的共享变量的方式带来的坏处是不够直接,不够清晰,除非是非常有价值的地方,一般不建议使用闭包。对象是附有行为的数据,而闭包是附有数据的行为,类在定义时已经显式地集中定义了行为,但是闭包中的数据没有显式地集中声明的地方,这种数据和行为耦合的模型不是一种推着的编程模型,闭包仅仅是锦上添花的东西,不是不可缺少的。 panic recoverpanic主动抛出错误，recover捕获panic抛出的错误recover只有在defer后面的函数体内被直接调用才能捕获panic异常（？） 第四章 接口接口类型查询语法： 12345678switch v:= i.(type) { case type1: xxxxx case type2: xxxxx default: xxxxx}","link":"/go/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01.html"},{"title":"你真的会写java吗 阅读笔记","text":"[toc] beandomain 包名一个数据库表 应该对应一个 普通的 entity 对象，因此包名应为 com.xxx.entity DTO只要是用于网络传输的对象，都应该被当做 DTO 对象，若约定某对象是 DTO 对象，就把名称改为 XXDTO, 比如订单下发 OMS: OMSOrderInputDTO. DTO转化DTO 是系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转换成 BO 对象（？）或者普通 entity 对象，让 service 层处理。 场景12345678910111213141516@RequestMapping(\"/v1/api/user\")@RestControllerpublic class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); }} 使用工具网上有很多工具，支持浅拷贝或深拷贝的Utils. 举个例子，我们可以使用org.springframework.beans.BeanUtils#copyProperties对代码进行重构和优化 BeanUtils.copyProperties是一个浅拷贝方法，复制属性时，我们只需要把DTO对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做DTO转化的时候一直使用set进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! 1234567@PostMappingpublic User addUser(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user);} 转化的语义123456789101112@PostMapping public User addUser(UserInputDTO userInputDTO){ User user = convertFor(userInputDTO); return userService.addUser(user); } private User convertFor(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中 抽象接口定义当实际工作中，完成了几个api的DTO转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。如果接口被定义以后，那么convertFor这个方法的语义将产生变化，他将是一个实现类。 看一下抽象后的接口: 123public interface DTOConvert&lt;S,T&gt; { T convert(S s);} 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的java程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现: 12345678public class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; }} 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范: 1234567891011121314RequestMapping(\"/v1/api/user\")@RestControllerpublic class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); }} review code12345678910111213141516171819202122public class UserInputDTO { private String username; private int age; // getters and setters public User convertToUser(){ UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; } private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } }} 1234567// 然后api中的转化则由:// User user = new UserInputDTOConvert().convert(userInputDTO);// User saveUserResult = userService.addUser(user);// 变成了:User user = userInputDTO.convertToUser();User saveUserResult = userService.addUser(user); DTO对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 利用工具类优化GUAVA的源码，发现了com.google.common.base.Convert这样的定义: 12345public abstract class Converter&lt;A, B&gt; implements Function&lt;A, B&gt; { protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略} 从源码可以了解到，GUAVA中的Convert可以完成正向转化和逆向转化，继续修改我们DTO中转化的这段代码: 12345678private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; }} 修改后: 123456789101112131415private static class UserInputDTOConvert extends Converter&lt;UserInputDTO, User&gt; { @Override protected User doForward(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } @Override protected UserInputDTO doBackward(User user) { UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; } } 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的UserInputDTO和UserOutputDTO都转成UserDTO展示给大家: DTO： 1234567891011121314151617181920212223242526272829303132333435public class UserDTO { private String username; private int age; // getters and setters public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; } }} api: 1234567@PostMapping public UserDTO addUser(UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的DTO对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的: 12345678910111213private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } 看一下doBackward方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 关于异常处理的更详细介绍，可以参考我之前的文章:如何优雅的设计java异常 ，应该可以帮你更好的理解异常。 bean的验证应该保证任何数据的入参到方法体内都是合法的 4.5. 拥抱lombok4.5.1. 去掉Setter和Getter123@Setter@Getter// @Data,@AllArgsConstructor,@NoArgsConstructor 。。。 4.5.2. bean中的链式风格什么是链式风格？我来举个例子，看下面这个Student的bean: 123456789101112131415161718192021public class Student { private String name; private int age; public String getName() { return name; } public Student setName(String name) { this.name = name; return this; } public int getAge() { return age; } public Student setAge(int age) { return this; }} 仔细看一下set方法，这样的设置便是chain的style，调用的时候，可以这样使用: 123Student student = new Student() .setAge(24) .setName(\"zs\"); 相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用lombok进行改善呢，请使用 @Accessors(chain = true),看如下代码: 1234567@Accessors(chain = true)@Setter@Getterpublic class Student { private String name; private int age;} 这样就完成了一个对于bean来讲很友好的链式操作。 4.5.3. 静态构造方法静态构造方法的语义和简化程度真的高于直接去new一个对象。比如new一个List对象，过去的使用是这样的: 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 看一下guava中的创建方式: 1List&lt;String&gt; list = Lists.newArrayList(); Lists命名是一种约定(俗话说：约定优于配置)，它是指Lists是List这个类的一个工具类，那么使用List的工具类去产生List，这样的语义是不是要比直接new一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做Maps，那你是否想到了创建Map的方法呢： 1HashMap&lt;String, String&gt; objectObjectHashMap = Maps.newHashMap(); 好了，如果你理解了我说的语义，那么，你已经向成为java程序员更近了一步了。 再回过头来看刚刚的Student，很多时候，我们去写Student这个bean的时候，他会有一些必输字段，比如Student中的name字段，一般处理的方式是将name字段包装成一个构造方法，只有传入name这样的构造方法，才能创建一个Student对象。 接上上边的静态构造方法和必传参数的构造方法，使用lombok将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = \"ofName\")public class Student { @NonNull private String name; private int age;} 测试代码: 1Student student = Student.ofName(\"zs\"); 这样构建出的bean语义是否要比直接new一个含参的构造方法(包含 name的构造方法)要好很多。 当然，看过很多源码以后，我想相信将静态构造方法ofName换成of会先的更加简洁: 12345678@Accessors(chain = true)@Setter@Getter@RequiredArgsConstructor(staticName = \"of\")public class Student { @NonNull private String name; private int age;} 测试代码: 1Student student = Student.of(\"zs\"); 当然他仍然是支持链式调用的: 1Student student = Student.of(\"zs\").setAge(24); 这样来写代码，真的很简洁，并且可读性很强。 4.5.4. 使用builder （？）Builder模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。 今天其实要说的是一种变种的builder模式，那就是构建bean的builder模式，其实主要的思想是带着大家一起看一下lombok给我们带来了什么。 看一下Student这个类的原始builder状态: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public static Builder builder(){ return new Builder(); } public static class Builder{ private String name; private int age; public Builder name(String name){ this.name = name; return this; } public Builder age(int age){ this.age = age; return this; } public Student build(){ Student student = new Student(); student.setAge(age); student.setName(name); return student; } }} 调用方式: 1Student student = Student.builder().name(\"zs\").age(24).build(); 这样的builder代码，让我是在恶心难受，于是我打算用lombok重构这段代码: 12345@Builderpublic class Student { private String name; private int age;} 调用方式: 1Student student = Student.builder().name(\"zs\").age(24).build(); 4.5.5. 代理模式 （？）正如我们所知的，在程序中调用rest接口是一个常见的行为动作，如果你和我一样使用过spring 的RestTemplate,我相信你会我和一样，对他抛出的非http状态码异常深恶痛绝。 所以我们考虑将RestTemplate最为底层包装器进行包装器模式的设计: 123456789public abstract class FilterRestTemplate implements RestOperations { protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate){ this.restTemplate = restTemplate; } //实现RestOperations所有的接口} 然后再由扩展类对FilterRestTemplate进行包装扩展: 123456789101112131415161718192021222324public class ExtractRestTemplate extends FilterRestTemplate { private RestTemplate restTemplate; public ExtractRestTemplate(RestTemplate restTemplate) { super(restTemplate); this.restTemplate = restTemplate; } public &lt;T&gt; RestResponseDTO&lt;T&gt; postForEntityWithNoException(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException { RestResponseDTO&lt;T&gt; restResponseDTO = new RestResponseDTO&lt;T&gt;(); ResponseEntity&lt;T&gt; tResponseEntity; try { tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables); restResponseDTO.setData(tResponseEntity.getBody()); restResponseDTO.setMessage(tResponseEntity.getStatusCode().name()); restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue()); }catch (Exception e){ restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR); restResponseDTO.setMessage(e.getMessage()); restResponseDTO.setData(null); } return restResponseDTO; }} 包装器ExtractRestTemplate很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑ExtractRestTemplate完成的功能，让我们把焦点放在FilterRestTemplate上，“实现RestOperations所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下: 1234567891011121314151617181920212223242526272829public abstract class FilterRestTemplate implements RestOperations { protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate) { this.restTemplate = restTemplate; } @Override public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException { return restTemplate.getForObject(url,responseType,uriVariables); } @Override public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException { return restTemplate.getForObject(url,responseType,uriVariables); } @Override public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException { return restTemplate.getForObject(url,responseType); } @Override public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException { return restTemplate.getForEntity(url,responseType,uriVariables); } //其他实现代码略。。。} 我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用lombok提供的代理注解优化了我的代码(@Delegate): 12345@AllArgsConstructorpublic abstract class FilterRestTemplate implements RestOperations { @Delegate protected volatile RestTemplate restTemplate;} 这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱lombok的程序员吧。","link":"/java/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99java%E5%90%97-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"},{"title":"1125-1201-week-plan","text":"一、 学习预期 《Vue.js快跑》 1/2 《Go语言核心编程》 1/2 LeetCode 5*7 1✅2✅3✅4✅5✅6✅7✅ 复习jQuery 复习JavaScript 附加 linux 基础复习，包括：文本处理 磁盘管理 进程管理 性能监控 网络工具 git 复习 《Java并发编程的艺术》 1/2 《Java程序员面试笔记》 第四章 《架构宝典》 1/2 jvm 牛客 20*7 二、课堂 中特 《万历十五年》读书笔记 软件开发项目管理 作业 测验 英语 PPT 高级数理逻辑 课后作业 慕课 工程伦理 附加 中特 期末论文 自然辩证法 实践报告 如何做好科研论文 自然辩证法 读书笔记 改成论文格式 三、健康 总共200个俯卧撑 1-55 4-65 keep 哑铃*3次 1✅4✅6 最少吃5天早饭 1✅2 3✅4✅5✅6✅7 附加 3km*3次 1✅ 琐事 改动博客 理发 leetcode hexo脚本修改tag获取途径，从九章获取-&gt;获取LeetCode所有tag下题目（查看所有tag下题目是否有交集），并更新已经上传的md的tag。 对于没有tag的题目，让用户手动输入","link":"/other/1125-1201-week-plan.html"},{"title":"hexo","text":"hexo 安装、使用安装见 https://wuzequn.com/2018/04/27/blog-build-and-ipv6-tools http://www.dragonbaby308.com/hexo 初始化项目hexo init blog 配置修改 bog 项目下的_config.yml 文件，D:\\01 Code\\hexo_config.ymllanguage: zh-Hans 使用创建新文章hexo new new-article 重新发布hexo clean;hexo g;hexo s hexo clean hexo generate 或 hexo g hexo server 或 hexo s 部署到 github 服务器部署 （一） 本地 + github.io 白嫖部署 生成 github.io 仓库首先注册并登录 GitHub，创建新 public 仓库，仓库名称一定要是：YourGitHubName.github.io（YourGitHubName 是你的 GitHub 昵称，大小写敏感！） 本地安装 Hexo 的 git 部署插件在 Hexo 的目录下，输入 npm install –save hexo-deployer-git，会报一个 peerDependencies WARNING，可以忽略。 本地修改_config.yaml 文件在 Hexo 目录下，找到_config.yaml 文件，在#Deployment 做如下修改： Markdown # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/DragonBaby308/DragonBaby308.github.io.git #你的 github.io 的网址 branch: master #“type:”、“repo:”和“branch:”后都要带一个空格 部署hexo d部署成功后，浏览器输入 YourGitHubName.github.io 即可访问，其中 YourGitHubName 是你的 GitHub 昵称，且大小写敏感见 详见 http://www.dragonbaby308.com/hexo/ 发布hexo clean;hexo g;hexo d 输入 github 账号名，密码 hexo d 即 hexo deploy 其他配置Hexo+Next 个人博客主题优化 - 简书https://www.jianshu.com/p/efbeddc5eb19 主要配置了： Hexo 之 next 主题设置首页不显示全文(只显示预览) - 简书https://www.jianshu.com/p/393d067dba8d Hexo+Next个人博客主题优化 - 简书https://www.jianshu.com/p/efbeddc5eb19 Dragonstyle’s Home – 记录、分享、交流http://www.dragonstyle.win/ 修改文章宽度https://ihaoming.top/archives/9a935f57.html deploy 免账号密码 可将_config.yml 中的 repo 修改为如下标准格式：repo: https://用户名:密码@github.com/用户名/用户名.github.io.git这样做的好处就是每次 hexo deploy 提交时不需要输入账号密码。 hexo的首页只显示文章的部分内容让hexo的首页只显示文章的部分内容而不是全部 | 朱启的个人博客 1234567891011第二种方法在你写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。效果上面两种方式展示出来的效果是不一样的。第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。而第二种加上 &lt;!--more--&gt;展示出来的就是你原本文章的样式，最后不会有… 换电脑见 https://feijunjie.github.io/2018/10/10/20181010-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8F%A6%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%BB%A7%E7%BB%ADhexo%E5%86%99%E5%8D%9A%E5%AE%A2/ 注意事项在标题开头使用如下形式[精]精华文章会报错 问题search一直加载解决办法： 查看search.xml的请求 打开新窗口，直接访问xml网址，查看哪一行解析失败，回到请求页面，查看是哪个文件 去vim查看异常字符 热度统计没生效Next 解决 Busuanzi 统计浏览失效 | G加菲 文章置顶Hexo文章置顶的方法 - 简书 侧边栏添加自定义文件夹【Hexo + Next】侧边栏添加自定义文件夹（如友链）_Spr Chan的博客-CSDN博客 Archive页面显示文章数量npm install hexo-generator-archive –save _config.yml中新增相关配置archive_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档index_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 tag_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 category_generator: per_page: 40 #值为0表示不分页，按需填写 yearly: true #是否按年生成归档 monthly: true #按月归档 EIO: i/o error➜ hexo hexo dINFO Deploying: gitINFO Clearing .deploy_git folder…FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: EIO: i/o error, stat ‘/Volumes/Data/01 Code/hexo/.deploy_git/2019’➜ hexo open .在finder中，删除文件夹再hexo deploy hexo文章模板设置 | 拈花把酒偏折煞世人情狂 Hexo设置网站的图标Favicon | G加菲在线免费将图片转换成ico图标格式-转换成ico hexo中文版 ![fWXaVcbtCg8kMNo](https://i.loli.net/2020/01/14/fWXaVcbtCg8kMNo.png) jaredly/hexo-admin: An Admin Interface for Hexo 图片和描述123photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpgdescription: 03 junit 多环境撰文hexo与github pages共同搭建博客有一个麻烦的地方就在于多环境下要同步本地的博客内容很麻烦，唯一的方法就是你用要么一个硬盘云盘之类的要么就是用github之类的，每次有更新你就同时把本地的博客文件都同步上去，毫无疑问这非常麻烦。之前想要自己写一个自动化工具来做这个事情，这几天发现有人已经写好了，可以直接用，这里直接贴出链接，里面也有详细的说明，按照步骤来做就好了。hexo-git-backup SEO当我们搭建一个网站之后，如果没有做一些相关的搜索引擎优化SEO，那么我们的网站是很难获取来自搜索引擎的流量的，用户很难在搜索引擎上搜索到我们网站的内容，所以在这里我们要为Hexo网站做一些简单的搜索优化。上周刚搭建好博客的时候只有谷歌能搜索到自己的博客，百度直接搜域名都没有任何信息，主要原因是因为Github Pages屏蔽了百度爬虫，百度根据没办法知道我们博客的内容，所以我将博客同步到两个平台上，一个Github，一个国内的Gitcafe，目前搜索自己博客的相关信息基本都在第一条。 SiteMap首先安装hexo的sitemap网站地图生成插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码： 12345# hexo sitemap网站地图sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。 蜘蛛协议robots.txt在source目录下创建robots.txt文件，添加下面的一段代码： 12Sitemap: http://www.linbinghe.com/sitemap.xmlSitemap: http://www.linbinghe.com/baidusitemap.xml 请自行改成自己的网站。 完整robots.txt文件内容： 1234567891011121314# hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.arao.me/sitemap.xmlSitemap: http://www.arao.me/baidusitemap.xml 谷歌Search Console与百度站长工具这两个平台都是便于管理自己的网站，查看爬虫爬去频率等等，这两个的使用都不难，但是两者都需要通过验证，只要搜索这两个平台，到各自官网添加域名，按照文档说明通过验证即可。谷歌可以通过提交站点地图提交我们的sitemap.xml，百度目前已经禁止了。 主动推送新链接解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。 1npm install hexo-baidu-url-submit --save 在 站点配置文件 中添加如下代码： 12345baidu_url_submit: count: 5 ## 比如3，代表提交最新的三个链接 host: blog.tangxiaozhu.com ## 在百度站长平台中注册的域名 token: ## 请注意这是您的秘钥， 请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 为了主动推送链接，你还得在全局配置文件的deploy中添加配置： 12deploy:- type: baidu_url_submitter Hexo: 给博客添加百度统计当Hexo博客被百度、必应、谷歌搜索引擎收录以后，有件重要的工作是统计博客的访问情况，比如博客的历史访问量、搜索关键字、访问来源、访问地域等统计数据。 百度统计 能方便的完成网站访问量分析统计，本文简单演示下Hexo+Next博客配置百度统计功能。 开通百度统计帐号 在 百度统计 注册帐号。 帐号注册成功后，在网站列表中添加目标网站。 获取跟踪代码 网站添加之后在代码管理模块选择代码获取，可以看到如下代码: 123456789&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?____________________&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 这段代码需要用户添加到网站全部页面的 `` 标签前，Next主题已对百度统计进行配置优化，只需要配置主题配置文件即可，下面会详细介绍。 其中 hm.js? 后面的字符串为用户的 key 值，将 key 值记录下来，后面会用到。 配置主题配置文件 配置主题配置文件 /d/hexo/themes/next/_config.yml ，配置 baidu_analytics 参数，如下: 12# Baidu Analytics IDbaidu_analytics: 上面步骤中记录的百度统计里用户的key值。 修改完参数后执行 hexo g 和 hexo d 命令部署博客。 验证百度统计 之后仍然在代码管理模块的代码获取页面进行验证，如下图: 上图表示验证通过。 一般过20分钟左右就可以看到网站分析数据，过了几小时后，已经看到博客的访问统计分析数据，如下图: 网站列表 - 网站中心网站概况 - 百度统计 评论Hexo使用gitalk作为评论插件 | VoidKing Hexo使用livere作为评论插件 | VoidKing gittalk 好看，livere 加载快 (…) Gitalk评论插件使用教程 - 个人文章 - SegmentFault 思否","link":"/other/hexo.html"},{"title":"job","text":"合肥 邮储软开 26w 毁约相关：毁约很正常，给人家说清楚，一般有违约金。很多，应该是大多数单位都会故意拖着不给办解约函，但只有拿到解约函学校才会给新三方，所以先给邮储说你要违约农行，看能不能等等，可以先和邮储签个两方，然后和农行走解约流程，一般会拖到明年了，期间可以多催催，这也就人家领导一句话的事儿，尽早拿到解约函，一拿到解约函，学校这边很好办，很快就能拿到新三方，然后和邮储签三方。比较难把控的是农行的办理违约办理时间，一般都会故意卡着不给办，恶心你，邮储如果不等的话，就比较麻烦。","link":"/other/job.html"},{"title":"markdown语法及编辑器","text":"编辑器 小书匠 优点：功能齐全，全平台支持,有html转markdown功能[鸡肋] 缺点：界面不好看，不能直接打开文件修改 其他软件： Markdown 编辑器推荐 | Markdown 简单的世界 markdown语法学习Markdown 简单的世界 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Markdown 基本语法 | Markdown 简单的世界- 用反引号` 来标记内联代码，它们会解释成&lt;code&gt;标签- 链接[an example](http://example.com/)[an example](http://example.com/ &quot;Optional Title&quot;)- 图像![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional Title&quot;)- 自动链接如果链接的地址和名字重复，可以用尖括号语法将其简化。+&lt;http://example.com/&gt;就相当于[http://example.com/](http://example.com/)- 代码区域有两种方式标记代码区域，原生风格是行首缩进死个空格。- 链接要么加上尖括号，要么两端加上空格。- 还有一种是github的风格，代码段的前后用三个反引号独占一行来标记- 可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：+* * *********- - ----------------------------------------- 新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览- 一行文字就是一个段落- 如果你需要另起一段，请在两个段落之间隔一个空行- 不隔一个空行的换行行为，在一些编辑器中被解释为换行，即插入一个&lt;br /&gt;标签。对与另外一些编辑器，会被解释为插入一个空格。对于后者，若要插入换行标签，请在当前一行的结尾打两个空格- 可以使用星号*或下划线_指定粗体或者斜体- *这是斜体*_这也是斜体_**这是粗体*****这是粗体+斜体***- 一部分编辑器支持删除线，它不是经典markdown中的要素。用波浪线~定义删除线- 通过在行首加上大于号&gt;来添加引用格式- 引用可以嵌套：+&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.- 无序列表使用星号、加号或是减号作为列表标记- 有序列表则使用数字接着一个英文句点· Highlighted Source : http://lnr.li/Q3Y2A/· Original Source : https://wizardforcel.gitbooks.io/markdown-simple-world/content/2.html","link":"/other/markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%BC%96%E8%BE%91%E5%99%A8.html"},{"title":"rss","text":"[toc] 工具rss 验证Feed Validator 网页版The Old Reader Home Page - AZ Reader MacReeder Android(未测试) News+：可高度自定义的全能阅读器 FeedMe：功能丰富还免费 Readably：简洁又好用的轻量级阅读器 SwipeNews：高颜值 RSS 工具 Read：手动订阅者的最佳选择 Palabre：支持插件扩展的阅读器 Newsfold：体验沉浸式阅读 Windows RSS 追踪 Chrome 插件 查看当前网站可用 RSSRSSHub Radar - Chrome 网上应用店 生成 RSSFeeds | FeedOcean 限量 20 个，操作简单 Full RSS - Full text rss feed generator 100% success &amp; freeFeed43 : Zronghui’s feeds 无限数量，较复杂 相关教程介绍 | RSSHub 打造属于自己的RSS源 - 萤火之森 RSS定制个人高质量信息流 - 简书 生成和订阅任意网站RSS工具-实现RSS全文,邮箱和手机APP提醒 RSS 工具大全 – 幻璧 查看浏览器中网页编码的通用方法找到Console标签，输入命令document.charset 需要订阅的网站编程科技爱好者周刊 · 语雀 – https://rsshub.app/yuque/doc/102804 guanguans/favorite-link: ❤️ 每日收集喜欢的开源项目 | RSS 订阅 | 快知 app 订阅 – https://rsshub.app/github/file/guanguans/favorite-link/master/README.md 521xueweihan/HelloGitHub: Find pearls on open-source seashore 分享 GitHub 上有趣、入门级的开源项目 – https://rsshub.app/github/file/521xueweihan/HelloGitHub/master/README.md Weekly Review | Baeldung – https://www.baeldung.com/feed 最近7天热门分享 - 开发者头条 – https://feed43.com/8633017563184185.xml 软件Recently Added - MacMenuBar.com – https://macmenubar.com/feed/ 帖子回复排行 - 排行榜 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn – https://feed43.com/3380182813145783.xml 原创工具 - 『原创发布区』 – https://www.52pojie.cn/forum.php?mod=rss&amp;fid=2 果核剥壳 - 还原软件的本质 – https://feed43.com/4874650357564440.xml 分享者 - 优质破解软件、互联网资源分享 – https://feed43.com/4223122352386404.xml 小众软件 - 分享免费、小巧、实用、有趣、绿色的软件 – http://feeds.appinn.com/appinns/ 【最美应用】 - Android 一起发现好用、好看、好玩的应用 – https://feed43.com/3860164582806815.xml 异次元软件世界 - 软件改变生活！ – https://feed.iplaysoft.com 反斗软件 – https://feed43.com/6686431683726277.xml 精品绿色便携软件 – https://feed43.com/7557338185735120.xml 芊芊精典 | 优质互联网资源分享与交流！ – https://feed43.com/3512786450224168.xml 不死鸟 - 分享为王 – https://feed43.com/8584272185423565.xml 盒子部落 - 互联网资源分享平台 – https://feed43.com/8107787027631862.xml 安卓应用 - 大眼仔旭 – https://feed43.com/1652573841537568.xml 异星软件空间 | 感受不一样的精彩体验！ – https://feed43.com/0450245615005046.xml 编码看似有问题，实际没问题 编者序 · Chrome插件英雄榜 – https://feed43.com/0273635824543181.xml 精品MAC应用分享 – https://feed43.com/8857213541600761.xml 一梦全网线报软件发布群 – 网址发送 post 请求 其他介绍 | RSSHub – https://rsshub.app/rsshub/rss 少数派 - 高效工作，品质生活 – https://sspai.com/feed 无作为|分享不仅仅是一种态度！ – https://feed43.com/7114536122142655.xml 電腦王阿達 – https://www.kocpc.com.tw/feed 电脑玩物 – 楚盟网 – 记录学习分享的个人网站 – Trending Python repositories on GitHub today – 最终效果","link":"/other/rss.html"},{"title":"you_get 自定义","text":"you get简介you-get 用来下载哔哩哔哩多p视频缺点: 不能指定开始p 下载的视频没有放在子目录里面 不支持失败重试 有时候，一集下完了还在疯狂下载，下十几个G都不停的 针对前2个缺点，做出自定义 项目地址：soimort/you-get: Dumb downloader that scrapes the web 操作过程记录git clone12git clone https://github.com/soimort/you-get.gitcd you-get 修改代码common.py添加start参数 12345678910111213141516171819# script_main 方法中， parser = 下一句parser.add_argument( '--start', help='start from index [start]' )# 修改 download_mainif args.start: start = args.startelse: start = 1ic(start)download_main( download, download_playlist, URLs, args.playlist, output_dir=args.output_dir, merge=not args.no_merge, info_only=info_only, json_output=json_output, caption=caption, password=args.password, start=start, **extra) extractors/bilibili.pydownload_playlist_by_url 中 123# 添加ic(kwargs['start'])start = int(kwargs['start']) 12345678if sort == 'video': initial_state_text = match1(html_content, r'__INITIAL_STATE__=(.*?);\\(function\\(\\)') # FIXME initial_state = json.loads(initial_state_text) # 添加下面几行 title = initial_state['videoData']['title'] kwargs['output_dir'] = os.path.join(kwargs['output_dir'], title) if os.path.exists(kwargs['output_dir']): os.system(f\"mkdir -p '{kwargs['output_dir']}'\") elif sort == ‘bangumi’: 上面 12345678for pi in range(pn): if pi + 1 &lt; start: continue self.prepare_by_cid(aid, initial_state['videoData']['pages'][pi]['cid'], 'P%s. %s' % ( pi + 1, initial_state['videoData']['pages'][pi]['part']), html_content, playinfo, playinfo_, url) self.extract(**kwargs) self.download(**kwargs) 再次修改修改内容：1. common.py123456# if args.skip_existing_file_size_check:# skip_existing_file_size_check = Trueskip_existing_file_size_check = Trueif args.output_dir == '.': args.output_dir = '/Volumes/My Passport/data/ut下载/0 未分类/ytdl videos/bilibili'ic(args.output_dir) 12345678910download_main( download, download_playlist, URLs, True, # URLs, args.playlist, output_dir=args.output_dir, merge=not args.no_merge, info_only=info_only, json_output=json_output, caption=caption, password=args.password, start=start, **extra) 2. extractors/bilibili.py123456789101112title = initial_state['videoData']['title']kwargs['output_dir'] = os.path.join(kwargs['output_dir'], title)if not os.path.exists(kwargs['output_dir']): os.system(f\"mkdir -p '{kwargs['output_dir']}'\")try: videos = sorted(os.listdir(kwargs['output_dir']), key=lambda i: int(i.split('.')[0][1:])) if videos[-1].endswith('download'): os.system(f\"rm '{os.path.join(kwargs['output_dir'], videos[-1])}'\") start = int(videos[-1].split('.')[0][1:])except: start = 1ic(start) pip install .1pip install . 使用shell然后就可以用 –start 参数例如： 1you-get --playlist --skip-existing-file-size-check --start 27 -d -o '/Volumes/My Passport/data/ut下载/0 未分类/ytdl videos/bilibili/test' https://www.bilibili.com/video/av81274709 python123456import sysfrom you_get import common as you_getdirectory = r'/Volumes/My Passport/data/ut下载/0 未分类/ytdl videos/bilibili/test'url = r'https://www.bilibili.com/video/av81274709'sys.argv = ['you-get', '-d', '-o', directory, '--playlist', '--start', '27', url]you_get.main()","link":"/other/you-get-%E8%87%AA%E5%AE%9A%E4%B9%89.html"},{"title":"图床","text":"zronghui’s uploaded images - ImgurAdd Client - Imgur API Access - SM.MS | DashboardSM.MS v2 API Docs 使用软件：upic使用图床：imgur","link":"/other/%E5%9B%BE%E5%BA%8A.html"},{"title":"10 python tips","text":"","link":"/python/10-python-tips.html"},{"title":"快捷键","text":"mweb 快捷键：command d: 任务列表 （改，同有道云笔记）ctrl option d: 代码块 （改，同有道云笔记）ctrl 1: 1级标题 （有道云笔记是command 1）","link":"/other/%E5%BF%AB%E6%8D%B7%E9%94%AE.html"},{"title":"Python tricks","text":"[toc] 02-28Personalize your python prompt | Arpit Bhayani 02-14Debugging in Python — A cakewalk with pdb - Python Features - Medium 02-13Pathlib (3.4+)12345from pathlib import Pathroot = Path('post_sub_folder')print(root)path = root / 'happy_user'print(path.resolve()) Type hinting (3.5+)123def sentence_has_animal(sentence: str) -&gt; bool: return \"animal\" in sentencesentence_has_animal(\"Donald had a farm without animals\") Enumerations (3.4+)Python3提供的Enum类让你很容就能实现一个枚举类型： 123456789from enum import Enum, autoclass Monster(Enum): ZOMBIE = auto() WARRIOR = auto() BEAR = auto()print(Monster.ZOMBIE)for monster in Monster: print(monster) Built-in LRU cache (3.2+)缓存是现在的软件领域经常使用的技术，Python3提供了一个lru_cache装饰器，来让你更好的使用缓存。 12345678910from functools import lru_cache@lru_cache(maxsize=512)def fib_memoization(number: int) -&gt; int: if number == 0: return 0 if number == 1: return 1 return fib_memoization(number-1) + fib_memoization(number-2)start = time.time()fib_memoization(40)print(f'Duration: {time.time() - start}s') Extended iterable unpacking (3.0+)*_用来抛弃元素 123456789101112131415head, *body, tail = range(5)print(head, body, tail)# 输出： 0 [1, 2, 3] 4py, filename, *cmds = \"python3.7 script.py -n 5 -l 15\".split()print(py)print(filename)print(cmds)# 输出：python3.7# script.py# ['-n', '5', '-l', '15']first, _, third, *_ = range(10)print(first, third)# 输出： 0 2 Data classes (3.7+)Python3提供data class装饰器来让我们更好的处理数据对象，而不用去实现 init() 和 repr() 方法。假设如下的代码: 1234567891011121314class Armor: def __init__(self, armor: float, description: str, level: int = 1): self.armor = armor self.level = level self.description = description def power(self) -&gt; float: return self.armor * self.levelarmor = Armor(5.2, \"Common armor.\", 2)armor.power()# 10.4print(armor)# &lt;__main__.Armor object at 0x7fc4800e2cf8&gt; 使用data class实现上面功能的代码，这么写: 12345678910111213141516from dataclasses import dataclass@dataclassclass Armor: armor: float description: str level: int = 1def power(self) -&gt; float: return self.armor * self.level armor = Armor(5.2, \"Common armor.\", 2)armor.power()# 10.4print(armor)# Armor(armor=5.2, description='Common armor.', level=2) Implicit namespace packages (3.3+)通常情况下，Python通过把代码打成包（在目录中加入init.py实现）来复用 在Python2里，每个目录都必须有init.py文件，以便其他模块调用目录下的python代码，在Python3里，通过 Implicit Namespace Packages可是不使用init.py文件 sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects echo.py surround.py reverse.py ... filters/ Subpackage for filters equalizer.py vocoder.py karaoke.py02-10neovim: 新时代的 vim，我在这个配置(https://github.com/PegasusWang/vim-config)上自定义了自己的配置，使用起来性能和反应速度上远超原生的老古董 vim meld/vimdiff: 文本比对工具。 tmux/tmuxp wemux: tmux 共享，https://github.com/zolrath/wemux sshfs: 本地挂在服务器文件夹 tmate: https://tmate.io 终端共享工具，结对编程。很多现代化编辑器 vscode, atom 提供结对编程的插件。 asciinema: 终端会话记录工具。https://asciinema.org/ devdocs.io: 文档查询工具 gitx(mac):方便查看代码提交历史，便于了解整个代码仓库是怎样一步步构建的。http://gitx.frim.nl/user_manual tig: text-mode interface for git. 喜欢命令行的可以尝试下。 https://github.com/jonas/tig EditorConfig: http://editorconfig.org/ 用来统一编辑器配置。如果成员用不同的操作系统和编辑器，建议使用。尤其是对于 python 这种使用缩进的语言 mac-setup: https://github.com/sb2nov/mac-setup mac 下各种编程语言开发环境配置指引 《使用vim+tmux+zsh+autojump高效工作》 prospector: 集成了众多python代码检测工具 mccabe: 圈复杂度检测工具。McCabe 是一种度量程序复杂度的方法，如果单个子程序复杂度过高，或许就需要拆分逻辑提高程序的易读性。 bandit: 用于Python代码的安全性分析，openstack 的项目 https://github.com/openstack/bandit rope，可以用来重构等，功能强大。笔者经常用rope自动帮我重新整理导入的包顺序。 Pyreverse: 代码 UML 生成工具, 帮助我们理解继承关系 (https://pythonhosted.org/theape/documentation/developer/explorations/explore_graphs/explore_pyreverse.html) Epydoc: Automatic API Documentation Generation for Python 2to3/python-modernize: python2 转 python3 工具。目前 Instagram 已经全面迁移到 python3 编写2/3兼容代码：http://python-future.org/compa pigar: 找出项目使用到的依赖库 buildout: 项目构建工具 pyenv/virtualenv/pipenv：多版本管理 bitbucket: 类似 github，好处是支持免费的私有仓库 cookiecutter: 一系列项目模板生成工具，懒人必备。https://github.com/audreyr/cookiecutter。笔者之前内部项目就直接用 flask-cookiecutter 直接生成的。 yeoman: http://yeoman.io/generators/ 前端项目模板生成工具 ant-design: 后端管理后台项目解决方案 https://ant.design/docs/react/p Api 工具 checklist: http://python.apichecklist.com/ 日志、异常收集工具 Sentry: 用来记录异常非常好用，能看到完善的栈信息，方便排错。 Fluentd 管理及运维、监控工具(devops很火) Supervisor.进程管理 Fabric.应用部署 docker.最近比较火的容器技术。很多采用微服务架构的公司使用 docker 作为容器部署服务，或者构建一致的开发环境 SaltStack和Ansible. 配置管理 StatsDGraphite等web监控 调试工具 ipdb/pdb: ipdb 支持自动补全，比原生的 pdb 要好用一些。 pdbpp: https://pypi.org/project/pdbpp/ https://curl.trillworks.com/ 把 curl 命令参数转成 requests 代码。 https://github.com/NickCarneiro/curlconverter/。 httpie postman http://httpbin.org curl/requests 互相转化: https://github.com/oeegor/curlify https://github.com/spulec/uncurl 抓包和下载工具 mitmproxy: 用 python 实现的终端命令行抓包工具，可以将请求直接导出成 python 代码，笔者经常用来抓包和调试。 charles 爬虫相关 Scrapy: 知名的爬虫框架。生态比较丰富 pyspider: 国人写的一个不错的爬虫框架 requests lxml/BeautifulSoup/pyquery: 解析 html，xml 等。 tornado: 异步的 http client 可以写爬虫 redis/celery: 实现队列、异步爬虫。异步方案也比较多 phantomjs/puppeteer: 用来处理动态网站。puppeteer 基于 nodejs 异步任务框架 celery: python 社区一个流行的异步任务框架 压测工具 locust: python实现的压测工具。http://locust.io/， 有 web 界面 ab wrk Profiler pyflame: https://github.com/uber/pyflame 数据库工具 mycli: mysql 命令行补全等。https://github.com/dbcli/mycli MysqlWorkbench/Sequel Pro: mysql 客户端工具。 Navicat Premium: 强大的数据库管理工具，收费 Medis: redis client 工具 MongoChef: Mongodb 客户端工具 2020 年 1 月 15 日(星期三)Python技巧小贴士 - 51CTO.COM 字符串一次性执行多个 replace12345678user_input = \"This\\nstring has\\tsome whitespaces...\\r\\n\" character_map = { ord('\\n') : ' ', ord('\\t') : ' ', ord('\\r') : None } user_input.translate(character_map) # This string has some whitespaces... 迭代器切片(Slice)如果对迭代器进行切片操作，会返回一个「TypeError」，提示生成器对象没有下标，但是我们可以用一个简单的方案来解决这个问题： 12345import itertools s = itertools.islice(range(50), 10, 20)for i in s: ... 跳过可迭代对象某些元素比如跳过文件的注释代码 1234import itertools for line in itertools.dropwhile(lambda line: line.startswith(\"//\"), string_from_file.split(\"\\n\")): print(line) 实现上下文管理12345678910from contextlib import contextmanager @contextmanager def tag(name): print(f\"&lt;{name}&gt;\") yield print(f\"&lt;/{name}&gt;\") with tag(\"h1\"): print(\"This is Title.\") 控制可以/不可以导入什么在 Python 中，所有成员都会被导出(除非我们使用了「all」)： 1234567def foo(): pass def bar(): pass __all__ = [\"bar\"] 在上面这段代码中，我们知道只有「bar」函数被导出了。同样，我们可以让「all」为空，这样就不会导出任何东西，当从这个模块导入的时候，会造成「AttributeError」。 实现所有比较运算符的简单方法为一个类实现所有的比较运算符(如 lt , le , gt , ge)是很繁琐的。有更简单的方法可以做到这一点吗？这种时候，「functools.total_ordering」就是一个很好的帮手： 1234567891011121314151617from functools import total_ordering @total_ordering class Number: def __init__(self, value): self.value = value def __lt__(self, other): return self.value &lt; other.value def __eq__(self, other): return self.value == other.value print(Number(20) &gt; Number(3)) print(Number(1) &lt; Number(5)) print(Number(15) &gt;= Number(15)) print(Number(10) &lt;= Number(2)) 用「total_ordering」装饰器简化实现对类实例排序的过程。我们只需要定义「lt」和「eq」就可以了 限制「CPU」和内存使用量？如果不是想优化程序对内存或 CPU 的使用率（how），而是想直接将其限制为某个确定的数字，Python 也有一个对应的库可以做到： 12345678910111213141516171819import signal import resource import os # To Limit CPU time def time_exceeded(signo, frame): print(\"CPU exceeded...\") raise SystemExit(1) def set_max_runtime(seconds): # Install the signal handler and set a resource limit soft, hard = resource.getrlimit(resource.RLIMIT_CPU) resource.setrlimit(resource.RLIMIT_CPU, (seconds, hard)) signal.signal(signal.SIGXCPU, time_exceeded) # To limit memory usage def set_max_memory(size): soft, hard = resource.getrlimit(resource.RLIMIT_AS) resource.setrlimit(resource.RLIMIT_AS, (size, hard))","link":"/python/Python-tricks.html"},{"title":"leetcode 103. Binary Tree Zigzag Level Order Traversal","text":"难度：Middleleetcode九章 题目描述Given a binary tree, return the zigzag level order traversal of its nodes’values. (ie, from left to right, then right to left for the next level andalternate between). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its zigzag level order traversal as: [ [3], [20,9], [15,7] ]Tags: Stack, Tree, Breadth-first Search Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Deque&lt;TreeNode&gt; lr = new ArrayDeque&lt;&gt;(); Deque&lt;TreeNode&gt; rl = new ArrayDeque&lt;&gt;(); lr.addFirst(root); while(!(lr.isEmpty() &amp;&amp; rl.isEmpty())){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); while(!lr.isEmpty()){ TreeNode cur = lr.removeFirst(); l.add(cur.val); if(cur.left!=null) rl.addFirst(cur.left); if(cur.right!=null) rl.addFirst(cur.right); } if(!l.isEmpty()) res.add(l); List&lt;Integer&gt; l1 = new ArrayList&lt;&gt;(); while(!rl.isEmpty()){ TreeNode cur = rl.removeFirst(); l1.add(cur.val); if(cur.right!=null) lr.addFirst(cur.right); if(cur.left!=null) lr.addFirst(cur.left); } if(!l1.isEmpty()) res.add(l1); } return res; }}","link":"/leetcode/leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal.html"},{"title":"leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal","text":"难度：Middleleetcode九章 题目描述Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7]Return the following binary tree: 3 / \\ 9 20 / \\ 15 7Tags: Array, Tree, Depth-first Search Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829303132class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder.length&lt;1) return null; return helper(preorder, inorder, 0, preorder.length-1, 0, inorder.length-1); } private TreeNode helper(int[] preorder, int[] inorder, int prestart, int preend, int instart, int inend){ TreeNode root = new TreeNode(preorder[prestart]); if(prestart==preend){ return root; } // root 在inorder的index int index = instart; for(; index&lt;=inend; index++){ if(inorder[index]==root.val){ break; } } if(index==instart){ // 没有左节点 root.left = null; root.right = helper(preorder, inorder, prestart+1, preend, instart+1, inend); }else if(index==inend){ root.right = null; root.left = helper(preorder, inorder, prestart+1, preend, instart, inend-1); }else{ root.left = helper(preorder, inorder, prestart+1, prestart+index-instart, instart, index-1); root.right = helper(preorder, inorder, prestart+index-instart+1, preend, index+1, inend); } return root; }}","link":"/leetcode/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html"},{"title":"python weekly","text":"[toc] Better Python tracebacks with Rich 类似于 pretty_errors JustPy 仅用 Python 写网页 vardbgA simple Python debugger and profiler that generates animated visualizations of program flow, useful for algorithm learning. 查看代码执行过程 类似于 http://pythontutor.com/visualize.html#mode=edit georgek42/inlinec: Effortlessly write inline C functions in Pythonmaxhumber/gif: ✨ Better animated Matplotlib gifs syncPlaylist在网易云音乐与 QQ 音乐之间同步歌单。易于使用、配置方便、代码简单，用到的技术：requests + beautifulsoup 以及 selenium + phantomjs GetSubtitles通过拖曳视频文件进终端，一步下载字幕 到视频对应文件夹，并重命名字幕名称为视频名称。Ubuntu 16.04、Windows 10上测试通过，同时兼容 Python2、3。Python 的魅力之一就是可以快速实现一个适合自己的小工具 Cool ✌️ pdir2Python 程序员需要一个更好的 dir() —— 以更加友好的显示 dir() 输出的结果 myclimycli 是一个带语法高亮、自动补全的 MySQL 命令行客户端工具。例如，连接数据库方法：mycli -h localhost -u 用户名 数据库 locust模拟用户行为的负载测试工具，包含友好的 Web 页面，如下图： flask-limiter一个 Flask 的扩展库，它可以根据访问者的 IP 限制其访问频率、次数等。 httpstathttpstat 美化了 curl 的结果，使得结果更加可读。同时它无依赖、兼容 Python3、一共才 300 多行。还可以显示 HTTP 请求的每个过程中消耗的时间，如下图： yakutils — yakutils 1.6.0 documentation read_csv¶ read_json¶ json_defaults¶ ? date_to_iso8601¶ datetime_to_iso8601¶ datetime_to_unixtimestamp¶ iso8601_to_datetime¶ md5¶ sha1¶ sha384¶ sha3_384¶ setup_logging¶ random_string¶ random_tolerance¶ update_qs¶ szsdk/quick: A real QUICK Qt5 based gUI generator for ClicK willmcgugan/rich: Rich is a Python library for rich text and beautiful formatting in the terminal. Rich print function Console Printing Console Logging Markdown Syntax Highlighting Tables Welcome to Rich’s documentation! — Rich 0.3.2 documentation scylla：一款高质量的免费代理 IP 池工具，仅支持 Python 3.6。中文文档，特性如下： 自动化的代理 IP 爬取与验证 易用的 JSON API 简单但美观的 web 用户界面，基于 TypeScript 和 React（例如，代理的地理分布） 最少仅用一行代码即可与 Scrapy 和 requests 进行集成 jiaaro/pydub: Manipulate audio with a simple and easy high level interfaceloguru：一个让 Python 记录日志变得简单的库 mahmoud/awesome-python-applications: 💿 Free software that works great, and also happens to be open-source Python. awslogs：一个简单的命令行工具，用于在本地查询 Amazon CloudWatch 日志，强大的支持多实例日志汇总查看。简单的查看命令：awslogs get /var/logs/syslog ALL -s1d 14、termtosvg：Python 写的终端记录器。通过命令 termtosvg 运行该工具，然后在终端执行你要展示的命令，最终输入 exit 命令结束录制，本地会生成一份 SVG 动画，可用于分享、展示终端操作。效果如下： 15、cx-extractor-python：这是一个对网页正文进行抽取的工具。 cx-extractor 算法的 python 版本，改进了原有算法，使其支持中英文，对新闻类网页正文抽取效果较好。示例代码： 123456from crawler.cx_extractor_Python import cx_extractor_Pythoncx = cx_extractor_Python()test_html = cx.getHtml('http://news.163.com/16/0101/10/BC84MRHS00014AED.html')content = cx.filter_tags(test_html)s = cx.getText(content)print(s) 2020年1月25日bullet：一个支持终端输入和菜单选择的 Python 库。可以让使用者在终端上用方向键移动、单选、复选、密码输入等，而且支持定制化格式和颜色。看下面的效果图你就知道它是干什么 TagUI-Python：一个 Python 自动化操作的库。比如：自动打开网页并截图，示例代码： 12345t.init()t.url('https://www.google.com')t.type('q', 'decentralization[enter]')t.snap('page', 'results.png')t.close() 2020年1月20日(星期一)guanguans/favorite-link: ❤️ 每日收集喜欢的开源项目 | RSS 订阅 | 快知 app 订阅 scrapydweb Python 爬虫框架 Scrapyd 集群管理的全功能 web UI，支持 Scrapy 日志分析和可视化、自动打包、定时器任务和邮件通知等特色功能。 Python爬虫代理IP池(proxy pool) jhao104/proxy_pool: Python爬虫代理IP池(proxy pool)facert/awesome-spider: 爬虫集合 hustcc/JS-Sorting-Algorithm: 一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。 injetlee/Python: Python脚本。模拟登录知乎， 爬虫，操作excel，微信公众号，远程开机 Kr1s77/awesome-python-login-model: 😮python模拟登陆一些大型网站，还有一些简单的爬虫 0xHJK/Proxies: 100行Python代码快速获得一个代理池，两分钟获得数千个有效代理 kenwoodjw/python_interview_question: 关于python的面试题 Python/Golang Web 入坑指南 — python-web-guide 0.1 文档 Python教程 mahmoud/awesome-python-applications: 💿 Free software that works great, and also happens to be open-source Python. 2020 年 1 月 17 日(星期五)emeryberger/scalene: a high-performance, high-precision CPU and memory profiler for Python安装pip install scalene 使用默认只测 CPU timepython -m scalene test/testme.py 优点line_profiler 将程序拖慢 12 倍，scalene 的性能有很大提升 alan-turing-institute/CleverCSVdetect_dialect: takes a path to a CSV file and returns the detected dialectread_csv: automatically detects the dialect and encoding of the file, and returns the data as a list of rows. pytest-testmon只运行受影响的 test rq/rq: Simple job queues for Pythonjob queue? carlosperate/awesome-pyproject2020-1-14打印太多东西到屏幕上，会严重拖慢程序执行速度使用Newspaper框架抓取新闻 – 前端开发，JQUERY特效，全栈开发，vue开发 2020-1-13codetiming · PyPI1pip install codetiming usage As a class: 1234t = Timer(name=\"class\")t.start()# Do somethingt.stop() As a context manager: 12with Timer(name=\"context manager\"): # Do something As a decorator: 123@Timer(name=\"decorator\")def stuff(): # Do something ### [robdmc/crontabs: A cron-like utility for Python](https://github.com/robdmc/crontabs) #### Installation 1pip install crontabs UsageSchedule a single job 点击查看代码 1234567891011from crontabs import Cron, Tabfrom datetime import datetimedef my_job(*args, **kwargs):print('args={} kwargs={} running at {}'.format(args, kwargs, datetime.now()))# Will run with a 5 second interval synced to the top of the minuteCron().schedule(Tab(name='run_my_job').every(seconds=5).run(my_job, 'my_arg', my_kwarg='hello')).go() Schedule multiple jobs 点击查看代码 ​```python from crontabs import Cron, Tab from datetime import datetime def my_job(args, *kwargs): print(‘args={} kwargs={} running at {}’.format(args, kwargs, datetime.now())) All logging messages are sent to sdtoutCron().schedule( # Turn off logging for job that runs every five seconds Tab(name=’my_fast_job’, verbose=False).every(seconds=5).run(my_job, ‘fast’, seconds=5), # Go ahead and let this job emit logging messages Tab(name=&apos;my_slow_job&apos;).every(seconds=20).run(my_job, &apos;slow&apos;, seconds=20),).go() 12345678910111213141516171819202122232425262728&lt;/details&gt;##### Schedule future job to run repeatedly for a fixed amount of time&lt;details&gt; &lt;summary&gt;点击查看代码&lt;/summary&gt;```pythonfrom crontabs import Cron, Tabfrom datetime import datetimedef my_job(*args, **kwargs):print('args={} kwargs={} running at {}'.format(args, kwargs, datetime.now()))Cron().schedule(Tab(name='future_job').every(seconds=5).starting_at('12/27/2017 16:45' # This argument can either be parsable text or datetime object.).run(my_job, 'fast', seconds=5)# max_seconds starts from the moment go is called. Pad for future run times accordingly.).go(max_seconds=60) ## 2020-1-3 [knowsuchagency/klaxon: Mac OS notifications from Python](https://github.com/knowsuchagency/klaxon) ## 2020-1-1 ### pretty_errors [onelivesleft/PrettyErrors: Prettify Python exception output to make it legible.](https://github.com/onelivesleft/PrettyErrors/) ​```pythonimport pretty_errors 123456789101112131415![zIxVZ2C](https://i.imgur.com/zIxVZ2C.png)### horology 钟表学，测试法[mjmikulski/horology: timing functions, contexts and for-loops](https://github.com/mjmikulski/horology)#### 可用作装饰器```pythonfrom horology import timed@timeddef foo(): pass wrap your code using with statement1234from horology import Timingwith Timing(name='adaf: '): code block 读写 Excelpylightxl · PyPIWelcome to pylightxl’s documentation! — pylightxl 2019 documentation 有意思的库kkroening/ffmpeg-python: Python bindings for FFmpeg - with complex filtering supportneeru1207/AI_Sudoku: GUI based Smart Sudoku Solver that tries to extract a sudoku puzzle from a photo and solve it","link":"/python/python-weekly.html"},{"title":"leetcode 107. Binary Tree Level Order Traversal II","text":"难度：Easyleetcode九章 题目描述Given a binary tree, return the bottom-up level order traversal of itsnodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ]Tags: Tree, Breadth-first Search Difficulty: Easy 答案 123456789101112131415161718192021class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;(); deque.add(root); while(!deque.isEmpty()){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); int size = deque.size(); for(int i=0; i&lt;size; i++){ TreeNode cur = deque.removeFirst(); l.add(cur.val); if(cur.left!=null) deque.add(cur.left); if(cur.right!=null) deque.add(cur.right); } res.add(l); } Collections.reverse(res); return res; }}","link":"/leetcode/leetcode-107-Binary-Tree-Level-Order-Traversal-II.html"},{"title":"leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal","text":"难度：Middleleetcode九章 题目描述Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3]Return the following binary tree: 3 / \\ 9 20 / \\ 15 7Tags: Array, Tree, Depth-first Search Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829303132class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if(postorder.length&lt;1) return null; return helper(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1); } private TreeNode helper(int[] inorder, int[] postorder, int instart, int inend, int poststart, int postend){ TreeNode root = new TreeNode(postorder[postend]); if(instart==inend){ return root; } // root 在inorder的index int index = instart; for(; index&lt;=inend; index++){ if(inorder[index]==root.val){ break; } } if(index==instart){ // 没有左节点 root.left = null; root.right = helper(inorder, postorder, instart+1, inend, poststart, postend-1); }else if(index==inend){ root.right = null; root.left = helper(inorder, postorder, instart, inend-1, poststart, postend-1); }else{ root.left = helper(inorder, postorder, instart, index-1, poststart, poststart+index-instart-1); root.right = helper(inorder, postorder, index+1, inend, poststart+index-instart, postend-1); } return root; }}","link":"/leetcode/leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.html"},{"title":"leetcode 108. Convert Sorted Array to Binary Search Tree","text":"难度：Easyleetcode九章 题目描述Given an array where elements are sorted in ascending order, convert it to aheight balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree inwhich the depth of the two subtrees of every node never differ by more than1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5Tags: Tree, Depth-first Search Difficulty: Easy 答案 1234567891011121314class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(nums==null || nums.length&lt;1) return null; return helper(nums, 0, nums.length-1); } private TreeNode helper(int[] nums, int start, int end){ if(start&gt;end) return null; TreeNode root = new TreeNode(nums[start+(end-start)/2]); root.left = helper(nums, start, start+(end-start)/2-1); root.right = helper(nums, start+(end-start)/2+1, end); return root; }}","link":"/leetcode/leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree.html"},{"title":"leetcode 110. Balanced Binary Tree","text":"难度：Easyleetcode九章 题目描述Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ inheight by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 Return false. Tags: Tree, Depth-first Search Difficulty: Easy 答案 123456789101112class Solution { public boolean isBalanced(TreeNode root) { return maxDepth(root)!=-1; } private int maxDepth(TreeNode root){ if(root==null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); if(Math.abs(left-right)&gt;1 || left==-1 || right==-1) return -1; return Math.max(left, right)+1; }}","link":"/leetcode/leetcode-110-Balanced-Binary-Tree.html"},{"title":"leetcode 111. Minimum Depth of Binary Tree","text":"难度：Easyleetcode九章 题目描述Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the rootnode down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its minimum depth = 2. Tags: Tree, Depth-first Search, Breadth-first Search Difficulty: Easy 答案 12345678910class Solution { public int minDepth(TreeNode root) { if(root==null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); // left 或 right 为0 表示 有1边没有节点，只能选另一边，然后加一 // 就是 left+right+1 return (left==0 || right==0)?left+right+1:Math.min(left, right)+1; }}","link":"/leetcode/leetcode-111-Minimum-Depth-of-Binary-Tree.html"},{"title":"leetcode 112. Path Sum","text":"难度：Easyleetcode九章 题目描述Given a binary tree and a sum, determine if the tree has a root-to-leaf pathsuch that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, **5** **/** \\ **4** 8 **/** / \\ **11** 13 4 / **\\** \\ 7 **2** 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Tags: Tree, Depth-first Search Difficulty: Easy 答案 12345678class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root==null) return false; if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) return true; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val); }}","link":"/leetcode/leetcode-112-Path-Sum.html"},{"title":"leetcode 113. Path Sum II","text":"难度：Middleleetcode九章 题目描述Given a binary tree and a sum, find all root-to-leaf paths where each path’ssum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, **5** **/ \\** **4 8** **/** / **\\** **11** 13 **4** / **\\** **/** \\ 7 **2** **5** 1Return: [ [5,4,11,2], [5,8,4,5] ]Tags: Tree, Depth-first Search Difficulty: Medium 答案 12345678910111213141516171819class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; helper(root, sum, res, null); return res; } private void helper(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr){ List&lt;Integer&gt; cur; if(curr==null) cur = new ArrayList&lt;Integer&gt;(); else cur = new ArrayList&lt;Integer&gt;(curr); cur.add(root.val); if(root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum) res.add(cur); sum -= root.val; if(root.left!=null) helper(root.left, sum, res, cur); if(root.right!=null) helper(root.right, sum, res, cur); }}","link":"/leetcode/leetcode-113-Path-Sum-II.html"},{"title":"leetcode 116. Populating Next Right Pointers in Each Node","text":"难度：Middleleetcode九章 题目描述You are given a perfect binary tree where all leaves are on the samelevel, and every parent has two children. The binary tree has the followingdefinition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is nonext right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with ‘#’ signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096. -1000 &lt;= node.val &lt;= 1000 Tags: Tree, Depth-first Search Difficulty: Medium 答案 123456789101112class Solution { public Node connect(Node root) { if(root==null || root.left==null) return root; root.left.next = root.right; if(root.next!=null) { root.right.next = root.next.left; } connect(root.left); connect(root.right); return root; }}","link":"/leetcode/leetcode-116-Populating-Next-Right-Pointers-in-Each-Node-1.html"},{"title":"leetcode 128. Longest Consecutive Sequence","text":"难度：Hardleetcode九章 题目描述Given an unsorted array of integers, find the length of the longestconsecutive elements sequence. Your algorithm should run in O( n ) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.Tags: Array, Union Find Difficulty: Hard 答案 12345678910111213141516171819202122class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num: nums){ set.add(num); } int res = 0; for(int num: nums){ // 只考虑连续序列起始数字 if(set.contains(num-1)){ continue; } int count = 0; int cur = num; while(set.contains(cur++)) { count++; } res = Math.max(res, count); } return res; }}","link":"/leetcode/leetcode-128-Longest-Consecutive-Sequence.html"},{"title":"leetcode 114. Flatten Binary Tree to Linked List","text":"难度：Middleleetcode九章 题目描述Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6Tags: Tree, Depth-first Search Difficulty: Medium 答案 1234567891011121314151617181920212223242526class Solution { public void flatten(TreeNode root) { if(root==null || (root.left==null &amp;&amp; root.right==null)) return; if(root.left!=null) { flatten(root.left); if(root.right==null){ root.right = root.left; } else{ TreeNode temp = root.right; root.right = root.left; // 左边的叶子节点 TreeNode leftBottom = root.left; while(leftBottom.right!=null){ leftBottom = leftBottom.right; } leftBottom.right = temp; flatten(temp); } // 记得将左树清空 root.left = null; }else{ flatten(root.right); } }}","link":"/leetcode/leetcode-114-Flatten-Binary-Tree-to-Linked-List.html"},{"title":"leetcode 1143. Longest Common Subsequence","text":"难度：Middleleetcode九章 题目描述Given two strings text1 and text2, return the length of their longestcommon subsequence. A subsequence of a string is a new string generated from the original stringwith some characters(can be none) deleted without changing the relative orderof the remaining characters. (eg, “ace” is a subsequence of “abcde” while“aec” is not). A common subsequence of two strings is a subsequence that iscommon to both strings. If there is no common subsequence, return 0. Example 1: Input: text1 = “abcde”, text2 = “ace” Output: 3 Explanation: The longest common subsequence is “ace” and its length is 3. Example 2: Input: text1 = “abc”, text2 = “abc” Output: 3 Explanation: The longest common subsequence is “abc” and its length is 3. Example 3: Input: text1 = “abc”, text2 = “def” Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 The input strings consist of lowercase English characters only. Tags: Dynamic Programming Difficulty: Medium 答案超详细，动态规划解法 1234567891011121314151617181920212223242526class Solution { public int longestCommonSubsequence(String s1, String s2) { if(s1==null || s1.length()==0) return 0; if(s2==null || s2.length()==0) return 0; int n = s1.length(); int m = s2.length(); // i=0 j=0 是为了防止越界 int[][] dp = new int[n+1][m+1]; // 处理边界 // i=j=1 dp[1][1] = s1.charAt(0)==s2.charAt(0)?1:0; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { //如果末端相同 if(s1.charAt(i-1)==s2.charAt(j-1)){ dp[i][j] = dp[i-1][j-1]+1; }else{ //如果末端不同 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); } } } return dp[n][m]; }}","link":"/leetcode/leetcode-1143-Longest-Common-Subsequence.html"},{"title":"leetcode 131. Palindrome Partitioning","text":"难度：Middleleetcode九章 题目描述Given a string s , partition s such that every substring of the partitionis a palindrome. Return all possible palindrome partitioning of s. Example: Input: &quot;aab&quot; Output: [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ]Tags: Backtracking Difficulty: Medium 答案 1234567891011121314151617181920212223242526class Solution { public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); if(s==null || s.length()==0) return res; int n = s.length(); boolean[][] dp = new boolean[n][n]; for(int j=0; j&lt;n; j++) { for(int i=0; i&lt;=j; i++) { dp[i][j] = s.charAt(i)==s.charAt(j) &amp;&amp; (j-i&lt;=2 || dp[i+1][j-1]); } } System.out.println(Arrays.deepToString(dp)); dfs(res, dp, 0, n, s, new ArrayList&lt;String&gt;()); return res; } private void dfs(List&lt;List&lt;String&gt;&gt; res, boolean[][] dp, int i, int n, String s, ArrayList&lt;String&gt; tmp) { if(i==n) res.add(new ArrayList&lt;&gt;(tmp)); for(int j=i; j&lt;n; j++) { if(dp[i][j]){ tmp.add(s.substring(i, j+1)); dfs(res, dp, j+1, n, s, tmp); tmp.remove(tmp.size()-1); } } }}","link":"/leetcode/leetcode-131-Palindrome-Partitioning.html"},{"title":"leetcode 134. Gas Station","text":"难度：Middleleetcode九章 题目描述There are N gas stations along a circular route, where the amount of gas atstation i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas totravel from station i to its next station ( i +1). You begin the journeywith an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuitonce in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: Input: gas = [1,2,3,4,5] cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.Example 2: Input: gas = [2,3,4] cost = [3,4,3] Output: -1 Explanation: You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station. Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can&apos;t travel around the circuit once no matter where you start.Tags: Greedy Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public int canCompleteCircuit0(int[] gas, int[] cost) { // Runtime: 157 ms, faster than 5.13% // Memory Usage: 37.8 MB, less than 52.94% int n = gas.length; int sum = 0; for(int i = 0; i&lt;n; i++) { gas[i] -= cost[i]; sum += gas[i]; } if(sum&lt;0) return -1; for(int i = 0; i&lt;n; i++) { if(helper(gas, i, i, 0, n)) return i; } return -1; } private boolean helper(int[] gas, int start, int index, int remain, int len){ remain += gas[index]; if(remain&lt;0) return false; index = (index+1)%len; if(index==start) return true; return helper(gas, start, index, remain, len); } public int canCompleteCircuit(int[] gas, int[] cost) { // 一旦遇到第一个无法到达的点 i，直接更换起始点为 i+1。 // 中间的[1,i-1]一定不是起始点 // https://leetcode-cn.com/problems/gas-station/solution/java-1ms-xiang-xi-shuo-ming-qi-shi-dian-xuan-qu-gu/ int start = 0, sum = 0, sumFromStart = 0; for(int i=0;i&lt;gas.length; i++) { sum += gas[i]-cost[i]; sumFromStart += gas[i]-cost[i]; if(sumFromStart&lt;0) { start = i+1; sumFromStart = 0; } } return sum&gt;=0?start:-1; }}","link":"/leetcode/leetcode-134-Gas-Station.html"},{"title":"leetcode 141. Linked List Cycle","text":"难度：Easyleetcode九章 题目描述Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos whichrepresents the position (0-indexed) in the linked list where tail connects to.If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Tags: Linked List, Two Pointers Difficulty: Easy 答案 123456789101112131415public class Solution { public boolean hasCycle(ListNode head) { if(head==null || head.next==null){ return false; } ListNode slow = head; ListNode fast = head.next; while(fast!=slow){ if(fast==null || fast.next==null) return false; fast = fast.next.next; slow = slow.next; } return true; }}","link":"/leetcode/leetcode-141-Linked-List-Cycle.html"},{"title":"leetcode 142. Linked List Cycle II","text":"难度：Middleleetcode九章 题目描述Given a linked list, return the node where the cycle begins. If there is nocycle, return null. To represent a cycle in the given linked list, we use an integer pos whichrepresents the position (0-indexed) in the linked list where tail connects to.If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Follow-up :Can you solve it without using extra space? Tags: Linked List, Two Pointers Difficulty: Medium 答案 123456789101112131415161718public class Solution { public ListNode detectCycle(ListNode head) { if(head==null || head.next==null) return null; ListNode slow = head, fast = head; do{ if(fast==null || fast.next==null) return null; fast = fast.next.next; slow = slow.next; }while(slow!=fast); slow = head; while(slow!=fast){ fast = fast.next; slow = slow.next; } return slow; }}","link":"/leetcode/leetcode-142-Linked-List-Cycle-II.html"},{"title":"leetcode 171. Excel Sheet Column Number","text":"难度：Easyleetcode九章 题目描述Given a column title as appear in an Excel sheet, return its correspondingcolumn number. For example: A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...Example 1: Input: &quot;A&quot; Output: 1Example 2: Input: &quot;AB&quot; Output: 28Example 3: Input: &quot;ZY&quot; Output: 701Tags: Math Difficulty: Easy 答案 1234567891011121314// 用时 5 min// char to int: int a = c;class Solution { public int titleToNumber(String s) { int res = 0; char[] cs = s.toCharArray(); int n = cs.length; for(int i=0; i&lt;n; i++) { int ascii = cs[i]; res += (ascii-64)*(int)Math.pow(26, n-i-1); } return res; }}","link":"/leetcode/leetcode-171-Excel-Sheet-Column-Number.html"},{"title":"leetcode 150. Evaluate Reverse Polish Notation","text":"难度：Middleleetcode九章 题目描述Evaluate the value of an arithmetic expression in Reverse PolishNotation. Valid operators are +, -, *, /. Each operand may be an integer oranother expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] Output: 9 Explanation: ((2 + 1) * 3) = 9Example 2: Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] Output: 6 Explanation: (4 + (13 / 5)) = 6Example 3: Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22Tags: Stack Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829class Solution { public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s: tokens) { if(!isOperator(s)){ stack.push(Integer.parseInt(s)); }else{ stack.push(operate(stack.pop(), stack.pop(), s)); } } return stack.pop(); } private boolean isOperator(String s){ return s.equals(\"+\") || s.equals(\"-\") || s.equals(\"*\") || s.equals(\"/\"); } private int operate(int b, int a, String operator) { int res = 0; if(operator.equals(\"+\")){ res = a+b; }else if(operator.equals(\"-\")) { res = a-b; }else if(operator.equals(\"*\")) { res = a*b; }else if(operator.equals(\"/\")) { res = a/b; } return res; }}","link":"/leetcode/leetcode-150-Evaluate-Reverse-Polish-Notation.html"},{"title":"leetcode 179. Largest Number","text":"难度：Middleleetcode九章 题目描述Given a list of non negative integers, arrange them such that they form thelargest number. Example 1: Input: [10,2] Output: &quot;210&quot;Example 2: Input: [3,30,34,5,9] Output: &quot;9534330&quot;Note: The result may be very large, so you need to return a string insteadof an integer. Tags: Sort Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public String largestNumber_0(int[] nums) { String[] strs = new String[nums.length]; for(int i=0; i&lt;nums.length; i++){ strs[i] = Integer.toString(nums[i]); } PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;String&gt;(){ @Override public int compare(String s1, String s2){ return (s2+s1).compareTo(s1+s2); } }); for(int i=0; i&lt;nums.length; i++) { priorityQueue.add(strs[i]); } StringBuilder sb = new StringBuilder(); for(int i=0; i&lt;nums.length; i++) { sb.append(priorityQueue.remove()); } if(sb.toString().startsWith(\"0\")) return \"0\"; return sb.toString(); } public String largestNumber(int[] nums) { String[] strs = new String[nums.length]; for(int i=0; i&lt;nums.length; i++){ strs[i] = Integer.toString(nums[i]); } Arrays.sort(strs, new Comparator&lt;String&gt;(){ @Override public int compare(String s1, String s2){ return (s2+s1).compareTo(s1+s2); } }); StringBuilder sb = new StringBuilder(); for(int i=0; i&lt;nums.length; i++) { sb.append(strs[i]); } if(sb.toString().startsWith(\"0\")) return \"0\"; return sb.toString(); }}","link":"/leetcode/leetcode-179-Largest-Number.html"},{"title":"leetcode 162. Find Peak Element","text":"难度：Middleleetcode九章 题目描述A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak elementand return its index. The array may contain multiple peaks, in that case return the index to any oneof the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: **nums** = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.Example 2: Input: **nums** = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.Note: Your solution should be in logarithmic complexity. Tags: Array, Binary Search Difficulty: Medium 答案 1234567891011121314class Solution { public int findPeakElement(int[] nums) { int n = nums.length; if(n==1) return 0; // 找到第一个开始下降的数字 for(int i=0; i&lt;n-1; i++) { if(nums[i]&gt;nums[i+1]) { return i; } } // 没找到返回最后一个 return n-1; }}","link":"/leetcode/leetcode-162-Find-Peak-Element.html"},{"title":"leetcode 189. Rotate Array","text":"难度：Easyleetcode九章 题目描述Given an array, rotate the array to the right by k steps, where k isnon-negative. Example 1: Input: [1,2,3,4,5,6,7] and _k_ = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]Example 2: Input: [-1,-100,3,99] and _k_ = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Tags: Array Difficulty: Easy 答案 12345678910111213141516171819202122class Solution { public void rotate(int[] nums, int k) { // [1,2,3,4,5,6,7] k = 3 // 1. reverse整个数组 [7654321] // 2. reverse 123 , reverse 4567 // [5,6,7,1,2,3,4] int n = nums.length; k %= n; reverse(nums, 0, n-1); reverse(nums, 0, k-1); reverse(nums, k, n-1); } private void reverse(int[] nums, int start, int end) { while(start&lt;end){ int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; } }}","link":"/leetcode/leetcode-189-Rotate-Array.html"},{"title":"leetcode 202. Happy Number","text":"题目描述Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with anypositive integer, replace the number by the sum of the squares of its digits,and repeat the process until the number equals 1 (where it will stay), or itloops endlessly in a cycle which does not include 1. Those numbers for whichthis process ends in 1 are happy numbers. *Example: * Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1Tags: Hash Table, Math Difficulty: Easy 答案 123456789101112131415161718192021class Solution { public boolean isHappy(int n) { HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(n!=1){ if(!set.add(n)){ return false; } n = trans(n); } return true; } private int trans(int n){ int res = 0; while(n!=0){ res += (int)Math.pow(n%10, 2); n = n/10; } return res; } }","link":"/leetcode/leetcode-202-Happy%20Number.html"},{"title":"leetcode 204. Count Primes","text":"题目描述Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.Tags: Hash Table, Math Difficulty: Easy 答案 12345678910111213141516171819class Solution { public int countPrimes(int n) { if(n&lt;=2) return 0; // 加上 n+1 boolean[] b = new boolean[n]; int res = 0; for(int i=2; i&lt;n; i++){ // 是默认值false &lt;-&gt; 是质数 if(!b[i]) { res++; // 将质数的整数标记为非质数 for(int j=2; i*j&lt;n; j++){ b[i*j] = true; } } } return res; }}","link":"/leetcode/leetcode-204-Count%20Primes.html"},{"title":"leetcode 208. Implement Trie (Prefix Tree)","text":"难度：Middleleetcode九章 题目描述Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie(); trie.insert(&quot;apple&quot;); trie.search(&quot;apple&quot;); // returns true trie.search(&quot;app&quot;); // returns false trie.startsWith(&quot;app&quot;); // returns true trie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns trueNote: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. Tags: Design, Trie Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Trie { class Node { boolean hasWord = false; char c; Map&lt;Character, Node&gt; children = new HashMap&lt;&gt;(); public Node(){} public Node(char c){ this.c = c; } } Node root; public Trie() { root = new Node(); } public void insert(String word) { Node cur = root; Node temp; for(char c: word.toCharArray()) { if(!cur.children.containsKey(c)) { temp = new Node(c); cur.children.put(c, temp); } cur = cur.children.get(c); } cur.hasWord = true; } public boolean search(String word) { Node cur = root; for(char c: word.toCharArray()) { if(!cur.children.containsKey(c)) { return false; }else{ cur = cur.children.get(c); } } return cur.hasWord; } public boolean startsWith(String prefix) { Node cur = root; for(char c: prefix.toCharArray()) { if(!cur.children.containsKey(c)) { return false; }else{ cur = cur.children.get(c); } } return true; }}","link":"/leetcode/leetcode-208-Implement-Trie-Prefix-Tree.html"},{"title":"leetcode 230. Kth Smallest Element in a BST","text":"难度：Middleleetcode九章 题目描述Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3Follow up:What if the BST is modified (insert/delete operations) often and you need tofind the kth smallest frequently? How would you optimize the kthSmallestroutine? Tags: Binary Search, Tree Difficulty: Medium 答案 12345678910111213141516171819class Solution { public int kthSmallest(TreeNode root, int k) { // 中序遍历第k个元素 // 中序遍历：将左节点压栈，直到为空，弹栈，转向右节点 // 弹栈的顺序就是中序遍历 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root!=null || !stack.isEmpty()){ while(root!=null){ stack.push(root); root = root.left; } root = stack.pop(); k--; if(k==0) return root.val; root = root.right; } return 0; }}","link":"/leetcode/leetcode-230-Kth-Smallest-Element-in-a-BST.html"},{"title":"leetcode 215. Kth Largest Element in an Array","text":"题目描述Find the k th largest element in an unsorted array. Note that it is thekth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. Tags: Divide and Conquer, Heap Difficulty: Medium 答案 123456789101112class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(k, Collections.reverseOrder()); for(int num: nums){ priorityQueue.add(num); } for(int i=0; i&lt;k-1; i++){ priorityQueue.poll(); } return priorityQueue.poll(); }}","link":"/leetcode/leetcode-215-Kth%20Largest%20Element%20in%20an%20Array.html"},{"title":"leetcode 229. Majority Element II","text":"难度：Middleleetcode九章 题目描述Given an integer array of size n , find all elements that appear more than⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: Input: [3,2,3] Output: [3]Example 2: Input: [1,1,1,3,3,2,2,2] Output: [1,2]Tags: Array Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930313233343536373839// https://leetcode-cn.com/problems/majority-element-ii/solution/duo-shu-tou-piao-de-sheng-ji-ban-hao-li-jie-java-b/class Solution { public List&lt;Integer&gt; majorityElement(int[] nums) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0){ return res; } int major1=nums[0], major2=nums[0], count1=0, count2=0; for(int n: nums) { if(major1==n){ count1++; }else if(major2==n){ count2++; }else if(count1==0){ major1 = n; count1++; }else if(count2==0){ major2 = n; count2++; }else{ count1--; count2--; } } count1 = 0; count2 = 0; for(int n: nums) { if(n==major1) count1++; else if(n==major2) count2++; } if(count1&gt;nums.length/3) { res.add(major1); } if(count2&gt;nums.length/3){ res.add(major2); } return res; }}","link":"/leetcode/leetcode-229-Majority-Element-II.html"},{"title":"leetcode 217. Contains Duplicate","text":"题目描述Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in thearray, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: trueExample 2: Input: [1,2,3,4] Output: falseExample 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: trueTags: Array, Hash Table Difficulty: Easy 答案 1234567891011class Solution { public boolean containsDuplicate(int[] nums) { HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num: nums){ if(!set.add(num)){ return true; } } return false; }}","link":"/leetcode/leetcode-217-Contains%20Duplicate.html"},{"title":"leetcode 236. Lowest Common Ancestor of a Binary Tree","text":"难度：Middleleetcode九章 题目描述Given a binary tree, find the lowest common ancestor (LCA) of two given nodesin the tree. According to the definition of LCA onWikipedia: “The lowestcommon ancestor is defined between two nodes p and q as the lowest node in Tthat has both p and q as descendants (where we allow a node to be adescendant of itself ).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. Tags: Tree Difficulty: Medium 答案 1234567891011121314151617class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { //找 P 或 Q, 或者没找到 if(root==null || root==q || root==p) return root; //左边查询结果 TreeNode left = lowestCommonAncestor(root.left, p, q); //右边查询结果 TreeNode right = lowestCommonAncestor(root.right, p, q); //因为肯定有这两个节点，所以如果一边是空，另一边查到了 p 或 q 任意一个，那个就是目标节点 //如果两边都查到了，肯定是一个 q,一个p ,所以直接返回顶部的就行。 //两边都没查到的话 就不存在这种情况了 if(left==null) return right; else if(right==null) return left; return root; }}","link":"/leetcode/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree.html"},{"title":"leetcode 237. Delete Node in a Linked List","text":"难度：Easyleetcode九章 题目描述Write a function to delete a node (except the tail) in a singly linked list,given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Tags: Linked List Difficulty: Easy 答案 1234567class Solution { public void deleteNode(ListNode node) { // 先把当前节点的值用下一个节点的值覆盖，然后删除下一个节点 node.val = node.next.val; node.next = node.next.next; }}","link":"/leetcode/leetcode-237-Delete-Node-in-a-Linked-List.html"},{"title":"leetcode 238. Product of Array Except Self","text":"难度：Middleleetcode九章 题目描述Given an array nums of n integers where n &gt; 1, return an array outputsuch that output[i] is equal to the product of all the elements of numsexcept nums[i]. Example: Input: [1,2,3,4] Output: [24,12,8,6]Note: Please solve it without division and in O( n ). Follow up:Could you solve it with constant space complexity? (The output array doesnot count as extra space for the purpose of space complexity analysis.) Tags: Array Difficulty: Medium 答案 12345678910111213141516171819class Solution { public int[] productExceptSelf(int[] nums) { // 1 2 3 4 // 1 1 2 6 从左往右累乘前面的数 // 24 12 8 6 从右往左累乘后面的数 int n = nums.length; int[] res = new int[n]; res[0] = 1; for(int i=1; i&lt;n; i++){ res[i] = res[i-1]*nums[i-1]; } int right = nums[n-1]; for(int i=n-2; i&gt;=0; i--){ res[i] = res[i] * right; right *= nums[i]; } return res; }}","link":"/leetcode/leetcode-238-Product-of-Array-Except-Self.html"},{"title":"leetcode 239. Sliding Window Maximum","text":"难度：Hardleetcode九章 题目描述Given an array nums , there is a sliding window of size k which is movingfrom the very left of the array to the very right. You can only see the knumbers in the window. Each time the sliding window moves right by oneposition. Return the max sliding window. Example: Input: _nums_ = [1,3,-1,-3,5,3,6,7], and _k_ = 3 Output:[3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 **3** 1 [3 -1 -3] 5 3 6 7 **3** 1 3 [-1 -3 5] 3 6 7 **5** 1 3 -1 [-3 5 3] 6 7 **5** 1 3 -1 -3 [5 3 6] 7 **6** 1 3 -1 -3 5 [3 6 7] **7**Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-emptyarray. Follow up:Could you solve it in linear time? Tags: Heap, Sliding Window Difficulty: Hard 答案 12345678910111213141516171819202122232425262728// /Volumes/My Passport/data/ut下载/03 算法/高频算法面试题精讲/3. 3栈和队列面试题精讲.mp4 例6// julyedu.comclass Solution { public int[] maxSlidingWindow(int[] nums, int k) { if(k&lt;=1) return nums; // 存放索引 Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); int n = nums.length; int[] res = new int[n-(k-1)]; // 添加前k-1个数 for(int i=0; i&lt;k-1; i++) { // 若即将插入的值比之前的数大，删除旧的数字，因为新数更晚被删除，旧数永远不会被选中 while(!deque.isEmpty()&amp;&amp;nums[deque.getLast()]&lt;=nums[i]) deque.pollLast(); deque.add(i); } for(int i=k-1; i&lt;n; i++) { while(!deque.isEmpty()&amp;&amp;nums[deque.getLast()]&lt;=nums[i]) deque.pollLast(); // 0 &lt;-&gt; k-1 // 第0个数在i=k-1时保留 // 删除窗口之前的数字 while(!deque.isEmpty()&amp;&amp;deque.getFirst()&lt;i-(k-1)) deque.pollFirst(); deque.add(i); res[i-(k-1)] = nums[deque.getFirst()]; } return res; }}","link":"/leetcode/leetcode-239-Sliding-Window-Maximum.html"},{"title":"leetcode 242. Valid Anagram","text":"难度：Easyleetcode九章 题目描述Given two strings s and t _, write a function to determine if _t is ananagram of s. Example 1: Input: _s_ = &quot;anagram&quot;, _t_ = &quot;nagaram&quot; Output: trueExample 2: Input: _s_ = &quot;rat&quot;, _t_ = &quot;car&quot; Output: falseNote:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt yoursolution to such case? Tags: Hash Table, Sort Difficulty: Easy 答案 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public boolean isAnagram_0(String s, String t) { HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c: s.toCharArray()){ if(!map.containsKey(c)){ map.put(c, 1); }else{ map.put(c, map.get(c)+1); } } for(char c: t.toCharArray()){ if(!map.containsKey(c)){ return false; }else{ if(map.get(c)==1){ map.remove(c); }else{ map.put(c, map.get(c)-1); } } } return map.isEmpty(); } public boolean isAnagram(String s, String t) { if(s.length()!=t.length()) return false; int[] is = new int[256]; int[] it = new int[256]; for(char c: s.toCharArray()){ is[c]++; } for(char c: t.toCharArray()){ it[c]++; } for(int i=0; i&lt;256; i++){ if(is[i]!=it[i]){ return false; } } return true; }}","link":"/leetcode/leetcode-242-Valid-Anagram.html"},{"title":"leetcode 24. Swap Nodes in Pairs","text":"难度：Middleleetcode九章 题目描述Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself maybe changed. Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Tags: Linked List Difficulty: Medium 答案 12345678910111213141516171819202122class Solution { public ListNode swapPairs(ListNode head) { if(head==null || head.next==null) return head; ListNode dummy = new ListNode(0); ListNode fast = head.next, slow = head, pre = dummy; swap(fast, slow, pre); head = slow; while(slow.next!=null &amp;&amp; slow.next.next!=null){ pre = slow; fast = slow.next.next; slow = slow.next; swap(fast, slow, pre); } return dummy.next; } private void swap(ListNode fast, ListNode slow, ListNode pre){ ListNode next = fast.next; fast.next = slow; slow.next = next; pre.next = fast; }}","link":"/leetcode/leetcode-24-Swap-Nodes-in-Pairs.html"},{"title":"leetcode 268. Missing Number","text":"难度：Easyleetcode九章 题目描述Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8Note :Your algorithm should run in linear runtime complexity. Could you implement itusing only constant extra space complexity? Tags: Array, Math, Bit Manipulation Difficulty: Easy 答案 123456789101112131415161718192021class Solution { public int missingNumber(int[] nums) { for(int i=0; i&lt;nums.length; i++){ while(i!=nums[i]){ if(nums[i]&gt;=nums.length || nums[i]&lt;0) break; swap(nums, i, nums[i]); } } for(int i=0; i&lt;nums.length; i++){ if(i!=nums[i]){ return i; } } return nums.length; } private void swap(int[] nums, int a, int b){ int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; }}","link":"/leetcode/leetcode-268-Missing-Number.html"},{"title":"leetcode 240. Search a 2D Matrix II","text":"难度：Middleleetcode九章 题目描述Write an efficient algorithm that searches for a value in an m x n matrix.This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]Given target = 5, return true. Given target = 20, return false. Tags: Binary Search, Divide and Conquer Difficulty: Medium 答案 123456789101112131415161718class Solution { public boolean searchMatrix(int[][] ma, int t) { if(ma==null || ma.length==0 || ma[0].length==0) return false; int n = ma.length; int m = ma[0].length; int i=n-1, j=0; while(i&gt;=0 &amp;&amp; j&lt;m) { if(ma[i][j]==t){ return true; }else if(ma[i][j]&gt;t){ i--; }else{ j++; } } return false; }}","link":"/leetcode/leetcode-240-Search-a-2D-Matrix-II.html"},{"title":"leetcode 278. First Bad Version","text":"难度：Easyleetcode九章 题目描述You are a product manager and currently leading a team to develop a newproduct. Unfortunately, the latest version of your product fails the qualitycheck. Since each version is developed based on the previous version, all theversions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out thefirst bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whetherversion is bad. Implement a function to find the first bad version. Youshould minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; false call isBadVersion(5) -&gt; true call isBadVersion(4) -&gt; true Then 4 is the first bad version. Tags: Binary Search Difficulty: Easy 答案 12345678910111213141516/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */// https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode/public class Solution extends VersionControl { public int firstBadVersion(int n) { int start = 0, end = n; while(start&lt;end) { int mid = start+(end-start)/2; if(isBadVersion(mid)) end = mid; else start = mid+1; } return start; }}","link":"/leetcode/leetcode-278-First-Bad-Version.html"},{"title":"leetcode 287. Find the Duplicate Number","text":"难度：Middleleetcode九章 题目描述Given an array nums containing n + 1 integers where each integer isbetween 1 and n (inclusive), prove that at least one duplicate number mustexist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2Example 2: Input: [3,1,3,4,2] Output: 3Note: You must not modify the array (assume the array is read only). You must use only constant, O (1) extra space. Your runtime complexity should be less than O ( n 2). There is only one duplicate number in the array, but it could be repeated more than once. Tags: Array, Two Pointers, Binary Search Difficulty: Medium 答案 123456789101112131415161718class Solution { public int findDuplicate(int[] nums) { // 快慢指针，找环 // 首先找到相遇的位置 int slow = 0, fast = 0; do{ fast = nums[nums[fast]]; slow = nums[slow]; }while(slow!=fast); // 再将一个指针移到队首，直至相遇，即为环的起点 slow = 0; while(slow!=fast){ slow = nums[slow]; fast = nums[fast]; } return fast; }}","link":"/leetcode/leetcode-287-Find-the-Duplicate-Number.html"},{"title":"leetcode 279. Perfect Squares","text":"难度：Middleleetcode九章 题目描述Given a positive integer n , find the least number of perfect square numbers(for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: _n_ = 12 Output: 3 Explanation:12 = 4 + 4 + 4.Example 2: Input: _n_ = 13 Output: 2 Explanation:13 = 4 + 9.Tags: Math, Dynamic Programming, Breadth-first Search Difficulty: Medium 答案 123456789101112131415161718192021class Solution { public int numSquares(int n) { // 四平方和定理 // 一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果 // 一个数除以8余7，那么肯定是由4个完全平方数组成 while(n%4==0) n/=4; if(n%8==7) return 4; // dp[i] = min(dp[i], dp[i-j*j]+1) (j*j&lt;i) int[] dp = new int[n+1]; Arrays.fill(dp, Integer.MAX_VALUE); for(int i=0; i*i&lt;=n; i++){ dp[i*i] = 1; } for(int i=0; i&lt;=n; i++) { for(int j=0; i+j*j&lt;=n; j++){ dp[i+j*j] = Math.min(dp[i]+1, dp[i+j*j]); } } return dp[n]; }}","link":"/leetcode/leetcode-279-Perfect-Squares.html"},{"title":"leetcode 289. Game of Life","text":"难度：Middleleetcode九章 题目描述According to the Wikipedia’sarticle: “The Gameof Life , also known simply as Life , is a cellular automaton devised bythe British mathematician John Horton Conway in 1970.” Given a board with m by n cells, each cell has an initial state live(1) or dead (0). Each cell interacts with its eightneighbors (horizontal,vertical, diagonal) using the following four rules (taken from the aboveWikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the boardgiven its current state. The next state is created by applying the above rulessimultaneously to every cell in the current state, where births and deathsoccur simultaneously. Example: Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ]Follow up : Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? Tags: Array Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930313233343536373839404142// 二位二进制数表示状态变化， 下一状态_当前状态// 00: 0 die to die// 01: 1 live to die// 10: 2 die to live// 11: 3 live to liveclass Solution { private int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1} }; public void gameOfLife(int[][] b) { if(b==null || b.length==0) return; int n = b.length, m = b[0].length; for(int i=0; i&lt;n; i++){ for(int j=0; j&lt;m; j++){ update(b, n, m, i, j); } } for(int i=0; i&lt;n; i++){ for(int j=0; j&lt;m; j++){ b[i][j] = b[i][j]&gt;&gt;1; } } } private void update(int[][] b, int n, int m, int i, int j){ int count = 0; for(int[] direction: directions){ int ii = i+direction[0], jj = j+direction[1]; if(ii&lt;0 || ii&gt;= n || jj&lt;0 || jj&gt;=m) continue; count += b[ii][jj]%2==1?1:0; } if(b[i][j]==1){ if(count&lt;2 || count&gt;3) b[i][j] = 1; else b[i][j] = 3; }else{ if(count==3){ b[i][j] = 2; } } }}","link":"/leetcode/leetcode-289-Game-of-Life.html"},{"title":"leetcode 3. Longest Substring Without Repeating Characters","text":"难度：Middleleetcode九章 题目描述Given a string, find the length of the longest substring without repeatingcharacters. Example 1: Input: &quot;abcabcbb&quot; Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: Input: &quot;bbbbb&quot; Output: 1 Explanation: The answer is &quot;b&quot;, with the length of 1.Example 3: Input: &quot;pwwkew&quot; Output: 3 Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a **substring** , &quot;pwke&quot; is a _subsequence_ and not a substring.Tags: Hash Table, Two Pointers, String, Sliding Window Difficulty: Medium 答案 12345678910111213141516// https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/class Solution { public int lengthOfLongestSubstring(String s) { int res=0; int[] map = new int[128]; // char: index+1 for(int i=0, j=0; j&lt;s.length(); j++) { char c = s.charAt(j); // 若c在map中, i是c的索引加一 // 不能用map[c]+1,因为会比i=0大 i = Math.max(map[c], i); map[c] = j+1; res = Math.max(res, j-i+1); } return res; }}","link":"/leetcode/leetcode-3-Longest-Substring-Without-Repeating-Characters.html"},{"title":"leetcode 29. Divide Two Integers","text":"难度：Middleleetcode九章 题目描述Given two integers dividend and divisor, divide two integers without usingmultiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3Example 2: Input: dividend = 7, divisor = -3 Output: -2Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Tags: Math, Binary Search Difficulty: Medium 答案 12345678910111213141516171819202122232425262728293031class Solution { public int divide(int dividend, int divisor) { // a/b = c // c*b &lt;= a &lt;= (c+1)*b if(divisor==0) return dividend&gt;=0?Integer.MAX_VALUE:Integer.MIN_VALUE; if(dividend==0) return 0; // -2147483648 / -1 if(dividend==Integer.MIN_VALUE &amp;&amp; divisor==-1) return Integer.MAX_VALUE; if(dividend==Integer.MIN_VALUE &amp;&amp; divisor==1) return Integer.MIN_VALUE; boolean sign = (dividend&gt;0&amp;&amp;divisor&gt;0) || (dividend&lt;0&amp;&amp;divisor&lt;0); long a = Math.abs((long)dividend); long b = Math.abs((long)divisor); long result = 0; while(a&gt;=b){ int shift = 0; while(a&gt;(b&lt;&lt;shift)){ shift++; } if(shift&gt;1){ a -= b&lt;&lt;(shift-1); result += 1&lt;&lt;(shift-1); }else{ a -= b; result += 1; } } if(result&gt;Integer.MAX_VALUE) return Integer.MAX_VALUE; return sign?(int)result:(int)-result; }}","link":"/leetcode/leetcode-29-Divide-Two-Integers.html"},{"title":"leetcode 297. Serialize and Deserialize Binary Tree","text":"难度：Hardleetcode九章 题目描述Serialization is the process of converting a data structure or object into asequence of bits so that it can be stored in a file or memory buffer, ortransmitted across a network connection link to be reconstructed later in thesame or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is norestriction on how your serialization/deserialization algorithm should work.You just need to ensure that a binary tree can be serialized to a string andthis string can be deserialized to the original tree structure. *Example: * You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5 as &quot;[1,2,3,null,null,4,5]&quot;Clarification: The above format is the same as how LeetCode serializes abinary tree. You do not necessarily need to follow thisformat, so please be creative and come up with different approaches yourself. *Note: *Do not use class member/global/static variables to store states.Your serialize and deserialize algorithms should be stateless. Tags: Tree, Design Difficulty: Hard 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { // 前序遍历 StringBuilder sb = new StringBuilder(); serializeHelper(root, sb); System.out.println(sb.toString()); return sb.substring(1, sb.length()).toString(); } private void serializeHelper(TreeNode root, StringBuilder sb){ if(root==null) { sb.append(\" #\"); return; } sb.append(\" \"); sb.append(String.valueOf(root.val)); serializeHelper(root.left, sb); serializeHelper(root.right, sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data==null || data.length()==0) return null; String[] temp = data.split(\" \"); List&lt;String&gt; strs = new ArrayList&lt;&gt;(); for(String s: temp){ strs.add(s); } return deserializeHelper(strs); } private TreeNode deserializeHelper(List&lt;String&gt; strs){ if(strs==null || strs.size()==0) return null; String str = strs.get(0); strs.remove(str); if(str.equals(\"#\")) return null; TreeNode node = new TreeNode(Integer.parseInt(str)); node.left = deserializeHelper(strs); node.right = deserializeHelper(strs); return node; }}// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root));","link":"/leetcode/leetcode-297-Serialize-and-Deserialize-Binary-Tree.html"},{"title":"leetcode 300. Longest Increasing Subsequence","text":"难度：Middleleetcode九章 题目描述Given an unsorted array of integers, find the length of longest increasingsubsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O( n 2) complexity. Follow up: Could you improve it to O( n log n ) time complexity? Tags: Binary Search, Dynamic Programming Difficulty: Medium 答案 1234567891011121314151617181920// Dp[i] 表示以第i个数字为结尾的最长上升子序列的长度。// 对于每个数字，枚举前面所有小于自己的数字 j，Dp[i] = max{Dp[j]} + 1. 如果没有比自己小的，Dp[i] = 1;class Solution { public int lengthOfLIS(int[] nums) { if(nums==null || nums.length==0) return 0; int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); int res = 1; for(int i=1; i&lt;n; i++) { for(int j=i-1; j&gt;=0; j--) { if(nums[i]&gt;nums[j]){ dp[i] = Math.max(dp[j]+1, dp[i]); } } res = Math.max(res, dp[i]); } return res; }}","link":"/leetcode/leetcode-300-Longest-Increasing-Subsequence.html"},{"title":"leetcode 328. Odd Even Linked List","text":"难度：Middleleetcode九章 题目描述Given a singly linked list, group all odd nodes together followed by the evennodes. Please note here we are talking about the node number and not the valuein the nodes. You should try to do it in place. The program should run in O(1) spacecomplexity and O(nodes) time complexity. Example 1: Input:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output:1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULLExample 2: Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL Output:2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULLNote: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … Tags: Linked List Difficulty: Medium 答案 123456789101112131415161718class Solution { public ListNode oddEvenList(ListNode head) { if(head==null || head.next==null) return head; ListNode odd = head, even = head.next, evenHead = even; // odd even // 1 2 3 // while(even!=null &amp;&amp; even.next!=null){ odd.next = even.next; even.next = even.next.next; odd = odd.next; even = even.next; } odd.next = evenHead; return head; }}","link":"/leetcode/leetcode-328-Odd-Even-Linked-List.html"},{"title":"leetcode 334. Increasing Triplet Subsequence","text":"难度：Middleleetcode九章 题目描述Given an unsorted array return whether an increasing subsequence of length 3exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n -1else return false. Note: Your algorithm should run in O( n ) time complexity and O( 1 )space complexity. Example 1: Input: [1,2,3,4,5] Output: trueExample 2: Input: [5,4,3,2,1] Output: falseTags: Difficulty: Medium 答案 123456789101112131415class Solution { public boolean increasingTriplet(int[] nums) { int one = Integer.MAX_VALUE, two = one; for(int n: nums){ if(n&lt;=one){ one = n; }else if(n&lt;=two) { two = n; }else{ return true; } } return false; }}","link":"/leetcode/leetcode-334-Increasing-Triplet-Subsequence.html"},{"title":"leetcode 34. Find First and Last Position of Element in Sorted Array","text":"难度：Middleleetcode九章 题目描述Given an array of integers nums sorted in ascending order, find the startingand ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O (log n ). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]Tags: Array, Binary Search Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public int[] searchRange(int[] nums, int target) { int[] res = new int[]{-1, -1}; if(nums==null || nums.length==0) return res; // end 为nums.length 为了确保能进while, 如[0]的情况不会进入while int start = 0, end = nums.length, mid = start+(end-start)/2; // 第一次二分的过程，确定第二次二分的end int max = end; while(start &lt; end){ mid = start+(end-start)/2; if(nums[mid]==target) { if(mid==0 || nums[mid-1]!=target) { res[0] = mid; break; }else { end = mid; } }else if(nums[mid]&gt;target){ max = mid; end = mid; }else { // 没有target的情况下，直接返回 if(mid+1&gt;=nums.length || nums[mid+1]&gt;target){ return res; } start = mid; } } end = max; while(start &lt; end){ mid = start+(end-start)/2; if(nums[mid]==target) { if(mid==nums.length-1 || nums[mid+1]!=target) { res[1] = mid; break; }else { start = mid; } }else if(nums[mid]&gt;target){ end = mid; }else { start = mid; } } return res; }}","link":"/leetcode/leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html"},{"title":"leetcode 350. Intersection of Two Arrays II","text":"难度：Easyleetcode九章 题目描述Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1 ‘s size is small compared to nums2 ‘s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Tags: Hash Table, Two Pointers, Binary Search, Sort Difficulty: Easy 答案 123456789101112131415161718192021222324252627282930313233class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); List&lt;Integer&gt; res; for(int n: nums1){ if(!m.containsKey(n)){ m.put(n, 1); }else{ m.put(n, m.get(n)+1); } } res = new ArrayList&lt;&gt;(); for(int n: nums2){ if(m.containsKey(n)){ res.add(n); int num = m.get(n); if(num==1){ m.remove(n); }else{ m.put(n, num-1); } } if(m.isEmpty()) break; } int[] ress = new int[res.size()]; for(int i=0; i&lt;res.size(); i++){ ress[i] = res.get(i); } return ress; }}","link":"/leetcode/leetcode-350-Intersection-of-Two-Arrays-II-1.html"},{"title":"leetcode 341. Flatten Nested List Iterator","text":"难度：Middleleetcode九章 题目描述Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also beintegers or other lists. Example 1: Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling _next_ repeatedly until _hasNext_ returns false, the order of elements returned by _next_ should be: [1,1,2,1,1].Example 2: Input: [1,[4,[6]]] Output: [1,4,6] Explanation: By calling _next_ repeatedly until _hasNext_ returns false, the order of elements returned by _next_ should be: [1,4,6].Tags: Stack, Design Difficulty: Medium 答案 12345678910111213141516171819202122232425262728293031public class NestedIterator implements Iterator&lt;Integer&gt; { private Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); public NestedIterator(List&lt;NestedInteger&gt; l) { for(int i=l.size()-1; i&gt;=0; i--){ stack.push(l.get(i)); // System.out.println(\"push\"); } } @Override public Integer next() { if (!hasNext()) { return null; } return stack.pop().getInteger(); } @Override public boolean hasNext() { while(!stack.isEmpty() &amp;&amp; !stack.peek().isInteger()){ List&lt;NestedInteger&gt; l = stack.pop().getList(); for(int i=l.size()-1; i&gt;=0; i--){ stack.push(l.get(i)); } } return !stack.isEmpty(); }}","link":"/leetcode/leetcode-341-Flatten-Nested-List-Iterator.html"},{"title":"leetcode 344. Reverse String","text":"难度：Easyleetcode九章 题目描述Write a function that reverses a string. The input string is given as an arrayof characters char[]. Do not allocate extra space for another array, you must do this by modifyingthe input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with O(1) extra memory. You may assume all the characters consist of printable asciicharacters. Example 1: Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]Example 2: Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]Tags: Two Pointers, String Difficulty: Easy 答案 12345678910111213class Solution { public void reverseString(char[] s) { if(s==null || s.length==0) return; int i = 0, j = s.length-1; while(i&lt;j){ char t = s[i]; s[i] = s[j]; s[j] = t; i++; j--; } }}","link":"/leetcode/leetcode-344-Reverse-String.html"},{"title":"leetcode 118. Pascal's Triangle","text":"难度：Easyleetcode九章 题目描述Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9]Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1 ‘s size is small compared to nums2 ‘s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Tags: Hash Table, Two Pointers, Binary Search, Sort Difficulty: Easy 答案 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int n) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(n==0) return res; List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); l.add(1); res.add(new ArrayList&lt;&gt;(l)); if(n==1) { return res; } l.add(1); res.add(new ArrayList&lt;&gt;(l)); if(n==2) { return res; } for(int i=3; i&lt;=n; i++) { List&lt;Integer&gt; last = res.get(res.size()-1); l.clear(); l.add(1); // i=3-&gt;[1] for(int j=1; j&lt;=i-2; j++){ l.add(last.get(j-1)+last.get(j)); } l.add(1); res.add(new ArrayList&lt;&gt;(l)); } return res; }}","link":"/leetcode/leetcode-350-Intersection-of-Two-Arrays-II.html"},{"title":"leetcode 347. Top K Frequent Elements","text":"难度：Middleleetcode九章 题目描述Given a non-empty array of integers, return the k most frequentelements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]Example 2: Input: nums = [1], k = 1 Output: [1]Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O( n log n ), where n is the array’s size. Tags: Hash Table, Heap Difficulty: Medium 答案 12345678910111213141516171819202122232425262728class Solution { public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { if(nums==null || nums.length==0) return null; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num: nums){ if(!map.containsKey(num)){ map.put(num, 1); }else{ map.put(num, 1+map.get(num)); } } PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; priorityQueue = new PriorityQueue&lt;&gt;(k, (j, i)-&gt;(i.getValue() - j.getValue())); for(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()){ priorityQueue.add(entry); } // 为什么取出了所有的值？ // while(!priorityQueue.isEmpty()){ // res.add(priorityQueue.poll().getKey()); // } for(int i=0; i&lt;k; i++){ res.add(priorityQueue.poll().getKey()); } return res; }}","link":"/leetcode/leetcode-347-Top-K-Frequent-Elements.html"},{"title":"leetcode 36. Valid Sudoku","text":"难度：Middleleetcode九章 题目描述Determine if a 9x9 Sudoku board is valid. Only the filled cells need to bevalidated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. ![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled withthe character '.'. Example 1: Input: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] Output: trueExample 2: Input: [ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] Output: false Explanation: Same as Example 1, except with the **5** in the top left corner being modified to **8**. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9. Tags: Hash Table Difficulty: Medium 答案 12345678910111213141516171819202122232425262728class Solution { public boolean isValidSudoku(char[][] cs) { HashSet&lt;Character&gt; row = new HashSet&lt;&gt;(); HashSet&lt;Character&gt; col = new HashSet&lt;&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;&gt;(); for(int i=0; i&lt;9; i++){ row.clear(); col.clear(); cube.clear(); for(int j=0; j&lt;9; j++){ if(cs[i][j]!='.' &amp;&amp; !row.add(cs[i][j])) return false; if(cs[j][i]!='.' &amp;&amp; !col.add(cs[j][i])) return false; // i 确定 是哪个cube // 0 1 2 // 3 4 5 // 6 7 8 // rowIndex colIndex 起始为cube左上角坐标 int rowIndex = 3*(i/3); int colIndex = 3*(i%3); // j 确定是cube的哪个点 int rowi = rowIndex+j/3; int coli = colIndex+j%3; if(cs[rowi][coli]!='.' &amp;&amp; !cube.add(cs[rowi][coli])) return false; } } return true; }}","link":"/leetcode/leetcode-36-Valid-Sudoku.html"},{"title":"leetcode 378. Kth Smallest Element in a Sorted Matrix","text":"难度：Middleleetcode九章 题目描述Given a n x n matrix where each of the rows and columns are sorted inascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kthdistinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13.Note:You may assume k is always valid, 1 ≤ k ≤ n2. Tags: Binary Search, Heap Difficulty: Medium 答案 1234567891011121314151617class Solution { // priorityQueue // Runtime: 30 ms, faster than 22.86% of Java online submissions // Memory Usage: 43 MB, less than 83.78% of Java online submissions public int kthSmallest_0(int[][] ma, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(k); for(int i=0; i&lt;ma.length; i++){ for(int j=0; j&lt;ma[0].length; j++){ pq.add(ma[i][j]); } } for(int i=0; i&lt;k-1; i++) { pq.poll(); } return pq.poll(); }}","link":"/leetcode/leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix.html"},{"title":"leetcode 380. Insert Delete GetRandom O(1)","text":"难度：Middleleetcode九章 题目描述Design a data structure that supports all following operations in averageO(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet(); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1); // Returns false as 2 does not exist in the set. randomSet.remove(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2); // getRandom should return either 1 or 2 randomly. randomSet.getRandom(); // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1); // 2 was already in the set, so return false. randomSet.insert(2); // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();Tags: Array, Hash Table, Design Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445class RandomizedSet { List&lt;Integer&gt; l; // val Map&lt;Integer, Integer&gt; map; // val to index Random r; public RandomizedSet() { l = new ArrayList&lt;&gt;(); map = new HashMap&lt;&gt;(); r = new Random(); } public boolean insert(int val) { if(map.containsKey(val)){ return false; }else{ l.add(val); map.put(val, l.size()-1); return true; } } public boolean remove(int val) { if(map.containsKey(val)){ int index = map.get(val); if(index!=l.size()-1){ int end = l.get(l.size()-1); l.set(index, end); map.put(end, index); } l.remove(l.size()-1); map.remove(val); return true; }else{ return false; } } public int getRandom() { return l.get(r.nextInt(l.size())); }}","link":"/leetcode/leetcode-380-Insert-Delete-GetRandom-O-1.html"},{"title":"leetcode 384. Shuffle an Array","text":"难度：Middleleetcode九章 题目描述Shuffle a set of numbers without duplicates. Example: // Init an array with set 1, 2, and 3. int[] nums = {1,2,3}; Solution solution = new Solution(nums); // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned. solution.shuffle(); // Resets the array back to its original configuration [1,2,3]. solution.reset(); // Returns the random shuffling of array [1,2,3]. solution.shuffle();Tags: Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829class Solution { private int[] origin; private int[] array; private Random rand = new Random(); public Solution(int[] nums) { array = nums; origin = array.clone(); } public int[] reset() { array = origin.clone(); return origin; } public int[] shuffle() { for(int i=0; i&lt;array.length; i++){ swap(array, i, rand.nextInt(array.length-i)+i); } return array; } private void swap(int[] nums, int a, int b){ int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; }}","link":"/leetcode/leetcode-384-Shuffle-an-Array.html"},{"title":"leetcode 409. Longest Palindrome","text":"难度：Easyleetcode九章 题目描述Given a string which consists of lowercase or uppercase letters, find thelength of the longest palindromes that can be built with those letters. This is case sensitive, for example &quot;Aa&quot; is not considered a palindromehere. Note:Assume the length of given string will not exceed 1,010. Example: Input: &quot;abccccdd&quot; Output: 7 Explanation: One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.Tags: Hash Table Difficulty: Easy 答案 123456789101112131415161718192021222324252627282930313233343536// map -&gt; int[256]// 6ms -&gt; 1ms// map iter// for(Map.Entry&lt;A, B&gt; entry: map.entrySet())// for(A key: map.keySet())// for(B value: map.values())class Solution { public int longestPalindrome(String s) { if(s==null || s.length()==0) return 0; // Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int[] map = new int[256]; for(char c: s.toCharArray()) { // if(!map.containsKey(c)){ // map.put(c, 1); // }else{ // map.put(c, 1+map.get(c)); // } map[c]++; } int res = 0; // map的value中是否有奇数 boolean one = false; // for(Integer value: map.values()) { for(int value: map) { if(value%2==1){ one = true; res += value-1; }else{ res += value; } } return res+(one?1:0); }}","link":"/leetcode/leetcode-409-Longest-Palindrome.html"},{"title":"leetcode 387. First Unique Character in a String","text":"难度：Easyleetcode九章 题目描述Given a string, find the first non-repeating character in it and return it’sindex. If it doesn’t exist, return -1. Examples: s = &quot;leetcode&quot; return 0. s = &quot;loveleetcode&quot;, return 2.Note: You may assume the string contain only lowercase letters. Tags: Hash Table, String Difficulty: Easy 答案 123456789101112131415161718192021222324class Solution { public int firstUniqChar(String s) { // map记录char出现次数 int[] map = new int[256]; // start记录char起始的index int[] start = new int[256]; Arrays.fill(start, -1); char[] cs = s.toCharArray(); for(int i=0; i&lt;cs.length; i++) { char c = cs[i]; map[c] += 1; if(start[c]==-1){ start[c] = i; } } int res = Integer.MAX_VALUE; for(int i=0; i&lt;256; i++){ if(map[i]==1){ res = Math.min(res, start[i]); } } return res==Integer.MAX_VALUE?-1:res; }}","link":"/leetcode/leetcode-387-First-Unique-Character-in-a-String.html"},{"title":"leetcode 412. Fizz Buzz","text":"难度：Easyleetcode九章 题目描述Write a program that outputs the string representation of numbers from 1 ton. But for multiples of three it should output “Fizz” instead of the number andfor the multiples of five output “Buzz”. For numbers which are multiples ofboth three and five output “FizzBuzz”. Example: n = 15, Return: [ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot; ]Tags: Difficulty: Easy 答案 123456789101112class Solution { public List&lt;String&gt; fizzBuzz(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); for(int i=0; i&lt;n; i++){ if((i+1)%15==0) res.add(\"FizzBuzz\"); else if((i+1)%5==0) res.add(\"Buzz\"); else if((i+1)%3==0) res.add(\"Fizz\"); else res.add(String.valueOf(i+1)); } return res; }}","link":"/leetcode/leetcode-412-Fizz-Buzz.html"},{"title":"leetcode 39. Combination Sum","text":"难度：Middleleetcode九章 题目描述Given a set of candidate numbers (candidates) (without duplicates)and a target number (target), find all unique combinations in candidateswhere the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited numberof times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, **A solution set is:** [ [7], [2,2,3] ]Example 2: Input: candidates = [2,3,5], target = 8, **A solution set is:** [ [2,2,2,2], [2,3,3], [3,5] ]Tags: Array, Backtracking Difficulty: Medium 答案 123456789101112131415161718192021class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return res; Arrays.sort(nums); helper(nums, target, res, new ArrayList&lt;Integer&gt;(), 0); return res; } private void helper(int[] nums, int target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cur, int start){ if(target==0) { res.add(new ArrayList&lt;&gt;(cur)); }else if(target&gt;0) { // start 去重, 且一个数字可以使用多次，故不是i+1 for(int i=start; i&lt;nums.length; i++){ cur.add(nums[i]); helper(nums, target-nums[i], res, cur, i); cur.remove(cur.size()-1); } } }}","link":"/leetcode/leetcode-39-Combination-Sum.html"},{"title":"leetcode 42. Trapping Rain Water","text":"难度：Hardleetcode九章 题目描述Given n non-negative integers representing an elevation map where the widthof each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. Inthis case, 6 units of rain water (blue section) are being trapped. ThanksMarcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6Tags: Array, Two Pointers, Stack Difficulty: Hard 答案 12345678910111213141516171819202122232425// https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/// 解法3class Solution { public int trap(int[] h) { int n = h.length; if(n&lt;2) return 0; int[] left = new int[n]; int[] right = new int[n]; left[0] = 0; right[n-1] = 0; for(int i=1; i&lt;n; i++){ left[i] = Math.max(left[i-1], h[i-1]); } for(int i=n-2; i&gt;=0; i--){ right[i] = Math.max(right[i+1], h[i+1]); } int res = 0; for(int i=1; i&lt;n; i++){ int min = Math.min(left[i], right[i]); if(h[i]&gt;=min) continue; res += min-h[i]; } return res; }}","link":"/leetcode/leetcode-42-Trapping-Rain-Water.html"},{"title":"leetcode 454. 4Sum II","text":"难度：Middleleetcode九章 题目描述Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N≤ 500. All integers are in the range of -228 to 228 - 1 and the result isguaranteed to be at most 231 - 1. Example: Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0Tags: Hash Table, Binary Search Difficulty: Medium 答案 123456789101112131415161718192021222324class Solution { public int fourSumCount(int[] a, int[] b, int[] c, int[] d) { HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i: a){ for(int j: b){ if(map.containsKey(i+j)){ map.put(i+j, map.get(i+j)+1); }else{ map.put(i+j, 1); } } } int res = 0; for(int i: c){ for(int j: d){ int target = 0 - i - j; if(map.containsKey(target)){ res += map.get(target); } } } return res; }}","link":"/leetcode/leetcode-454-4Sum-II.html"},{"title":"leetcode 46. Permutations","text":"难度：Middleleetcode九章 题目描述Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]Tags: Backtracking Difficulty: Medium 答案 123456789101112131415161718192021222324252627class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { return helper(nums, nums.length); } // 前len个数的组合 private List&lt;List&lt;Integer&gt;&gt; helper(int[] nums, int len) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(nums==null || nums.length==0) return res; if(len==1) { res.add(new ArrayList&lt;&gt;(Arrays.asList(nums[0]))); return res; } // 1 2 2 1 // 插入3 // 3 1 2 1 3 2 1 2 3 // 3 2 1 2 3 1 2 1 3 for(List&lt;Integer&gt; l: helper(nums, len-1)){ for(int i=0; i&lt;=len-1; i++){ List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(l); temp.add(i, nums[len-1]); res.add(temp); } } return res; }}","link":"/leetcode/leetcode-46-Permutations.html"},{"title":"leetcode 461. Hamming Distance","text":"难度：Easyleetcode九章 题目描述The Hamming distance betweentwo integers is the number of positions at which the corresponding bits aredifferent. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.Tags: Bit Manipulation Difficulty: Easy 答案 12345678910111213141516171819202122232425class Solution { public int hammingDistance(int x, int y) { int res = 0; while(!(x==y || (x==0 &amp;&amp; y==0))){ int a = x%2, b = y%2; if(a!=b) res++; x&gt;&gt;=1; y&gt;&gt;=1; } return res; }}class Solution { public int hammingDistance(int x, int y) { int res = 0; int n = x^y; while(n!=0){ res++; // 去除最后一个1 n = n &amp; (n-1); } return res; }}","link":"/leetcode/leetcode-461-Hamming-Distance.html"},{"title":"leetcode 50. Pow(x, n)","text":"难度：Middleleetcode九章 题目描述Implement pow( x , n), which calculates xraised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000Example 2: Input: 2.10000, 3 Output: 9.26100Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] Tags: Math, Binary Search Difficulty: Medium 答案 123456789class Solution { public double myPow(double x, int n) { if(n==0) return 1; if(n==1) return x; if(n==-1) return 1/x; double half = myPow(x, n/2); return half*half*myPow(x, n%2); }};","link":"/leetcode/leetcode-50-Pow-x-n.html"},{"title":"leetcode 48. Rotate Image","text":"难度：Middleleetcode九章 题目描述You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image [in-place](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly.DO NOT allocate another 2D matrix and do the rotation. Example 1: Given **input matrix** = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix **in-place** such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ]Example 2: Given **input matrix** = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix **in-place** such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]Tags: Array Difficulty: Medium 答案 12345678910111213141516171819202122232425class Solution { public void rotate(int[][] m) { // goal: (i, j) --&gt; (j, n-1-i) // step 1: (i, j) --&gt; (j, i) // step 2: (j, i) -- &gt; (j, n-1-i) int n = m.length; // 下三角与上三角互换 for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;=i; j++) { int temp = m[i][j]; m[i][j] = m[j][i]; m[j][i] = temp; } } // 逆转每一行 for(int r=0; r&lt;n; r++) { for(int i=0, j=n-1; i&lt;j; i++, j--){ int temp = m[r][i]; m[r][i] = m[r][j]; m[r][j] = temp; } } }}","link":"/leetcode/leetcode-48-Rotate-Image.html"},{"title":"leetcode 49. Group Anagrams","text":"难度：Middleleetcode九章 题目描述Given an array of strings, group anagrams together. Example: Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Output: [ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;] ]Note: All inputs will be in lowercase. The order of your output does not matter. Tags: Hash Table, String Difficulty: Medium 答案 12345678910111213141516// map.putIfAbsent// map.get(key).add(s)// new ArrayList&lt;&gt;(map.values())class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String s: strs){ char[] cs = s.toCharArray(); Arrays.sort(cs); String key = String.valueOf(cs); map.putIfAbsent(key, new ArrayList&lt;String&gt;()); map.get(key).add(s); } return new ArrayList&lt;&gt;(map.values()); }}","link":"/leetcode/leetcode-49-Group-Anagrams.html"},{"title":"leetcode 538. Convert BST to Greater Tree","text":"难度：Easyleetcode九章 题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that everykey of the original BST is changed to the original key plus sum of all keysgreater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / \\ 2 13 Output: The root of a Greater Tree like this: 18 / \\ 20 13Tags: Tree Difficulty: Easy 答案 12345678910111213// https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-jia-shu-3/class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if(root==null) return root; convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root; }}","link":"/leetcode/leetcode-538-Convert-BST-to-Greater-Tree.html"},{"title":"leetcode 559. Maximum Depth of N-ary Tree","text":"难度：Easyleetcode九章 题目描述Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the rootnode down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal,each group of children is separated by the null value (See examples). Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 Constraints: The depth of the n-ary tree is less than or equal to 1000. The total number of nodes is between [0, 10^4]. Tags: Tree, Depth-first Search, Breadth-first Search Difficulty: Easy 答案 12345678910111213141516171819202122232425262728293031323334353637/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public int maxDepth(Node root) { Deque&lt;Node&gt; deque = new ArrayDeque&lt;&gt;(); if(root==null) return 0; int res = 0; deque.add(root); while(!deque.isEmpty()) { res++; int size = deque.size(); for(int i=0; i&lt;size; i++){ Node node = deque.removeFirst(); for(Node n: node.children) { deque.add(n); } } } return res; }}","link":"/leetcode/leetcode-559-Maximum-Depth-of-N-ary-Tree.html"},{"title":"leetcode 589. N-ary Tree Preorder Traversal","text":"难度：Easyleetcode九章 题目描述Given an n-ary tree, return the preorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal,each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] Tags: Tree Difficulty: Easy 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445// class Node {// public int val;// public List&lt;Node&gt; children;// public Node() {}// public Node(int _val) {// val = _val;// }// public Node(int _val, List&lt;Node&gt; _children) {// val = _val;// children = _children;// }// };// Recursive solution is trivial, could you do it iteratively?// trival 微不足道的class Solution { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder0(Node root) { // 1 ms if(root==null) return res; res.add(root.val); for(Node child: root.children){ preorder(child); } return res; } public List&lt;Integer&gt; preorder(Node root) { // 3 ms? if(root==null) return res; // stack逆序存储children Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) { Node node = stack.pop(); res.add(node.val); for(int i=node.children.size()-1; i&gt;=0; i--) { stack.push(node.children.get(i)); } } return res; }}","link":"/leetcode/leetcode-589-N-ary-Tree-Preorder-Traversal.html"},{"title":"leetcode 61. Rotate List","text":"难度：Middleleetcode九章 题目描述Given a linked list, rotate the list to the right by k places, where k isnon-negative. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExample 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULLTags: Linked List, Two Pointers Difficulty: Medium 答案 1234567891011121314151617181920212223242526class Solution { public ListNode rotateRight(ListNode head, int k) { if(head==null) return null; // 遍历一次，确定链表长度和链尾 int count = 1; ListNode cur = head, end; while(cur.next!=null) { count ++; cur = cur.next; } end = cur; cur = head; System.out.println(count); k = k%count; // 找到第 count-k 个节点（是新链表的链尾） int index = 1; while(index!=(count-k)){ cur = cur.next; index++; } end.next = head; head = cur.next; cur.next = null; return head; }}","link":"/leetcode/leetcode-61-Rotate-List.html"},{"title":"leetcode 590. N-ary Tree Postorder Traversal","text":"难度：Easyleetcode九章 题目描述Given an n-ary tree, return the postorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal,each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] Tags: Tree Difficulty: Easy 答案 1234567891011121314151617181920212223242526272829/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorder0(Node root) { if(root==null) return res; for(Node node: root.children) { postorder(node); } res.add(root.val); return res; }}","link":"/leetcode/leetcode-590-N-ary-Tree-Postorder-Traversal.html"},{"title":"leetcode 653. Two Sum IV - Input is a BST","text":"难度：Easyleetcode九章 题目描述Given a Binary Search Tree and a target number, return true if there exist twoelements in the BST such that their sum is equal to the given target. Example 1: Input: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 Output: TrueExample 2: Input: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 Output: FalseTags: Tree Difficulty: Easy 答案 1234567891011121314151617class Solution { public boolean findTarget(TreeNode root, int k) { HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); return helper(root, k, set); } private boolean helper(TreeNode root, int k, HashSet&lt;Integer&gt; set){ if(root==null) return false; if(set.contains(k-root.val)) { return true; } else{ set.add(root.val); } return helper(root.left, k, set) || helper(root.right, k, set); }}","link":"/leetcode/leetcode-653-Two-Sum-IV-Input-is-a-BST.html"},{"title":"leetcode 621. Task Scheduler","text":"难度：Middleleetcode九章 题目描述Given a char array representing tasks CPU need to do. It contains capitalletters A to Z where different letters represent different tasks. Tasks couldbe done without original order. Each task could be done in one interval. Foreach interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between twosame tasks , there must be at least n intervals that CPU are doingdifferent tasks or just be idle. You need to return the least number of intervals the CPU will take tofinish all the given tasks. Example: Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2 Output: 8 Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.Note: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. Tags: Array, Greedy, Queue Difficulty: Medium 答案 12345678910111213141516// 代码：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/// 讲解：https://www.youtube.com/watch?v=YCD_iYxyXooclass Solution { public int leastInterval(char[] tasks, int n) { int[] map = new int[26]; for(char c: tasks) { map[c-'A']++; } Arrays.sort(map); int max_val = map[25]-1, idle_slots = max_val*n; for(int i=0; i&lt;25; i++) { idle_slots -= Math.min(max_val, map[i]); } return idle_slots&gt;0?tasks.length+idle_slots:tasks.length; }}","link":"/leetcode/leetcode-621-Task-Scheduler.html"},{"title":"leetcode 66. Plus One","text":"难度：Easyleetcode九章 题目描述Given a non-empty array of digits representing a non-negative integer,plus one to the integer. The digits are stored such that the most significant digit is at the head ofthe list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except thenumber 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321.Tags: Array Difficulty: Easy 答案 1234567891011121314151617181920class Solution { public int[] plusOne(int[] digits) { int carry = 0; int n = digits.length; for(int i=n-1; i&gt;=0; i--){ int sum = digits[i]+(i==n-1?1:0)+carry; digits[i] = sum%10; carry = sum/10; } if(carry==1){ int[] res = new int[n+1]; res[0] = 1; for(int i=1; i&lt;n+1; i++){ res[i] = digits[i-1]; } return res; } return digits; }}","link":"/leetcode/leetcode-66-Plus-One.html"},{"title":"leetcode 637. Average of Levels in Binary Tree","text":"难度：Easyleetcode九章 题目描述Given a non-empty binary tree, return the average value of the nodes on eachlevel in the form of an array. Example 1: Input: 3 / \\ 9 20 / \\ 15 7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].Note: The range of node’s value is in the range of 32-bit signed integer. Tags: Tree Difficulty: Easy 答案 12345678910111213141516171819202122232425// 为何注释部分失败class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;(); deque.add(root); while(!deque.isEmpty()){ int size = deque.size(); double sum = 0; for(int i=0; i&lt;size; i++) { TreeNode node = deque.removeFirst(); sum += (double)node.val; // sum += (double)node.val/size; if(node.left!=null) deque.add(node.left); if(node.right!=null) deque.add(node.right); } res.add(sum/size); // res.add(sum); } return res; }}","link":"/leetcode/leetcode-637-Average-of-Levels-in-Binary-Tree.html"},{"title":"leetcode 673. Number of Longest Increasing Subsequence","text":"难度：Middleleetcode九章 题目描述Given an unsorted array of integers, find the number of longest increasingsubsequence. Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&apos; length is 1, so output 5.Note: Length of the given array will be not exceed 2000 and the answer isguaranteed to be fit in 32-bit signed int. Tags: Dynamic Programming Difficulty: Medium 答案 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public int findNumberOfLIS(int[] nums) { // keep 两个数组，一个记录当前的count，一个记录最长路径长度 // if lis[i] == lis[j] + 1, count[i] += count[j] // 因为除了原有的到达当前lis的路径数量，还有count[i]种方法可以到达。 // if lis[i] &lt; lis[j] + 1，直接换为count[j]， // 因为首次发现了自己的最长路径 // 最后keep一个max，然后loop找有几个是max，加起来count if(nums==null || nums.length==0) return 0; int n = nums.length; if(n==1) return 1; int[] len = new int[n]; Arrays.fill(len, 1); int[] count = new int[n]; Arrays.fill(count, 1); int max = 1; for(int i=1; i&lt;n; i++) { for(int j=0; j&lt;i; j++){ if(nums[j]&lt;nums[i]){ if(len[i]&lt;len[j]+1) { len[i] = len[j]+1; count[i] = count[j]; }else if(len[i]==len[j]+1) { count[i] += count[j]; } } } max = Math.max(max, len[i]); } int res = 0; for(int i=0; i&lt;n; i++) { if(len[i]==max){ res+=count[i]; } } return res; }}","link":"/leetcode/leetcode-673-Number-of-Longest-Increasing-Subsequence.html"},{"title":"leetcode 69. Sqrt(x)","text":"难度：Easyleetcode九章 题目描述Implement int sqrt(int x). Compute and return the square root of x , where x is guaranteed to be anon-negative integer. Since the return type is an integer, the decimal digits are truncated and onlythe integer part of the result is returned. Example 1: Input: 4 Output: 2Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.Tags: Math, Binary Search Difficulty: Easy 答案 1234567891011121314class Solution { public int mySqrt(int x) { // 二分 if(x&lt;2) return x; int start = 1, end = x, mid = end/2; while(start &lt; mid) { if(mid == x/mid) return mid; else if(mid &lt; x/mid) start = mid; else end = mid; mid = start+(end-start)/2; } return mid; }}","link":"/leetcode/leetcode-69-Sqrt-x.html"},{"title":"leetcode 674. Longest Continuous Increasing Subsequence","text":"难度：Easyleetcode九章 题目描述Given an unsorted array of integers, find the length of longest continuousincreasing subsequence (subarray). Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. Note: Length of the array will not exceed 10,000. Tags: Array Difficulty: Easy 答案 1234567891011121314151617class Solution { public int findLengthOfLCIS(int[] nums) { if(nums==null || nums.length==0) return 0; if(nums.length==1) return 1; int res = 1; int cur = 1; for(int i=1; i&lt;nums.length; i++) { if(nums[i]&gt;nums[i-1]) { cur++; }else{ res = Math.max(res, cur); cur = 1; } } return Math.max(res, cur); }}","link":"/leetcode/leetcode-674-Longest-Continuous-Increasing-Subsequence.html"},{"title":"leetcode 700. Search in a Binary Search Tree","text":"难度：Easyleetcode九章 题目描述Given the root node of a binary search tree (BST) and a value. You need tofind the node in the BST that the node’s value equals the given value. Returnthe subtree rooted with that node. If such node doesn’t exist, you shouldreturn NULL. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to search: 2You should return this subtree: 2 / \\ 1 3In the example above, if we want to search the value 5, since there is nonode with value 5, we should return NULL. Note that an empty tree is represented by NULL, therefore you would see theexpected output (serialized tree format) as [], not null. Tags: Tree Difficulty: Easy 答案 12345678class Solution { public TreeNode searchBST(TreeNode root, int val) { if(root==null || root.val==val) return root; if(root.val&gt;val) return searchBST(root.left, val); return searchBST(root.right, val); }}","link":"/leetcode/leetcode-700-Search-in-a-Binary-Search-Tree.html"},{"title":"leetcode 701. Insert into a Binary Search Tree","text":"难度：Middleleetcode九章 题目描述Given the root node of a binary search tree (BST) and a value to be insertedinto the tree, insert the value into the BST. Return the root node of the BSTafter the insertion. It is guaranteed that the new value does not exist in theoriginal BST. Note that there may exist multiple valid ways for the insertion, as long asthe tree remains a BST after insertion. You can return any of them. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4Tags: Tree Difficulty: Medium 答案 123456789101112131415161718192021222324class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { helper(root, val); return root; } private void helper(TreeNode root, int val){ if(val &lt; root.val){ if(root.left==null){ root.left = new TreeNode(val); return; }else{ insertIntoBST(root.left, val); } }else{ if(root.right==null){ root.right = new TreeNode(val); return; }else{ insertIntoBST(root.right, val); } } }}","link":"/leetcode/leetcode-701-Insert-into-a-Binary-Search-Tree.html"},{"title":"leetcode 78. Subsets","text":"难度：Middleleetcode九章 题目描述Given a set of distinct integers, nums , return all possible subsets(the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]Tags: Array, Backtracking, Bit Manipulation Difficulty: Medium 答案 12345678910111213141516171819202122232425262728// 开始时间-写完-调完错// 31-43-46class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { return helper(nums, nums.length); } // 1 2 3 // [[]] len=0 // [[], [1]] len=1 // [[], [1], [2], [1, 2]] len=2 // [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] len=3 private List&lt;List&lt;Integer&gt;&gt; helper(int[] nums, int len){ List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(nums==null || len==0) { res.add(new ArrayList&lt;&gt;()); return res; } int num = nums[len-1]; // 在len-1的res中的每一个list加上num for(List&lt;Integer&gt; l: helper(nums, len-1)){ res.add(l); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(l); temp.add(num); res.add(temp); } return res; }}","link":"/leetcode/leetcode-78-Subsets.html"},{"title":"leetcode 762. Prime Number of Set Bits in Binary Representation","text":"难度：Easyleetcode九章 题目描述Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binaryrepresentation. (Recall that the number of set bits an integer has is the number of 1spresent when written in binary. For example, 21 written in binary is 10101which has 3 set bits. Also, 1 is not a prime.) Example 1: Input: L = 6, R = 10 Output: 4 Explanation: 6 -&gt; 110 (2 set bits, 2 is prime) 7 -&gt; 111 (3 set bits, 3 is prime) 9 -&gt; 1001 (2 set bits , 2 is prime) 10-&gt;1010 (2 set bits , 2 is prime)Example 2: Input: L = 10, R = 15 Output: 5 Explanation: 10 -&gt; 1010 (2 set bits, 2 is prime) 11 -&gt; 1011 (3 set bits, 3 is prime) 12 -&gt; 1100 (2 set bits, 2 is prime) 13 -&gt; 1101 (3 set bits, 3 is prime) 14 -&gt; 1110 (3 set bits, 3 is prime) 15 -&gt; 1111 (4 set bits, 4 is not prime)Note: L, R will be integers L &lt;= R in the range [1, 10^6]. R - L will be at most 10000. Tags: Bit Manipulation Difficulty: Easy 答案 123456789101112131415161718192021222324class Solution { public int countPrimeSetBits(int L, int R) { // 1. 获取最长bits：20 // int mul = 1; // for(int i=1; i&lt;64; i++) { // mul *= 2; // if(mul&gt;1000000) // return i; // } // return mul; // 2. Integer.bitCount(i) int res = 0; int[] isPrimeSetBits = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0}; for(int i=L; i&lt;R+1; i++) { res += isPrimeSetBits[Integer.bitCount(i)]; } return res; }}","link":"/leetcode/leetcode-762-Prime-Number-of-Set-Bits-in-Binary-Representation.html"},{"title":"leetcode 73. Set Matrix Zeroes","text":"难度：Middleleetcode九章 题目描述Given a m x n matrix, if an element is 0, set its entire row and column to0. Do it in-place. Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ]Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ]Follow up: A straight forward solution using O( m n ) space is probably a bad idea. A simple improvement uses O( m + n ) space, but still not the best solution. Could you devise a constant space solution? Tags: Array Difficulty: Medium 答案 1234567891011121314151617181920212223242526class Solution { public void setZeroes(int[][] ma) { Set&lt;Integer&gt; row = new HashSet&lt;&gt;(); Set&lt;Integer&gt; col = new HashSet&lt;&gt;(); int n = ma.length; int m = ma[0].length; for(int i=0; i&lt;n; i++){ for(int j=0; j&lt;m; j++){ if(ma[i][j]==0){ row.add(i); col.add(j); } } } for(int i: row){ for(int j=0; j&lt;m; j++) { ma[i][j] = 0; } } for(int j: col){ for(int i=0; i&lt;n; i++) { ma[i][j] = 0; } } }}","link":"/leetcode/leetcode-73-Set-Matrix-Zeroes.html"},{"title":"leetcode 79. Word Search","text":"难度：Middleleetcode九章 题目描述Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where“adjacent” cells are those horizontally or vertically neighboring. The sameletter cell may not be used more than once. Example: board = [ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;] ] Given word = &quot; **ABCCED** &quot;, return **true**. Given word = &quot; **SEE** &quot;, return **true**. Given word = &quot; **ABCB** &quot;, return **false**.Tags: Array, Backtracking Difficulty: Medium 答案 123456789101112131415161718192021222324252627282930class Solution { // dfs + 标记 int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; public boolean exist(char[][] board, String word) { if(board==null || board.length==0 || board[0].length==0) return false; int n = board.length, m = board[0].length; boolean[][] mark = new boolean[n][m]; for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { if(helper(board, n, m, i, j, word, word.length(), 0, mark)) return true; } } return false; } private boolean helper(char[][] board, int n, int m, int i, int j, String word, int len, int start, boolean[][] mark) { if(i&lt;0 || i&gt;=n || j&lt;0 || j&gt;=m || mark[i][j]) return false; if(word.charAt(start)!=board[i][j]) return false; if(start==len-1) return true; mark[i][j] = true; for(int[] direction: directions) { if (helper(board, n, m, i+direction[0], j+direction[1], word, len, start+1, mark)) return true; } mark[i][j] = false; return false; }}","link":"/leetcode/leetcode-79-Word-Search.html"},{"title":"leetcode 872. Leaf-Similar Trees","text":"难度：Easyleetcode九章 题目描述Consider all the leaves of a binary tree. From left to right order, thevalues of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequenceis the same. Return true if and only if the two given trees with head nodes root1 androot2 are leaf-similar. Note: Both of the given trees will have between 1 and 100 nodes. Tags: Tree, Depth-first Search Difficulty: Easy 答案 1234567891011121314151617181920// 前序遍历应该用stack// deque remove==removeFirst add==addLastclass Solution { public boolean leafSimilar(TreeNode root1, TreeNode root2) { List&lt;Integer&gt; l1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;&gt;(); preOrder(root1, l1); preOrder(root2, l2); return l1.equals(l2); } private void preOrder(TreeNode root, List&lt;Integer&gt; l){ if(root==null) return; if(root.left==null &amp;&amp; root.right==null){ l.add(root.val); } preOrder(root.left, l); preOrder(root.right, l); }}","link":"/leetcode/leetcode-872-Leaf-Similar-Trees.html"},{"title":"leetcode 897. Increasing Order Search Tree","text":"难度：Easyleetcode九章 题目描述Given a binary search tree, rearrange the tree in in-order so that theleftmost node in the tree is now the root of the tree, and every node has noleft child and only 1 right child. **Example 1:** Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 Note: The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000. Tags: Tree, Depth-first Search Difficulty: Easy 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public TreeNode increasingBST0(TreeNode root) { // Runtime: 5 ms, faster than 11.04% // Memory Usage: 44.5 MB, less than 40.63% TreeNode res = new TreeNode(0); TreeNode cur = res; // inorder TreeNode temp = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || temp!=null){ while(temp!=null){ stack.push(temp); temp = temp.left; } if(!stack.isEmpty()){ TreeNode node = stack.pop(); node.left = null; cur.right = node; cur = node; temp = node.right; } } return res.right; } TreeNode cur; public TreeNode increasingBST(TreeNode root) { // https://leetcode-cn.com/problems/increasing-order-search-tree/solution/di-zeng-shun-xu-cha-zhao-shu-by-leetcode/ // 方法2 // Runtime: 2 ms, faster than 100.00% // Memory Usage: 38.2 MB, less than 100.00% TreeNode dummy = new TreeNode(0); cur = dummy; helper(root); return dummy.right; } private void helper(TreeNode node){ if(node==null) return; helper(node.left); node.left = null; cur.right = node; cur = node; helper(node.right); }}","link":"/leetcode/leetcode-897-Increasing-Order-Search-Tree.html"},{"title":"leetcode 96. Unique Binary Search Trees","text":"难度：Middleleetcode九章 题目描述Given n , how many structurally unique BST ‘s (binary search trees) thatstore values 1 … n? Example: Input: 3 Output: 5 Explanation: Given _n_ = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3Tags: Dynamic Programming, Tree Difficulty: Medium 答案 1234567891011121314class Solution { public int numTrees(int n) { // 1为root, 左子树有0个 。。。。 n为root，右子树有0个 // dp[n] = dp[0]*dp[n-1]+dp[1]*dp[n-2]+...+dp[n-1]*dp[0] int[] dp = new int[n+1]; dp[0] = 1; for(int i=1; i&lt;=n; i++){ for(int j=0; j&lt;i; j++){ dp[i] += dp[j]*dp[i-j-1]; } } return dp[n]; }}","link":"/leetcode/leetcode-96-Unique-Binary-Search-Trees.html"},{"title":"leetcode 82. Remove Duplicates from Sorted List II","text":"难度：Middleleetcode九章 题目描述Given a sorted linked list, delete all nodes that have duplicate numbers,leaving only distinct numbers from the original list. Example 1: Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 Output: 1-&gt;2-&gt;5Example 2: Input: 1-&gt;1-&gt;1-&gt;2-&gt;3 Output: 2-&gt;3Tags: Linked List Difficulty: Medium 答案 123456789101112131415161718192021class Solution { public ListNode deleteDuplicates(ListNode head) { if(head==null) return null; ListNode dummy = new ListNode(0), cur=head; dummy.next = head; ListNode pre = dummy; while(cur!=null){ if(cur.next!=null &amp;&amp; cur.next.val==cur.val){ while(cur.next!=null &amp;&amp; cur.val==cur.next.val){ cur = cur.next; } pre.next = cur.next; cur = cur.next; }else{ pre = cur; cur = cur.next; } } return dummy.next; }}","link":"/leetcode/leetcode-82-Remove-Duplicates-from-Sorted-List-II.html"},{"title":"leetcode 92. Reverse Linked List II","text":"难度：Middleleetcode九章 题目描述Reverse a linked list from position m to n. Do it in one-pass. *Note: *1 ≤ m ≤ n ≤ length of list. Example: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, _m_ = 2, _n_ = 4 Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULLTags: Linked List Difficulty: Medium 答案 12345678910111213141516171819202122232425262728293031323334class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dummy = new ListNode(0), pre, cur, next; pre = dummy; dummy.next = head; cur = head; // 1 2 3 4 5 m=2, n=4 // node1 node2 // 开始翻转的前一个，以及头一个 ListNode node1=head, node2=head; if(head==null) return null; for(int i=1; i&lt;=n; i++){ if(i&lt;m) { pre = cur; cur = cur.next; }else{ if(i==m){ node1 = pre; node2 = cur; } next = cur.next; cur.next = pre; // next.next = cur; if(i==n){ node1.next = cur; node2.next = next; } pre = cur; cur = next; } } return dummy.next; }}","link":"/leetcode/leetcode-92-Reverse-Linked-List-II.html"},{"title":"leetcode 965. Univalued Binary Tree","text":"难度：Easyleetcode九章 题目描述A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued. Example 1: Input: [1,1,1,1,1,null,1] Output: trueExample 2: Input: [2,2,2,5,2] Output: falseNote: The number of nodes in the given tree will be in the range [1, 100]. Each node’s value will be an integer in the range [0, 99]. Tags: Tree Difficulty: Easy 答案 123456789class Solution { public boolean isUnivalTree(TreeNode root) { if(root==null) return true; if(root.left!=null &amp;&amp; root.left.val!=root.val) return false; if(root.right!=null &amp;&amp; root.right.val!=root.val) return false; return isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right); }}","link":"/leetcode/leetcode-965-Univalued-Binary-Tree.html"},{"title":"leetcode 98. Validate Binary Search Tree","text":"难度：Middleleetcode九章 题目描述Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: trueExample 2: 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node&apos;s value is 5 but its right child&apos;s value is 4.Tags: Tree, Depth-first Search Difficulty: Medium 答案 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isValidBST(TreeNode root) { // 要求所有右子树的元素大于root // if(root==null) return true; // else if(root.left!=null &amp;&amp; root.left.val&gt;=root.val) // return false; // else if(root.right!=null &amp;&amp; root.right.val&lt;=root.val) // return false; // return isValidBST(root.left) &amp;&amp; isValidBST(root.right); return divConq(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean divConq(TreeNode root, long min, long max){ // min~max 是root应该处于的范围 if(root==null) return true; else if(root.val&lt;=min || root.val&gt;=max) return false; else { // root.left &lt; root &amp;&amp; root.right &gt; root return divConq(root.left, min, Math.min(root.val, max)) &amp;&amp; divConq(root.right, Math.max(root.val, min), max) ; } }}","link":"/leetcode/leetcode-98-Validate-Binary-Search-Tree.html"},{"title":"leetcode 938. Range Sum of BST","text":"难度：Easyleetcode九章 题目描述Given the root node of a binary search tree, return the sum of values of allnodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values. Example 1: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23Note: The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31. Tags: Tree, Recursion Difficulty: Easy 答案 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int sum; public int rangeSumBST(TreeNode root, int L, int R) { sum = 0; helper(root, L, R); return sum; } private void helper(TreeNode root, int l, int r){ // 如果 node.val 小于等于 L，那么只需要继续搜索它的右子树；如果 node.val 大于等于 R，那么只需要继续搜索它的左子树；如果 node.val 在区间 (L, R) 中，则需要搜索它的所有子树 if(root==null) return; if(root.val&gt;=l &amp;&amp; root.val&lt;=r){ sum += root.val; helper(root.left, l, r); helper(root.right, l ,r); }else if(root.val&lt;l){ helper(root.right, l ,r); }else{ helper(root.left, l, r); } }}","link":"/leetcode/leetcode-938-Range-Sum-of-BST.html"},{"title":"加密文章测试","text":"嗨，请准确无误地输入密码查看哟（密码：123456）！ 42401e656a30ed09e8e3b0fbe2fbd18ae1b8c2138de0b629bd1233cbc0cc80918b020088b54c79621b8ef9a9af7b0f06b4f358e8c86ef99d097fb161589581b453752da7da2e21aa4d35b94c835c62d1204ab327d5d9241d6be3c6b4b1e68d3697229826ffa52b53920e92cbe496af209269f803aa7450ba136338b0e891ba54f6fe48d0d23c1ba5b981305fdee3badd054b7ad20712af650adf010b25c3fa117b769979c2ef7a2ccccee14b24ed84530b911e7b68c43d9f4592ba8687b2c7fb","link":"/private/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html"},{"title":"leetcode 99. Recover Binary Search Tree","text":"难度：Hardleetcode九章 题目描述Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2] 1 / 3 \\ 2 Output: [3,1,null,null,2] 3 / 1 \\ 2Example 2: Input: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3Follow up: A solution using O( n ) space is pretty straight forward. Could you devise a constant space solution? Tags: Tree, Depth-first Search Difficulty: Hard 答案 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { TreeNode first, second, pre; // 1 2 3 4 5 // 2种情况：替换的值相邻（pre&gt;cur 发生一次） // 替换的值不相邻 (pre&gt;cur 发生2次) // 1 3 2 4 5 // 1 4 3 2 5 public void recoverTree(TreeNode root) { helper(root); int temp = first.val; first.val = second.val; second.val = temp; } private void helper(TreeNode root){ if(root==null) return; helper(root.left); if(pre!=null &amp;&amp; pre.val&gt;root.val){ if(first==null) { first = pre; second = root; } else { second = root; return; } } pre = root; helper(root.right); }}","link":"/leetcode/leetcode-99-Recover-Binary-Search-Tree.html"},{"title":"leetcode 993. Cousins in Binary Tree","text":"难度：Easyleetcode九章 题目描述In a binary tree, the root node is at depth 0, and children of each depthk node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but havedifferent parents. We are given the root of a binary tree with unique values, and the valuesx and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and yare cousins. Example 1: Input: root = [1,2,3,4], x = 4, y = 3 Output: falseExample 2: Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: trueExample 3: Input: root = [1,2,3,null,4], x = 2, y = 3 Output: falseNote: The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100. Tags: Tree, Breadth-first Search Difficulty: Easy 答案 12345678910111213141516171819202122232425class Solution { public boolean isCousins(TreeNode root, int x, int y) { if(root==null) return false; Map&lt;Integer, Integer&gt; level = new HashMap&lt;&gt;(); Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;&gt;(); helper(root, level, parent, 0); return level.containsKey(x) &amp;&amp; level.containsKey(y) &amp;&amp; level.get(x)==level.get(y) &amp;&amp; parent.get(x)!=parent.get(y); } private void helper(TreeNode root, Map&lt;Integer, Integer&gt; level, Map&lt;Integer, TreeNode&gt; parent, int curLevel){ curLevel++; if(root.left!=null){ level.put(root.left.val, curLevel); parent.put(root.left.val, root); helper(root.left, level, parent, curLevel); } if(root.right!=null){ level.put(root.right.val, curLevel); parent.put(root.right.val, root); helper(root.right, level, parent, curLevel); } }}","link":"/leetcode/leetcode-993-Cousins-in-Binary-Tree.html"},{"title":"github Issue 作为博客微型数据库的应用","text":"背景众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法: a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。 b.或者有的直接后台写一些接口服务啥的，还得在买个服务器部署上去，然后博客中访问接口。 c.或者有些可能就直接写到html中。 对于a、c方法都比较麻烦，每次更新了都要编译部署，不能很方便的动态更新。对于b的话，成本以及技术要求可能就更多一些了。 基于上面出现的问题，目前想到的一个解决方案就是，利用github 的issue作为一个微型数据库。能够很方便的动态更新，也能分页，也不需要啥json文件，想想都很方便。 issue数据库使用步骤issue的创建先创建一个Repository，对于此Repository可以专门作为微型的数据库，取名issue_database。创建好之后建立一些issue 如下所示 目前博客中，所有的动态数据都放到issue中了。 issue中存储数据对于创建好的issue，就可以往里面写数据了，比如我的友链数据为issue：blog_friends 对于issue中存储的数据最好存json格式的，因为可以方便后面取出来使用。存储好数据后，如果太多的话，可以点击hide,隐藏起来。同时这个issue最好给Lock conversation这样的好处是，防止别人往里面加些脏数据，只能自己往里写数据。哈哈，一般也没有闲的无聊的网友恶作剧。这样就存储好数据了。 博客中获取issue数据博客中通过js获取issue中的数据，以博客友链为例，以下是获取代码，以及处理 123456789101112131415161718// author by removef// https://removeif.github.io/$(function () { //获取处理友链数据，来自issue，一次取完 $.getJSON(\"https://api.github.com/repos/removeif/issue_database/issues/2/comments?per_page=100&amp;client_id=46a9f3481b46ea0129d8&amp;client_secret=79c7c9cb847e141757d7864453bcbf89f0655b24\", function (source) { var data = []; var source1; source1 = source; // 以后每次更新的都在后面，此处倒序，按时间降序排 source1.reverse(); // 把所有的数据放到data的列表中 $.each(source1, function (i, e) { data.push(...JSON.parse(e.body)); }); $.each(data, function (i, e) { // 博客中html文件的构建，渲染 });}); 上面代码中client_id、client_secret在另一篇文章中博客源码分享有详细的说明,可以查看一下。这样就能获取到相应的数据，进行操作。 issue数据的更新比如想更新任意一项数据都可以进github中对应的仓库的issue下进行更新，添加。然后实时去博客中查看。 扩展一下对于有些爱唠叨的人（比如我），弄个类似碎碎念的东西就比较实用了。之前想过各种方案，存json数据太不方便；后台写个服务部署服务器也太麻烦。最后思来想去还是利用了下现成的优秀项目gitalk,稍稍改改就能很好使用。 博客中的碎碎念对于博主而言，有发表框和修改的操作，能够方便发表和修改。 可能有时候还会发表一些图片，对图片的样式做了一些控制 对于网友的话只能查看以及点赞加❤️ 做法就是源码中改下返回html的文件内容，如果是管理员和非管理员返回一些不同的元素，能够很好的实现碎碎念的功能。查看碎碎念。 总结静态博客的动态数据是个痛点，GitHub Issue有很多可利用的地方。多去探索发掘其中的奥妙。 利用GitHub Issue来解决目前也是一种解决方法。希望后面会出现更好的解决方案。","link":"/theme/github-Issue-%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%BE%AE%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%94%E7%94%A8.html"},{"title":"github page网站cdn优化加速","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 图片加速关于图传以及GitHub作为图库的使用方法请参考文章：博客图片上传picgo工具github图传使用。 在上面参考文章的基础之上只需要修改以下配置：（指定相关cdn域名） 原来项目中使用了原来的方式，进行全局替换，Mac idea直接快捷键command+shift+R全局替换 【ps：题外话】原来是统一用的GitHub的仓库中的图片，通过这样替换，可以看到图片统一管理是多么的重要，多么的方便管理操作。 至此，博客中的相关图片都加上了cdn。 其余资源文件用法： 1https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 123https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.csshttps://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js// 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js// 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 至此，github page 博客基本需要加速的完成。 参考文章:参考链接1参考链接2","link":"/theme/github-page%E7%BD%91%E7%AB%99cdn%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F.html"},{"title":"博客图片上传picgo工具github图传使用","text":"摘要对于每一个写博客的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真XX方便！ PicGo工具下载安装配置下载 .PicGo下载 github网站提供三个版本的下载，MacOs、linux、windows覆盖市面上90%系统，还是很给力了。 我是mac用户，直接使用brew cask来安装PicGo: brew cask install picgo，简直方便到爆。 配置 PicGo配置(使用github图传，免费方便，同时配合github.io博客真是方便) 选上必填的就ok,一开始不知道token的设置，附赠token获取方法 图片上传相关的设置 链接格式：选择适合自己的，一般用户md文件中，选第一个，然后就可以疯狂使用了。 使用github图传，获取token在github-&gt;setting-&gt;developer settings 选择generate new token 勾选好之后生成就好了 使用 PicGo使用，简直方便 1).默认网页上直接右键复制图片 2).点击等待中的图片，开始上传 3).上传完之后有个提示，同时粘贴板也会自动粘贴上 4).直接粘贴到想要的地方 或者也可以直接截图，然后点击图片里的图片上传，很方便 PicGo上传动图gif 如果直接复制网页上的动图，去上传的话是截取的某帧，是静图。应该下载到本地，然后在拖进去上传就可以了。","link":"/theme/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0picgo%E5%B7%A5%E5%85%B7github%E5%9B%BE%E4%BC%A0%E4%BD%BF%E7%94%A8.html"},{"title":"不蒜子统计常见问题","text":"不蒜子统计官网：http://busuanzi.ibruce.info/ 详细使用教程：http://ibruce.info/2015/04/04/busuanzi/ 目前支持的功能：（两行代码，搞定计数；方便、简洁、实用） a、显示站点总访问量 b、显示单页面访问量 c、显示站点总访问量和单页面访问量 d、只计数不显示 关于怎么实现当天、昨天、本月、上月（即具体时间段）的访问量目前没有支持，请配合目前不蒜子支持的功能自行实现。 1.常见问题400错误，统计不生效 如图（1）的地方没有加载出统计数据 此时F12打开浏览器控制台，找到（2）network地方，刷新一下页面找到（3），请求统计的网址如图所示，查看（4）referrer-policy是否如图所示，如图的话是不能访问的，需要更改。 导致此问题原因，检查网页源码中，一般header有如下标签 解决方法，去掉此标签，之后访问如下（1）已有统计值，（2）已改变。可详细对比正常使用不蒜子统计网址https://removeif.github.io/ 中请求busuanzi?jsonpCallback=BusuanziCallback_236107382952地址的请求和返回参数的差异！ 这样设置带来的影响，可能有些图床的图片不能显示，会图裂，如新浪图床。解决方法，可以用其他不冲突的图床。 2.统计访问数巨大（清零问题）http://localhost:4000/ 或http://127.0.0.1:4000/ 访问时，统计数巨大，这是正常的，不用清零。部署到线上，用线上域名网址访问数据就正常了。 3.统计无法访问如图所示 查看红色url部分如下所示 此问题是Request URL填写错误，请确保Request URL前部分为http://busuanzi.ibruce.info/busuanzi?，，，，如下 同时查看Response，出现如下数据，就是成功访问了不蒜子统计，如果网站中还没出统计数据，就是自己的代码写错了，检查代码 4.其余问题(1).同一个页面，同名的id标签确保只能放一个如下 123&lt;span id=\"busuanzi_container_site_uv\" style=\"display: inline;\"&gt; &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;&lt;/span&gt; 同一个页面id名为busuanzi_value_site_uv只能放一个! (2).safari（包括移动端的safari）浏览器页面pv统计问题，如下，因为Safari浏览器referer在文章页面时也上送的域名（而单个页面的pv统计是根据页面路径，即上送的referer），所以此时页面的pv返回的站点的pv值。暂时没解决方法，可自行搜索解决方案构造正确的referer值。对于此问题可以换个浏览器看哇，比如Chrome，哈哈。 (3).部分live2d可能与不蒜子统计有冲突，出现此问题时，请查看网页源码引用统计id处是否被隐藏，一般网页上会自动加上display: none;自行选择性的使用。网友的解决方法，修改源码为以下，并引用修改后的js文件 不蒜子源码文件： 修改为如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889var bszCaller, bszTag;!function() { var c, d, e, a = !1, b = []; ready = function(c) { return a || \"interactive\" === document.readyState || \"complete\" === document.readyState ? c.call(document) : b.push(function() { return c.call(this) }), this } , d = function() { for (var a = 0, c = b.length; c &gt; a; a++) b[a].apply(document); b = [] } , e = function() { a || (a = !0, d.call(window), document.removeEventListener ? document.removeEventListener(\"DOMContentLoaded\", e, !1) : document.attachEvent &amp;&amp; (document.detachEvent(\"onreadystatechange\", e), window == window.top &amp;&amp; (clearInterval(c), c = null))) } , document.addEventListener ? document.addEventListener(\"DOMContentLoaded\", e, !1) : document.attachEvent &amp;&amp; (document.attachEvent(\"onreadystatechange\", function() { /loaded|complete/.test(document.readyState) &amp;&amp; e() }), window == window.top &amp;&amp; (c = setInterval(function() { try { a || document.documentElement.doScroll(\"left\") } catch (b) { return } e() }, 5)))}(),bszCaller = { fetch: function(a, b) { var c = \"BusuanziCallback_\" + Math.floor(1099511627776 * Math.random()); window[c] = this.evalCall(b), a = a.replace(\"=BusuanziCallback\", \"=\" + c), scriptTag = document.createElement(\"SCRIPT\"), scriptTag.type = \"text/javascript\", scriptTag.defer = !0, scriptTag.src = a, document.getElementsByTagName(\"HEAD\")[0].appendChild(scriptTag) }, evalCall: function(a) { return function(b) { ready(function() { try { a(b), - // 此处为修改的逻辑- scriptTag.parentElement.removeChild(scriptTag)+ if(scriptTag != null &amp;&amp; scriptTag.parentElement != null){+ scriptTag.parentElement.removeChild(scriptTag)+ } } catch (c) { bszTag.hides() } }) } }},bszCaller.fetch(\"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback\", function(a) { bszTag.texts(a), bszTag.shows()}),bszTag = { bszs: [\"site_pv\", \"page_pv\", \"site_uv\"], texts: function(a) { this.bszs.map(function(b) { var c = document.getElementById(\"busuanzi_value_\" + b); c &amp;&amp; (c.innerHTML = a[b]) }) }, hides: function() { this.bszs.map(function(a) { var b = document.getElementById(\"busuanzi_container_\" + a); b &amp;&amp; (b.style.display = \"none\") }) }, shows: function() { this.bszs.map(function(a) { var b = document.getElementById(\"busuanzi_container_\" + a); b &amp;&amp; (b.style.display = \"inline\") }) }}; 5.官方群！！！群号：419260983，有其余问题进群讨论，提问时遇到其他的问题请同时发出问题的在线网址！！！","link":"/theme/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"},{"title":"博客中gitalk最新评论的获取","text":"博客中，对于网友的评论以及每篇文章的评论数还是很重要的。但是基于静态的页面想要存储动态的评论数据是比较难的，一般博客主题中都内置了评论插件，但是博客主题中对于最新评论的支持显示还是很少的，至少目前我是没怎么发现。博客 Powered by Hexo &amp; Icarus，采用Gitalk评论，再次感谢此三位作者的辛勤码代码，才有了以下的内容。基于此背景基础上，聊聊最新评论的实现。 博客的使用， Hexo &amp; Icarus，采用Gitalk评论 的使用自行百度了。 使用场景 最新评论列表 最热文章列表（基于评论数判断是否最热，也比较片面，但是侧面也能反映，问题不大） 使用方法主要参考自官方文档 目前主要用到两个方法，一个是获取仓库下所有的issue，每个issue节点下有相关的评论数，以及对应issue下的评论的url;还有一个是根据issue下评论的URL获取相应的所有的评论 方法1：List issues for a repository1GET /orgs/:org/issues 参数列表 Name Type Description milestone integer or string If an integer is passed, it should refer to a milestone by its number field. If the string * is passed, issues with any milestone are accepted. If the string none is passed, issues without milestones are returned. state string Indicates the state of the issues to return. Can be either open, closed, or all. Default: open assignee string Can be the name of a user. Pass in none for issues with no assigned user, and * for issues assigned to any user. creator string The user that created the issue. mentioned string A user that’s mentioned in the issue. labels string A list of comma separated label names. Example: bug,ui,@high sort string What to sort results by. Can be either created, updated, comments. Default: created direction string The direction of the sort. Can be either asc or desc. Default: desc since string Only issues updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 以上参数，主要用到 sort 排序，page页数，per_page每页数量，其余的参数看个人需要使用。注意文档中的说明，排序的字段和返回的稍许不太一样。 方法2：List comments on an issue1GET /repos/:owner/:repo/issues/:issue_number/comments Issue Comments are ordered by ascending ID. 排序根据 ascending (上升的，增长的；升（序）的)ID.也就是说，从老到新。这个比较坑，对于我们获取最新评论来说。 参数如下 Name Type Description since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 根据尝试以及以上参数，试出不支持排序，但是支持分页，page,per_page参数，对于我们获取最新的评论来说可以根据评论数，算出分页数，拿到最后一条，即最新一条 123456//如果只有一页int page = 1;int per_page = 1;// 如果超出一页的话int page = 2;int per_page = commentsNumber-1;//commentsNumber:评论数 js代码中使用实例核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var timesSet = [];var timesBodyMap = {};var timesSetMap = {};var resultArr = [];// 方法1：sort=comments可以按评论数排序，此处更适合按更新时间排序,可以根据updated排序，但是0条评论的也会出来，所以此处还是根据评论数排序全部查出来，过滤掉0条评论的，拿到每个issue下最新的一条评论详情和时间，根据时间内存排序// per_page 每页数量，根据需求配置$.getJSON(\"https://api.github.com/repos/{用户名}/{仓库}/issues?per_page=100&amp;sort=comments\", function (result) { $.each(result, function (i, item) { var commentsCount = item.comments; if (commentsCount &gt; 0) { $.ajaxSettings.async = false; // 此处保证是最后一条，api没有排序参数，只能分页取最后一条，保证最少的数据量传输，快速处理 var page = 2; var pageSize = commentsCount - 1; if (commentsCount == 1) { page = 1; pageSize = 1; } // 方法2：的使用 $.getJSON(item.comments_url + \"?page=\" + page + \"&amp;per_page=\" + pageSize, function (commentResult) { var item1 = commentResult[0]; var contentStr = item1.body.trim(); if (contentStr.length &gt; 50) { contentStr = contentStr.substr(0, 60); contentStr += \"...\"; } timesSet.push(new Date(item1.created_at).getTime()); timesBodyMap[item1.created_at] = { \"title\": item.title.substr(0, item.title.indexOf(\"-\") - 1), \"url\": item.body.substr(0, item.body.indexOf(\"\\n\") - 1), \"content\": contentStr, \"date\": item1.created_at, \"userName\": item1[\"user\"].login, \"userUrl\": item1[\"user\"].html_url, \"commentCount\": commentsCount }; timesSetMap[new Date(item1.created_at).getTime()] = item1.created_at; }); } });});// 排序if (timesSet.length &gt; 0) { timesSet.sort();}// 根据需要取10条if (timesSet.length &gt; 10) { for (var i = timesSet.length - 1; i &gt;= 0 &amp;&amp; resultArr.length &lt; 10; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }}else { for (var i = timesSet.length - 1; i &gt;= 0; i--) { resultArr.push(timesBodyMap[timesSetMap[timesSet[i]]]); }} 方法1：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues?per_page=100&amp;sort=comments 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"repository_url\": \"https://api.github.com/repos/removeif/blog_comment\", \"labels_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/labels{/name}\", \"comments_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/comments\", \"events_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3/events\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3\", \"id\": 458985510, \"node_id\": \"MDU6SXNzdWU0NTg5ODU1MTA=\", \"number\": 3, \"title\": \"留言板 - 辣椒の酱\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"labels\": [ { \"id\": 1416043904, \"node_id\": \"MDU6TGFiZWwxNDE2MDQzOTA0\", \"url\": \"https://api.github.com/repos/removeif/blog_comment/labels/3306ea6632b94cc388b40cef9dda4a8f\", \"name\": \"3306ea6632b94cc388b40cef9dda4a8f\", \"color\": \"0e8a16\", \"default\": false }, { \"id\": 1415994590, \"node_id\": \"MDU6TGFiZWwxNDE1OTk0NTkw\", \"url\": \"https://api.github.com/repos/removeif/blog_comment/labels/Gitalk\", \"name\": \"Gitalk\", \"color\": \"5319e7\", \"default\": false } ], \"state\": \"open\", \"locked\": false, \"assignee\": null, \"assignees\": [ ], \"milestone\": null, \"comments\": 33, \"created_at\": \"2019-06-21T03:06:53Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"closed_at\": null, \"author_association\": \"OWNER\", \"body\": \"https://removeif.github.io/message/\\r\\n\\r\\n留言板信息。\" }, {...} ] 方法2：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/3/comments?per_page=32&amp;page=2 返回结果 123456789101112131415161718192021222324252627282930313233[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913\", \"issue_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"id\": 530767913, \"node_id\": \"MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"created_at\": \"2019-09-12T10:37:34Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"author_association\": \"OWNER\", \"body\": \"&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦\" }] 博客中目前有两个页面使用,根据个人的需要放到各自的位置吧。 首页热门推荐 还有个最新评论页： 扩展一个方法上面的实例程序，每个issue（因为我的每个issue关联一个文章链接）只取了一条最新的评论，假如每个issue下有两个都是最新的评论，而我也不管是不是同一个issue下的评论，获取所有的最新评论，还有一个方法比较好用。 List comments in a repository1GET /repos/:owner/:repo/issues/comments By default, Issue Comments are ordered by ascending ID. 和上面一样，但是以下参数就不一样了 Name Type Description sort string Either created or updated. Default: created direction string Either asc or desc. Ignored without the sort parameter. since string Only comments updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. 多了排序字段和排序方式，也有per和per_page，这是相当的有用啊 扩展方法：请求接口地址示例1https://api.github.com/repos/removeif/blog_comment/issues/comments?sort=updated&amp;direction=desc&amp;per_page=10&amp;page=1 返回结果 123456789101112131415161718192021222324252627282930313233343536[ { \"url\": \"https://api.github.com/repos/removeif/blog_comment/issues/comments/530767913\", \"html_url\": \"https://github.com/removeif/blog_comment/issues/3#issuecomment-530767913\", \"issue_url\": \"https://api.github.com/repos/removeif/blog_comment/issues/3\", \"id\": 530767913, \"node_id\": \"MDEyOklzc3VlQ29tbWVudDUzMDc2NzkxMw==\", \"user\": { \"login\": \"removeif\", \"id\": 10427139, \"node_id\": \"MDQ6VXNlcjEwNDI3MTM5\", \"avatar_url\": \"https://avatars1.githubusercontent.com/u/10427139?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/removeif\", \"html_url\": \"https://github.com/removeif\", \"followers_url\": \"https://api.github.com/users/removeif/followers\", \"following_url\": \"https://api.github.com/users/removeif/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/removeif/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/removeif/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/removeif/subscriptions\", \"organizations_url\": \"https://api.github.com/users/removeif/orgs\", \"repos_url\": \"https://api.github.com/users/removeif/repos\", \"events_url\": \"https://api.github.com/users/removeif/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/removeif/received_events\", \"type\": \"User\", \"site_admin\": false }, \"created_at\": \"2019-09-12T10:37:34Z\", \"updated_at\": \"2019-09-12T10:37:34Z\", \"author_association\": \"OWNER\", \"body\": \"&gt; 哇 大佬你博客弄的好厉害啊 可以指点指点吗\\n&gt;&gt; @xuelangjing 还好吧😂，简简单单的，可以多看下网页上的源码，有什么问题可以讨论讨论哦\" }, { ... } ] 总结此扩展方法优点：对于不在乎issue数量，只在乎最新评论的就比较适用，能够精准拿出前10条，很赞不足：一个issue下多个最新评论，如果想要显示的最新评论列表还包括文章标题，看起来可能不太好看，很多重复，但是看个人需要吧 注意事项，采坑环节 对应接口的请求限制，目前接口有请求的限制，所以使用中不能频繁请求，调试的时候一会儿又限制，一会儿又限制比较麻烦，限制十几分钟之后就解除了。 对于页面中，一般很多个地方可能都需要展示这个列表，所以不能每次都去请求，必须缓存起来，一般缓存到本地，我的是存的cookie中，十分钟去请求一次，所以调好后一般不会出现限制情况。但是马上评论了的就看不到，有10分钟的延迟，不过也还好。 对于如果issue以及评论太多的情况，尽量的少请求，比如上面的分页优化，取最后一条。以及页面中请求时做出异步请求的方式，不要阻止其他元素的渲染。 本人主要做后端，对前端的set/排序不太熟悉，上面实现排序代码比较繁琐😂，如果有什么更好的方法，麻烦也告知一下，互相学习共同进步。","link":"/theme/%E5%8D%9A%E5%AE%A2%E4%B8%ADgitalk%E6%9C%80%E6%96%B0%E8%AF%84%E8%AE%BA%E7%9A%84%E8%8E%B7%E5%8F%96.html"},{"title":"博客换肤的一种实现方式思路","text":"当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。 配置方法关于_config.yml主配置文件的注意事项。 1234567891011+ root: /remove.io/ #精简模式- root: / #正常模式deploy: type: git+ repo: https://github.com/removeif/remove.io.git #精简模式- repo: https://github.com/removeif/removeif.github.io.git #正常模式+ theme: icarus #正常模式- theme: nextn #精简模式 对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ 总结注意事项 对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问/image/tuizi.jpg，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的username.github.io/remove.io/ 地址。 对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。 对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的_config.yml配置。 12+ /remove.io/abouta/ #精简模式- /abouta/ #正常模式 本博客正常模式 精简模式 以上只是提供了一种解决方法思路，肯定还有更好的方式。","link":"/theme/%E5%8D%9A%E5%AE%A2%E6%8D%A2%E8%82%A4%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%80%9D%E8%B7%AF.html"},{"title":"博客源码分享","text":"写在前面 博客源码包括两个主题icarus和next，在主题基础之上参照各网友博客，以及自己的一些想法做出的一些修改以及增加部分新元素。因为修改了原作者源码，有什么问题请先联系我，不要去麻烦原作者了，能自己解决的问题就不要麻烦别人了，每个人的时间都很宝贵。膜拜和感谢所有模块的原作者,orz👻,辛苦了。 源码地址：欢迎围观，博主博客 一、icarus主题之上主要改动 新增gitalk最新评论widget 首页增加热门推荐 增加弹性配置影音（可加音乐、视频）模块 丰富弹性配置about页面 新增弹性配置友链模块 整体布局左右拉伸了一点，紧凑一些 文章页双栏模式、固定导航栏 引入可配置看板娘 归档页加入了一个文章贡献概览 置顶文章的设置 文章列表评论数显示 文章中推荐文章模块配置 增加深色主题切换 加入加密文章 碎碎念功能 透明无界样式 简化部分widget数据，加入查看全部按钮 gitalk评论增加评论开关，评论列表中标记博主 还有什么新的，好的feature欢迎大家随时提出来，有能力有时间就做出来 二、部分配置说明：本机环境：1234192:hexo-theme-icarus-removeif xx$ node -vv11.1.0192:hexo-theme-icarus-removeif xx$ npm -v6.4.1 克隆博客代码到本地1git clone https://github.com/removeif/hexo-theme-icarus-removeif.git 开始部分配置：敲黑板！！！！首先全局以及主题中的_config.yml配置成自己的对应参数。 1.热门推荐，最新评论：仅针对gitalk评论有效，如果配置完后显示本博客相关评论、推荐，请详细阅读这一条热门推荐，最新评论，文章评论数关联的js文件路径：themes/icarus/source/js/comment-issue-data.js以下引号里的地址改成自己对应的博客评论的issues的仓库相关的值。repoIssuesUrl改两个值（removeif和blog_comment改成自己对应的） themes/icarus/source/js/comment-issue-data.js12345// 评论issues仓库 by.removeif https://removeif.github.io/var repoIssuesUrl = \"https://api.github.com/repos/removeif/blog_comment/issues\"; // removeif：用户名，blog_comment：评论的issue仓库// 评论issues仓库 clientId、clientSecret怎么申请自行搜索，关于这暴露两个参数的安全问题，查看 https://removeif.github.io/2019/09/19/博客源码分享.html#1-热门推荐，最新评论：var clientId = \"46a9f3481b46ea0129d8\";var clientSecret = \"79c7c9cb847e141757d7864453bcbf89f0655b24\"; github api 详情可以参照官方api说明关于配置暴露client_id和client_secret安全性问题，gitalk作者有解释对应主题中的_config.yml要开启如下配置，xxx换成自己的，否则无效。 themes/icarus/_config.yml >folded1234567891011comment: type: gitalk owner: xxx # (required) GitHub user name repo: xxx # (required) GitHub repository name client_id: xxx # (required) OAuth application client id client_secret: xxx # (required) OAuth application client secret admin: xxx #此账户一般为用户名 GitHub user name 文章中能创建issue需要此用户登录才可以，点了创建issue后刷新一遍才能看到！！！！ create_issue_manually: true distraction_free_mode: true has_hot_recommend: true # 是否有热门推荐 has_latest_comment: true #是否有最新评论 说明： has_hot_recommend: true 是否开启首页热评，false-不开启，true-开启 has_latest_comment: true 是否开启最新评论，false-不开启，true-开启 热门推荐数据为评论数最多的文章，🔥后面的数字：根据文章的评论数*101 。 最新评论：为该仓库下，所有issue中的最新评论。 目前的最新评论有1分钟的本地缓存，评论后可能1分钟后才能看见最新评论，出于性能优化，每次请求接口处理还是挺耗时，comment-issue-data.js中可以自己去掉。 2.友链数据文件：文件路径：themes/icarus/source/js/friend.js相应格式增加自己需要的数据。 3.影音数据文件：文件路径：音乐：themes/icarus/source/json_data/music.json视频：themes/icarus/source/json_data/video.json相应格式增加自己需要的数据。 4.关于页面时间轴记录数据文件：文件路径：themes/icarus/source/json_data/record.json相应格式增加自己需要的数据。 5.看板娘配置主题中的_config.yml配置如下设置 1live2Dswitch: off #live2D开关 on为打开,off为关闭 6.置顶设置：.md文章头部数据中加入top值，top值越大越靠前，大于0显示置顶图标。修改依赖包中文件removeif/node_modules/hexo-generator-index/lib/generator.js如下： node_modules/hexo-generator-index/lib/generator.js >folded12345678910111213141516171819202122232425262728'use strict';const pagination = require('hexo-pagination');module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top == undefined){ a.top = 0; } if(b.top == undefined){ b.top = 0; } if(a.top == b.top){ return b.date - a.date; }else{ return b.top - a.top; } }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 7.配置文章中推荐文章模块根据配置的recommend值（必须大于0），值越大越靠前，相等取最新的，最多取5条。recommend（6.中top值也在下面示例）配置在.md文章头中，如下 123456789title: 博客源码分享top: 1toc: truerecommend: 1 keywords: categories-githubdate: 2019-09-19 22:10:43thumbnail: https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190919221611.pngtags: 工具教程categories: [工具教程,主题工具] 8.文章中某个代码块折叠的方法代码块头部加入标记 &gt;folded，如下代码块中使用。 main.java >folded123456789// 使用示例，.md 文件中头行标记\"&gt;folded\"// ```java main.java &gt;folded// import main.java// private static void main(){// // test// int i = 0;// return i;// }// \\\\``` 9.加入加密文章如下需要加密的文章头部加入以下代码 1234567891011121314---title: 2019成长记01top: -1toc: truekeywords: categories-java#以下为文章加密信息encrypt: truepassword: 123456 #此处为文章密码abstract: 咦，这是一篇加密文章，好像需要输入密码才能查看呢！message: 嗨，请准确无误地输入密码查看哟！wrong_pass_message: 不好意思，密码没对哦，在检查检查呢！wrong_hash_message: 不好意思，信息无法验证！--- 注：加密文章不会出现在最新文章列表widget中，也不会出现在文章中推荐列表中，首页列表中需要设置top: -1 让它排在最后比较合理一些。 10.碎碎念的使用在github中，创建碎碎念issue，并且打上对应的label（eg:666666）对应配置中为id，填写到source/self-talking/index.md文件中如下对应位置，其余配置也要改成自己的，如clientID等。 12345678910111213&lt;script&gt; var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')&lt;/script&gt; 如下： 11.本博客样式（透明无界）只需要放开themes/icarus/source/css/base.styl文件中以下样式代码注释即可，默认是注释的没启用 base.styl >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//=================本博客使用样式 start// 首页去图.body_hot_comment .comment-content .card-comment-item .ava, .media-left, .is-6-widescreen .card-image { display: none;}hover-color = #deeafb;// 去card.card { background-color: unset; //box-shadow: unset;}.navbar, footer.footer { background-color: unset;}body:not(.night) .navbar:hover,body:not(.night) .footer:hover,body:not(.night) .card:hover,body:not(.night) .pagination:hover,body:not(.night) .post-navigation:hover{ background-color: hover-color; box-shadow: 0 4px 10px rgba(0,0,0,0.05),0 0 1px rgba(0,0,0,0.1);}.pagination, .post-navigation{ padding: 10px;}.pagination .pagination-link:not(.is-current), .pagination .pagination-previous, .pagination .pagination-next { background-color:rgba(255,255,255,0);}.timeline .media:last-child:after { background: unset;}.footer { box-shadow: 0px 4px 10px 10px rgba(0,0,0,0.05); padding: 3rem 1.5rem 2rem;}@media screen and (max-width: 1087px) .navbar-menu { background-color: unset; }//=================本博客使用样式 end 如下： 精简部分widget数据widget中的归档和分类和标签精简了，数据多时很丑，改为了分别展示5条和10条和20条，增加了查看全部。 gitalk评论增加评论开关，评论列表中标记博主需要关闭评论的在文章头部加入 comments: false,原来已经评论的依然会显示，如下 原来已有博客文章的迁移，只需要把原来对应的文章放到source/_posts里即可。然后去对应文章下面创建评论issue。 以上配置好后12345$ npm install hexo --save #安装依赖包（只需要执行一次）$ hexo clean #清除缓存$ hexo g #编译 $ hexo s #启动服务 $ hexo d #推到远程 安装依赖包（只需要执行一次），以后修改了代码 只需要执行后面几条就好。 ok,enjoy it!！👏👏 有什么问题，欢迎issue里讨论。 写在后面如果你有问题请反馈: issues （请务必先于issues中寻找答案）如果你喜欢该主题: star如果你想定制主题: fork 文章中横竖图demo；对于横竖图推荐分开使用，且长宽一致的，如统一手机拍照、电脑截图使用方法：md文章中放入以下代码 index.html>folded123456789101112131415161718+ 横竖图&lt;div class=\"justified-gallery\"&gt;![张芷溪](http://wx1.sinaimg.cn/large/b5d1b710ly1g6bz7n92s7j212w0nr1kx.jpg) ![李一桐](http://wx2.sinaimg.cn/mw1024/005RAHfgly1fvfc4f19qfj33402c0qv9.jpg) ![gakki](http://wx1.sinaimg.cn/mw1024/70396e5agy1g5qe457i6yj21660ogtap.jpg) ![李一桐](http://wx1.sinaimg.cn/mw1024/005RAHfgly1fuzz17s2q3j32e43cku0x.jpg) ![彭小苒](http://wx1.sinaimg.cn/mw1024/d79c9b94ly1g1pb1uthr5j21f02iox6t.jpg)&lt;/div&gt;+ 横图4&lt;div class=\"img-x\"&gt;![v4](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191022182226.png) ![v3](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191018114126.png) ![v4](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191022182226.png) ![v3](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191018114126.png)&lt;/div&gt;+ 竖图5&lt;div class=\"img-y\"&gt;![电池](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145940.jpg) ![打王者荣耀](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024141906.jpg) ![支付宝付款](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024141926.jpg) ![锤子便签](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145956.jpg) ![电池](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145940.jpg)&lt;/div&gt; 效果如下（多图左右拉查看） 横竖图 横图4 竖图5 博客快照： 主页 深色主题 置顶 文章评论数 推荐文章模块 归档 留言 友链 美图 影音 关于","link":"/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html"},{"title":"安装、部分配置icarus主题中文版","text":"摘要发现icarus主题还不错，花了一两个小时研究了下安装、部分配置icarus主题中文版 安装icarus 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 配置icarus 完全参照官网配置，进行翻译解说 配置文章部分顶部图片添加icarus 主题中的配置_config.yml中开启图片开关 12article: thumbnail: true 文章.md文件头中添加图片绝对/相对地址 12345title: Getting Started with Icarusthumbnail: /gallery/thumbnails/desert.jpg// thumbnail:https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620152744.png---Post content... 配置完成后部署显示效果如下(最新文章列表显示缩略图、文章开头显示一张设置图片) 左边文章导航栏开启icarus 主题中的配置_config.yml中开关 1234widgets: - type: toc position: left 同事文章顶部加入标签 1234title: Table of Contents Exampletoc: true---Post content... 配置效果 评论系统开启icarus 主题中的配置_config.yml中开启（部分评论系统需要翻墙才能使用，valine不用翻墙个人推荐，valine安装参考） 1234567comment: type: valine app_id: xxxxxxxx # (required) LeanCloud application id app_key: xxxxxxxx # (required) LeanCloud application key notify: false # (optional) receive email notification verify: false # (optional) show verification code placeholder: xxxxxxxx # (optional) comment box placeholder text 开启效果 捐赠收款开启icarus 主题中的配置_config.yml中开启 注意如果默认不配置，编译时有报错，可以# 把它注释掉，不启用功能 1234567891011donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvxdcwm0j20p011i4bg.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvwdcpb5j20u014qgy2.jpg' 开启配置效果如下 全局搜索开启icarus 主题中的配置_config.yml中开启,不同的搜索类型需要安装插件参考官网,type: insight此类型不需要安装，已经内置 12search: type: insight 效果如下 更多配置请参考官网配置目前配置基本已经够使用，还需要更多配置请参考连接 参考自","link":"/theme/%E5%AE%89%E8%A3%85%E3%80%81%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AEicarus%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87%E7%89%88.html"},{"title":"tricks-2020-02","text":"[toc] 3屏保软件LINE Screen savernemesit/SwiftBubble: recreation of the soap bubble screen saver from apple’s promotional videos for the new MacBook 12”pedrommcarrasco/Brooklyn: 🍎 Screensaver inspired by Apple’s Event on October 30, 2018 4git 操作详解图片 5MySQL思维导图v2-06e4f9b7dcf0d4b157196f5e0eeab0cc_r.jpg (2536×2969) https://img-blog.csdn.net/20180321211647612?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1gxODYyMTE0NDU3Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70 Git aliasZshrc 定义了许多 git alias alias | grep git 常用的： 123456789101112131415161718192021g=gitga='git add'gaa='git add -all'gcb='git branch -b'gcmsg='git commit -m'gco='git checkout'gl='git pull'ggpull='git pull origin \"$(git_current_branch)\"'gp='git push'ggpush='git push origin \"$(git_current_branch)\"'ggsup='git branch --set-upstream=origin/$(git_current_branch)'gloga='git log --oneline --decorate --graph --all'grm='git rm'grmc='git rm --cached'# 区别在于，gss 更简短，一行一个状态，以 M（modified） 或 ？？（untracked）开头gss='git status -s'gst='git status' 12cd ~/.oh-my-zsh/plugins/gitcat git.plugin.zsh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257## Functions## The name of the current branch# Back-compatibility wrapper for when this function was defined here in# the plugin, before being pulled in to core lib/git.zsh as git_current_branch()# to fix the core -&gt; git plugin dependency.function current_branch() { git_current_branch}# Pretty log messagesfunction _git_log_prettily(){ if ! [ -z $1 ]; then git log --pretty=$1 fi}compdef _git _git_log_prettily=git-log# Warn if the current branch is a WIPfunction work_in_progress() { if $(git log -n 1 2&gt;/dev/null | grep -q -c \"\\-\\-wip\\-\\-\"); then echo \"WIP!!\" fi}## Aliases# (sorted alphabetically)#alias g='git'alias ga='git add'alias gaa='git add --all'alias gapa='git add --patch'alias gau='git add --update'alias gav='git add --verbose'alias gap='git apply'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gbda='git branch --no-color --merged | command grep -vE \"^(\\+|\\*|\\s*(master|develop|dev)\\s*$)\" | command xargs -n 1 git branch -d'alias gbD='git branch -D'alias gbl='git blame -b -w'alias gbnm='git branch --no-merged'alias gbr='git branch --remote'alias gbs='git bisect'alias gbsb='git bisect bad'alias gbsg='git bisect good'alias gbsr='git bisect reset'alias gbss='git bisect start'alias gc='git commit -v'alias gc!='git commit -v --amend'alias gcn!='git commit -v --no-edit --amend'alias gca='git commit -v -a'alias gca!='git commit -v -a --amend'alias gcan!='git commit -v -a --no-edit --amend'alias gcans!='git commit -v -a -s --no-edit --amend'alias gcam='git commit -a -m'alias gcsm='git commit -s -m'alias gcb='git checkout -b'alias gcf='git config --list'alias gcl='git clone --recurse-submodules'alias gclean='git clean -id'alias gpristine='git reset --hard &amp;&amp; git clean -dfx'alias gcm='git checkout master'alias gcd='git checkout develop'alias gcmsg='git commit -m'alias gco='git checkout'alias gcount='git shortlog -sn'alias gcp='git cherry-pick'alias gcpa='git cherry-pick --abort'alias gcpc='git cherry-pick --continue'alias gcs='git commit -S'alias gd='git diff'alias gdca='git diff --cached'alias gdcw='git diff --cached --word-diff'alias gdct='git describe --tags $(git rev-list --tags --max-count=1)'alias gds='git diff --staged'alias gdt='git diff-tree --no-commit-id --name-only -r'alias gdw='git diff --word-diff'function gdv() { git diff -w \"$@\" | view - }compdef _git gdv=git-diffalias gf='git fetch'alias gfa='git fetch --all --prune'alias gfo='git fetch origin'alias gfg='git ls-files | grep'alias gg='git gui citool'alias gga='git gui citool --amend'function ggf() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force origin \"${b:=$1}\"}compdef _git ggf=git-checkoutfunction ggfl() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force-with-lease origin \"${b:=$1}\"}compdef _git ggfl=git-checkoutfunction ggl() { if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git pull origin \"${*}\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull origin \"${b:=$1}\" fi}compdef _git ggl=git-checkoutfunction ggp() { if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git push origin \"${*}\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push origin \"${b:=$1}\" fi}compdef _git ggp=git-checkoutfunction ggpnp() { if [[ \"$#\" == 0 ]]; then ggl &amp;&amp; ggp else ggl \"${*}\" &amp;&amp; ggp \"${*}\" fi}compdef _git ggpnp=git-checkoutfunction ggu() { [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull --rebase origin \"${b:=$1}\"}compdef _git ggu=git-checkoutalias ggpur='ggu'alias ggpull='git pull origin \"$(git_current_branch)\"'alias ggpush='git push origin \"$(git_current_branch)\"'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias gpsup='git push --set-upstream origin $(git_current_branch)'alias ghh='git help'alias gignore='git update-index --assume-unchanged'alias gignored='git ls-files -v | grep \"^[[:lower:]]\"'alias git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github master:svntrunk'alias gk='\\gitk --all --branches'alias gke='\\gitk --all $(git log -g --pretty=%h)'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p'alias glgg='git log --graph'alias glgga='git log --graph --decorate --all'alias glgm='git log --graph --max-count=10'alias glo='git log --oneline --decorate'alias glol=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\"alias glols=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --stat\"alias glod=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\"alias glods=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset' --date=short\"alias glola=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --all\"alias glog='git log --oneline --decorate --graph'alias gloga='git log --oneline --decorate --graph --all'alias glp=\"_git_log_prettily\"alias gm='git merge'alias gmom='git merge origin/master'alias gmt='git mergetool --no-prompt'alias gmtvim='git mergetool --no-prompt --tool=vimdiff'alias gmum='git merge upstream/master'alias gma='git merge --abort'alias gp='git push'alias gpd='git push --dry-run'alias gpf='git push --force-with-lease'alias gpf!='git push --force'alias gpoat='git push origin --all &amp;&amp; git push origin --tags'alias gpu='git push upstream'alias gpv='git push -v'alias gr='git remote'alias gra='git remote add'alias grb='git rebase'alias grba='git rebase --abort'alias grbc='git rebase --continue'alias grbd='git rebase develop'alias grbi='git rebase -i'alias grbm='git rebase master'alias grbs='git rebase --skip'alias grev='git revert'alias grh='git reset'alias grhh='git reset --hard'alias groh='git reset origin/$(git_current_branch) --hard'alias grm='git rm'alias grmc='git rm --cached'alias grmv='git remote rename'alias grrm='git remote remove'alias grs='git restore'alias grset='git remote set-url'alias grss='git restore --source'alias grt='cd \"$(git rev-parse --show-toplevel || echo .)\"'alias gru='git reset --'alias grup='git remote update'alias grv='git remote -v'alias gsb='git status -sb'alias gsd='git svn dcommit'alias gsh='git show'alias gsi='git submodule init'alias gsps='git show --pretty=short --show-signature'alias gsr='git svn rebase'alias gss='git status -s'alias gst='git status'# use the default stash push on git 2.13 and newerautoload -Uz is-at-leastis-at-least 2.13 \"$(git --version 2&gt;/dev/null | awk '{print $3}')\" \\ &amp;&amp; alias gsta='git stash push' \\ || alias gsta='git stash save'alias gstaa='git stash apply'alias gstc='git stash clear'alias gstd='git stash drop'alias gstl='git stash list'alias gstp='git stash pop'alias gsts='git stash show --text'alias gstall='git stash --all'alias gsu='git submodule update'alias gsw='git switch'alias gswc='git switch -c'alias gts='git tag -s'alias gtv='git tag | sort -V'alias gtl='gtl(){ git tag --sort=-v:refname -n -l \"${1}*\" }; noglob gtl'alias gunignore='git update-index --no-assume-unchanged'alias gunwip='git log -n 1 | grep -q -c \"\\-\\-wip\\-\\-\" &amp;&amp; git reset HEAD~1'alias gup='git pull --rebase'alias gupv='git pull --rebase -v'alias gupa='git pull --rebase --autostash'alias gupav='git pull --rebase --autostash -v'alias glum='git pull upstream master'alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'alias gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify --no-gpg-sign -m \"--wip-- [skip ci]\"' 临时禁用 alias 加 \\ , 如： \\ls 或 unalias ls 我的 alias1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/usr/bin/env bash# 文件过长，建议放~/.alias## 控制cd命令的行为## get rid of command not found ##alias cd..='cd ..'## a quick way to get out of current directory ##alias ..='cd ..'# zsh 自带以下alias#alias ...='cd ../../../'#alias ....='cd ../../../../'#alias .....='cd ../../../../'#alias .4='cd ../../../../'#alias .5='cd ../.././../..'## 命令加默认参数alias bc='bc -l' # 让计算器默认开启math库alias mkdir='mkdir -p' # 自动创建父目录alias mv='mv -i' # 移动，复制文件显示详细信息alias cp='cp -i'alias ln='ln -i'alias wget='wget -c' #默认断点续传alias df='df -H' # human df查看磁盘使用情况alias du='du -h' # du 查看当前目录各个文件、目录占用大小，-s （sum）总大小alias ping='ping -c 5' # ping 5次停止alias top='htop' # 用更好用的htop替换top## 命令缩写alias h='history -30'alias c='clear'## 创建一系列新命令alias path='echo -e ${PATH//:/\\\\n}' # 显示变量PATH,并将：替换为回车alias now='date +\"%T\"' # 时分秒alias nowtime=nowalias nowdate='date +\"%Y-%d-%m\"'# 年月日alias header='curl -I' # get web server headers #alias checknet='curl -I http://www.baidu.com' # 检查网络连通性alias checkproxy='curl -I http://www.youtube.com' # 检查 proxyalias psmem10='ps aux | sort -nr -k 4 | head' # mem占用前10alias pscpu10='ps aux | sort -nr -k 3 | head' # cpu占用前10alias speed='speedtest-cli --simple' #测速 （需安装speedtest-cli）alias ipe='curl ipinfo.io/ip' # 查看公网ip（???）alias ipi='ipconfig getifaddr en0' # 查看ip地址alias untar='tar -zxvf'alias getpass='openssl rand -base64 6' # 8位密码mcd() { mkdir -p \"$1\"; cd \"$1\";} # 创建目录并进入cls() { cd \"$1\"; ls;} # cd and ls## 以树形结构递归地显示目录结构,命令有问题，不实用sbs() { du -d 1 | sort -nr | perl -pe 's{([0-9]+)}{sprintf \"%.1f %s\", $1&gt;=2**30? ($1/2**30, \"G\"): $1&gt;=2**20? ($1/2**20, \"M\"): $1&gt;=2**10? ($1/2**10, \"K\"): ($1, \"\")}e';}# k8salias kdev=\"kubectl --cluster kubernetes-dev --user kubernetes-admin -n\"alias ktest=\"kdev data-test\"alias kprod=\"kubectl --cluster kubernetes --user dev -n data-prod\"alias kstaging=\"kubectl --cluster kubernetes --user dev -n data-staging\"# sshalias sshcpui='ssh -CAXY determined-cori.zhangronghui.brw@bj-a-internal.brainpp.cn'alias sshgpui='ssh -CAXY goofy-mestorf.zhangronghui.brc@bj-a-internal.brainpp.cn'alias sshcpu='ssh -CAXY determined-cori.zhangronghui.brw@bj-a.brainpp.cn'alias sshgpu='ssh -CAXY goofy-mestorf.zhangronghui.brc@bj-a.brainpp.cn'export cpui='determined-cori.zhangronghui.brw@bj-a-internal.brainpp.cn'export cpu='determined-cori.zhangronghui.brw@bj-a.brainpp.cn'export gpui='goofy-mestorf.zhangronghui.brc@bj-a-internal.brainpp.cn'export gpu='goofy-mestorf.zhangronghui.brc@bj-a.brainpp.cn'alias ytdl='cd \"/Users/zhangronghui/ytdl\"; python3 main.py'# alias ytdl=\"youtube-dl --proxy 'socks5://127.0.0.1:1086' --write-auto-sub --sub-lang en,cn -f bestvideo+bestaudio -o '%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s'\"# alias rm=rmtrashalias py=\"python3 main.py\"alias tabcopyToMdLink=\"python3 '/Volumes/Data/PycharmProjects/private/22 tabcopyToMdLink/main.py'\"# 常用命令的替代工具alias ls='exa'alias npm='cnpm'alias grep='ag'alias cat='bat'# mycli -uroot -pkang0322# 替代 mysql -uroot -p# 查看 json 文件# fx package-lock.jsonalias wget='axel -n 32'alias pip='pip3'# 关于 ssh 别名的注意事项不要创建 ssh 别名，代之以 ~/.ssh/config 这个 OpenSSH SSH 客户端配置文件。它的选项更加丰富。下面是一个例子： Host server10 Hostname 1.2.3.4 IdentityFile ~/backups/.ssh/id_dsa user foobar Port 30000 ForwardX11Trusted yes TCPKeepAlive yes然后你就可以使用下面语句连接 server10 了： $ ssh server10 如果有来生—— 三毛 如果有来生，要做一棵树， 站成永恒。没有悲欢的姿势， 一半在尘土里安详， 一半在风里飞扬； 一半洒落荫凉， 一半沐浴阳光。 非常沉默、非常骄傲。 从不依靠、从不寻找。 如果有来生，要化成一阵风， 一瞬间也能成为永恒。 没有善感的情怀，没有多情的眼睛。 一半在雨里洒脱， 一半在春光里旅行； 寂寞了，孤自去远行， 把淡淡的思念统统带走， 从不思念、从不爱恋； 如果有来生，要做一只鸟， 飞越永恒，没有迷途的苦恼。 东方有火红的希望， 南方有温暖的巢床， 向西逐退残阳，向北唤醒芬芳。 如果有来生， 希望每次相遇， 都能化为永恒。 5拆米袋线短的一边，在线与袋子的连接处，剪断。米袋一边 1 条线，一边 2 条线。从 2 条线的一边解开。 nfc 记录时间知道自己的时间花费之后能够让我们更好的做计划、平衡生活和自我提升。每次想记录时间就觉得过程十分复杂和枯燥，今天就和大家分享一个最近研究出来的，超高效的时间记录吧！ 出现&amp;提到的产品： ​ NFC电子标签 https://m.tb.cn/h.VYLOGi2 （如果贴在电脑上需要用抗金属贴） Toggl 时间记录 ​ 电脑 http://bit.ly/2tY3ps3 ​ 苹果手机 https://apple.co/2Ryd81l ​ 安卓手机 http://bit.ly/36Azjbm 批量重命名和批量替换字符串批量修改文件名假设要把所有以“disc-”开头的文件改为“dev-”开头，那么在linux下执行命令： 1rename 's/disc-/dev-/' * 批量修改文件内容1、假设我们要把文件中的“设计开发”改为“专业”，那么执行命令： 1sed -i \"s/设计开发/专业/g\" `grep 设计开发 -rl .` 2、假设我们要把文件中的http://7oxjrx.com1.z0.glb.clouddn.com改为http://cdn.voidking.com，那么执行命令： 123sed -i \"s/http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com/http:\\/\\/cdn.voidking.com/g\" `grep http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com -rl .`# 或者sed -i 's!http://7oxjrx.com1.z0.glb.clouddn.com!http://cdn.voidking.com!g' `grep http:\\/\\/7oxjrx.com1.z0.glb.clouddn.com -rl .` 3、假设我们要把文件中的https://www.voidking.com/2018/06/11/dev-hexo-categories/改为https://www.voidking.com/dev-hexo-categories/，这个就比较难了，可以先进行调试： 12345grep -P '\\d{4}\\/\\d{2}\\/\\d{2}\\/' -rl .echo \"https://www.voidking.com/2018/06/11/dev-hexo-categories/\" | sed \"s/\\d{4}\\/\\d{2}\\/\\d{2}\\///g\"echo \"https://www.voidking.com/2018/06/11/dev-hexo-categories/\" | sed \"s/\\([0-9][0-9][0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\///g\" 因为grep和sed都不支持完全的正则表达式，所以grep要加P参数，sed要改写正则表达式。最后得到的命令为： 1sed -i \"s/\\([0-9][0-9][0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\/\\([0-9][0-9]\\)\\///g\" `grep -P '\\d{4}\\/\\d{2}\\/\\d{2}\\/' -rl .` 在线分词工具微词云 - 制作 - 设计页 9京东口罩自动抢购并下单cycz/jdBuyMask: 京东监控口罩有货爬虫，自动下单爬虫，口罩爬虫Rlacat/jd-automask: 防护-京东口罩自动抢购并下单 黑苹果macOS取消4位数密码限制 可设置一位数密码 – 黑苹果屋 pwpolicy -clearaccountpolicies 未测试 黑苹果三码注入解决iMessage、FaceTime、APPStore、iCloud登录（陆）使用问题 – 黑苹果屋Clover引导如何简单隐藏多余启动磁盘 – 黑苹果屋设置Clover自动倒计时引导系统 – 黑苹果屋 关键字 免费 的搜索结果 - 精品MAC应用分享ReadKit 2.4.3 一站式阅读体验 - 精品MAC应用分享 Mpv 安装 export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; brew cask install mpv 装的过程有点久 去 IINA+ 将播放器设置为 mpv, 可解决播放视频没声音的问题 配置见本站其他博客 10推荐一个非常实用的学习 GitHub 的软件 | Laravel China 社区 用不上的网站： 再分享几个YouTube视频在线解析下载网站 – 楚盟网分享一个视频在线解析下载网站，秒杀youtube、Facebook视频 – 楚盟网 bilibili evolved : bilibili 优化 及 批量下载油猴插件 雨课堂一键完成预习【注意：此软件只适用于没有习题的课件】 蓝奏云：https://www.lanzous.com/i6voq6d Berrycast - 屏幕录制分享工具[Windows/macOS] - 小众软件小爱同学v2.8.01通用版 非小米手机可用 | 芊芊精典4k wallpaper 壁纸4k Wallpapers HD &amp; 8k Images for Desktop and MobileIncredible Wallpapers and Background pictures for mobile and desktop for free - WallpaperTAG Authy 两步验证利器 Authy 是一款两步验证软件，与 Google 身份验证器类似，支持 iOS、安卓、macOS、Windows、谷歌浏览器扩展。 Authy 可以同时管理多个平台的两步验证，支持多设备同时使用，也可以快速在设备之间迁移、抹除。 对于中国用户 Authy 偶尔会出现短信接受延迟等情况。 官网 https://authy.com iRightMouse 1.0.3 for Mac 超赞的Mac右键菜单扩展干净的Mac 破解软件下载macwkhttps://macstore.info/https://www.macappbox.com/ pushups 备份位置 12Mac 悬浮播放 YouTube 影片codeclown/FloatPlayer: FloatPlayer is a simple Mac app that plays a floating YouTube-video on your screen. 自动生成视频字幕raryelcostasouza/pyTranscriber: pyTranscriber can be used to generate automatic transcription / automatic subtitles for audio/video files through a friendly graphical user interface. AlternativeTo 寻找同类优秀软件AlternativeTo - Crowdsourced software recommendations Ma63d/leetcode-viewer: 用无后台、纯前端的单页应用来分享、呈现你的leetcode源码吧!13Mpv 录制直播streaming - Save video playing in mpv –ytdl to a file while playing - Super User 1234mpv --stream-record=video.mkv url# --record-file 过时了mpv --record-file=video.mkv url url 可以通过 iina+ + iina 播放直播，然后在播放列表里右键复制链接 Mac技巧之苹果电脑下载/录制 Bilibili 直播视频的软件：B站录播机 - 苹果fans博客未测试 Mpv 官方脚本User Scripts · mpv-player/mpv Wiki IFTTT（没学）4.打造你自己的个性化极速通知神器。如果你和我一样喜欢折腾，并且还没有用过IFTTT这款软件，那么请赶紧尝试吧~ ifttt是“if this then that”的缩写，事实上是让你的网络行为能够引发连锁反应、让你使用更为方便，其宗旨是“Put the internet to work for you”（让互联网为你服务）。ifttt旨在帮助人们利用各网站的开放API，将Facebook、Twitter等各个网站或应用衔接，完成任务，使“每个人都可以成为整个互联网不用编程的程序员”。 目前已经同时支持iOS、Android以及网页版：Put the internet to work for you.有了它可以实现非常多非常好玩有用的功能，爱折腾的同学肯定能自行研究出各种厉害的用法。入门介绍：iFTTT 入门介绍与简单使用设置教程 这里只介绍和RSS功能结合起来的基本应用：注册了IFTTT账号、在手机上下载客户端后，就能够在线编辑你想要的各种网络任务了。比如实现这个：“如果在交大BBS上有人出售ipad的话，在手机上弹窗通知我” 因为学校BBS上经常有抢手的二手货，每次等我看到的时候就被人秒掉了。自从有了RSS+IFTTT，遇到我关注的二手商品，我每次都能快人一步了XD。 另外PushBullet也是非常好的可以结合使用的应用，暂不详述。 cnfeat/Rime: 鼠须管 小鹤双拼 输入法配置及配色方案 sunzongzheng/music: electron跨平台音乐播放器；可搜网易云、QQ音乐、虾米音乐；支持QQ、微博、Github登录，云歌单; 支持一键导入音乐平台歌单13Chrome插件Zoom Text Only，实现浏览器中仅缩放文本大小-文章-扩展迷Share Extensions插件，一键分享你正在使用的Chrome扩展-文章-扩展迷最高增强六倍的VolumeControl插件，应该是浏览器上最好用的音量控制器-文章-扩展迷Scroll To Top Button插件，一键到达网页顶部或底部-文章-扩展迷牛客简历助手，闪填简历模板，自动同步招聘官网-文章-扩展迷SearchBar，快捷搜索插件，集合维基百科/Wolfram/eBay等多平台-文章-扩展迷AutoScroll，页面自动滚动插件，自定义滚动速度-文章-扩展迷colorize-change-color-for，浏览器颜色调整插件，打造谷歌搜索/YouTube新主题-文章-扩展迷Hippo Video，视频在线录制/编辑插件，支持屏幕录制-文章-扩展迷 Web Developer，开发者调试插件，集成多类web开发工具-文章-扩展迷 hr3lxphr6j/bililive-go: 一个直播录制工具全平台 CHKZL/DDTV2: 监控室老大爷多路直播监控——DDTV1.0的精神续作(，DDTV2.0。可进行B站直播开播提醒，自动录制，播放。油管，TC直播监控。 Win 平台 m-cli 命令行控制 Mac12345678910111213141516171819202122232425262728293031323334353637383940414243444546➜ ~ brew install m-cli➜ ~ m -h Swiss Army Knife for macOS ! usage: m [OPTIONS] COMMAND [help]OPTIONS --update update m-cli to the latest version --uninstall uninstall m-cliCOMMANDS: help battery bluetooth dir disk display dns dock finder firewall flightmode gatekeeper group hostname info itunes lock network nosleep notification ntp printer restart safeboot screensaver service shutdown sleep timezone trash update user volume vpn wallpaper wifi 14win baiduyun 破解下载 亿寻 — yixun繁体字幕转简体12345678910111213141516171819➜ subtitles pip install hanziconv➜ subtitles hanzi-convert -husage: hanzi-convert [-h] [-o OUTFILE] [-s] [-v] infileSimplified and Traditional Chinese Character ConversionVersion 0.3.2 (By Bernard Yue)Converting to Traditional Hanzi by defaultpositional arguments: infile filename | \"-\", corresponds to stdinoptional arguments: -h, --help show this help message and exit -o OUTFILE, --output OUTFILE filename to save output, default to stdout -s, --simplified convert to simplified -v, --version show program's version number and exit➜ subtitles hanzi-convert -o While.You.Were.Sleeping.E02.170927.1080p-NEXT.chs.srt -s While.You.Were.Sleeping.E02.170927.1080p-NEXT.cht.srt Todo: 简化操作123# hanzi-convert-s ....srt 转换一个字幕hanzi-convert-s(){hanzi-convert -o $1.chs.$2 -s $1.$2}# hanzi-convert-s-dir ./path 转换一个目录 有编码问题，不是所有字幕都能转换 电话骚扰 - 不死鸟 - 分享为王15agefans：动漫追番网站 - 不死鸟 - 分享为王每日图片：第176期 - 不死鸟 - 分享为王微信QQ最简单互传文件软件——open2share - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn用了很久的鼠标指针样式，用了很久了哦，超级喜欢 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn微信僵尸粉被删好友查找工具 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn 关于疫情防控期间开通WEBVPN访问校内网站资源的通知美剧星球 v1.1.4无广告免费看最新高清美剧 | 芊芊精典电影迷 Mod v1.6.0去广告推荐精简会员版+影迷天堂v1.2.9无广告免费看全网影视 | 芊芊精典抖音短视频v9.8.1去广告去水印版 | 芊芊精典 Enhancer for YouTube插件，YouTube播放器多功能增强控件-文章-扩展迷Auto Sci-Hub插件，将DOI号自动替换为Sci-Hub链接，一键下载文献-文章-扩展迷SearchBar，快捷搜索插件，集合维基百科/Wolfram/eBay等多平台-文章-扩展迷吐血推荐珍藏的IDEA插件Android 抖音短视频v9.8.1 去广告版 - 果核剥壳Sleepo「Sleepa」v1.6.2 for Android 破解高级版 —— 提升您睡眠质量、休息质量、放松和冥想 | 异星软件空间 SoundSource 4.2.1 音频控制软件 - 精品MAC应用分享超全的PanDownload搜索插件！ - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cnKlokki 1.1.3 任务管理 - 精品MAC应用分享DropDMG 3.5.9 轻松制作DMG文件 - 精品MAC应用分享最新版PC微信2.8.0.121正式版-防撤回 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cnbackiee 提供數千張 8K、5K、4K 與高畫質 Windows 免費桌布圖片的免費工具，支援一鍵設置功能 - 電腦王阿達Motion 可針對特定時間鎖定指定網站，來提升工作效率的免費擴充外掛 - 電腦王阿達FeedPop - RSS阅读器，更适合国人使用的优秀国产RSS阅读器-文章-扩展迷满速的百度网盘下载工具-亿寻，更新新版及官网-福利吧窗口最前工具WTOP - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn微搜v2.0.1 图片网盘等多功能搜索器 | 芊芊精典电影天堂v1.0去广告去升级版+Noad v8.0.2_清爽版『付费电影/直接免费看』 | 芊芊精典光影v1.5.0全网VIP支持倍速缓存 | 芊芊精典大象视频v1.3.6去广告版 全网VIP影视免费看 | 芊芊精典面试热点|理解TCP/IP传输层拥塞控制算法ZY Player(开源影视聚合播放器) v0.8.9 绿色版 - 果核剥壳Downie 3.9.9 视频下载工具 - 精品MAC应用分享 关于启动“雨课堂”教学平台开展在线教学的通知关于春季学期使用“爱课堂”网络教学平台开展在线教学的通知Wondershare Video Converter(万兴优转)v11.7.1.3 特别版 - 果核剥壳 Berrycast - 屏幕录制分享工具[Windows/macOS] - 小众软件All Windows Appear - MacMenuBar.com【2月8日更新】选择文件-右键-发送到蓝奏云盘【一键生成蓝奏云盘分享链接】 - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|破解软件|www.52pojie.cn 北京邮电大学研究生院 Unplug Alarm - MacMenuBar.com MacBook Pro 中app store购买过程中出错是为什么？ - 知乎在 Mac App Store 注销并重新登录。 16低端影视 - 超清在线视频站首页_海兔影院-中国版电视剧-6v电影-新版6v电影_免费电影_高清电影__最新电视剧下载（旧版66影视） 独播库哔嘀影视，热门电影，最新电影，最新电视剧，免费下载，免费在线观看 最新电影网_西瓜影音_碟调网_看看屋影视_看看影院_2018最新电影电视剧在线观看蛋蛋赞影院 | 最新最全高清在线影院 迅播影院-迅播高清-Gvod电影-迅雷电影下载-迅播22tu.cc酷绘视频 - 轻松随心看手机看大片,手机看电影,手机看电视,手机电影下载 - 我的电影网七七看片-七七影院_七七电影天堂_最新电影百度影音_BT天堂全集网 23.草民电影：https://www.cmdy5.com/24.私人官网：http://www.aishang118.cn/25.电影盒子：http://www.tv5box.com/26.全能影视：http://www.qnvod.net/27.影视分享：https://www.ysshare.com/28.94神马电影网：http://www.9rmb.com/29.好恐怖：http://www.hkb123.com/30.慢头影视：http://www.paojiaoys.com/31.影猫：http://www.mvcat.com/32.BT猫：https://www.btmao.cc/33.神马电影网：https://www.jlszyy.c34.达达兔电影院：https://www.dadatutu.com/35.西瓜影院：https://www.xigua2222.com/36.片吧：http://www.pianba.tv/37.片库网：https://www.pianku.tv/38.无双影视：https://53ys.cc/39.80s手机电影网：http://www.8080s.net/40.西瓜电影：https://www.xigua110.com/41.人人影视：http://www.yyetss.com/41.人人影视：http://www.yyetss.com/42.高清资源网：http://www.gaoqingzy.com/43.OK电影网：http://www.kk2w.cc/44.豆瓣电影资源采集网：http://www.douban666.com/45.87影院：https://www.87kk.tv/46.放映影院：https://www.t90dyy.tv/47.速影TV：https://suyingtv.com/48.嘀哆咪影视：https://www.haiduomi.cc/49.优片网：http://www.iupian.com/50.黑米影院：https://www.tv432.com/51.且听风吟：http://www.qtfy7.com/52.88影视网：https://www.88ys.com/53.嘀哩哩：http://www.dililitv.com/54.云播TV：https://www.yunbtv.com/55.田鸡影院：http://www.tianjiyy123.com/56.奈非影视：https://www.nfmovies.com/57.全集网：https://www.quanji789.com/58.全集网：http://quanji456.com/59.狗带TV：http://www.goudaitv1.com/60.五杀电影院：https://www.lol5s.com/61.蓝马影视：https://www.lanmays.com/62.奇葩影视：https://www.qpvod.com/63.迅雷哥：https://www.4142.cc/64.影视分享：https://www.ysshare.com/65.新视觉影院：http://www.yy6080.cn/66.v部落：http://www.vbuluo99.com/67.神驴影院：http://www.shenlvyy.com/68.美鱼剧场：http://www.hailiys.com/69.吼吼：http://hoho.tv/70.酷云影视：https://kuyun.tv/71.想看剧：https://www.xiangkanju.cc/72.去看TV：http://www.quk73.胖子视频：http://www.pangzi.ca/74.海外影院：https://www.haiwaiyy.com/75.好吧：http://hao8tv.com/76.日本影视：http://www.jp2468.com/77.TNT影视：http://www.tntdy2.vip/78.优乐电影网：http://www.youlebe.com/79.面包网：https://www.mianbao99.com/80.猫哈哈：http://www.maohaha.com/81.七七电视：https://www.77ds.vip/82.我乐电影：http://www.56dy.com/83.钉子电影：http://www.dingziyc.com/84.蓝鲸电影：https://www.ljmovie.com/85.葡萄影视：https://www.putaoys.com/86.太初电影：https://www.tcmove.com/87.完美看看：https://www.wanmeikk.me/88.吾爱看影视：http://www.5aikp.com/89播王：https://bowan.su/90.Gimy TV剧迷：https://gimy.tv/91.NO视频：http://www.novipnoad.com/92.枫林网：http://8maple.ru/93.91美剧：https://91mjw.com/94.美剧鸟：http://www.meijuniao.com/95.爱美剧：https://www.meiju.net/96.天天看美剧：http://www.ttkmj.tv/97.日剧TV：https://www.rijutv.com/98.韩剧集网：https://www.juji.tv/99.韩剧网：http://www.hanju.cc/100.韩剧TV：https://www.hanjutv.com/101.Zzzfun：http://www.zzzfun.com/102.妮可动漫：http://www.nicotv.me/103.吐槽弹幕网：http://www.tucao.one/104.动漫岛：http://www.dmd8.com/105.碟影视界：http://www.952780.com/106.皮皮影视网：https://www.taiks.com/107.ADC电影网：https://www.adcmove.com/108.欧西电影：https://www.ouxi.me/109.青鸟影视：https://www.qingniao.me/110.盐酥鸡：https://www.ysuzy.com/111.爱电影天堂：https://www.idytt.com/ 北京地铁满载率查询功能升级 可实时显示车厢满载率 - CNMO 17GitZipGitZip 可以帮助我们下载仓库中的部分文件，并且支持下载单个文件夹。 如何使用呢？ 鼠标定位到我们需要下载的某个项目子文件夹上，在空白区域双击： 然后点击下载即可！ clicli.me 超清动漫视频在线观看c站-clicli弹幕网_(⁄•⁄ω⁄•⁄) 社保~ clicli.me 分轨-上传文件，即刻分离人声和伴奏全国新冠肺炎疫情实时动态 - 丁香园·丁香医生首页 - 简单教程，简单编程 寻–优秀好玩的网址聚合 18免费宽带提速工具，支持部分地区及宽带 - 冰封娱乐网 19\\1. pdf2doc https://www.pdf2doc.com/\\2. 局域网共享精灵 http://lanshared.com/\\3. 造字APP http://myfont.me/\\4. copytranslator https://copytranslator.github.io/github项目https://github.com/CopyTranslator/CopyTranslator\\5. 较真查证平台 https://vp.fact.qq.com/home\\6. visulgo https://visualgo.net/en\\7. OneDrive直链获取工具 https://onedrive.gimhoy.com/\\8. 考试酷 https://www.examcoo.com/index/ku\\9. logo-crunch https://brandmark.io/logo-crunch/\\10. Soundgood https://play.soundsgood.co/ (被墙) desktop.telegram.orgdesktop 版本可以用 23电子书下载网站全览每日书单- 精品电子书下载 - azw3 - epub - mobi - kindle电子书水果派 美剧星球APP官网 -免费在线看最新高清美剧攀登 https://pan.baidu.com/s/1dI8S31Z4oE7kpuO-CfS_yw 提取码：p79k备用 提取码: v283 电影推荐 · MVCATTable Capture，Chrome表格复制插件，自动筛选复制HTML中的表格-文章-扩展迷Smart Tab Mute插件，让浏览器仅保留其中一个标签页的音频播放-文章-扩展迷 打不开“XXX”，因为它来自身份不明的开发者1.打开了 Terminal 终端后 ，在命令提示后输入 sudo spctl –master-disable 2.系统偏好设置&gt;&gt;安全与隐私&gt;&gt;允许安装未知来源 24Github中转下载Link Klipper插件，提取并导出网页链接插件，储存为CSV或者TXT格式文件-文章-扩展迷 可以用来导出所有链接，然后下载视频 25等门槛效应 一个人如果接受了他人的请求，为了避免认知上的失调，或者是出于想保持人设的心理，就有可能接受更大的请求 自我羊群效应 所谓自我羊群效应，指的是，即使影响你决策的情绪已经消失了，你日后的决策也会参考第一次的结果，从而持续受到最初那个情绪的影响。 比如说你女朋友生日前几天你刚好打麻将赢了不少，心情非常畅快，于是平时只舍得送露华浓的，这次居然买了香奈儿，而下次她生日的时候，即使你已经不记得赢钱这回事了，你也很大可能不会再送露华浓了。 所以啊，在面对新环境或者情绪很不稳定的时候，一定不要轻易下决定，因为一次决定并不是只影响一个结果。 ④逆向合理化效应 人是相当奇怪的自我合理化机器，这个效应指的是，当一件是你做久了之后，你就会为这件事找到一个合理的原因，以此来证明自己是正确的。 ⑤赋能效应 这张图你应该很熟悉了，就是所谓的艾宾浩斯遗忘曲线图，但实际上，还有一个非常重要的点你可能没有注意到，就是下面这张图： 不同内容的遗忘程度，也是不同的，艾宾浩斯总结出来，我们的大脑，最容易忘记那些没有意义的音节，有意义的东西，留存率会更高。 所以，在学习一个技能或者知识点之前，就要不断在心中赋予这个技能或知识点意义，比如说学了之后，能让自己轻松很多，能给客户更好的用户体验，能得到老板的赏识，走上人生巅峰等等。 ⑦生成效应 说的是相对于你故意去背诵的现成的知识点，你更能记住的是学习过程中，自己主动提取推导出来的知识点，这点运用在学习上非常有效。 ⑧踢猫效应 这个效应要多注意一下哦，指的是对比自己弱小或者等级比自己低的人发泄不满，进而产生了连锁反应，由塔尖一直扩散到最底层，最后那个成为最终受害者。 我们经常能看到，刚进团队的新人经常成为背锅侠；那些努力扎进高级圈子的人，最后都不正常了。 在一个环境里，如果只能当最弱一环，那还是赶紧离开的好。 ⑨人们会倾向于在当前的选项里做选择，而不是考虑有没有其他选项。 所以啊，如果你要约人，最好不要说“诶，你周六有没有空？”，因为如果对方原本就没有什么打算跟你出去，那ta会倾向于选择成本低的那个，没空；但如果你说“周六出去还是周日？”那ta无论选哪个，你的目的都得逞啦。 ⑩启动效应 所谓的启动效应，指的是当你看到某个事物的时候，大脑自动会触发你的行为或认知。 如果你想要坚持运动，就把瑜伽垫哑铃之类的放在显眼的地方，请了私教的话，就把他的朋友圈星标，聊天窗口置顶，这些东西就会触发你想运动这个认知； 如果你早上喝杯咖啡工作效率能提高不少，那咖啡对你来说也有启动效应。 把每一个启动效应都记下来，你的每天的成就感，至少能提升30% ⑪从来没有体验过失去的人，对于拥有是什么滋味的认知，往往也非常有限。 总是无条件地帮别人的忙，别人一喊你就到，长此以往，你的付出就会沦为应该，深藏不露，偶尔出手相助，反而能让大家记住你的好。 ⑫出丑效应 又称仰巴脚效应或缺点效应，是指太过完美的人，经常不太讨人喜欢，因为无论谁，站在你身边都无所适从，自愧不如，还怎么做朋友嘛。 最讨人喜欢的人，往往都是精明之中又带点小缺点的。 ⑬过度理由效应 之前在一个读本里看到一个故事： 一位老人在一个小乡村里休养，但附近却住着一些十分顽皮的孩子，他们天天互相追逐打闹，喧哗的吵闹声使老人无法好好休息。在屡禁不止的情况下，老人把孩子们都叫到一起，告诉他们谁叫的声音越大，谁得到的报酬就越多，他每次都根据孩子们吵闹的情况给予不同的奖励。到孩子们已经习惯于获取奖励的时候，老人开始逐渐减少所给的奖励，最后无论孩子们怎么吵，老人一分钱也不给。结果，孩子们认为受到的待遇越来越不公正，认为不给钱了谁还给你叫，再也不到老人所住的房子附近大声吵闹。 这其实就是过度理由效应，每个人都力图使自己和别人的行为看起来合理，因而总是为行为寻找原因。一旦找到足够的原因，人们就很少再继续找下去。 有时候反其道而行效果很不错。 ⑭破窗效应 一个屋子如果窗户破了，没有及时修补，隔段时间，其他的窗子也会被打破，这个现象就是破窗效应。 其实人也是这样的，一个坏习惯你放着不管，迟早会滋生出更多的坏习惯；对方如果一开始欺负你的时候，你没有反抗，后面就会变本加厉。 ⑮皮格马利翁效应 心理学家们发现，人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 用人话来讲，就是当一个人获得了别人的信任跟支持之后，ta就会不断调整自己去适应大家的期望，从而增强了自我的价值，变得自信，变得更加积极向上，并且尽力达到大家的期待，从而维持这种社会支持的连续性。 关于这个效有一个非常著名的实验，我记得是中学的时候了解到的。 1960年，哈佛大学的罗森塔尔博士告诉加州一所学校的两位教师，他们是本校最好的教师，他们班里的学生比同龄孩子智商要高，请他们务必与其他孩子一样正常对待。一年之后，这两个班级的学生成绩是全校中最优秀的，甚至比其他班学生的分数值高出好几倍。而其实这两位教师是被随机挑选出来的，所教的孩子们也与其他孩子无异。 26fan qiang API IDEA javadoc 安装插件 javadoc 在需要生成doc 的目录右键 generate javadoc，会为 Java 代码的 public 方法生成注释 tools generate javadoc，弹出一个对话框，Locale 是语言类型，填zh-CN idea 会自动用浏览器打开 HTML，生成的文件在 idea 软件目录中 mac iterm2 以单词为单位移动的快捷键设置Mac下iTerm2光标按照单词快速移动设置_运维_skyyws的博客-CSDN博客 27在线文字Logo设计制作工具 - 万能兔工具网 Keyboard Maestro 9.0.5 破解版 for Mac 超强的mac自动化工具Soulver 3.2.2.1 破解版 for Mac 记事本中快速计算Kaleidoscope 2.3.1438 破解版 for Mac 很好的文件对比工具 28深呼吸放松 Breathe Relaxer - Calm down your mind, relax your body","link":"/tricks/tricks-2020-02.html"},{"title":"tricks 2020 01","text":"tricks 2020 01 31 Introduction - 十大经典排序算法 Visualize Python, Java, JavaScript, C, C++, Ruby code execution 查看代码执行过程，找bug Java Tutor - Visualize Java code execution to learn Java online 30在线编辑网页生成代码: https://grapesjs.com/根据草图生成代码：https://sketch2code.azurewebsites.net/ 18个堪称神器的命令行工具 icdiff：分屏显示 diff常规 diff： icdiff： 比传统 diff 更明白些，是吧？效果比 sdiff 好不少，还可以配置到 git 里，变成默认的 git diff查看工具，比原来的 diff 漂亮不少吧？ pm：在 bash / zsh 中迅速切换项目目录将你常去的目录添加到 pm 中，然后一条命令进行切换： 12cd projects/awesome-projectpm add awesome-project 上面的 pm add + 名称，可以将当前目录存储到 pm 中，并取一个名字。 类似的方法再添加几个目录，然后用 pm list 查看一下现在添加了哪些： 123pm list# awesome-project# another-project 然后使用 pm go + 名字，迅速切换到该目录： 12pm go awesome-project# Current project: awesome-project 最后还有一个命令：pm remove + 名字，进行删除。 bro：以用例为主的帮助系统man 以外的帮助系统有很多，除去 cheat, tldr 外，还有一款有意思的帮助系统 – bro，它是以用例为主的帮助，所有用例都是由用户提供，并且由用户投票筛选出来的： 比如我们查看 cut 命令的帮助，就运行 “bro cut”，显示内容如图，查看按投票多少排序，你如果觉得哪条解释比较好，你可以投赞成票，或者反对票。 安装很简单，先安装 ruby 和 ruby-dev ，然后： 1gem install bropages 即可，相比由某些官方写的帮助文档，这种知乎式的帮助筛选方法，更容易将最好的帮助信息筛选出来。 2. 便捷的 ssh 管理将常用的ssh服务器配置好： 1234567891011$ cat ~/.ssh/config# Test hostHost test HostName 10.1.1.1 User adminHost * ServerAliveInterval 60 ControlMaster auto ControlPath ~/.ssh/%h-%p-%r ControlPersist yes 将以下内容添加到~/.bash_profile 或者 ~/.bashrc 文件中： 1234567# Auto complete ssh server defined in ~/.ssh/config#complete -W \"$(awk '/^Host/{if ($2!=\"*\") print $2}' ~/.ssh/config)\" ssh# Define ssh alias for server defined in ~/.ssh/configfor host in $(awk '/^Host/{if ($2!=\"*\") print $2}' ~/.ssh/config); do alias $host=\"ssh $host\"done 然后输入 test 命令就可以 ssh 到 test 服务器了 cat -A 命令可以显示”见不着”的字符，有时候很有用12$ echo xxx | cat -A$ cat -A xxx.txt 终端快捷键 ctrl+k 删除从光标到结尾处的命令文本 ctrl + a:光标移动到命令开头 ctrl + e：光标移动到命令结尾 alt f:光标向前移动一个单词 alt b：光标向后移动一个单词 ctrl w：删除一个词（以空格隔开的字符串） 将日志同时记录文件并打印到控制台在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？ 1$ ./test.sh |tee test.log 简介 · Linux 101 hacksElvish Shell Advanced Bash-Scripting Guide gtop 27申请订阅邮箱 可以在此留下邮箱地址 · Issue #26 · chenjiandongx/weekly-email-subscribe2020年1月25日Homebrew on Linux — Homebrew Documentation reverse-interview：如果当面试官问“你还有什么要问我的吗？”的时候你毫无头绪，那这个项目正是你所需要的。中文 pull：一个 GitHub App，它可以让 fork 的仓库自动同步，保持和原仓库同步的神器。很多同学参与开源时会 fork 项目，但无法取得原项目的最新更新。此 Github App 可以很好的解决这个问题，截至目前已有几万仓库使用，截至目前已经自动生成了 70 万个 PR，该数字还在持续增加。注意：如果 master 有更改需要备份后使用，具体见英文文档 使用 Pull app 自动从上游同步 Forks – 4563博客@每日更新,本地保留 GitHub Apps - Pull 2020年1月24日(星期五)subsync 有时，srt 字幕文件跟视频不同步，该工具可以自动让其同步。它的原理是，从视频里面检测出，何时有语音，然后将字幕与其对齐。 git-open：用 git 命令 push 完代码，想看仓库网页内容是否更新成功还需要再去打开网页查看。有了这个项目，直接输入 git open 命令浏览器就能自动打开对应的仓库的网页 antonmedv/fx: Command-line tool and terminal JSON viewer 🔥asciinema - Record and share your terminal sessions, the right wayshimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 2020年1月21日(星期二)Shuttle | A simple shortcut menu for macOS 在menu bar执行命令，如快速ssh等 matryer/bitbar: Put the output from any script or program in your Mac OS X Menu Bar 2020年1月20日(星期一)cloudconvert 在线文件格式转换工具，支持218种格式文件的转换。 哈利路亚 英文输入法dongyuwei/hallelujahIM: hallelujahIM(哈利路亚 英文输入法) is an intelligent English input method with auto-suggestions and spell check features, Mac only. exa ls的替代品 目录查看命令ls的替代品。 2020年1月19日(星期日)Mac 平台免费经典的音频内录插件 Soundflower 使用方法_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili forbesmyester/esqlate: Build minimum viable admin panels quickly with just SQL 快捷地创建sql插入，查询面板 danistefanovic/build-your-own-x: 🤓 Build your own (insert technology here) 2020年1月18日(星期六)typora theme–VueTexpad 1.8.14 专业的LaTeX的编辑器 - 精品MAC应用分享 PPLink - 帮电脑/手机搭建直连通道剪贴板同步快贴 - 真正的云剪贴板工具设置： 8 款免费的图片处理网页工具 在线抠图：remove.bg Emoji 填充图片 ：Emoji Mosaic 图片压缩：TinyPNG 图片立体像素画：voxelize-image 词云图制作：WordArt 「抖音风格」图片制作：PhotoMosh 全能的图片编辑器：iLoveIMG 右键服务 及 文件夹操作设置 - 少数派USB共享给Mac网络jwise/HoRNDIS: Android USB tethering driver for Mac OS X 12brew cask install horndissudo kextload /Library/Extensions/HoRNDIS.kext CockTail Mac优化软件Cocktail - A perfect mixture for macOS 下载注意Mac是10.14版本 在访达的标题栏中显示文件路径 为访达添加「Command + Q」 将隐藏应用的图标「虚化」 取消显示程序坞的延时 在程序坞右侧添加「最近使用的应用」堆栈 开启「专注模式」 去掉截图命名里的截图时间 文件备份还能怎么玩？试试这条命令 - 少数派路径最后需要以 / 结尾 在末位添加这–delete参数后，如果删除了源文件夹里的某些东西，备份中的对应文件也会乖乖消失 1rsync -av [源文件夹路径] [备份路径] --delete --exclude \"想要排除的文件或文件夹\" Automator 日历启动定时任务 laurent22/rsync-time-backup: 基于 rsync 二次开发的脚本，可在 Linux 上实现类 Time Machine 的备份 用终端命令删除「回收站」中的顽固文件丨一日一技 - 少数派\\1. 在应用程序中打开「终端」，或者使用 Spotlight 搜索启动「终端」； \\2. 在终端内键入 sudo rm -R 后按下空格； \\3. 打开回收站，选中无法删除的文件，将文件拖拽到「终端」窗口下，系统会自动帮你输入文件路径名称； \\4. 按下回车，并输入系统密码（密码不会以 * 方式显示在窗口内）； \\5. 之后你会发现之前无法删除的文件被删除了。 网络剪贴板可以生成在线纯文本文档，最多有效期3年，支持密码 2020-1-16 2020-1-13思维导图 + 流程图，免费在线工具 GitMind 一次搞定 - 少数派 2020-1-11变设龙智能抠图-免费在线抠图网站_告别PS繁琐抠图LoreFree-去中心化免费电子书共享社区单词发音| Howjsayweb前端资源_web前端导航_前端网址大全前端面试题库_前端面试宝典_各大企业面试宝典_前端面试题锦集占位图生成工具Markdown在线编辑器阅读酷 - 书源在线分享平台ASMR – ASMR分享 2020-1-4rss订阅Android 上的 RSS 阅读器怎么选？这 7 款好看好用的 App 不能错过 - 少数派RSSHub Radar — 订阅一个 RSS 源不应该这么难 - 少数派Mac 上的 RSS 阅读工具，你有这些好看实用的选择 - 少数派高效获取信息，你需要这份 RSS 入门指南 - 少数派 微软爱写作 - Aim Writing如何不写 SQL ，探索和分析数据库？ - 少数派 2020-1-3rss(19) Inoreader - Hello World! • xu3352’s Tech Blog feed 自定义Feed URL: https://feed43.com/6300252736338045.xmlEdit URL: https://feed43.com/feed.html?name=6300252736338045 Inoreader - Recent Commits to weekly:masterWallpapers | WallpaperHubBandizip 开始收费后，Peazip 或许是 Windows 压缩软件的下一个不错的选择 - 少数派一周 App 派评 ｜ 近期值得关注的 11 款应用 - 少数派通知滤盒：巧用「规则」来管理通知 ​ 小码短链接多了很多统计功能 有浏览器插件 通过 Mathpix API 将公式识别为 LaTeX - 少数派Mac 电脑终极选购指南 2019——双十一特刊 - 少数派Arya - 在线 Markdown 编辑器kootenpv/yagmail: Send email in Python conveniently for gmail using yagmailyou-get 教程下载 vip 视频 XML 弹幕文件转 ass 文件[开源工具] 本地播放B站会员视频及弹幕, 开源工具you-get使用攻略 - V2方圆 聚合网页应用，窗口管理工具：Slidepad | App+1 - 少数派有趣的搜索引擎 Magi用好这些隐藏「小开关」，让 Chrome 浏览器更好用 - 少数派给标签页进行分组chrome://flags/#tab-groups开启全局媒体播放控制chrome://flags/#global-media-controls 2020-1-1Java 2019 学习路线（视频） - 哔哩哔哩前端 2019 学习路线（视频） - 哔哩哔哩 Chrome自带的长截屏功能 | G加菲网站上任意空白处右键 – 选择 “检查” 或者“审查元素”快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车浏览器自动保存图片 markdown 折叠与展开1234&lt;details&gt; &lt;summary&gt;点击查看详细内容&lt;/summary&gt; tada&lt;/details&gt; 点击查看详细内容 tada ## Markdown代码块中有反引号处理 外层的反引号比里面多一个就行 1234​````markdown​```python`````` Python如何将字符串转为字典 | G加菲通过literal_eval 123456789&gt;&gt;&gt; import ast&gt;&gt;&gt; user = '{\"name\" : \"john\", \"gender\" : \"male\", \"age\": 28}'&gt;&gt;&gt; user_dict = ast.literal_eval(user)&gt;&gt;&gt; user_dict{'gender': 'male', 'age': 28, 'name': 'john'}user_info = \"{'name' : 'john', 'gender' : 'male', 'age': 28}\"&gt;&gt;&gt; user_dict = ast.literal_eval(user)&gt;&gt;&gt; user_dict{'gender': 'male', 'age': 28, 'name': 'john'} 使用 ast.literal_eval进行转换既不存在使用json进行转换的问题，也不存在使用eval进行转换的安全性问题，因此推荐使用ast.literal_eval。 grep显示前后几行信息显示foo及前5行grep -B 5 foo file显示foo及后5行grep -A 5 foo file显示 file 文件里匹配 foo 字串那行以及上下5行grep -C 5 foo file 书签打开页面javascript:location.href = “https://outline.com/&quot; + location.href; void(0) 让小米手环在 Android 上更好用：Notify &amp; Fitness - 少数派docker使用Docker 的入门「指北」 - 少数派portainer/portainer: Making Docker management easy.","link":"/tricks/tricks-2020-01.html"},{"title":"openProject","text":"[toc] dbohdan/structured-text-tools: A list of command line tools for manipulating structured text data dandavison/delta: A syntax-highlighter for git and diff outputwolverinn/Waking-Up: 计算机基础（计算机网络/操作系统/数据库/Git…）面试问题全面总结jackzhenguo/python-small-examples guanguans/favorite-link: 每日收集喜欢的开源项目 科技爱好者周刊 · 语雀 OXYGEN - hand drawn style diagrams generator 手绘风格流程图 Snip 将打印的数学公式转成 LaTex 代码的工具。 在线office编辑： http://yiqixie.com 在线latex编辑: Overleaf, Online LaTeX Editor 在线markdown编辑：http://zybuluo.com 在线json解析: http://json.cn 在线正则表达式解析: http://regex101.com 博客订阅：http://theoldreader.com 代码库：http://github.com 英文语法检查：https://grammarly.com 词典：http://youdao.com 图片编辑：http://pixlr.com/editor/ fyne-io/fyne: Cross platform GUI in Go based on Material Design GitHub Marketplace · Tools to improve your workflow程序员实用工具，推荐一款代码统计神器GitStats-云栖社区-阿里云推荐一个非常实用的学习 GitHub 的软件 | Laravel China 社区jlord/git-it-electron: Git-it is a (Mac, Win, Linux) Desktop App for Learning Git and GitHub 21、Best-App：苹果系统下的优秀软件、硬件、技巧、周边设备的集合 22、follow-me-install-kubernetes-cluster：部署 kubernetes 集群教程。该教程介绍使用二进制部署最新 kubernetes 集群的所有步骤，而不是使用 kubeadm 等自动化方式来部署集群。这样有助于理解系统各组件的交互原理，进而能够快速定位、解决实际中遇到的问题 vjtools/othertools.md at master · vipshop/vjtoolsScylla 中文文档 — Scylla 文档Git - Bookluhuisicnu/The-Flask-Mega-Tutorial-zh: hzlzh/Best-App: 收集&amp;推荐优秀的 Apps/硬件/技巧/周边等 ByteScout SQL Trainer 一个互动式的在线 SQL 语法教程，针对新手。答对一个问题，才能进入下一个。 发送短消息的 App 谷歌官方推出了一个网页应用，使你可以在浏览器上远程通过自己的手机发短消息。有人使用了它的底层 API，做成一个桌面 App，可以在电脑桌面上发短信。 localroast 一个根据 JSON 文件快速生成 API 的 Web 服务端，主要用了测试和开发环境。 DevTube 该网站收集 Youtube 上面的软件开发视频。 登录页设计 登录页的各种页面设计，可以免费下载模板。 crushcourse.club Crash Course 是一个 Youtube 的教育频道。B站上面有很多翻译小组。他们组成了一个联盟防止翻译重复，并提供了索引 Whaler 该软件可以从 Docker image 逆向还原出 Dockerfile。 skanehira/docui: TUI Client for Docker lazydocker A simple terminal UI for both docker and docker-compose, written in Go with the gocui library. docker.vim Manage docker containers and images in Vim color：Golang 的命令行色彩使用库。拥有丰富的色彩渲染输出、通用的 API 方法、兼容 Windows 系统 gitbatch：批量管理 Git 仓库的命令行工具 hutool：功能丰富的 Java 工具包。它帮助我们实现了常用的工具方法，从而减少代码的体积，提高开发效率。该项目最初是作者工作项目中的util模块，后来慢慢积累并加入更多非业务相关工具类方法。经过整理修改，最终形成丰富的开源工具集。 q：Golang debug 库，自动打印变量类型并且格式化输出 7、tldr：Golang tldr 客户端。对比之前推荐过的 Python 版本客户端，Golang 版本速度更快、交互友好、且支持选择搜索结果的展示样式。每当你想要用 tar 解压缩，但是记不住具体参数的时候，tldr 可以拯救世界 wonderfulsuccess/weixin_crawler: 高效微信公众号全部历史文章和阅读数据爬虫powered by scrapy 微信公众号爬虫 微信采集 公众号采集 微信爬虫 nginxconfig.io：在线生成 Nginx 配置文件网站，在线尝试 soar：SQL 自动优化和改写的工具。可以自动优化 MySQL 语法族，并且给出为什么要这样优化的理由。功能特点： 跨平台支持 目前只支持 MySQL 语法族协议的 SQL 优化 支持基于启发式算法的语句优化 支持复杂查询的多列索引优化（UPDATE、INSERT、DELETE、SELECT） 等等 1234567891011echo \"select title from sakila.film\" | ./soar # Query: 25807E6B94BEA72C★ ★ ★ ★ ☆ 80分SELECT titleFROM sakila. film## 最外层SELECT未指定WHERE条件* **Item:** CLA.001* **Severity:** L4* **Content:** SELECT语句没有WHERE子句，可能检查比预期更多的行(全表扫描)。对于SELECT COUNT(\\*)类型的请求如果不要求精度，建议使用SHOW TABLE STATUS或EXPLAIN替代。 athens：Go Modules 下载代理服务，解决国内 Go 装包的痛。妈妈再也不用担心我因为装不上依赖库而不吃饭，使用步骤： 1234567$ export GO111MODULE=on$ export GOPROXY=http://127.0.0.1:3000$ git clone https://github.com/athens-artifacts/walkthrough.git$ cd walkthrough$ go run .go: downloading github.com/athens-artifacts/samplelib v1.0.0The 🦁 says rawr! archiver：命令行压缩和解压缩工具。终于不用再记 tar -czvf 了，使用命令： 1234567# Syntax: arc archive [archive name] [input files...] 压缩$ arc archive test.tar.gz file1.txt images/file2.jpg folder/subfolder# Syntax: arc unarchive [archive name] [destination] 解压缩$ arc unarchive test.tar.gz Best-websites-a-programmer-should-visit：（英文）一些对程序员有用的网站，网站类别包含：新闻、查问题、学习、教程等 XChart：用于绘制数据的轻量级 Java 库。示例代码： 12345678910double[] xData = new double[] { 0.0, 1.0, 2.0 };double[] yData = new double[] { 2.0, 1.0, 0.0 };// Create ChartXYChart chart = QuickChart.getChart(\"Sample Chart\", \"X\", \"Y\", \"y(x)\", xData, yData);// Show itnew SwingWrapper(chart).displayChart();// Save itBitmapEncoder.saveBitmap(chart, \"./Sample_Chart\", BitmapFormat.PNG);// or save it in high-resBitmapEncoder.saveBitmapWithDPI(chart, \"./Sample_Chart_300_DPI\", BitmapFormat.PNG, 300); gitea：一个极易安装、运行快速、安装简单、使用体验良好的自建 Git 服务。采用 Go 作为后端语言，支持 Linux、 macOS、Windows 等，在线Demo。安装步骤如下： 1234$ git clone https://github.com/go-gitea/gitea$ cd gitea$ TAGS=\"bindata\" make generate all$ ./gitea web 521xueweihan/git-tips: Git的奇技淫巧 git-open：用 git 命令 push 完代码，想看仓库网页内容是否更新成功还需要再去打开网页查看。有了这个项目，直接输入 git open 命令浏览器就能自动打开对应的仓库的网页 Wei-Xia/most-frequent-technology-english-words: 程序员工作中常见的英语词汇 learn-go-with-tests：通过单元测试学习 Go 语言。下载仓库源码后，进入对应目录。每一个小文件夹就是一个对应的 Go 项目，在里面go test即可运行单元测试。由于是测试驱动开发，所以需要在你改动代码之后跑通单元测试才算学会通过。每一个对应的文件夹都有相应 Markdown 文字教程，比较浅显易懂。而且还有中文版 easyexcel：使用简单、上手快速、占用内存小且避免内存溢出的 Java 处理 Excel 工具 Project Showcase 该工具根据你的 GitHub 个人项目，自动生成一张个人介绍页面。 gitsome 一个 Git / GitHub 的命令行客户端，提供强大的自动补全功能 Gitless Git 的版本模型对新手来说，并不是很容易理解。Gitless 试图将 Git 变得更容易理解，它基于 Git，但是用自己的概念和命令替换了 Git，比如把 git add 改成 gl track antonmedv/fx: Command-line tool and terminal JSON viewer 🔥asciinema - Record and share your terminal sessions, the right wayshimohq/chinese-programmer-wrong-pronunciation: 中国程序员容易发音错误的单词 Linux Crontab 生成器双拼输入法练习 在线练习双拼输入法的网站，漂亮的键位图，支持多种双拼方案。这里还有一个同类网站。 Online Utility to Generate Crontab Line Easily 通过 Web 界面生成 Crontab 配置。 Go by Example 通过示例学习 Go 语言的教程。 gitignore.io 生成 gitignore 文件的网站。 uncss 去除样式表里面没有用到的 CSS 规则的工具。 subsync 有时，srt 字幕文件跟视频不同步，该工具可以自动让其同步。它的原理是，从视频里面检测出，何时有语音，然后将字幕与其对齐。 Learn anything 一个学习资源的搜索引擎，可以搜索各种主题，返回相应的教程。 UserLAnd 安卓手机安装 Linux 发行版的 App。 easychen/howto-make-more-money: 程序员如何优雅的挣零花钱 trimstray/the-book-of-secret-knowledge: A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more. hujiulong/gcoord: 地理坐标系转换工具，支持WGS84/GCJ02/BD09等常用坐标系互转textmate/textmate: TextMate is a graphical text editor for macOS 10.12 or laternicolargo/glances: Glances an Eye on your system. A top/htop alternative for GNU/Linux, BSD, Mac OS and Windows operating systems.gold-miner/introducing-github-actions.md at master · xitu/gold-minerxitu/gold-miner: 🥇掘金翻译计划，可能是世界最大最好的英译中技术社区，最懂读者和译者的翻译平台：gold-miner/backend.md at master · xitu/gold-minergold-miner/front-end.md at master · xitu/gold-minercaicloud/kube-ladder: Learning Kubernetes, The Chinese Taoist Waythlorenz/doctoc: 📜 Generates table of contents for markdown files inside local git repository. Links are compatible with anchors generated by github or other sites. jaywcjlove/package.json: 文件 package.json 的说明文档。jakubroztocil/httpie 替代curl OverNote Shitaibin/golang_step_by_step: Golang入门教程的文章、示例代码 duke7553/files-uwp: “More than just a rewrite of Windows Explorer” No-Github/404-I-remember: 收集各种网站的404页面 styfle/awesome-online-ide: 🌩️ A list of awesome online development environments dyweb/awesome-resume-for-chinese: 适合中文的简历模板收集（LaTeX，HTML/JS and so on）由 @hoodiearon 维护dyweb/awesome-resume-for-chinese: 适合中文的简历模板收集（LaTeX，HTML/JS and so on）由 @hoodiearon 维护 [Github Explore] - 超实用工具，看老司机怎么把 Github 玩出花来 · Issue #1 · github-serendipity/github-serendipity.github.io Louiszhai/tool: 开发效率提升：Mac生产力工具链推荐 MacMenuBar.com - A curated directory of 400+ Mac menu bar apps jaywcjlove/linux-command: Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集。https://git.io/linux serhii-londar/open-source-mac-os-apps: 🚀 Awesome list of open source applications for macOS. dropcss 清理样式表里面无用的 CSS一个清理样式表里面无用的 CSS 代码的工具 mas Mac 应用商店的命令行界面可以用来从命令行安装 MacOS App。 gacp 定制 Git 的提交信息的命令行工具，支持 EmojiLorem Picsum 图片占位服务图片占位服务，可以返回指定大小的图片，并且提供多种定制参数。 Colorize 黑白照片自动上色黑白照片自动上色的服务。 RMind 在线的思维导图在线的思维导图工具，使用 React Hooks 与 flex 布局实现。（@Mongkii 投稿） Table Convert Online 在线表格转成其他数据格式一个网页工具，可以在线表格转成 Markdown、JSON、HTML、XML、YAML 等数据格式，并支持格式之间互相转化。(@Fechin 投稿) nodeppt Markdown 文档转成幻灯片将 Markdown 文档转成幻灯片，在浏览器演示的工具。（@JsonLeex 投稿） userrecon 看某个用户名是否还未注册 一次查询75个社交媒体，看看某个用户名是否还未注册。 3、SQL 风格指南 SQL 语句如何写得清晰明确，这个仓库列出了风格规则。 4、LaTex 教程 Overleaf 提供的 LaTex 新人教程，容易入门。 9、visitor-count-badge 一个开源服务，可以统计 GitHub 仓库的 Readme 文件的阅读次数，然后生成 badge 徽章，以便挂在仓库里。（@jwenjian 投稿） 5、lazydocker 命令行管理 Docker 服务的一个图形界面工具。 哈利路亚 英文输入法dongyuwei/hallelujahIM: hallelujahIM(哈利路亚 英文输入法) is an intelligent English input method with auto-suggestions and spell check features, Mac only. 10、docker-slim 一个 Docker 镜像文件的瘦身工具，据称最好情况下，可以让镜像文件体积缩小为原来的30分之一。 5、Eternal Terminal 一个类似 SSH 的服务器远程登录工具，但是可以自动重新连接而不会中断会话。 Happy Hues - Curated colors in context. 在线预览网站配色效果 1、EasyDB 一次性云端数据库，可以免费使用 24 小时。如果想永久保存数据，需要付费。 2、Sourcetrail 可视化源码浏览器，可以对 C、C ++、Java、Python 源代码进行静态分析，并以图形可视化的形式呈现。 3、texme 一个轻量级的 JavaScript 脚本，可以把 Markdown + LaTeX 文档直接渲染成网页。 6、resumd 在线的简历编辑器 可以分享给他人一个可编辑的简历，也可以导出 PDF。（@timqian 投稿） 8、KubeSphere 一个开源的容器管理平台，构建在 Kubernetes 之上，帮助企业管理容器环境。（@FeynmanZhou 投稿） 9、mdr 命令行的 Markdown 文件阅读器 暂时没看到Mac版本 1、 vy 一个命令行的极简风格的 IDE。 2、必收 一个收集和订阅外部内容的应用，有手机端和桌面端，可以收藏网址、微信文章、头条文章等。（@sinner-xing 投稿） 3、invidious Youtube 的开源前端，等于为 Youtube 换了皮肤，可以自己搭建实例。 4、p2 一个极简的 PDF 文件转 PNG 图片的开源服务器，我觉得挺好用，查看 Demo。 6、Joplin 一个笔记和待办事项软件，支持桌面、手机和命令行，可以多端同步。 7、code-surfer 一个以幻灯片的形式展示源码的工具。 9、远程浏览器 该网站提供免费的远程浏览器，用户可以在本地浏览器里面打开远程浏览器，再通过后者访问网站。该站的代码开源。 7、在线屏幕录制 一个浏览器里面的在线录屏小工具。（@w3yyb 投稿） 8、加密信息写入图片工具 这个在线工具可以把隐藏文本写入图片文件。图片依然可以正常使用，并且外观不发生变化，用户不会发现里面隐藏了加密信息。（@w3yyb 投稿） 10、marktext 一个跨平台的桌面 Markdown 编辑器。 2、Chrome remote desktop 谷歌推出了远程桌面软件，可以在手机和桌面浏览器里面，访问远程电脑的桌面，进行各种操作。 3、CustomAnim 这个网站可以将用户输入的文本，渲染成一段微粒的动画，支持中文。缺点就是后台资源有限，玩的人一多，就要排队等。 4、onefetch 这个命令行工具可以显示 Git 仓库的信息。 5、Daily-warm 一个 Go 语言脚本，每天向指定邮箱发送一封邮件，里面是天气、名言、诗歌。（@BarryYan 投稿） 7、snake-go Go 语言写的命令行贪吃蛇游戏。 8、dn 一个非常简单的命令行笔记脚本，可以写入/读取笔记。所有代码就是十几行 Bash 命令。 10、SearX SearX 是一个开源的搜索代理，可以自己架设谷歌实例，查看 demo 和实例列表。 1、OnionShare 匿名分享文件的工具，通过 Tor 网络下载文件。 2、dcp 一个在主机间分享文件的命令行工具，使用 Dat 协议，进行点对点拷贝。 10、bruno simon 这是很久以来，我见过的最酷主页，整个页面都是 3D 的。页面源码是开源的。 7、navi 一个命令行的交互式备忘工具，你可以查阅某个命令的作用。 8、Slouch stoppah 一个在线小工具，通过电脑摄像头，判断坐在屏幕前面的人的坐姿是否正确。 12、GitHub Mobile GitHub 首次发布官方的手机客户端，目前只有 iOS 的 App，安卓版将稍后发布。 3、crontab 编辑器 crontab 是 Linux 系统的定时任务执行器。这个在线工具可以可视化生成 crontab 的配置文件。 5、AltStore 苹果设备安装第三方应用商店的方法（不必越狱），看上去好像有效。 6、nanoid 一个极小的 uuid 生成的 JS 库。 10、imagededup 一个基于 Python 的找出重复图片的工具，支持多种查重算法。 1、git-quick-stats 查看 Git 仓库各种统计信息的命令行工具。 2、Regexper 将 JS 的正则表达式转成图形解释的在线工具。（@DoctorLai 投稿） 3、Write With Transformer 这个工具可以自动生成英语文本。你输入一句话，然后按 Tab 键，就得到一整段。 我输入：以前有一个男孩。得到：他名叫杰克，还有一个女孩名叫维奥莱特。 女孩穿黄色，男孩穿蓝色。杰克说他打算买一件新衣服，搭配她的衣服。 5、Publisheet Excel 表格转为网页表格的在线工具。 7、This is sand 一个手机 App，用来制作沙画。（@victor-fa 投稿） 8、folder-explorer 扫描一个目录，给出目录结构、文件大小等统计信息的桌面工具。（@FairyEver 投稿） 4、MarioHTML TypeScript 写的马里奥网页游戏。 5、Kate KDE 项目里面的多文档编辑器，可以在一个窗口编辑多个文档，具有 IDE 的功能。 6、Markdown-Here 浏览器插件，让你可以使用 Markdown 写 Email，然后由这个插件转为富文本格式。 7、mjml 复杂格式的电子邮件 HTML 源码很难写，因为各个邮件客户端支持的 CSS 属性不一样。mjml 是一个响应式电子邮件框架，定义了一套自己的语法，你用这套语法写邮件，然后编译成 HTML。 8、LaTeX Search LaTeX 搜索引擎。你给出英语描述，它返回符号的写法。比如，搜索root（平方根），返回 \\sqrt{}。 9、Textmate 一个好用的文本编辑器，最近推出了2.0版。 3、resume.io 该网站提供多套简历模板，用户可以选择一套，自动生成自己的简历。 1、Postwoman 一个在线 HTTP 请求调试工具，类似 Postman，不过是 Web 版。 2、WTF 一个命令行的信息仪表盘，可以定制显示内容。 3、gradex 一个开源的在线工具，从上传的图片里面提取两种主色，生成一张渐变的背景图，可以下载。（@jwenjian 投稿） 5、NetNewsWire MacOS 的桌面 RSS 阅读器，免费软件。 9、dbdiagram.io 创建数据库的实体-关系图的工具。 4、Base API 这家云服务公司提供基本的 Web API，包括身份验证、电子邮件发送、文件和图像存储。用法简单，容易上手，作为概念产品很不错。 5、Git paging 一组 Bash 函数，可以在命令行迅速查看 Git 仓库某个版本的信息（比如，第一个、最后一个、上一个、下一个版本）。 9、d2-admin 一个企业中后台产品的前端集成方案。（@FairyEver 投稿） 10、GoAccess 开源的日志分析工具，可以生成命令行、JSON、HTML 等格式的分析报告。 11、drinkNow Chrome 浏览器插件。每过一段时候，就会弹出一只小鸭子，提醒你要喝水。（@sologgfun 投稿） awesome-qrcode 二维码生成工具，可以生成静态二维码、图像二维码和动画二维码。 10、Raccoon 从 Google Play 将安卓 apk 安装包下载到桌面的工具。 极客导航 | 国内最专业、收录最全的极客导航！KubeAcademy - Unlock your full potential with Kubernetes courses designed by experts k8s教程 A Docker Tutorial for Beginners Free for developers 9、CS50 IDE 一个在线 IDE，背后是基于云的 Ubuntu 环境，支持代码高亮和单词自动完成，以及代码调试。 10、在线哈希计算器 用户输入一个字符串，在线显示各种哈希算法的运算结果。（@DoctorLai 投稿） 11、logForShell Bash 的日志工具，出错时打印调用堆栈，方便快速定位问题和源文件。（@7ippo 投稿） 8、WPS Office for Linux 金山 WPS 的 Linux 版本 Md2All 3、blogger-cli 命令行工具，可以将 jupyter notebook、markdown 文件转成静态网站。 4、fork 桌面的 Git 客户端。 1、exa 目录查看命令ls的替代品。 2、wtf-cli 一个查询字母缩写含义的命令行工具，比如缩写 OS 代表 Operation System，数据来自abbreviations.com。（@Haixiang6123 投稿） 3、sandman2 一个 Python 语言的数据库适配库，可以为各种数据库自动生成 RESTful 接口。 6、SuperTinyIcons 一个 SVG 图标库，提供100多个常用的 Logo 图标。 7、Ananas Analytics 数据可视化的桌面工具，可以连接各种数据源，进行图形可视化操作。 「工具推荐」golang 代码可视化工具 go-callvis - 掘金","link":"/tricks/openProject.html"},{"title":"tricks-2019-12","text":"tricks-2019-12 2019年1月17日(星期四)yAnXImIN/weiboPicDownloader: 免登录下载微博图片 爬虫 Download Weibo Images without Logging-ingui PPLink - 帮电脑/手机搭建直连通道日常干货在线工具网站分享平台 – SBKKOlinux下替换多个文件中的指定字符串 - 简书 2019-12-31iSlide Mac 玩转输入法每个输入法不一样，以搜狗为例：u 生僻字模式v 数字、小数、日期、算式自定义短语 小鹤双拼 除了搜狗输入法，还有这些好用的输入法。触宝输入法笔画过滤。首先用拼音拼出你想输入的字词，然后直接在键盘上手写笔画进行 QQ输入法快捷翻译 讯飞输入法语音识别，包括方言 百度输入法设置-&gt;高级设置-&gt;管理个性短语-&gt;编辑个性短语懒人短语，类似于“自定义短语” AutoDraw手画icon，ai智能识别 Markdown[TOC] 用来显示Markdown目录有道云笔记 默认支持Markdown印象笔记也支持，需要建立Markdown笔记 WPS有团队文件功能知页 - 用简单的方式，制作专业的简历下载收费 图表秀——免费在线图表制作工具,数据可视化工具PDF24 Tools在线格式转换 All2Allwin桌面分屏看微信文章WeRss - 微信公众号RSS订阅今天看啥 - 让阅读更高品质学习工具 – 微信公众账号和文章的导航及推荐 – 传送门 2019-12-30传输文件的网址：Send Large Files - Free Secure File Transfer - TransferNowP2P傳檔 – 免費資源網路社群 其他网址：国外网站推荐-分享互联网-外国网站大全歌曲大全-音乐聚合搜索引擎-音乐免费下载mp3-音乐免费下载办公资源网_海量办公资源及素材_精美创意模板下载国外网站推荐-分享互联网-外国网站大全PM25.in | 北京PM2.5及空气质量指数(AQI)互联网运营者必备之的修炼清单- eGouz上网导航失眠怎么办？你可以试试这些助眠神器- eGouz上网导航文案创作者必备的写作辅助工具推荐- eGouz上网导航值得收藏的找书网站大全- eGouz上网导航周读：提供免费电子书下载、分享。包括mobi、epud、pdf、txt格式，kindle电子书下载 - 周读DevFreeBooksConvert any URL or Web Page to PDF. Online API servicegitmoji | An emoji guide for your commit messagesgitmoji的使用 | 我的博客GitHub - carloscuesta/gitmoji: An emoji guide for your commit messages. 😜Base64 Image Encoder在线JSON校验格式化工具（Be JSON）CarbonCSS Reference - A free visual guide to CSS 2019-12-29mac slashgtd软件，为当前所做的任务计时 open web monitor优点：在每次监测网页前可以执行一系列操作，包括去登录页面点击和填写表单，以实现登录功能缺点：免费版只能添加3个监测任务 chrome插件 distill web monitor优点：监控页面变化，发出提醒，配置方便缺点：功能单一 知乎封神榜 - 您的知乎之旅从此开始APP影院-全网最全视频库🐒 渣男: 说话的艺术读知乎-精选每日知乎热门答案6个网站磁力搜索网站JsOCR介绍 | 文档中心Windows dock牛牛TV - 搜你想看老Y的免费VIP播放器 todo:权力的游戏 万能钥匙[Vue.js]—-基于 Vue.js 2.0 的 UI 组件库 Element UI讲解_哔哩哔哩 (゜-゜)つロ 干杯~-bilibilivue+elementUI+axios管理平台_哔哩哔哩 (゜-゜)つロ 干杯~-bilibilivue.js+element-ui数据增删查改实战_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili黑马2019新版java项目好客租房网上房源系统-SOA架构 源码+笔记_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 2019-12-28airpods 连接android声音小问题将耳机放入耳机盒，长按按钮15s重置耳机 2019-12-27airpods 连接Mac问题去除Android File Transfer自启动https://www.v2ex.com/t/567112 2019-12-25意志力训练冥想 （锻炼大脑）充足的休息意志力会消耗殆尽，所以重要的事情优先做 2019-12-17fakerPython最假的库：Faker - 知乎 1234from faker import Fakerfake = Faker(locale='zh_CN')fake.company()# '昂歌信息网络有限公司' js 数组中值的存在12[1, 2, 3, 4].indexOf(1)&gt;-1 // 存在value1 in [a, b, c] // 存在索引1 2019-12-14youtube视频下载插件 2019-12-11mock js官方API 可以打开控制台，随意地试验这些方法 mock js 基于Vue 2019-12-10网页中插入好看的图表 2019-12-09vuevue.js2.5基础入门视频教程-慕课网进阶vue2.5开发去哪儿网App 从零基础到实战项目 窗口最大化option 点击窗口左上角 绿色按钮 全屏 -&gt; 最大化 复制文件全路径来源 快捷键 Command+Option+C 右键文件，option 拷贝文件全路径 若要多个文件的全路径，打开一个文本编辑器，将文件拖拽进去 在Finder中查看文件夹大小1、打开Finder(访达）并进入所需查看的文件夹2、在菜单栏中选择“显示”&gt;”查看显示选项”，或者直接按快捷键 Command+J3、在弹出的窗口中勾选“计算所有大小”选项。4、关闭弹出窗口这样我们在Finder中就可以显示文件夹的实际大小了。注意：此设置不是全局设置，而是针对某一文件夹的设置，对其它文件夹需要重新设置。","link":"/tricks/tricks.html"},{"title":"资源","text":"CS-Notes On Java 8 CNCF x Alibaba 云原生技术公开课 - 云原生教程 - 阿里云大学序言 · Kubernetes Handbook - Kubernetes中文指南/云原生应用架构实践手册 by Jimmy Song(宋净超) wolverinn/Waking-Up: 计算机基础（计算机网络/操作系统/数据库/Git…）面试问题全面总结jackzhenguo/python-small-examples 阿里巴巴java开发手册 · 看云 architecture-roadGithubStars [Github 上的学习资源 | Emil`s Blog](https://hvnobug.github.io/post/github-learning.html#Java-Kotlin) hooj0/architecture-roadxingshaocheng/architect-awesome: 后端架构师技术图谱sorenduan/awesome-java-books Introduction · 笔试面试知识整理 h2pl/Java-Tutorial wuyouzhuguli/SpringAll: 循序渐进，学习Spring Boot、Spring Boot &amp; Shiro、Spring Cloud、Spring Security &amp; Spring Security OAuth2，博客Spring系列源码 MaximAbramchuck/awesome-interview-questions: A curated awesome list of lists of interview questions. Feel free to contribute! GitHubDaily/GitHubDaily 各语言优质教程及项目 VisuAlgo - 数据结构和算法动态可视化 (Chinese) git-flight-rules/README_zh-CN.md at master · k88hudson/git-flight-rules xingshaocheng/architect-awesome: 后端架构师技术图谱 rfyiamcool/share_ppt: 🚗 我个人曾经做过的技术分享… 0voice/interview_internal_reference: 2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。 CarGuo/gsy_flutter_book: Flutter 完整开发实战详解系列，提供在线预览和pdf下载，本系列将完整讲述：如何快速从 0 开发一个完整的 Flutter APP，配套高完成度 Flutter 开源项目 GSYGithubAppFlutter ，同时会提供一些Flutter的开发细节技巧，之后深入源码和实战为你全面解析 Flutter 。 pushmetop/30-seconds-for-everyday: 聚焦前端 | 夯实基础 | 趣味教程 | 轻松进阶 wolverinn/Waking-Up: 计算机基础面试问题全面总结，包含详细的follow-up question以及答案；模拟面试，知识点复习，快速备战面试… bregman-arie/devops-exercises: Linux, Jenkins, AWS, SRE, Prometheus, Docker, Python, Ansible, Git, Kubernetes, Terraform, OpenStack, SQL, NoSQL, Azure, GCP, DNS, Elastic, Network, Virtualization AobingJava/JavaFamily: 面试+学习指南 Java面试题大全，看完这些面试文章足够了 - 好好学Java Snailclimb/JavaGuidealgorithm-visualizer/algorithm-visualizer: Interactive Online Platform that Visualizes Algorithms from Codewangzheng0822/algo: 数据结构和算法必知必会的50个代码实现zhangdaiscott/jeecg-bootjeecg的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibiligzc426/Java-Interview: Java 面试必会 直通BAT学习资源汇总（持续更新） - 简书 金三银四，二月就要准备！八大基础排序总结Java 实例 | 菜鸟教程Java并发编程之美-有道云笔记 ZhongFuCheng3y/3y: 从Java基础、JavaWeb基础到常用的框架再到面试题都有完整的教程，几乎涵盖了Java后端必备的知识点","link":"/tricks/%E8%B5%84%E6%BA%90.html"},{"title":"List Operations","text":"[toc] Converting Iterator to List12345678910111213141516171819202122232425// 有时会获得一个 IteratorIterator&lt;Integer&gt; iterator = Arrays.asList(1, 2, 3).iterator();// 怎么转成 List 呢List&lt;Integer&gt; actualList = new ArrayList&lt;&gt;();// 1. using a while loopwhile (iterator.hasNext()) { actualList.add(iterator.next());}// 2. using java 8 Iterator.forEachRemainingiterator.forEachRemaining(actualList::add);// 3. using java 8 streams API ?// 先把 iterator 转成 iterableIterable&lt;Integer&gt; iterable = () -&gt; iterator;List&lt;Integer&gt; actualList = StreamSupport .stream(iterable.spliterator(), false) .collect(Collectors.toList());// 4. Guava// 4.1 Immutable ListList&lt;Integer&gt; actualList = ImmutableList.copyOf(iterator);// 4.2 mutable listList&lt;Integer&gt; actualList = Lists.newArrayList(iterator);// 5. apache CommonsList&lt;Integer&gt; actualList = IteratorUtils.toList(iterator);assertThat(actualList, containsInAnyOrder(1, 2, 3)); Java – Get Random Item/Element From a List1234567891011List&lt;Integer&gt; givenList = Arrays.asList(1, 2, 3);// 2.1. Single Random ItemRandom rand = new Random();givenList.get(rand.nextInt(givenList.size()));// 2.2. in Multithread Environmentint randomElementIndex = THreadLocalRandom.current().nextInt(listSize) % givenList.size();// 2.4. Without Repetitions// 获取后 remove 元素即可givenList.remove(randomIndex);// 2.5. Select Random SeriesCollections.shuffle(givenList); Partition a List in Java1234567891011121314151617181920212223242526272829303132// 将一个 list 划分为指定长度的 sublistsList&lt;Integer&gt; intList = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9); // guava// 1. Guava// Keep in mind that the partitions are sublist views of the original collection// which means that changes in the original collection will be reflected in the partitions// 1.1. Use Guava to Partition the ListLists.partition(intList, 3);// 1.2. Use Guava to partition a Collection// 略// 2. Use Apache Commons Collections to Partition the List// the same caveat applies here as well – // the resulting partition are views of the original List.ListUtils.partition(intList, 3);// 3. Use Java8 to Partition the List// 3.1. Collectors partitioningBy// use Collectors.partitioningBy() to split the list into 2 sublistsMap&lt;Boolean, List&lt;Integer&gt;&gt; groups = intList.stream().collect(Collectors.partitioningBy(s -&gt; s &gt; 6));List&lt;List&lt;Integer&gt;&gt; subSets = new ArrayList&lt;List&lt;Integer&gt;&gt;(groups.values());// 3.2. Collectors groupingBy// use Collectors.groupingBy() to split our list to multiple partitionsMap&lt;Integer, List&lt;Integer&gt;&gt; groups = intList.stream().collect(Collectors.groupingBy(s -&gt; (s - 1) / 3));List&lt;List&lt;Integer&gt;&gt; subSets = new ArrayList&lt;List&lt;Integer&gt;&gt;(groups.values());// 3.3. Split the List by Separator// use Java8 to split our List by separatorint[] indexes = Stream.of(IntStream.of(-1), IntStream.range(0, intList.size()) .filter(i -&gt; intList.get(i) == 0), IntStream.of(intList.size())) .flatMapToInt(s -&gt; s).toArray();List&lt;List&lt;Integer&gt;&gt; subSets = IntStream.range(0, indexes.length - 1) .mapToObj(i -&gt; intList.subList(indexes[i] + 1, indexes[i + 1])) .collect(Collectors.toList()); Removing all nulls from a List in Java1234567891011121314151617181920212223242526List&lt;Integer&gt; list = Lists.newArrayList(null, 1, null);// 1. plain javawhile (list.remove(null));// 或者list.removeAll(Collections.singleton(null)); // ?// 2. Guava// 2.1 via predicates (modify original list)Iterables.removeIf(list, Predicates.isNull());// 2.2 do not modify original listList&lt;Integer&gt; listWithoutNulls = Lists.newArrayList( Iterables.filter(list, Predicates.notNull()));assertThat(list, hasSize(1));// 3. Commons// (modify original list)CollectionUtils.filter(list, PredicateUtils.notNullPredicate());// 4. java8 lambdas// 4.1 parallel (do not modify original list)list.parallelStream() .filter(Objects::nonNull) .collect(Collectors.toList());// 4.2 serial (do not modify original list)list.stream() .filter(Objects::nonNull) .collect(Collectors.toList());// 4.3 (modify original list)list.removeIf(Objects::isNull); Removing all duplicates from a List in Java1234567891011List&lt;Integer&gt; list = Lists.newArrayList(0, 1, 2, 3, 0, 0);// 以下做法均类似于 Python 的 list(set(l))// 1. plain java// using setList&lt;Integer&gt; listWithoutDuplicates = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(list));// 2. GuavaLists.newArrayList(Sets.newHashSet(list));// 3. java 8 streamlist.stream().distinct().collect(Collectors.toList());assertThat(listWithoutDuplicates, hasSize(4)); Check If Two Lists are Equal in Java1234567891011121314151617List&lt;String&gt; list1 = Arrays.asList(\"1\", \"2\", \"3\", \"4\");List&lt;String&gt; list2 = Arrays.asList(\"1\", \"2\", \"3\", \"4\");List&lt;String&gt; list3 = Arrays.asList(\"1\", \"2\", \"4\", \"3\");// 1. JUnitAssert.assertEquals(list1, list2);Assert.assertNotSame(list1, list2);Assert.assertNotEquals(list1, list3);// 2. TestNG (用法类似)Assert.assertEquals(list1, list2);Assert.assertNotSame(list1, list2);Assert.assertNotEquals(list1, list3);// 3. AssertJassertThat(list1) .isEqualTo(list2) .isNotEqualTo(list3);assertThat(list1.equals(list2)).isTrue;assertThat(list1.equals(list3)).isFalse; How to Find an Element in a List with Java12345678910111213// contains indexOf loop// 略// java 8 stream api// invoke stream() on the list// call the filter() method with a proper Predicate// call the findAny() construct which returns the first element // that matches the filter predicate wrapped in an Optional if such an element existscustomers.stream() .filter(customer -&gt; \"James\".equals(customer.getName())) .findAny() .orElse(null);// guava / commons// 写的很晦涩，略 Java List UnsupportedOperationException1234List&lt;String&gt; flowerList = Arrays.asList(flowers);// Arrays.asList() 返回的 list 大小固定，不可增删（修改呢？）// 改进, 若要修改new ArrayList(Arrays.asList(flowers)); Copy a List to Another List in Java1234567891011121314151617181920// 1. 利用构造函数List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);// 2. addAllList&lt;Integer&gt; copy = new ArrayList&lt;&gt;();copy.addAll(list);// 但是: 这 2 种方法只是复制了引用，修改一个会影响另一个// 3. Collections.copy// src dest 长度一样，dest 会被覆盖List&lt;Integer&gt; source = Arrays.asList(1,2,3);List&lt;Integer&gt; dest = Arrays.asList(4,5,6);Collections.copy(dest, source);// dest 留出前三个位置List&lt;Integer&gt; source = Arrays.asList(1, 2, 3);List&lt;Integer&gt; dest = Arrays.asList(5, 6, 7, 8, 9, 10);Collections.copy(dest, source);// 4. java 8 streamlist.stream().collect(Collectors.toList()); Remove All Occurrences of a Specific Value from a List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// list.remove(1) 若 1 是 int, 会被当成索引，不是 value，是 integer 才行// void removeAll(List&lt;Integer&gt; list, int element) {void removeAll(List&lt;Integer&gt; list, Integer element) { while (list.contains(element)) { list.remove(element); }}// 或者void removeAll(List&lt;Integer&gt; list, Integer element) { int index; while ((index = list.indexOf(element)) &gt;= 0) { list.remove(index); }}// 但以上方法都很慢// for loop, 但需要考虑到同时删除相邻元素时的问题// 因此，因为 for-each loop 没有解决同时删除相邻元素时的问题，test failedvoid removeAll(List&lt;Integer&gt; list, int element) { for (int i = 0; i &lt; list.size();) { if (Objects.equals(element, list.get(i))) { list.remove(i); } else { i++; } }}// using an Iteratorvoid removeAll(List&lt;Integer&gt; list, int element) { for (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();) { Integer number = i.next(); if (Objects.equals(number, element)) { i.remove(); } }}// 建立一个新 listList&lt;Integer&gt; removeAll(List&lt;Integer&gt; list, int element) { List&lt;Integer&gt; remainingElements = new ArrayList&lt;&gt;(); for (Integer number : list) { if (!Objects.equals(number, element)) { remainingElements.add(number); } } return remainingElements;}// 或者返回 voidvoid removeAll(List&lt;Integer&gt; list, int element) { List&lt;Integer&gt; remainingElements = new ArrayList&lt;&gt;(); for (Integer number : list) { if (!Objects.equals(number, element)) { remainingElements.add(number); } } list.clear(); list.addAll(remainingElements);}// stream apilist.stream().filter(e -&gt; !Object.equals(e, element)) .collect(Collectors.toList());// 最简单的方法（你不早说）：// removeIflist.removeIf(n -&gt; Objects.equals(n, element)); Add Multiple Items to an Java ArrayList12345678// list1.addAll(list2) // Collections.addAll(list1, list2)// Collections.addAll(list1, 1, 2, 3)// 以上 2 种方法添加的都是引用// using stream 更简便，还能用 skip filtersource.stream().forEachOrdered(target::add);// 不能用collect(target::add) ，因为 collect 将所有元素看为一个整体 Remove the First Element from a List1234// ArrayListlist.remove(0);// linkedListlist.removeFirst() Ways to Iterate Over a List in Java12345// loop foreach loop Iterator// list.forEachcountries.forEach(System.out::println);// Stream.forEach()countries.stream().forEach((c) -&gt; System.out.println(c)); Intersection of Two Lists in Java12345List&lt;String&gt; list = Arrays.asList(\"red\", \"blue\", \"blue\", \"green\", \"red\");List&lt;String&gt; otherList = Arrays.asList(\"red\", \"green\", \"green\", \"yellow\");Set&lt;String&gt; result = list.stream().filter(otherList::contains) .collect(Collectors.toSet());","link":"/java/Collections/02-List-Operations.html"},{"title":"List Implementations","text":"[toc] A Guide to the Java LinkedList1List list = Collections.synchronizedList(new LinkedList(...)); Guide to the Java ArrayList1234567891011121314// Constructor Accepting Initial Capacity**List list = new ArrayList&lt;&gt;(20);// Constructor Accepting CollectionCollection&lt;Integer&gt; number = IntStream.range(0, 10).boxed().collect(toSet());List&lt;Integer&gt; list = new ArrayList&lt;&gt;(numbers);assertEquals(10, list.size());assertTrue(numbers.containsAll(list));// insert a collection or several elements at once:List&lt;Long&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1L, 2L, 3L));LongStream.range(4, 10).boxed() .collect(collectingAndThen(toCollection(ArrayList::new), ys -&gt; list.addAll(0, ys)));assertThat(Arrays.asList(4L, 5L, 6L, 7L, 8L, 9L, 1L, 2L, 3L), equalTo(list)); Immutable ArrayList in Java12345678910111213141516// With the JDK// Collections.unmodifiableList(list);List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"one\", \"two\", \"three\"));List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);// With Java 9// List.of(E… elements)final List&lt;String&gt; unmodifiableList = List.of(list.toArray(new String[]{}));// With Guava// ImmutableList.copyOf(list);List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"one\", \"two\", \"three\"));List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);// With the Apache Collections CommonsListUtils.unmodifiableList(list); Guide to CopyOnWriteArrayListIterating Over CopyOnWriteArrayList While Inserting when we create an iterator for the CopyOnWriteArrayList, we get an immutable snapshot of the data in the list at the time iterator() was called. 1assertThat(result).containsOnly(1, 3, 5, 8); // ? Removing While Iterating Is Not Allowed 允许修改元素，但是不允许删除 Multi Dimensional ArrayList in Java","link":"/java/Collections/01-List-Implementations.html"},{"title":"Map Implementations","text":"[toc] The Java HashMap Under the Hood12 A Guide to TreeMap in Java123456789101112131415TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(Comparator.reverseOrder());treeMap.put(1, \"a\");treeMap.put(2, \"a\");treeMap.put(3, \"a\");treeMap.put(4, \"a\");treeMap.put(5, \"a\");System.out.println(treeMap.lastKey());System.out.println(treeMap.firstKey());System.out.println(treeMap.headMap(3).keySet().toString());System.out.println(treeMap.tailMap(3).keySet().toString());//1//5//[5, 4]//[3, 2, 1] Java TreeMap vs HashMap Differences Implementation红黑树 hashtable Order Null Values不允许 null 作为 key 允许 null 作为 key Performance Analysis 3.1. HashMap 3.2. TreeMap Similarities 4.1. Unique Elements4.2. Concurrent Access Both Map implementations aren’t synchronized We have to explicitly use Collections.synchronizedMap(mapName) to obtain a synchronized view of a provided map. 4.3. Fail-Fast Iterators Guide to WeakHashMap in JavaWeakHashMap 的用途？ 1234567891011121314151617181920212223242526272829303132// 2. Strong, Soft, and Weak References// 2.1. Strong ReferencesInteger prime = 1;// 2.2. Soft References// an object that has a SoftReference pointing to it won't be garbage collected until the JVM absolutely needs memory.Integer prime = 1; SoftReference&lt;Integer&gt; soft = new SoftReference&lt;Integer&gt;(prime); prime = null;// The prime object has a strong reference pointing to it.// Next, we are wrapping prime strong reference into a soft reference. After making that strong reference null, a prime object is eligible for GC but will be collected only when JVM absolutely needs memory.// 2.3. Weak References// The objects that are referenced only by weak references are garbage collected eagerly; the GC won't wait until it needs memory in that case.Integer prime = 1; WeakReference&lt;Integer&gt; soft = new WeakReference&lt;Integer&gt;(prime); prime = null;// When we made a prime reference null, the prime object will be garbage collected in the next GC cycle, as there is no other strong reference pointing to it.// 3. WeakHashMap as an Efficient Memory Cache// References of a WeakReference type are used as keys in WeakHashMap.WeakHashMap&lt;UniqueImageName, BigImage&gt; map = new WeakHashMap&lt;&gt;();BigImage bigImage = new BigImage(\"image_id\");UniqueImageName imageName = new UniqueImageName(\"name_of_big_image\"); map.put(imageName, bigImage);assertTrue(map.containsKey(imageName)); imageName = null;System.gc(); await().atMost(10, TimeUnit.SECONDS).until(map::isEmpty); A Guide to ConcurrentMap1234567891011121314151617181920212223// 2. ConcurrentMap 是一个 interface// Several default implementations are overridden, disabling the null key/value support:getOrDefaultforEachreplaceAllcomputeIfAbsentcomputeIfPresentcomputemerge// The following APIs are also overridden to support atomicity, without a default interface implementation:putIfAbsentremovereplace(key, oldValue, newValue)replace(key, value) // 3. ConcurrentHashMap// 3.1. Thread-Safety// 3.2. Null Key/Value// 3.3. Stream Support// 3.4. Performance// 3.5. Pitfalls// 4. ConcurrentNavigableMap// 5. ConcurrentSkipListMap Guide to the ConcurrentSkipListMap12 An Introduction to Java.util.Hashtable Class12 A Guide to LinkedHashMap in Java12 A Guide to EnumMap12 Immutable Map Implementations in Java12 A Guide to Java HashMap12","link":"/java/Collections/04-Map-Implementations.html"},{"title":"Set Implementations","text":"[toc] A Guide to TreeSet in Java123456789101112131415161718192021222324252627282930313233343536373839// 2. Intro to TreeSet// 2.1. TreeSet With a Constructor Comparator ParamSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(Comparator.comparing(String::length));// 2.2 synchronized treeSetSet&lt;String&gt; syncTreeSet = Collections.synchronizedSet(treeSet);// 3. TreeSet add()// 返回 boolean, 源码如下，可以看到内部用的是 treemappublic boolean add(E e) { return m.put(e, PRESENT) == null;}// 4. TreeSet contains()// 5. TreeSet remove() 返回 boolean// 6. TreeSet clear()// 7. TreeSet size()// 8. TreeSet isEmpty()// 9. TreeSet iterator()--升序 descendingIterator()--降序// 若迭代时用treeSet 的 remove 方法，会触发 fail-fast 机制，抛出 ConcurrentModificationException 异常while (itr.hasNext()) { itr.next(); treeSet.remove(\"Second\");}// 但是若用 Iterator 的 remove 方法就没问题while (itr.hasNext()) { String element = itr.next(); if (element.equals(\"Second\")) itr.remove();}// 10. TreeSet first()// size() 为 0 的话抛出异常// 11. TreeSet last()// 12. TreeSet subSet()// return the elements ranging from fromElement to toElement// 13. TreeSet headSet()// return elements of TreeSet which are smaller than the specified element:// 14. TreeSet tailSet()// return the elements of a TreeSet which are greater than or equal to the specified element// 15. Storing Null Elements// 不可添加 null A Guide to HashSet in Java内部维护了一个 HashMap How HashSet Maintains Uniqueness?When we put an object into a HashSet, it uses the object’s hashcode value to determine if an element is not in the set already. Each hash code value corresponds to a certain bucket location which can contain various elements, for which the calculated hash value is the same. But two objects with the same *hashCode* might not be equal. So, objects within the same bucket will be compared using the equals() method.","link":"/java/Collections/03-Set-Implementations.html"},{"title":"Apache Commons Collections","text":"[toc]","link":"/java/Collections/Apache-Commons-Collections.html"},{"title":"Map Operations","text":"[toc]","link":"/java/Collections/05-Map-Operations.html"},{"title":"Convert Collections","text":"[toc]","link":"/java/Collections/Convert-Collections.html"},{"title":"Java Collections | Baeldung","text":"[toc] Java Collections | Baeldung ListsList Implementations:A Guide to the Java LinkedListGuide to the Java ArrayListImmutable ArrayList in JavaGuide to CopyOnWriteArrayListMulti Dimensional ArrayList in Java List Operations:Converting Iterator to ListJava – Get Random Item/Element From a ListPartition a List in Java Removing all nulls from a List in JavaRemoving all duplicates from a List in JavaRemoving all Nulls from a List in JavaCheck If Two Lists are Equal in Java How to Find an Element in a List with JavaJava List UnsupportedOperationExceptionCopy a List to Another List in JavaRemove All Occurrences of a Specific Value from a ListAdd Multiple Items to an Java ArrayListRemove the First Element from a ListWays to Iterate Over a List in JavaIntersection of Two Lists in Java SetsSet Implementations:A Guide to TreeSet in JavaA Guide to HashSet in Java MapsMap Implementations:The Java HashMap Under the HoodA Guide to TreeMap in JavaJava TreeMap vs HashMapGuide to WeakHashMap in JavaA Guide to ConcurrentMapGuide to the ConcurrentSkipListMapAn Introduction to Java.util.Hashtable ClassA Guide to LinkedHashMap in JavaA Guide to EnumMapImmutable Map Implementations in JavaA Guide to Java HashMap Map Operations:How to Store Duplicate Keys in a Map in Java?Initialize a HashMap in JavaMerging Two Maps with Java 8Sort a HashMap in JavaComparing Two HashMaps in Java QueuesGuide to PriorityBlockingQueue in JavaGuide to java.util.concurrent.BlockingQueueA Guide to Java SynchronousQueueGuide to the Java TransferQueueGuide to DelayQueueIntroduction to the Java ArrayDequeGuide to the Java Queue Interface Convert CollectionsConverting between an Array and a List in JavaConverting Between an Array and a Set in JavaConverting between a List and a Set in JavaConvert a Map to an Array, List or Set in JavaHow to Convert List to Map in JavaMap to String Conversion in Java Operations on CollectionThe Difference Between Collection.stream().forEach() and Collection.forEach()Sorting in JavaShuffling Collections In JavaFlattening Nested Collections in JavaZipping Collections in JavaJoin and Split Arrays and Collections in JavaJava – Combine Multiple CollectionsFinding Max/Min of a List or CollectionCollect a Java Stream to an Immutable CollectionJava 9 Convenience Factory Methods for CollectionsJava Collections Interview QuestionsA Guide to Iterator in JavaGetting the Size of an Iterable in JavaRemoving Elements from Java Collections Apache Commons CollectionsApache Commons Collections BagApache Commons Collections SetUtilsApache Commons Collections OrderedMapApache Commons Collections BidiMapA Guide to Apache Commons Collections CollectionUtilsApache Commons Collections MapUtilsGuide to Apache Commons CircularFifoQueue Guava CollectionsGuava Collections CookbookGuide to Guava MultimapGuava – Join and Split CollectionsGuide to Guava Table Other CollectionsIntroduction to Eclipse CollectionsIntroduction to PCollectionsFiltering and Transforming Collections in GuavaHamcrest Collections CookbookImplementing a Binary Tree in Java","link":"/java/Collections/Java-Collections-Baeldung.html"},{"title":"Operations on Collection","text":"[toc]","link":"/java/Collections/Operations-on-Collection.html"},{"title":"01 json解析","text":"[toc] fastjsonmaven12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; code1234567891011121314151617181920212223242526272829303132333435package json;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import java.util.ArrayList;import java.util.List;// [Java中那些常用的json库性能比较，常见Json库用法示例代码 - 51CTO.COM](https://developer.51cto.com/art/201907/599631.htm)public class JsonTest { public static void main(String[] args) { Person person = new Person(); person.setId(1111); person.setUsername(\"zronghui\"); person.setAddress(\"广东\"); person.setAge(100); List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(person); // fastjson // Java对象转化成为json字符串 System.out.println(JSON.toJSONString(person)); // 集合对象转化成为json字符串 System.out.println(JSON.toJSONString(list)); // 字符串转化成java对象 Person person1 = JSON.parseObject(JSON.toJSONString(person), Person.class); // 字符串转化成json对象 JSONObject jsonObject = JSON.parseObject(JSON.toJSONString(person)); // 字符串转化成为java集合 List&lt;Person&gt; people = JSON.parseArray(JSON.toJSONString(list), Person.class); }} Person.java 123456789101112131415package json;import lombok.Data;import lombok.Getter;import lombok.Setter;@Data@Getter@Setterpublic class Person { private Integer id; private String username; private Integer age; private String address;} 问题maven helloworld8、运行程序 在运行之前需要先进行相关的配置。点击Run-&gt;Edit Configurations… 2 种运行方法 Maven项目中出现“不再支持目标选项 1.5。请使用 1.6 或更高版本。”的解决方法在pom.xml中添加： 12345&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt; IDEA自动补全当前语句的分号command shift + enter IDEA 中快速导入 maven 依赖command + n 调出 generator 窗口，选 dependency 输入关键词搜索，搜索的速度比较慢 如何使用分页插件","link":"/java/module%20test/01-json%E8%A7%A3%E6%9E%90.html"},{"title":"Guava Collections","text":"[toc]","link":"/java/Collections/Guava-Collections.html"},{"title":" Other Collections","text":"[toc]","link":"/java/Collections/Other-Collections.html"},{"title":"02 log","text":"[toc] logSLF4J不同于其他日志类库，与其它有很大的不同。SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。 在代码中表示为{}的特性。占位符是一个非常类似于在String的format()方法中的%s，它会在运行时被某个提供的实际字符串所替换。 slf4j-log4j12-1.5.8.jar –- Log4J Adapter for SLF4J maven12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt;&lt;/dependency&gt; code12345678910111213package log;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class log { private static Logger logger = LoggerFactory.getLogger(log.class); public static void main(String[] args) { logger.info(\"template: {} + {} = {}\", 1, 2, 3); logger.error(\"something wrong\"); }} properties1234567891011# Configure logging for testing: optionally with log filelog4j.rootLogger=INFO, stdout#log4j.rootLogger=WARN, stdout# log4j.rootLogger=WARN, stdout, logfilelog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.logfile=org.apache.log4j.FileAppenderlog4j.appender.logfile.File=target/spring.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n","link":"/java/module%20test/02-log.html"},{"title":"Queues","text":"[toc]","link":"/java/Collections/Queues.html"},{"title":"03 junit","text":"[toc] Junitmaven123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; code12345678910111213141516171819202122232425262728293031323334353637383940414243444546import log.log;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * log Tester. * * @author &lt;Authors name&gt; * @version 1.0 * @since &lt;pre&gt;2月 8, 2020&lt;/pre&gt; */public class logTest { @Before public void before() throws Exception { } @After public void after() throws Exception { } /** * Method: add(int a, int b) */ @Test public void testAdd() throws Exception { //TODO: Test goes here... log log = new log(); assert log.add(1, 3) == 4; Assert.assertEquals(1, 2); Assert.assertTrue(true); Assert.assertNotNull(1); } /** * Method: main(String[] args) */ @Test public void testMain() throws Exception { //TODO: Test goes here... testAdd(); }} Assert例如，Assert.assertEquals(3, result); 主要有如下几个断言方法： assertTrue/False（）：判断一个条件是 true 还是 false。 fail（）：失败，可以有消息，也可以没有消息。 assertEquals（）：判断是否想等，可以指定输出错误信息。注意不同数据类型所使用的 assertEquals 方法参数有所不同。 assertNotNull/Null（）：判断一个对象是否为空。 assertSame/NotSame（）：判断两个对象是否指向同一个对象。 failNotSame/failNotEquals（）：当不指向同一个内存地址或者不相等的时候，输出错误信息。错误信息为指定的格式。 setUp每次测试方法执行之前，都会执行 setUp 方法，此方法用于进行一些固定的准备工作，比如，实例化对象，打开网络连接等。 tearDown每次测试方法执行之后，都会执行 tearDown 方法，此方法用于进行一些固定的善后工作，比如，关闭网络连接等。 Failure与Error区别单元测试的失败（Failure）与测试出现了错误（Error）JUnit 将测试失败的情况分为两种：Failure 和 Error 。 Failure 一般是由单元测试使用的断言方法判断失败引起的，它表示在测试点发现了问题（程序中的 bug）；而 Error 则是有代码异常引起的，这是测试目的之外的发现，它可能产生于测试代码本身的错误（也就是说，编写的测试代码有问题），也可能是被测试代码中的一个隐藏 bug 。不过，一般情况下是第一种情况。 常用注解 @Before初始化方法，在任何一个测试方法执行之前，必须执行的代码。对比 JUnit 3 ，和 setUp（）方法具有相同的功能。在该注解的方法中，可以进行一些准备工作，比如初始化对象，打开网络连接等。 @After释放资源，在任何一个测试方法执行之后，需要进行的收尾工作。对比 JUnit 3 ，和 tearDown（）方法具有相同的功能。 @Test测试方法，表明这是一个测试方法。在 JUnit 中将会自动被执行。对与方法的声明也有如下要求：名字可以随便取，没有任何限制，但是返回值必须为 void ，而且不能有任何参数。如果违反这些规定，会在运行时抛出一个异常。不过，为了培养一个好的编程习惯，我们一般在测试的方法名上加 test ，比如：testAdd（）。同时，该 Annotation（@Test） 还可以测试期望异常和超时时间，如 @Test（timeout=100），我们给测试函数设定一个执行时间，超过这个时间（100毫秒），他们就会被系统强行终止，并且系统还会向你汇报该函数结束的原因是因为超时，这样你就可以发现这些 bug 了。而且，它还可以测试期望的异常，例如，我们刚刚的那个空指针异常就可以这样：@Test(expected=NullPointerException.class)，此时如果出现空指针异常，反正会认为测试通过 @Ignore忽略的测试方法，标注的含义就是“某些方法尚未完成，咱不参与此次测试”；这样的话测试结果就会提示你有几个测试被忽略，而不是失败。一旦你完成了相应的函数，只需要把 @Ignore 注解删除即可，就可以进行正常测试了。 @BeforeClass针对所有测试，也就是整个测试类中，在所有测试方法执行前，都会先执行由它注解的方法，而且只执行一次。当然，需要注意的是，修饰符必须是 public static void xxxx ；此 Annotation 是 JUnit 4 新增的功能。 @AfterClass针对所有测试，也就是整个测试类中，在所有测试方法都执行完之后，才会执行由它注解的方法，而且只执行一次。当然，需要注意的是，修饰符也必须是 public static void xxxx ；此 Annotation 也是 JUnit 4 新增的功能，与 @BeforeClass 是一对。","link":"/java/module%20test/03-junit.html"},{"title":"06 joda time","text":"[toc] Introduction to Joda-Time | Baeldung使用Joda-Time优雅的处理日期时间 - 简书Joda-Time使用手册 - 后端 - 掘金 核心类介绍下面介绍5个最常用的date-time类： Instant - 不可变的类，用来表示时间轴上一个瞬时的点 DateTime - 不可变的类，用来替换JDK的Calendar类 LocalDate - 不可变的类，表示一个本地的日期，而不包含时间部分（没有时区信息） LocalTime - 不可变的类，表示一个本地的时间，而不包含日期部分（没有时区信息） LocalDateTime - 不可变的类，表示一个本地的日期－时间（没有时区信息） maven12345&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt;&lt;/dependency&gt; code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package jodaTime;import org.joda.time.DateTime;import java.util.Date;public class JodaTime { public static void main(String[] args) { // 1. 构造一个DateTime实例 // now DateTime dateTime1 = new DateTime(); // 指定年月日 DateTime dateTime2 = new DateTime(2020, 2, 23, 18, 12, 0); // long DateTime dateTime3 = new DateTime(12345678910L); // java.util.date DateTime dateTime4 = new DateTime(new Date()); // ? DateTime dateTime5 = new DateTime(\"2016-02-15T00:00:00.000+08:00\"); // with 设定时间 dateTime1.withYear(2019); // plus minus 加减时间 dateTime1.plusDays(5); // 获取 property dateTime1.monthOfYear().getAsText(); dateTime1.dayOfWeek().getAsText(); // 因为当时那个地区执行夏令时的原因，在添加一个Period的时候会添加23个小时。 // 而添加一个Duration，则会精确地添加24个小时，而不考虑历法。 // 所以，Period和Duration的差别不但体现在精度上，也同样体现在语义上。 // 因为，有时候按照有些地区的历法 1天 不等于 24小时。 // 因此，用 Duration 不用 Period // 实例 // 例一 计算上一个月的最后一天 new DateTime().minusMonths(1).dayOfMonth().withMaximumValue(); // 例二 获得任何一年中的第 11 月的第一个星期一的日期，而这天必须是这个月的第一个星期一之后 new DateTime().monthOfYear().setCopy(11) .dayOfMonth().withMinimumValue() .plusDays(6) .dayOfWeek() .setCopy(1) // set to monday (it will round down) .plusDays(1); // 例三 计算五年后的第二个月的最后一天 new DateTime().plusYears(5).monthOfYear().setCopy(2).dayOfMonth().withMaximumValue(); }}","link":"/java/module%20test/06-joda-time.html"},{"title":"04 guava","text":"[toc] Google Guava官方教程（中文版） | 并发编程网 – ifeve.comGuava教程™ maven12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;28.2-jre&lt;/version&gt;&lt;/dependency&gt; OptionalOptional 被 Java 自带的替代 12345678910111213141516171819202122232425262728package guava;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Optional;public class aOptional { private static Logger logger = LoggerFactory.getLogger(aOptional.class); public static void add(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) { logger.info(String.valueOf(a.isPresent())); logger.info(String.valueOf(b.isPresent())); logger.info(String.valueOf(a.orElse(0) + b.orElse(0))); // 获取值 // a.get() a 为 null 报错 // a.orElse(x) a 为 null 返回 x } public static void main(String[] args) { // 构造 // Optional.empty() // Optional.of(x) // Optional.ofNullable(x) 若为 null，返回代表 null 的 Optional : Optional.empty() Optional&lt;Integer&gt; a = Optional.ofNullable(10); Optional&lt;Integer&gt; b = Optional.of(10); add(a, b); }} Preconditions1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package guava;import com.google.common.base.Preconditions;import org.slf4j.Logger;import org.slf4j.LoggerFactory;// Preconditions.checkArgument// Preconditions.checkNotNull// Preconditions.checkElementIndexpublic class bPreconditions { private static Logger logger = LoggerFactory.getLogger(bPreconditions.class); public static double sqrt(double input) throws IllegalArgumentException { Preconditions.checkArgument(input &gt; 0.0, \"Illegal Argument passed: Negative value %s.\", input); return Math.sqrt(input); } public static int sum(Integer a, Integer b) { a = Preconditions.checkNotNull(a, \"Illegal Argument passed: First parameter is Null.\"); b = Preconditions.checkNotNull(b, \"Illegal Argument passed: Second parameter is Null.\"); return a + b; } public static int getValue(int input) { int[] data = {1, 2, 3, 4, 5}; Preconditions.checkElementIndex(input, data.length, \"Illegal Argument passed: Invalid index.\"); return 0; } public static void main(String[] args) { try { System.out.println(sqrt(-3.0)); } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } try { System.out.println(sum(null, 3)); } catch (NullPointerException e) { System.out.println(e.getMessage()); } try { System.out.println(getValue(6)); } catch (IndexOutOfBoundsException e) { System.out.println(e.getMessage()); } }} Guava Ordering类1234567891011121314151617181920212223242526272829303132333435package guava;import com.google.common.collect.Ordering;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;public class cOrdering { public static void main(String[] args) { ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); Collections.addAll(integers, 6, 3, 2, 7, 9); // sort Ordering&lt;Comparable&gt; ordering = Ordering.natural(); Collections.sort(integers, ordering); // reverse sort Collections.sort(integers, ordering.reverse()); // isOrdered System.out.println(ordering.reverse().isOrdered(integers)); System.out.println(integers); System.out.println(Collections.max(integers)); System.out.println(Collections.min(integers)); // max min System.out.println(ordering.max(integers)); System.out.println(ordering.min(integers)); integers.add(null); // nullsFirst nullsLast Collections.sort(integers, ordering.reverse().nullsFirst()); System.out.println(integers); }} Guava Objects类123456789101112131415161718192021222324252627282930313233343536373839404142package guava;import com.google.common.base.Objects;import com.google.common.collect.ComparisonChain;import lombok.Data;import lombok.Getter;import lombok.Setter;public class dObjects {}@Setter@Getter@Dataclass Student implements Comparable&lt;Student&gt; { private int id; private String name; @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return id == student.id &amp;&amp; Objects.equal(name, student.name); } @Override public int hashCode() { // Objects.hashCode(field-1, field-2, …, field-n) return Objects.hashCode(id, name); } @Override public int compareTo(Student o) { return ComparisonChain.start() .compare(this.name, o.name) .compare(this.id, o.id) .result(); }} Guava集合工具不可变集合不可变集合可以用如下多种方式创建： copyOf方法，如ImmutableSet.copyOf(set); of方法，如ImmutableSet.of(“a”, “b”, “c”)或 ImmutableMap.of(“a”, 1, “b”, 2); Builder工具 细节：关联可变集合和不可变集合 可变集合接口 属于**JDK还是Guava** 不可变版本 Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet/NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable Guava Multiset接口允许 set 重复，并统计每个值的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.Set;import com.google.common.collect.HashMultiset;import com.google.common.collect.Multiset;public class GuavaTester { public static void main(String args[]){ // HashMultiset.create() Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(\"a\"); multiset.add(\"b\"); multiset.add(\"c\"); multiset.add(\"d\"); multiset.add(\"a\"); multiset.add(\"b\"); multiset.add(\"c\"); multiset.add(\"b\"); multiset.add(\"b\"); multiset.add(\"b\"); // multiset.count(\"b\") multiset.size() multiset.elementSet() System.out.println(\"Occurrence of 'b' : \"+multiset.count(\"b\")); System.out.println(\"Total Size : \"+multiset.size()); Set&lt;String&gt; set = multiset.elementSet(); System.out.println(\"Set [\"); for (String s : set) { System.out.println(s); } System.out.println(\"]\"); //display all the elements of the multiset using iterator Iterator&lt;String&gt; iterator = multiset.iterator(); System.out.println(\"MultiSet [\"); while(iterator.hasNext()){ System.out.println(iterator.next()); } System.out.println(\"]\"); //display the distinct elements of the multiset with their occurrence count System.out.println(\"MultiSet [\"); for (Multiset.Entry&lt;String&gt; entry : multiset.entrySet()) { System.out.println(\"Element: \"+entry.getElement() +\", Occurrence(s): \" + entry.getCount()); } System.out.println(\"]\"); //remove extra occurrences multiset.remove(\"b\",2); //print the occurrence of an element System.out.println(\"Occurence of 'b' : \"+multiset.count(\"b\")); } } Guava Bimap接口可以 inverse，获得 value: key 的 map 12345678910111213141516import com.google.common.collect.BiMap;import com.google.common.collect.HashBiMap;public class GuavaTester { public static void main(String args[]){ BiMap&lt;Integer, String&gt; empIDNameMap = HashBiMap.create(); empIDNameMap.put(new Integer(101), \"Mahesh\"); empIDNameMap.put(new Integer(102), \"Sohan\"); empIDNameMap.put(new Integer(103), \"Ramesh\"); //Emp Id of Employee \"Mahesh\" System.out.println(empIDNameMap.inverse().get(\"Mahesh\")); } } BiMap的各种实现 键–值实现 值–键实现 对应BiMap实现 HashMap HashMap HashBiMap ImmutableMap ImmutableMap ImmutableBiMap EnumMap EnumMap EnumBiMap EnumMap HashMap EnumHashBiMap Guava Table接口类似于 map 的 map，table(r, c, v) (row, col, value) (r, c) 确定 value 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Map;import java.util.Set;import com.google.common.collect.HashBasedTable;import com.google.common.collect.Table;public class GuavaTester { public static void main(String args[]){ //Table&lt;R,C,V&gt; == Map&lt;R,Map&lt;C,V&gt;&gt; /* * Company: IBM, Microsoft, TCS * IBM -&gt; {101:Mahesh, 102:Ramesh, 103:Suresh} * Microsoft -&gt; {101:Sohan, 102:Mohan, 103:Rohan } * TCS -&gt; {101:Ram, 102: Shyam, 103: Sunil } * * */ //create a table Table&lt;String, String, String&gt; employeeTable = HashBasedTable.create(); //initialize the table with employee details employeeTable.put(\"IBM\", \"101\",\"Mahesh\"); employeeTable.put(\"IBM\", \"102\",\"Ramesh\"); employeeTable.put(\"IBM\", \"103\",\"Suresh\"); employeeTable.put(\"Microsoft\", \"111\",\"Sohan\"); employeeTable.put(\"Microsoft\", \"112\",\"Mohan\"); employeeTable.put(\"Microsoft\", \"113\",\"Rohan\"); employeeTable.put(\"TCS\", \"121\",\"Ram\"); employeeTable.put(\"TCS\", \"122\",\"Shyam\"); employeeTable.put(\"TCS\", \"123\",\"Sunil\"); //get Map corresponding to IBM Map&lt;String,String&gt; ibmEmployees = employeeTable.row(\"IBM\"); System.out.println(\"List of IBM Employees\"); for(Map.Entry&lt;String, String&gt; entry : ibmEmployees.entrySet()){ System.out.println(\"Emp Id: \" + entry.getKey() + \", Name: \" + entry.getValue()); } //get all the unique keys of the table Set&lt;String&gt; employers = employeeTable.rowKeySet(); System.out.print(\"Employers: \"); for(String employer: employers){ System.out.print(employer + \" \"); } System.out.println(); //get a Map corresponding to 102 Map&lt;String,String&gt; EmployerMap = employeeTable.column(\"102\"); for(Map.Entry&lt;String, String&gt; entry : EmployerMap.entrySet()){ System.out.println(\"Employer: \" + entry.getKey() + \", Name: \" + entry.getValue()); } } } Multimap很少会直接使用Multimap接口，更多时候你会用ListMultimap或SetMultimap接口，它们分别把键映射到List或Set。 Multimap的各种实现Multimap提供了多种形式的实现。在大多数要使用Map&lt;K, Collection&gt;的地方，你都可以使用它们： 实现 键行为类似 值行为类似 ArrayListMultimap HashMap ArrayList HashMultimap HashMap HashSet LinkedListMultimap* LinkedHashMap* LinkedList* LinkedHashMultimap** LinkedHashMap LinkedHashMap TreeMultimap TreeMap TreeSet ImmutableListMultimap ImmutableMap ImmutableList ImmutableSetMultimap ImmutableMap ImmutableSet Guava 集合工具123456789101112131415161718192021222324252627282930// 用工厂方法模式，我们可以方便地在初始化时就指定起始元素。List theseElements = Lists.newArrayList(\"alpha\", \"beta\", \"gamma\");// 此外，通过为工厂方法命名（Effective Java第一条），我们可以提高集合初始化大小的可读性：List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100);List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100);Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100);// IterablesIterable&lt;Integer&gt; concatenated = Iterables.concat( Ints.asList(1, 2, 3), Ints.asList(4, 5, 6)); // concatenated包括元素 1, 2, 3, 4, 5, 6String lastAdded = Iterables.getLast(myLinkedHashSet);String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);List countUp = Ints.asList(1, 2, 3, 4, 5);// 注: 如果List是不可变的，考虑改用ImmutableList.reverse()。List countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}List&lt;List&gt; parts = Lists.partition(countUp, 2);//{{1,2}, {3,4}, {5}}Set&lt;String&gt; wordsWithPrimeLength = ImmutableSet.of(\"one\", \"two\", \"three\", \"six\", \"seven\", \"eight\");Set&lt;String&gt; primes = ImmutableSet.of(\"two\", \"three\", \"five\", \"seven\");SetView&lt;String&gt; intersection = Sets.intersection(primes,wordsWithPrimeLength);// intersection包含\"two\", \"three\", \"seven\"Map&lt;String, Integer&gt; map = ImmutableMap.of(\"a\", 1, \"b\", 1, \"c\", 2);SetMultimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);// multimap：[\"a\" =&gt; {1}, \"b\" =&gt; {1}, \"c\" =&gt; {2}]Multimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, HashMultimap&lt;Integer, String&gt;.create());// inverse：[1 =&gt; {\"a\",\"b\"}, 2 =&gt; {\"c\"}] Iterables 常规方法 concat(Iterable) 串联多个iterables的懒视图* concat(Iterable...) [frequency(Iterable, Object)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#frequency(java.lang.Iterable, java.lang.Object)) 返回对象在iterable中出现的次数 与Collections.frequency (Collection, Object)比较；``Multiset [partition(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#partition(java.lang.Iterable, int)) 把iterable按指定大小分割，得到的子集都不能进行修改操作 [Lists.partition(List, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Lists.html#partition(java.util.List, int))；[paddedPartition(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#paddedPartition(java.lang.Iterable, int)) [getFirst(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getFirst(java.lang.Iterable, T)) 返回iterable的第一个元素，若iterable为空则返回默认值 与Iterable.iterator(). next()比较;FluentIterable.first() getLast(Iterable) 返回iterable的最后一个元素，若iterable为空则抛出NoSuchElementException [getLast(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getLast(java.lang.Iterable, T))； FluentIterable.last() [elementsEqual(Iterable, Iterable)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#elementsEqual(java.lang.Iterable, java.lang.Iterable)) 如果两个iterable中的所有元素相等且顺序一致，返回true 与List.equals(Object)比较 unmodifiableIterable(Iterable) 返回iterable的不可变视图 与Collections. unmodifiableCollection(Collection)比较 [limit(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#limit(java.lang.Iterable, int)) 限制iterable的元素个数限制给定值 FluentIterable.limit(int) getOnlyElement(Iterable) 获取iterable中唯一的元素，如果iterable为空或有多个元素，则快速失败 [getOnlyElement(Iterable, T default)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#getOnlyElement(java.lang.Iterable, T)) 与Collection方法相似的工具方法通常来说，Collection的实现天然支持操作其他Collection，但却不能操作Iterable。 下面的方法中，如果传入的Iterable是一个Collection实例，则实际操作将会委托给相应的Collection接口方法。例如，往Iterables.size方法传入是一个Collection实例，它不会真的遍历iterator获取大小，而是直接调用Collection.size。 方法 类似的**Collection**方法 等价的**FluentIterable**方法 [addAll(Collection addTo, Iterable toAdd)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#addAll(java.util.Collection, java.lang.Iterable)) Collection.addAll(Collection) [contains(Iterable, Object)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#contains(java.lang.Iterable, java.lang.Object)) Collection.contains(Object) FluentIterable.contains(Object) [removeAll(Iterable removeFrom, Collection toRemove)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#removeAll(java.lang.Iterable, java.util.Collection)) Collection.removeAll(Collection) [retainAll(Iterable removeFrom, Collection toRetain)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#retainAll(java.lang.Iterable, java.util.Collection)) Collection.retainAll(Collection) size(Iterable) Collection.size() FluentIterable.size() [toArray(Iterable, Class)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#toArray(java.lang.Iterable, java.lang.Class)) Collection.toArray(T[]) FluentIterable.toArray(Class) isEmpty(Iterable) Collection.isEmpty() FluentIterable.isEmpty() [get(Iterable, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterables.html#get(java.lang.Iterable, int)) List.get(int) [FluentIterable.get(int)](http://docs.guava-libraries.googlecode.com/git- history/release12/javadoc/com/google/common/collect/FluentIterable.html#get(int)) toString(Iterable) Collection.toString() FluentIterable.toString() Sets 方法 [union(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#union(java.util.Set, java.util.Set)) [intersection(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#intersection(java.util.Set, java.util.Set)) [difference(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#difference(java.util.Set, java.util.Set)) [symmetricDifference(Set, Set)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html#symmetricDifference(java.util.Set, java.util.Set)) Guava缓存工具暂时用不到 12 Guava字符串工具Guava Joiner类Joiner 提供了各种方法来处理字符串加入操作，对象等。 1234// useForNull(String) 给定某个字符串来替换null// skipNulls() 直接忽略nullJoiner joiner = Joiner.on(\"; \").skipNulls();return joiner.join(\"Harry\", null, \"Ron\", \"Hermione\"); Guava Spiltter类1234Splitter.on(',') .trimResults() .omitEmptyStrings() .split(\"foo,bar,, qux\"); Guava CharMatcher类1234567// only the digitsSystem.out.println(CharMatcher.DIGIT.retainFrom(\"mahesh123\"));// trim whitespace at ends, and replace/collapse whitespace into single spacesSystem.out.println(CharMatcher.WHITESPACE.trimAndCollapseFrom(\" Mahesh Parashar \", ' '));// star out all digitsSystem.out.println(CharMatcher.JAVA_DIGIT.replaceFrom(\"mahesh123\", \"*\"));System.out.println(CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(\"mahesh123\")); Guava CaseFormat类12 Guava原语工具Java的原生类型就是指基本类型：byte、short、int、long、float、double、char和boolean。 原生类型数组是处理原生类型集合的最有效方式（从内存和性能双方面考虑）。Guava为此提供了许多工具方法。 方法签名 描述 类似方法 可用性 List asList(prim… backingArray) 把数组转为相应包装类的List Arrays.asList 符号无关* prim[] toArray(Collection collection) 把集合拷贝为数组，和collection.toArray()一样线程安全 Collection.toArray() 符号无关 prim[] concat(prim[]… arrays) 串联多个原生类型数组 Iterables.concat 符号无关 boolean contains(prim[] array, prim target) 判断原生类型数组是否包含给定值 Collection.contains 符号无关 int indexOf(prim[] array, prim target) 给定值在数组中首次出现处的索引，若不包含此值返回-1 List.indexOf 符号无关 int lastIndexOf(prim[] array, prim target) 给定值在数组最后出现的索引，若不包含此值返回-1 List.lastIndexOf 符号无关 prim min(prim… array) 数组中最小的值 Collections.min 符号相关* prim max(prim… array) 数组中最大的值 Collections.max 符号相关 String join(String separator, prim… array) 把数组用给定分隔符连接为字符串 Joiner.on(separator).join 符号相关 Comparator&lt;prim[]&gt; lexicographicalComparator() 按字典序比较原生类型数组的Comparator Ordering.natural().lexicographical() 符号相关 *符号无关方法存在于Bytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans。而UnsignedInts, UnsignedLongs, SignedBytes, 或UnsignedBytes不存在。 *符号相关方法存在于SignedBytes, UnsignedBytes, Shorts, Ints, Longs, Floats, Doubles, Chars, Booleans, UnsignedInts, UnsignedLongs。而Bytes不存在。 Guava Ints类 方法及说明 static int compare(int a, int b) 比较两个指定的int值。 static boolean contains(int[] array, int target) 返回true，如果target是否存在在任何地方数组元素。 static int[] ensureCapacity(int[] array, int minLength, int padding) 返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。 static String join(String separator, int… array) 返回包含由分离器分离所提供的整型值的字符串。 static int saturatedCast(long value) 返回最接近的int值。 static Converter stringConverter() 返回使用字符串和整数之间的一个转换器序列化对象 Integer.decode(java.lang.String) 和 Integer.toString(). static int[] toArray(Collection collection) 返回包含集合的每个值的数组，转换为int值的方式Number.intValue(). static Integer tryParse(String string) 解析指定的字符串作为符号十进制整数。 12 Guava数学工具Guava还另外提供了一些有用的运算函数 运算 IntMath LongMath BigIntegerMath***** 最大公约数 [gcd(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/IntMath.html#gcd(int, int)) [gcd(long, long)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/LongMath.html#gcd(long, long)) BigInteger.gcd(BigInteger) 取模 [mod(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/IntMath.html#mod(int, int)) [mod(long, long)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/LongMath.html#mod(long, long)) BigInteger.mod(BigInteger) 取幂 [pow(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/IntMath.html#pow(int, int)) [pow(long, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/LongMath.html#pow(long, int)) BigInteger.pow(int) 是否2的幂 isPowerOfTwo(int) isPowerOfTwo(long) isPowerOfTwo(BigInteger) 阶乘* factorial(int) factorial(int) factorial(int) 二项式系数* [binomial(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/IntMath.html#binomial(int, int)) [binomial(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/LongMath.html#binomial(int, int)) [binomial(int, int)](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/math/BigIntegerMath.html#binomial(int, int)) ​","link":"/java/module%20test/04-guava.html"},{"title":"05 Apache Commons","text":"[toc] maven12 BidiMap双向映射 123456789101112131415BidiMap&lt;String, String&gt; bidi = new TreeBidiMap&lt;&gt;();bidi.put(\"One\", \"1\");bidi.put(\"Two\", \"2\");bidi.put(\"Three\", \"3\");// get getKeySystem.out.println(bidi.get(\"One\")); System.out.println(bidi.getKey(\"1\"));System.out.println(\"Original Map: \" + bidi);// inverseBidiMapbidi.removeValue(\"1\"); System.out.println(\"Modified Map: \" + bidi);BidiMap&lt;String, String&gt; inversedMap = bidi.inverseBidiMap(); System.out.println(\"Inversed Map: \" + inversedMap); MapIteratorJDK Map接口很难作为迭代在EntrySet或KeySet对象上迭代。 MapIterator提供了对Map的简单迭代。下面的例子说明了这一点。 MapIterator接口示例 123456789101112131415161718192021222324import org.apache.commons.collections4.IterableMap;import org.apache.commons.collections4.MapIterator;import org.apache.commons.collections4.map.HashedMap;public class MapIteratorTester { public static void main(String[] args) { IterableMap&lt;String, String&gt; map = new HashedMap&lt;&gt;(); map.put(\"1\", \"One\"); map.put(\"2\", \"Two\"); map.put(\"3\", \"Three\"); map.put(\"4\", \"Four\"); map.put(\"5\", \"Five\"); MapIterator&lt;String, String&gt; iterator = map.mapIterator(); while (iterator.hasNext()) { Object key = iterator.next(); Object value = iterator.getValue(); System.out.println(\"key: \" + key); System.out.println(\"Value: \" + value); iterator.setValue(value + \"_\"); } System.out.println(map); }} OrderedMap接口OrderedMap是映射的新接口，用于保留添加元素的顺序。 LinkedMap和ListOrderedMap是两种可用的实现。 此接口支持Map的迭代器，并允许在Map中向前或向后两个方向进行迭代。 下面的例子说明了这一点。 示例代码 OrderedMapTester.java - 123456789101112131415import org.apache.commons.collections4.OrderedMap;import org.apache.commons.collections4.map.LinkedMap;public class OrderedMapTester { public static void main(String[] args) { OrderedMap&lt;String, String&gt; map = new LinkedMap&lt;String, String&gt;(); map.put(\"One\", \"1\"); map.put(\"Two\", \"2\"); map.put(\"Three\", \"3\"); System.out.println(map.firstKey()); System.out.println(map.nextKey(\"One\")); System.out.println(map.nextKey(\"Two\")); }} CollectionUtils.addIgnoreNull()检查是否为空元素 CollectionUtils的addIgnoreNull()方法可用于确保只有非空(null)值被添加到集合中。 声明 以下是org.apache.commons.collections4.CollectionUtils.addIgnoreNull()的声明 - 1234public static &lt;T&gt; boolean addIgnoreNull(Collection&lt;T&gt; collection, T object)Java 参数 collection - 要添加到的集合，不能为null值。 object - 要添加的对象，如果为null，则不会添加。 返回值 如果集合已更改，则返回为True。 示例 以下示例显示org.apache.commons.collections4.CollectionUtils.addIgnoreNull()方法的用法。在示例中试图添加一个空值和一个非空值。 123456789101112131415161718192021import java.util.LinkedList;import java.util.List;import org.apache.commons.collections4.CollectionUtils;public class CollectionUtilsTester { public static void main(String[] args) { List&lt;String&gt; list = new LinkedList&lt;String&gt;(); CollectionUtils.addIgnoreNull(list, null); CollectionUtils.addIgnoreNull(list, \"a\"); System.out.println(list); if(list.contains(null)) { System.out.println(\"Null value is present\"); } else { System.out.println(\"Null value is not present\"); } }} CollectionUtils.collate() 合并并排序CollectionUtils的collate()方法可用于合并两个已排序的列表。 声明以下是org.apache.commons.collections4.CollectionUtils.collate()方法的声明 - 12345public static &lt;O extends Comparable&lt;? super O&gt;&gt; List&lt;O&gt; collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)Java 参数 a - 第一个集合，不能为null。 b - 第二个集合不能为null。 返回值 一个新的排序列表，其中包含集合a和b的元素。 异常 NullPointerException - 如果其中一个集合为null。 示例 以下示例显示了用法org.apache.commons.collections4.CollectionUtils.collate()方法。 我们将合并两个已排序的列表，然后打印已合并和已排序的列表。 12345678910111213import java.util.Arrays;import java.util.List;import org.apache.commons.collections4.CollectionUtils;public class CollectionUtilsTester { public static void main(String[] args) { List&lt;String&gt; sortedList1 = Arrays.asList(\"A\",\"C\",\"E\"); List&lt;String&gt; sortedList2 = Arrays.asList(\"B\",\"D\",\"F\"); List&lt;String&gt; mergedList = CollectionUtils.collate(sortedList1, sortedList2); System.out.println(mergedList); }} isEmpty() isNotEmpty()12345// CollectionUtils.isNotEmpty(list) 等价于static boolean checkNotEmpty1(List&lt;String&gt; list) { return !(list == null || list.isEmpty());}// isEmpty() 与之相反 12345678// 子集CollectionUtils.isSubCollection(list2, list1);// 相交CollectionUtils.intersection(list1, list2);// 差集CollectionUtils.subtract(list1, list2);// 联合CollectionUtils.union(list1, list2);","link":"/java/module%20test/05-Apache-Commons.html"},{"title":"07 AssertJ","text":"[toc] AssertJ一分钟入门 - 简书AssertJ / Fluent assertions for java maven12345&lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;version&gt;3.11.1&lt;/version&gt;&lt;/dependency&gt; code123456789101112131415161718package AssertJ;import java.util.ArrayList;import java.util.Collections;import java.util.List;//import static org.assertj.core.api.Assertions.*;import static org.assertj.core.api.Assertions.assertThat;public class AssertJTest { public static void main(String[] args) { assertThat(\"aa\".equals(\"aa\")); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 1, 2, 3); assertThat(list).contains(1); assertThat(list).containsOnly(1, 2, 3); }} Basic tips :Java 8 assertions, see release notes : 3.8.0 / 3.7.0 / 3.6.0 / 3.5.0 / 3.4.0 / 3.3.0 /3.2.0 / 3.1.0 / 3.0.0IDE configuration to directly get assertThat in code completionDescribe your assertion using as(String description, Object… args)call as() before the assertion 123assertThat(frodo.getAge()).as(\"check %s's age\", frodo.getName()).isEqualTo(100);// The error message starts with the given description in [] :// [check Frodo's age] expected:&lt;100&gt; but was:&lt;33&gt; Exception assertions guideUsing String assertions on the content of a fileIterable and arrays assertions :Combining filtering and assertions on iterables or arrays1234567891011121314151617181920212223242526// Filtering can be done on arrays or iterables. Filter criteria are expressed by :// - a Java 8 Predicate// using simple predicate(谓语？), best expressed with a lambdaassertThat(fellowshipOfTheRing).filteredOn( character -&gt; character.getName().contains(\"o\") ) .containsOnly(aragorn, frodo, legolas, boromir);// - Filtering on a property or a fieldassertThat(fellowshipOfTheRing).filteredOn(\"race\", MAN) .filteredOn(\"name\", not(\"Boromir\")) .containsOnly(aragorn);// - Filtering with a Conditionimport org.assertj.core.api.Condition;Condition&lt;Player&gt; mvpStats= new Condition&lt;Player&gt;() { @Override public boolean matches(Player player) { return player.pointsPerGame() &gt; 20 &amp;&amp; (player.assistsPerGame() &gt;= 8 || player.reboundsPerGame() &gt;= 8); }};List&lt;Player&gt; players;players.add(rose); // Derrick Rose : 25 ppg - 8 assists - 5 reboundsplayers.add(lebron); // Lebron James : 27 ppg - 6 assists - 9 reboundsplayers.add(noah); // Joachim Noah : 8 ppg - 5 assists - 11 reboundsassertThat(players).filteredOn(mvpStats) .containsOnly(rose, lebron); Assertions on extracted properties/fields of iterable/array elements123456789101112assertThat(fellowshipOfTheRing).extracting(\"name\") .contains(\"Boromir\", \"Gandalf\", \"Frodo\", \"Legolas\") .doesNotContain(\"Sauron\", \"Elrond\");// when checking several properties/fields you have to use tuples :import static org.assertj.core.api.Assertions.tuple;// extracting name, age and and race.name nested propertyassertThat(fellowshipOfTheRing).extracting(\"name\", \"age\", \"race.name\") .contains(tuple(\"Boromir\", 37, \"Man\"), tuple(\"Sam\", 38, \"Hobbit\"), tuple(\"Legolas\", 1000, \"Elf\")); Flat(map) extracting1234567891011121314151617List&lt;Player&gt; reallyGoodPlayers = list(jordan, magic);// check all team mates by specifying the teamMates property (Player has a getTeamMates() method):assertThat(reallyGoodPlayers).flatExtracting(\"teamMates\") .contains(pippen, kukoc, jabbar, worthy);// alternatively, you can implement an Extractor to extract the team mates:assertThat(reallyGoodPlayers).flatExtracting(teamMates) .contains(pippen, kukoc, jabbar, worthy);// where teamMates is an instance of PlayerTeammatesExtractor:public class PlayerTeammatesExtractor implements Extractor&lt;Player, List&lt;Player&gt;&gt; { @Override public List&lt;Player&gt; extract(Player input) { return input.getTeamMates(); }} Assertions on results of a method call on iterable/array elements12345678910111213141516// Like extracting but instead of extracting properties/fields// ** it extracts the result of a given method invocation on the elements of the Iterable/Array under test and puts the results into a new Iterable/Array which becomes the object under test.// WesterosHouse class has a method: public String sayTheWords()List&lt;WesterosHouse&gt; greatHouses = new ArrayList&lt;WesterosHouse&gt;();greatHouses.add(new WesterosHouse(\"Stark\", \"Winter is Coming\"));greatHouses.add(new WesterosHouse(\"Lannister\", \"Hear Me Roar!\"));greatHouses.add(new WesterosHouse(\"Greyjoy\", \"We Do Not Sow\"));greatHouses.add(new WesterosHouse(\"Baratheon\", \"Our is the Fury\"));greatHouses.add(new WesterosHouse(\"Martell\", \"Unbowed, Unbent, Unbroken\"));greatHouses.add(new WesterosHouse(\"Tyrell\", \"Growing Strong\"));// let's verify the words of the great houses of Westeros:// 对每个对象调用 sayTheWords 方法assertThat(greatHouses).extractingResultOf(\"sayTheWords\") .contains(\"Winter is Coming\", \"We Do Not Sow\", \"Hear Me Roar\") .doesNotContain(\"Lannisters always pay their debts\"); Advanced tips :Gather all errors message with soft assertions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Using soft assertions, AssertJ collects all assertion errors instead of stopping at the first one.// use SoftAssertions instead of direct assertThat methodsSoftAssertions softly = new SoftAssertions();softly.assertThat(mansion.guests()).as(\"Living Guests\").isEqualTo(7);softly.assertThat(mansion.kitchen()).as(\"Kitchen\").isEqualTo(\"clean\");softly.assertThat(mansion.library()).as(\"Library\").isEqualTo(\"clean\");softly.assertThat(mansion.revolverAmmo()).as(\"Revolver Ammo\").isEqualTo(6);softly.assertThat(mansion.candlestick()).as(\"Candlestick\").isEqualTo(\"pristine\");softly.assertThat(mansion.colonel()).as(\"Colonel\").isEqualTo(\"well kempt\");softly.assertThat(mansion.professor()).as(\"Professor\").isEqualTo(\"well kempt\");// Don't forget to call SoftAssertions global verification !softly.assertAll();// When the collected assertions are all asserted together they yield a more descriptive error message:// org.assertj.core.api.SoftAssertionError:// The following 4 assertions failed:// 1) [Living Guests] expected:&lt;[7]&gt; but was:&lt;[6]&gt;// 2) [Library] expected:&lt;'[clean]'&gt; but was:&lt;'[messy]'&gt;// 3) [Candlestick] expected:&lt;'[pristine]'&gt; but was:&lt;'[bent]'&gt;// 4) [Professor] expected:&lt;'[well kempt]'&gt; but was:&lt;'[bloodied and dishevelled]'&gt;// AssertJ also provides a few ways to avoid having to call softly.assertAll() manually:// JUnitSoftAssertions with a JUnit rule@Rulepublic final JUnitSoftAssertions softly = new JUnitSoftAssertions();@Testpublic void host_dinner_party_where_nobody_dies() { Mansion mansion = new Mansion(); mansion.hostPotentiallyMurderousDinnerParty(); // use SoftAssertions instead of direct assertThat methods softly.assertThat(mansion.guests()).as(\"Living Guests\").isEqualTo(7); // ... // No need to call softly.assertAll(), it is automatically done by JUnitSoftAssertions rule}// AutoCloseableSoftAssertions@Testpublic void host_dinner_party_where_nobody_dies() { Mansion mansion = new Mansion(); mansion.hostPotentiallyMurderousDinnerParty(); try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) { softly.assertThat(mansion.guests()).as(\"Living Guests\").isEqualTo(7); // ... // no need to call assertAll, it is done when softly is closed. }}// Using the static assertSoftly method@Testpublic void host_dinner_party_where_nobody_dies() { Mansion mansion = new Mansion(); mansion.hostPotentiallyMurderousDinnerParty(); SoftAssertions.assertSoftly(softly -&gt; { softly.assertThat(mansion.guests()).as(\"Living Guests\").isEqualTo(7); // ... // no need to call assertAll, it is done by assertSoftly. });} Using String assertions on the content of a file1234567File xFile = writeFile(\"xFile\", \"The Truth Is Out There\");// classic File assertionsassertThat(xFile).exists().isFile().isRelative();// String assertions on the file content : contentOf() comes from Assertions.contentOf static importassertThat(contentOf(xFile)).startsWith(\"The Truth\").contains(\"Is Out\").endsWith(\"There\"); Exception assertions guide123456789101112131415161718192021assertThatThrownBy(() -&gt; { throw new Exception(\"boom!\"); }).isInstanceOf(Exception.class) .hasMessageContaining(\"boom\");// 或者assertThatExceptionOfType(IOException.class).isThrownBy(() -&gt; { throw new IOException(\"boom!\"); }) .withMessage(\"%s!\", \"boom\") .withMessageContaining(\"boom\") .withNoCause();// 或者// whenThrowable thrown = catchThrowable(() -&gt; { throw new Exception(\"boom!\"); });// thenassertThat(thrown).isInstanceOf(Exception.class) .hasMessageContaining(\"boom\");// 无错assertThatCode(() -&gt; { // code that should throw an exception ...}).doesNotThrowAnyException(); Using a custom comparison strategy in assertions123456789101112// usingComparator(Comparator) example :// frodo and sam are instances of TolkienCharacter with Hobbit race (obviously :)), they are not equalassertThat(frodo).isNotEqualTo(sam);// ... but if we compare race only, they are (raceComparator implements Comparator&lt;TolkienCharacter&gt;)assertThat(frodo).usingComparator(raceComparator).isEqualTo(sam);// usingElementComparator(Comparator) example :// standard comparison : the fellowshipOfTheRing includes Gandalf but not Sauron (believe me) ...assertThat(fellowshipOfTheRing).contains(gandalf).doesNotContain(sauron);// ... but if we compare race only, Sauron is in fellowshipOfTheRing (he's a Maia like Gandalf)assertThat(fellowshipOfTheRing).usingElementComparator(raceComparator).contains(sauron); Field by field comparisons isEqualToComparingFieldByField : compares all fields/properties including inherited ones - not recursive isEqualToComparingOnlyGivenFields : compares only the specified fields/properties - not recursive isEqualToIgnoringGivenFields : compares all fields/properties except specified ones - not recursive isEqualToIgnoringNullFields : compares non null fields/properties only - not recursive isEqualToComparingFieldByFieldRecursively : compares all fields/properties recursively 1234567891011121314151617181920212223242526272829TolkienCharacter frodo = new TolkienCharacter(\"Frodo\", 33, HOBBIT);TolkienCharacter frodoClone = new TolkienCharacter(\"Frodo\", 33, HOBBIT);// 1. isEqualToComparingFieldByField// Fail as equals compares object referencesassertThat(frodo).isEqualsTo(frodoClone);// frodo and frodoClone are equal when doing a field by field comparison.assertThat(frodo).isEqualToComparingFieldByField(frodoClone);// 2. isEqualToComparingOnlyGivenFields// frodo and sam both are hobbits, so they are equal when comparing only raceassertThat(frodo).isEqualToComparingOnlyGivenFields(sam, \"race\"); // OK// they are also equals when comparing only race name (nested field).assertThat(frodo).isEqualToComparingOnlyGivenFields(sam, \"race.name\"); // OK// ... but not when comparing both name and raceassertThat(frodo).isEqualToComparingOnlyGivenFields(sam, \"name\", \"race\"); // FAIL// 3. isEqualToIgnoringGivenFields// frodo and sam are equal when ignoring name and age as the only remaining field is raceassertThat(frodo).isEqualToIgnoringGivenFields(sam, \"name\", \"age\"); // OK both are HOBBIT// ... but they are not equals if only age is ignored as their names differ.assertThat(frodo).isEqualToIgnoringGivenFields(sam, \"age\"); // FAIL// 4. isEqualToIgnoringNullFieldsTolkienCharacter frodo = new TolkienCharacter(\"Frodo\", 33, HOBBIT);TolkienCharacter mysteriousHobbit = new TolkienCharacter(null, 33, HOBBIT);// Null fields in expected object are ignored, mysteriousHobbit has a null name thus it's ignoredassertThat(frodo).isEqualToIgnoringNullFields(mysteriousHobbit); // OK// ... but this is not reversible !assertThat(mysteriousHobbit).isEqualToIgnoringNullFields(frodo); // FAIL Using a custom representation in assertions12 Extending assertions with conditions12 Creating assertions for your domain12","link":"/java/module%20test/07-AssertJ.html"},{"title":"Dubbo面试28题答案详解：核心功能+服务治理+架构设计等","text":"[toc] Dubbo面试28题答案详解：核心功能+服务治理+架构设计等Java学习分享 1.Dubbo是什么？RPC 指的是远程调用协议，也就是说两个服务器交互数据。 Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案，可以和 Spring 框架无缝集成。 2.Dubbo的由来？互联网的快速发展，Web 应用程序规模的不断扩大，一般会经历如下四个发展阶段。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起即可。 垂直应用架构**当访问量逐渐增大，单一应用按照有业务线拆成多个应用，以提升效率。 此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速地响应多变的市场需求。 此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 3.Dubbo的主要应用场景？透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 4.Dubbo的核心功能？主要就是如下3个核心功能： Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。 Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 5.Dubbo的核心组件？ Provider Consumer Registry Monitor Container 6.Dubbo服务注册与发现的流程？ 流程说明： Provider 绑定指定端口并启动服务 Provider 连接注册中心，并发送 本机IP、端口、应用信息和提供服务信息 至 Registry 存储 Consumer 连接注册中心 ，并发送应用信息、所求服务信息至注册中心 Registry 根据 Consumer 所求服务信息匹配对应的 Provider 列表发送至 Consumer 应用缓存。 Consumer 在发起远程调用时基于缓存的 Provider 列表择其一发起调用。 Provider 状态变更会实时通知Registry、再由Registry实时推送至Consumer 设计的原因： Consumer 与Provider 解偶，双方都可以横向增减节点数。 Registry 对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台 去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用 服务提供者无状态，任意一台宕掉后，不影响使用 7.Dubbo的架构设计？ Dubbo框架设计一共划分了10个层： 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心。 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton。 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心。 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心。 监控层（Monitor）：RPC调用次数和调用时间监控。 远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心。 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心。 8.Dubbo的服务调用流程？ 9.Dubbo支持哪些协议，每种协议的应用场景，优缺点？ dubbo： 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化； rmi： 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。 多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞； webservice： 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用； http： 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用； hessian： 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件； memcache： 基于memcached实现的RPC协议 redis： 基于redis实现的RPC协议 10.dubbo推荐用什么协议？默认使用dubbo协议 11.Dubbo有些哪些注册中心？ Multicast注册中心： Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现； Zookeeper注册中心： 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更； redis注册中心： 基于redis实现，采用key/Map存储，住key存储服务名和类型，Map中key存储服务URL，value服务过期时间。基于redis的发布/订阅模式通知数据变更； Simple注册中心 12.Dubbo的服务治理？ 过多的服务URL配置困难 负载均衡分配节点压力过大的情况下也需要部署集群 服务依赖混乱，启动顺序不清晰 过多服务导致性能指标分析难度较大，需要监控 13.Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？可以的，启动dubbo时，消费者会从zookeeper拉取注册的生产者的地址接口等数据，缓存在本地。 每次调用时，按照本地存储的地址进行调用。 14.Dubbo与Spring的关系？Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 15.Dubbo使用的是什么通信框架?默认使用NIO Netty框架 16.Dubbo集群提供了哪些负载均衡策略？ Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀； RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题； LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求； ConstantHash LoadBalance: 一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动； 缺省时为Random随机调用 17.Dubbo的集群容错方案有哪些？ Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。 Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。 18.Dubbo的默认集群容错方案？Failover Cluster 19.Dubbo支持哪些序列化方式？默认使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。 20.Dubbo超时时间怎样设置？Dubbo超时时间设置有两种方式： 服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。 21.服务调用超时问题怎么解决？dubbo在调用服务不成功时，默认是会重试两次的。 22.Dubbo在安全机制方面是如何解决？Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。 23.dubbo 和 dubbox 之间的区别？dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。 24.除了Dubbo还有哪些分布式框架？大家熟知的就是Spring cloud，当然国外也有类似的多个框架。 25.Dubbo和Spring Cloud的关系？Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态。 26.dubbo和spring cloud的区别？最大的区别：Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC通信。 而SpringCloud是基于Http协议+Rest接口调用远程过程的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。","link":"/java/other/Dubbo%E9%9D%A2%E8%AF%9528%E9%A2%98%E7%AD%94%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AD%89.html"},{"title":"分布式消息Kafka的原理、基础架构、使用场景","text":"[toc] 分布式消息Kafka的原理、基础架构、使用场景一：Kafka简介Kafka 是分布式发布-订阅系统，在 kafka 官网上对 kafaka 的定义：一个分布式发布订阅消息传递系统。kafka 是一种快速、可扩展的、分布式、分区的和可复制的提交日志服务。 二：Kafka基本架构它的架构包括以下组件： Topic: 特定类型的消息流。消息是字节的有效负载（payload），topic 是消息的分类名或种子（feed）名 Producer：发布消息到 topic 的对象 Broker / kafka 集群：已发布的消息保存在一组服务器中 Consumer： 可以订阅一个或多个话题，并从 Broker 拉数据，从而消费这些已发布的消息 上图中可以看出，生产者将数据发送到Broker代理，Broker代理有多个话题topic，消费者从Broker获取数据。 三：Kafka基本原理 生产者将数据生产出来，交给 broker 进行存储，消费者需要消费数据了，就从broker中去拿出数据来，然后完成一系列对数据的处理操作。 kafka 官方给出的图： 多个 broker 协同合作，producer 和 consumer 部署在各个业务逻辑中被频繁的调用，三者通过 zookeeper管理协调请求和转发。这样一个高性能的分布式消息发布订阅系统就完成了。 图上有个细节需要注意，producer 到 broker 的过程是 push，也就是有数据就推送到 broker，而 consumer 到 broker 的过程是 pull，是通过 consumer 主动去拉数据的，而不是 broker 把数据主懂发送到 consumer 端的。 四：Zookeeper在kafka的作用 无论是 kafaka 集群还是 producer 、consume 都依赖与 zookeeper 来保证系统可用性集群保存一些 meta 信息。 kafaka 使用 zookeeper 作为其分布式协调框架，很好地将消息生产、消息存储、消息消费的过程结合在一起。 同时借助 zookeeper，kafka 能够建立生产者和消费者的订阅关系，并实现生产者与消费者的负载均衡。 五：Kafka的特性1.高吞吐量、低延迟kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。 2.可扩展性kafka集群支持热扩展 3.持久性、可靠性消息被持久化到本地磁盘，并且支持数据备份防止数据丢失 4.容错性允许集群中节点失败（若副本数量为n,则允许n-1个节点失败） 5.高并发支持数千个客户端同时读写 Kafka的使用场景： 1.日志收集一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。 2.消息系统3.用户活动跟踪Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。 4.运营指标Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。 5.流式处理比如spark streaming和storm 六：ActiveMQ、Kafka、RabbitMQ消息系统的对比","link":"/java/other/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AFKafka%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{"title":"学习JVM是如何从入门到放弃的？","text":"[toc] 一、简单聊聊JVM1.1先来看看简单的Java程序1.2编译过程1.3JVM实现跨平台1.4class文件和JVM的恩怨情仇1.5类加载完以后JVM干了什么？1.5.1JVM的内存结构1.5.2例子中的流程1.6简单聊聊各种常量池1.7GC垃圾回收1.8JVM参数与调优二、JVM面试题2.1详细jvm内存结构2.2讲讲什么情况下回出现内存溢出，内存泄漏？2.3说说线程栈2.4JVM 年轻代到年老代的晋升过程的判断条件是什么呢？2.5JVM 出现 fullGC 很频繁，怎么去线上排查问题2.6类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？2.7类的实例化顺序2.8JVM垃圾回收机制，何时触发MinorGC等操作2.9JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的2.10各种回收算法2.11各种回收器，各自优缺点，重点CMS、G12.12stackoverflow错误，permgen space错误三、总结","link":"/java/other/%E5%AD%A6%E4%B9%A0JVM%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%9A%84%EF%BC%9F.html"},{"title":"淘淘商城 01","text":"[toc] Idea中自动注释的缩进（避免添加注释自动到行首）打开设置界面，依次选择Editor-Code Style-Java，选择Code Generation，取消Line comment at first column和Block comment at first column的选中即可。 接着同样的修改 html xml idea 导入多个maven项目将多个 maven 项目放入一个文件夹下，再用 idea 打开文件夹，打开每个项目的 pom.xml ，右键 add as maven project 项目结构 mvn install parent 和 common manager 项目中： clean tomcat7:run Git-本地已有仓库推送到远程Git-本地已有仓库推送到远程 - 简书 在GitHub 建立新仓库，注意不要勾选 readme git init git remote add origin &lt;你的远程仓库地址&gt; 编写 .gitignore git add . git commit -m ‘…’ git push -u origin master 若勾选 readme： git pull origin master –allow-unrelated-histories 如果进入到merge信息界面，说明成功了，只需要输入:wq,回车，如果不报错误，直接执行下面的语句即可 git push -u origin master git ignoregitignore.io - Create Useful .gitignore Files ForYour Project 如何在IntelliJ IDEA中使用.ignore插件忽略不必要提交的文件_idea,git,插件_qq_34590097的博客-CSDN博客 安装插件 .gitignore 自动生成后，使用 vim .gitignore 添加(因为安装插件后，gitignore 只读) \u0004.idea/target/ 注意以下几个的区别 .idea/ 所有目录下 ./.idea/ 当前目录 怎样删除github上的仓库 - 简书点击进入你要删除的仓库 找到Settings按钮，点击 拉到最下面找到Delete this repository按钮 Maven Repositorygithub 新仓库指南Quick setup — if you’ve done this kind of thing before Set up in Desktop or HTTPSSSH Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore. …or create a new repository on the command line123456echo &quot;# hexo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:zronghui/hexo.gitgit push -u origin master …or push an existing repository from the command line12git remote add origin git@github.com:zronghui/hexo.gitgit push -u origin master …or import code from another repositoryYou can initialize this repository with code from a Subversion, Mercurial, or TFS project. Import code","link":"/java/taotao/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E-01.html"},{"title":"淘淘商城 02","text":"[toc] How can I import a database using command line?the format is: 1mysql -u username -p database_name &lt; /path/to/file.sql From within mysql: 12mysql&gt; use db_name;mysql&gt; source backup-file.sql; 注意： sql 文件外不能加 引号 GitHub 图片加载不出来v2ray 设置全局 mybatis-generator-guiGitHub： zouzg/mybatis-generator-gui: mybatis-generator界面工具，让你生成代码更简单更快捷 指南： Usage Guide · zouzg/mybatis-generator-gui Wiki 视频及可执行文件： Java程序员搬砖头神器 - MyBatis Generator GUI Maven 安装及配置export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; brew install maven 报错： The JAVA_HOME environment variable is not defined correctlyThis environment variable is needed to run this programNB: JAVA_HOME should point to a JDK not a JRE 说明$JAVA_HOME设置错误： 12echo $JAVA_HOME/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jdk tab 自动补全路径，然后在~/.zshrc 里设置变量 IDEA webapp文件夹不识别解决方案","link":"/java/taotao/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E-02.html"},{"title":"Java 并发","text":"CS-Notes [一、使用线程](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=一、使用线程) [实现 Runnable 接口](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现-runnable-接口) [实现 Callable 接口](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现-callable-接口) 12345public class myCallable implements Callable&lt;Integer&gt;{ public Integer call(){ return 123; }} 123FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(new myCallable());new Thread(new FutureTask&lt;Integer&gt;(ft).start();sout(ft.get()); [继承 Thread 类](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=继承-thread-类) [实现接口 VS 继承 Thread](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=实现接口-vs-继承-thread) 用接口好一些 [二、基础线程机制](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=二、基础线程机制) [Executor](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=executor) 三种executor： CachedThreadPool–不限数量 FixedThreadPool–固定数量 SingleThreadExecutor–数量为一 1234567public static void main(String[] args){ ExecutorService executorService = Executors.newCachedThreadPool(); for (int i=0; i&lt;5; i++){ executorService.execute(new myRunnable()); } executorService.shutdown();} [Daemon](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=daemon) [sleep()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=sleep) Sleep 可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。 [yield()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=yield) [三、中断](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=三、中断) [InterruptedException](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=interruptedexception) 无法中断IO阻塞和synchronized阻塞 [interrupted()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=interrupted) 如果一个线程的run()方法执行一个无限循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用interrupt()方法就无法使线程提前结束。 但是调用interrupt()方法会设置线程的中断标记，此时调用interrupted()方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。 1234567891011121314151617public class InterruptExample{ private static class MyThread2 extends Thread { @Override public void run() { while(!interrupted()){ // ... } sout(\"thread end\"); } } public static void main(String[] args) throws InterruptedException{ Thread thread = MyThread2(); thread2.start(); thread.interrupt(); }} [Executor 的中断操作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=executor-的中断操作) 12executorService.shutdown();executorService.shutdownNow(); 若要中断某个线程： 使用submit替代execute 1234Future&lt;?&gt; future = executorService.submit(() -&gt; { // ...});future.cancel(true); [四、互斥同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=四、互斥同步) [synchronized](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=synchronized) [ReentrantLock](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=reentrantlock) [比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=比较) synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能大致相同 ReentrantLock可中断，而synchronized不行。 一个ReentrantLock可以同时绑定多个condition对象。 [使用选择](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=使用选择) 除非使用ReentrantLock的高级功能，否则优先使用synchronized。这是因为synchronized是JVM实现的一种锁机制，JVM原生地支持它，而ReentrantLock不是所有的JDK版本都支持。并且使用synchronized不用担心没有释放锁而导致死锁问题，因为JVM会确保锁的释放。 [五、线程之间的协作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=五、线程之间的协作) [join()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=join) 将当前线程挂起，直到目标线程结束。 [wait() notify() notifyAll()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=wait-notify-notifyall) 它们都是Object的方法 而sleep是Thread的静态方法 [await() signal() signalAll()](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=await-signal-signalall) java.util.concurrent类库提供Condition类库来实现线程间的协调 condition.await() conditon.signal() condition.signalAll() 12345678910111213141516171819202122232425262728293031323334public class AwaitSignalExample { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() { lock.lock(); try { System.out.println(\"before\"); condition.signalAll(); } finally { lock.unlock(); } } public void after() { lock.lock(); try { condition.await(); System.out.println(\"after\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before()); }} [六、线程状态](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=六、线程状态) [新建（NEW）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=新建（new）) [可运行（RUNABLE）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=可运行（runable）) [阻塞（BLOCKED）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=阻塞（blocked）) [无限期等待（WAITING）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=无限期等待（waiting）) [限期等待（TIMED_WAITING）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=限期等待（timed_waiting）) [死亡（TERMINATED）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=死亡（terminated）) [七、J.U.C - AQS](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=七、juc-aqs) [CountDownLatch](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=countdownlatch) 用来控制一个或多个线程等待多个线程 [CyclicBarrier](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=cyclicbarrier) 多个线程互相等待 [Semaphore](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=semaphore) 类似于操作系统的信号量，可以控制对互斥资源的访问线程数。 12345678910111213141516171819202122public class SemaphoreExample { public static void main(String[] args) { final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) { executorService.execute(()-&gt;{ try { semaphore.acquire(); System.out.print(semaphore.availablePermits() + \" \"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }); } executorService.shutdown(); }} [八、J.U.C - 其它组件](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=八、juc-其它组件) [FutureTask](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=futuretask) [BlockingQueue](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=blockingqueue) java.util.concurrent.BlockingQueue接口有以下阻塞队列的实现 FIFO队列： LinkedBlockingQueue ArrayBlockingQueue(固定长度) 优先级队列：PriorityBlockingQueue 提供了阻塞的take put 方法：如果队列为空 take 将阻塞，直到有内容；如果队列为满put将阻塞，直到队列有空闲位置 使用BlockingQueue实现生产者消费者问题 12345678910111213141516171819202122232425262728293031323334353637383940public class ProducerConsumer{ private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread { @Override public void run(){ try{ queue.put(\"product\"); }catch (InterruptedException e){ e.printStackTrace(); } sout(\"produce..\"); } } private static class Consumer extends Thread { @Override public void run(){ try{ String product = queue.take(); } catch (InterruptedException e) { e.printStackTrace(); } sout(\"consume...\"); } } public static void main(Stirng[] args) { for (int i = 0; i &lt; 2; i++) { Producer producer = new Producer(); producer.start(); } for (int i = 0; i &lt; 5; i++) { Consumer consumer = new Consumer(); consumer.start(); } for (int i = 0; i &lt; 3; i++) { Producer producer = new Producer(); producer.start(); } }} 1produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. [ForkJoin](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=forkjoin) ？ [九、线程不安全示例](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=九、线程不安全示例) [十、Java 内存模型](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十、java-内存模型) [主内存与工作内存](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=主内存与工作内存) [内存间交互操作](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=内存间交互操作) [内存模型三大特性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=内存模型三大特性) [1. 原子性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-原子性) [2. 可见性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-可见性) [3. 有序性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-有序性) volatile满足可见性，有序性，不能满足原子性。 synchronized满足三者 [先行发生原则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=先行发生原则) [1. 单一线程原则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-单一线程原则) [2. 管程锁定规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-管程锁定规则) [3. volatile 变量规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-volatile-变量规则) [4. 线程启动规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_4-线程启动规则) [5. 线程加入规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_5-线程加入规则) [6. 线程中断规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_6-线程中断规则) [7. 对象终结规则](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_7-对象终结规则) [8. 传递性](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_8-传递性) [十一、线程安全](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十一、线程安全) [不可变](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=不可变) [互斥同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=互斥同步) [非阻塞同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=非阻塞同步) [1. CAS](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-cas) [2. AtomicInteger](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-atomicinteger) [3. ABA](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-aba) [无同步方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=无同步方案) [1. 栈封闭](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_1-栈封闭) [2. 线程本地存储（Thread Local Storage）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_2-线程本地存储（thread-local-storage）) 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} get() 方法类似。 12345678910111213public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();} - [3. 可重入代码（Reentrant Code）](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=_3-可重入代码（reentrant-code）) [十二、锁优化](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十二、锁优化) [自旋锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=自旋锁) 在jdk1.6中引入了自适应的自旋锁，自适应意味着自选的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 [锁消除](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=锁消除) 锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 [锁粗化](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=锁粗化) 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 锁粗化–把加锁的范围扩展（粗化）到整个操作序列的外部 [轻量级锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=轻量级锁) [偏向锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=偏向锁) [十三、多线程开发良好的实践](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=十三、多线程开发良好的实践) 给线程起个有意义的名字，这样可以方便找bug 缩小同步范围，从而减少锁的争用，例如对于synchronized, 应该尽量使用同步块而不是同步方法。 多用同步工具少用wait notify。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的JDK中 还会不断优化和完善。 使用BlockingQueue实现生产者消费者问题 多用并发集合少用同步集合，例如应该使用ConcurrentHashMap而不是Hashtable. 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 [参考资料](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=参考资料)","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E5%B9%B6%E5%8F%91.html"},{"title":"Java 虚拟机","text":"[toc] [一、运行时数据区域](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=一、运行时数据区域) [pc register](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=程序计数器)记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 [JVM stack](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=java-虚拟机栈)每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K, 而在 JDK 1.5+ 默认为1M: 1java -Xss2M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展是如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 [native method stack–本地方法栈](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=本地方法栈)本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般使用其他语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本地硬件和操作系统的程序，对待这些方法需要特别处理。 [堆](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=堆)所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分带收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava [方法区](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=方法区)用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对累的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 ？ [运行时常量池](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=运行时常量池)运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 除了在编译器生成的变量，还允许动态生成，例如Spring 类的 intern() [直接内存](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=直接内存)在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在堆内存和堆外内存来回拷贝数据。 [二、垃圾收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=二、垃圾收集)垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 [判断一个对象是否可被回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=判断一个对象是否可被回收)[1. 引用计数算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-引用计数算法)为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。 在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对他们进行回收。正是因为循环引用的存在，因此Java虚拟机不使用引用计数算法。 1234567891011121314public class Test { public Object instance = null; public static void main(String[] args) { Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); }} 在上述代码中，a与b引用的对象实例互相持有了对象的引用，因此当我们把对a对象与b对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个Test对象无法被回收。 [2. 可达性分析算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-可达性分析算法)以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 [3. 方法区的回收](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-方法区的回收)因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要至少满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 [4. finalize()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-finalize)类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 [引用类型](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=引用类型)无论是通过引用计数算法判断对象的引用数量，还是用过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 [1. 强引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-强引用)使用 new 一个新对象的方式来创建强引用。 被强引用关联的对象不会被回收。 1Object obj = new Object(); [2. 软引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-软引用)使用 SoftReference 类来创建软引用。 被软引用关联的对象只有在内存不够的情况下才会被回收。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 [3. 弱引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-弱引用)使用 WeakReference 类来创建弱引用。 被弱引用关联的对象一定会被回收，也就是说他只能存活到下一次垃圾回收发生之前。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; [4. 虚引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-虚引用)使用 PhantomReference 来创建虚引用。 虚引用又被称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象创建虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; [垃圾收集算法](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集算法)[1. 标记 - 清除](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-标记-清除) 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会分割为 size 与 (block - size) 两部分，返回 size 大小的分块，并把大小为 block-size 的块返回给空闲链表。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 [2. 标记 - 整理](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-标记-整理) 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 [3. 复制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-复制) 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次整理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10%的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间 分配担保，也就是借用老年代的空间存储放不下的对象。 [4. 分代收集](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-分代收集)现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记-清除算法 或者 标记-整理算法 [垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=垃圾收集器)? 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 是并行的，其他垃圾收集器都是以串行的方式执行。 [1. Serial 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-serial-收集器) 特点：串行 单线程 优点：简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 [2. ParNew 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-parnew-收集器) 它是 Serial 收集器的多线程版本。 特点：多线程 串行 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 [3. Parallel Scavenge 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-parallel-scavenge-收集器)并行 与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 [4. Serial Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-serial-old-收集器) 串行 是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 [5. Parallel Old 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-parallel-old-收集器) 并行 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 [6. CMS 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_6-cms-收集器) CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 [7. G1 收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_7-g1-收集器)G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 将整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 [三、内存分配与回收策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=三、内存分配与回收策略)[Minor GC 和 Full GC](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=minor-gc-和-full-gc) Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 [内存分配策略](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=内存分配策略)[1. 对象优先在 Eden 分配](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-对象优先在-eden-分配)大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 [2. 大对象直接进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-大对象直接进入老年代)大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 [3. 长期存活的对象进入老年代](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-长期存活的对象进入老年代)为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 [4. 动态对象年龄判定](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-动态对象年龄判定)虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 [5. 空间分配担保](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-空间分配担保)在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 [Full GC 的触发条件](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=full-gc-的触发条件)对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： [1. 调用 System.gc()](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-调用-systemgc)只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 [2. 老年代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-老年代空间不足)老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 [3. 空间分配担保失败](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-空间分配担保失败)使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。 [4. JDK 1.7 及以前的永久代空间不足](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-jdk-17-及以前的永久代空间不足)在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 [5. Concurrent Mode Failure](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_5-concurrent-mode-failure)执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 [四、类加载机制](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=四、类加载机制)类是在运行期间第一次使用是动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。 [类的生命周期](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类的生命周期) 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） [类加载过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载过程)包含了加载、验证、准备、解析和初始化这 5 个阶段。 [1. 加载](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-加载)加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 [2. 验证](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-验证)确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 [3. 准备](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-准备)类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; [4. 解析](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-解析)将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 5. 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 () 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” } static int i = 1;} 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent { public static int A = 1; static { A = 2; }}static class Sub extends Parent { public static int B = A;}public static void main(String[] args) { System.out.println(Sub.B); // 2} 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 [类初始化时机](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类初始化时机)[1. 主动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-主动引用)虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； [2. 被动引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-被动引用)以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); [类与类加载器](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类与类加载器)两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 [类加载器分类](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=类加载器分类)从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 [1. 工作过程](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-工作过程)一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。 [2. 好处](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-好处)使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 [3. 实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-实现)以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader { // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); }} [自定义类加载器实现](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=自定义类加载器实现)以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader { private String rootDir; public FileSystemClassLoader(String rootDir) { this.rootDir = rootDir; } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { String path = classNameToPath(className); try { InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; }} JVM的4种垃圾回收算法、垃圾回收机制与总结Java学习分享 垃圾回收算法1.标记清除标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。 在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。 适用场合： 存活对象较多的情况下比较高效 适用于年老代（即旧生代） 缺点： 容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象） 2.复制算法从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉 现在的商业虚拟机都采用这种收集算法来回收新生代。 适用场合： 存活对象较少的情况下比较高效 扫描了整个空间一次（标记存活对象并复制移动） 适用于年轻代（即新生代）：基本上98%的对象是”朝生夕死”的，存活下来的会很少 缺点： 需要一块儿空的内存空间 需要复制移动对象 3.标记整理复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。 这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。 首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 4.分代收集算法分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。 在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。 垃圾回收机制年轻代分为Eden区和survivor区（两块儿：from和to），且Eden:from:to==8:1:1。 jvm内存结构 1）新产生的对象优先分配在Eden区（除非配置了-XX:PretenureSizeThreshold，大于该值的对象会直接进入年老代）； 2）当Eden区满了或放不下了，这时候其中存活的对象会复制到from区。 3）之后产生的对象继续分配在Eden区，当Eden区又满了或放不下了，这时候将会把Eden区和from区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉Eden区和from区的所有内存。 4）如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：-XX:MaxTenuringThreshold来配置），就会进入年老代了。 5）当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）。 垃圾回收有两种类型：Minor GC 和 Full GC。1.Minor GC对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。 2.Full GC也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比MinorGC要慢，因此应该尽可能减少Full GC的次数，导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。 垃圾回收算法总结1.年轻代：复制算法1) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 2)新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，如此往复。 3) 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。 4) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 2.年老代：标记-清除或标记-整理1) 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 2) 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 以上这种年轻代与年老代分别采用不同回收算法的方式称为”分代收集算法”，这也是当下企业使用的一种方式 每一种算法都会有很多不同的垃圾回收器去实现，在实际使用中，根据自己的业务特点做出选择就好。","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA.html"},{"title":"Java 集合","text":"[toc] 集合大家族 - Java 提高篇 - 极客学院Wiki 点击查看图片 ![1Ysxl73BwkfSpvM](https://i.loli.net/2020/01/16/1Ysxl73BwkfSpvM.jpg) 一、Collection 接口Collection 接口是最基本的集合接口 二、List 接口List 接口为 Collection 直接接口。List 所代表的是有序的 Collection实现 List 接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 2.1、ArrayListArrayList 是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括 null。每一个 ArrayList 都有一个初始容量（10）。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。O(1)： size、isEmpty、get、set、iterator 和 listIteratorO(n)： addArrayList 擅长于随机访问。同时 ArrayList 是非同步的。 构造函数ArrayList 提供了三个构造函数：ArrayList()：默认构造函数，提供初始容量为 10 的空列表。ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表 新增add(E e)：将指定的元素添加到此列表的尾部add(int index, E element)：将指定的元素插入此列表中的指定位置。addAll(Collection&lt;? extends E&gt; c)addAll(int index, Collection&lt;? extends E&gt; c)set(int index, E element) 删除remove(int index)、remove(Object o)、removeRange(int fromIndex, int toIndex)、removeAll() 查找get(int index) 扩容ensureCapacity()，该方法就是 ArrayList 的扩容方法当我们清楚知道业务数据量或者需要插入大量元素前，我可以使用 ensureCapacity 来手动增加 ArrayList 实例的容量，以减少递增式再分配的数量 2.2、LinkedListLinkedList 是一个双向链表可以通过较低的代价在 List 中进行插入和删除操作。与 ArrayList 一样，LinkedList 也是非同步的。如果多个线程同时访问一个 List，则必须自己实现访问同步。一种解决方法是在创建 List 时构造一个同步的 List： 1List list = Collections.synchronizedList(new LinkedList(…)); 构造方法LinkedList 提供了两个构造方法：LinkedList() 和 LinkedList(Collection&lt;? extends E&gt; c) 增加方法add(E e)add(int index, E element)addAll(Collection&lt;? extends E&gt; c)addAll(int index, Collection&lt;? extends E&gt; c)addFirst(E e)addLast(E e) 移除方法clear()： 从此列表中移除所有元素。remove()/removeFirst()：获取并移除此列表的第一个元素remove(int index)：移除此列表中指定位置处的元素。remove(Objec o)/removeFirstOccurrence(Object o)：从此列表中移除首次出现的指定元素（如果存在）。removeLast()：移除并返回此列表的最后一个元素。removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 查找方法get(int index)getFirst()getLast()indexOf(Object o)lastIndexOf(Object o) 2.3、Vector与 ArrayList 相似，但是 Vector 是同步的。所以说 Vector 是线程安全的动态数组。它的操作与 ArrayList 几乎一样。 2.4、StackStack 继承自 Vectorpush pop peek empty/isEmpty search 三、Set 接口与 List 一样，它同样允许 null 的存在，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致 e1.equals(e2)==true，则必定会产生某些问题（？）。实现了 Set 接口的集合有：EnumSet、HashSet、TreeSet。 3.1、EnumSet是枚举的专用 Set。所有的元素都是枚举类型。 3.2、HashSetHashSet 堪称查询速度最快的集合，因为其内部是以 HashCode 来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。HashSet 底层使用了 HashMap 实现 3.3、TreeSet基于 TreeMap，生成一个总是处于排序状态的 set，内部以 TreeMap 来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建 Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 四、Map 接口实现 map 的有：HashMap、TreeMap、HashTable、Properties、EnumMap。 4.1、HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个 hash 表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看 HashMap.Entry 的源码它是一个单链表结构。 二、构造函数HashMap 提供了三个构造函数：HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。HashMap(int initialCapacity)HashMap(int initialCapacity, float loadFactor) 三、数据结构table 数组 + 链表HashMap 底层实现还是数组，只是数组的每一项都是一条链。其中参数 initialCapacity 就代表了该数组的长度 4.2、TreeMap键以某种排序规则排序，内部以 red-black（红-黑）树数据结构实现，实现了 SortedMap 接口 4.3、HashTable也是以哈希表数据结构实现的，解决冲突时与 HashMap 也一样也是采用了散列链表的形式，不过性能比 HashMap 要低 五、Queue队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括 ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 六、异同点出处：http://blog.csdn.net/softwave/article/details/4166598 6.1、Vector 和 ArrayList1，vector 是线程同步的，所以它也是线程安全的，而 arraylist 是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用 arraylist 效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector 增长率为目前数组长度的 100%,而 arraylist 增长率为目前数组长度的 50%.如过在集合中使用数据量比较大的数据，用 vector 有一定的优势。3，如果查找一个指定位置的数据，vector 和 arraylist 使用的时间是相同的，都是 0(1),这个时候使用 vector 和 arraylist 都可以。而如果移动一个指定位置的数据花费的时间为 0(n-i)n 为总长度，这个时候就应该考虑到使用 linklist,因为它移动一个指定位置的数据所花费的时间为 0(1),而查询一个指定位置的数据时花费的时间为 0(i)。 6.3、HashMap 与 TreeMap1、HashMap 通过 hashcode 对其内容进行快速查找，而 TreeMap 中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用 TreeMap（HashMap 中元素的排列顺序是不固定的）2、在 Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。使用 HashMap 要求添加的键类明确定义了 hashCode() 和 equals() 的实现。 这个 TreeMap 没有调优选项，因为该树总处于平衡状态。 6.4、hashTable 与 hashMap1、历史原因：Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口的一个实现 。2、同步性：Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的 。但是，通过 Collections 类的 synchronizedMap 方法是可以让 HashMap 线程同步3、 hashMap 允许 key 为 null，hashTable 不行当 HashMap 遇到为 null 的 key 时，它会调用 putForNullKey 方法来进行处理。对于 value 没有进行任何处理，只要是对象都可以。 12if (key == null) return putForNullKey(value); 而当 HashTable 遇到 null 时，他会直接抛出 NullPointerException 异常信息。 123if (value == null) { throw new NullPointerException();} 七、对集合的选择7.1、对 List 的选择1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用 ArrayList2、LinkedList 使用双向链表对元素的增加和删除提供了非常好的支持，而 ArrayList 执行增加和删除元素需要进行元素位移。3、对于 Vector 而已，我们一般都是避免使用。4、将 ArrayList 当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为 List 的频繁插入和删除而降低时，再考虑 LinkedList。 7.2、对 Set 的选择1、HashSet 由于使用 HashCode 实现，所以在某种程度上来说它的性能永远比 TreeSet 要好，尤其是进行增加和查找操作。2、虽然 TreeSet 没有 HashSet 性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。 7.3、对 Map 的选择1、HashMap 与 HashSet 同样，支持快速查询。虽然 HashTable 速度的速度也不慢，但是在 HashMap 面前还是稍微慢了些，所以 HashMap 在查询方面可以取代 HashTable。2、由于 TreeMap 需要维持内部元素的顺序，所以它通常要比 HashMap 和 HashTable 慢。","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%88.html"},{"title":"Java-集合-总结与面试题","text":"[toc] 原文地址 https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484172&amp;idx=1&amp;sn=4e9ea26b6b4b88dd9619c34ea07ba45c&amp;chksm=ebd7420ddca0cb1b798bb6bce3b91216f242e7bc18c2170d26455ea632e4e14b9b250b8d1e8b&amp;scene=21###wechat_redirect 前言 声明，本文用的是 jdk1.8 花了一个星期，把 Java 容器核心的知识过了一遍，感觉集合已经无所畏惧了！！(哈哈哈….)，现在来总结一下吧~~ 回顾目录： Collection 总览 List 集合就这么简单【源码剖析】 Map 集合、散列表、红黑树介绍 HashMap 就是这么简单【源码剖析】 LinkedHashMap 就这么简单【源码剖析】 TreeMap 就这么简单【源码剖析】 ConcurrentHashMap 基于 JDK1.8 源码剖析 Set 集合就这么简单！ Java 容器可分为两大类： Collection List ArrayList LinkedList Vector(了解，已过时) Set TreeSet HashSet LinkedHashSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable(了解，，已过时) 着重标出的那些就是我们用得最多的容器。 一、ArrayList 和 Vector 的区别共同点： 这两个类都实现了 List 接口，它们都是有序的集合 (存储有序)，底层是数组。我们可以按位置索引号取出某个元素，允许元素重复和为 null。 区别： 同步性： ArrayList 是非同步的 Vector 是同步的 即便需要同步的时候，我们可以使用 Collections 工具类来构建出同步的 ArrayList 而不用 Vector 扩容大小： Vector 增长原来的一倍，ArrayList 增长原来的 0.5 倍 二、HashMap 和 Hashtable 的区别共同点： 从存储结构和实现来讲基本上都是相同的，都是实现 Map 接口~ 区别： 同步性： HashMap 是非同步的 Hashtable 是同步的 需要同步的时候，我们往往不使用，而使用 ConcurrentHashMapConcurrentHashMap 基于 JDK1.8 源码剖析 是否允许为 null： HashMap 允许为 null Hashtable 不允许为 null contains 方法 这知识点是在牛客网刷到的，没想到这种题还会有 (我不太喜欢)…. Hashtable 有 contains 方法 HashMap 把 Hashtable 的 contains 方法去掉了，改成了 containsValue 和 containsKey 继承不同： HashMap extends AbstractMap public class Hashtable ​ extends Dictionary 五、Collection 和 Collections 的区别 Collection 是集合的上级接口，继承它的有 Set 和 List 接口 Collections 是集合的工具类，提供了一系列的静态方法对集合的搜索、查找、同步等操作 六、说出 ArrayList,LinkedList 的存储性能和特性ArrayList 的底层是数组，LinkedList 的底层是双向链表。 ArrayList 它支持以角标位置进行索引出对应的元素 (随机访问)，而 LinkedList 则需要遍历整个链表来获取对应的元素。因此一般来说 ArrayList 的访问速度是要比 LinkedList 要快的 ArrayList 由于是数组，对于删除和修改而言消耗是比较大 (复制和移动数组实现)，LinkedList 是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说 LinkedList 的增删速度是要比 ArrayList 要快的 6.1 扩展：ArrayList 的增删未必就是比 LinkedList 要慢。 如果增删都是在末尾来操作【每次调用的都是 remove() 和 add()】，此时 ArrayList 就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。(我测试过) 如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上 (底层调用的是 arraycopy() 方法，是 native 方法)。 LinkedList 的遍历速度是要慢于 ArrayList 的复制移动速度的 如果数据量有百万级的时，还是 ArrayList 要快。(我测试过) 七、Enumeration 和 Iterator 接口的区别这个我在前面的文章中也没有详细去讲它们，只是大概知道的是：Iterator 替代了 Enumeration，Enumeration 是一个旧的迭代器了。 与 Enumeration 相比，Iterator 更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。 我们在做练习的时候，迭代时会不会经常出错，抛出 ConcurrentModificationException 异常，说我们在遍历的时候还在修改元素。 这其实就是 fail-fast 机制~ 具体可参考博文：https://blog.csdn.net/panweiwei1994/article/details/77051261 区别有三点： Iterator 的方法名比 Enumeration 更科学 Iterator 有 fail-fast 机制，比 Enumeration 更安全 Iterator 能够删除元素，Enumeration 并不能删除元素 八、ListIterator 有什么特点 ListIterator 继承了 Iterator 接口，它用于遍历 List 集合的元素。 ListIterator 可以实现双向遍历, 添加元素，设置元素 看一下源码的方法就知道了： 九、并发集合类是什么？Java1.5 并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。 迭代器被设计为 fail-fast 的，会抛出 ConcurrentModificationException。 一部分类为： CopyOnWriteArrayList ConcurrentHashMap CopyOnWriteArraySet 十、Java 中 HashMap 的 key 值要是为类对象则该类需要满足什么条件？需要同时重写该类的 hashCode() 方法和它的 equals() 方法。 从源码可以得知，在插入元素的时候是先算出该对象的 hashCode。如果 hashcode 相等话的。那么表明该对象是存储在同一个位置上的。 如果调用 equals() 方法，两个 key 相同，则替换元素 如果调用 equals() 方法，两个 key 不相同，则说明该 hashCode 仅仅是碰巧相同，此时是散列冲突，将新增的元素放在桶子上 一般来说，我们会认为：只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！因为，Object 底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~ 这也就为什么我们要重写equals()方法 重写了 equals() 方法，就要重写 hashCode() 的方法。因为 equals() 认定了这两个对象相同，而同一个对象调用 hashCode() 方法时，是应该返回相同的值的！ 十一、与 Java 集合框架相关的有哪些最好的实践 根据需要确定集合的类型。如果是单列的集合，我们考虑用 Collection 下的子接口 ArrayList 和 Set。如果是映射，我们就考虑使用 Map~ 确定完我们的集合类型，我们接下来确定使用该集合类型下的哪个子类~ 我认为可以简单分成几个步骤： 去找 Tree 红黑树类型的 (JDK1.8) 去找 Linked 双向列表结构的 去找线程安全的集合类使用 是否需要同步 迭代时是否需要有序 (插入顺序有序) 是否需要排序 (自然顺序或者手动排序) 估算存放集合的数据量有多大，无论是 List 还是 Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗~ 使用泛型，避免在运行时出现 ClassCastException 尽可能使用 Collections 工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性 十二、ArrayList 集合加入 1 万条数据，应该怎么提高效率ArrayList 的默认初始容量为 10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！ 这样就可以提高效率了~","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%88-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{"title":"Java基础-2","text":"[toc] 还在用Synchronized？Atomic你了解不？一、基础铺垫count++并不是原子操作。因为count++需要经过读取-修改-写入三个步骤 1.2 CAScompare and swap旧值 期待的旧值 新值前二者相同，执行赋值否则，自旋（重试）或什么也不做 二、原子变量类简单介绍 可以对其进行分类： * 基本类型： AtomicBoolean：布尔型 AtomicInteger：整型 AtomicLong：长整型 数组： AtomicIntegerArray：数组里的整型 AtomicLongArray：数组里的长整型 AtomicReferenceArray：数组里的引用类型 引用类型： AtomicReference：引用类型 AtomicStampedReference：带有版本号的引用类型 AtomicMarkableReference：带有标记位的引用类型 对象的属性： AtomicIntegerFieldUpdater：对象的属性是整型 AtomicLongFieldUpdater：对象的属性是长整型 AtomicReferenceFieldUpdater：对象的属性是引用类型 JDK8新增DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder 是对AtomicLong等类的改进。比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效。 #### 2.1 原子变量类使用 12345678910class Count{ // 共享变量(使用AtomicInteger来替代Synchronized锁) private AtomicInteger count = new AtomicInteger(0); public Integer getCount() { return count.get(); } public void increase() { count.incrementAndGet(); }} 2.2 ABA问题就是可能出现某线程以为旧值没变，其实变了的情况a -&gt; b -&gt; a2个a并不相同 说明图 ![WuOFTQBhkmiC7Mw](https://i.loli.net/2020/01/13/WuOFTQBhkmiC7Mw.jpg) #### 2.3 解决ABA问题 使用JDK给我们提供的AtomicStampedReference和AtomicMarkableReference类 原理大概就是：维护了一个Pair对象，Pair对象存储我们的对象引用和一个stamp值。每次CAS比较的是两个Pair对象 #### 2.4 LongAdder性能比AtomicLong要好 原因： 使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS会成功，所以其他线程会不断尝试自旋尝试CAS操作，这会浪费不少的CPU资源。 而LongAdder可以概括成这样：内部核心数据value分离成一个数组(Cell)，每个线程访问时,通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。 简单来说就是将一个值分散成多个值，在并发的时候就可以分散压力，性能有所提高。 手把手带你体验Stream流优点代码简洁，支持并行计算例如 12int sum2 = IntStream.of(nums).sum();int sum2 = IntStream.of(nums).parallel().sum(); 使用Stream流分为三步：创建Stream流通过Stream流对象执行中间操作执行最终操作，得到结果 2.1 创建流最常用的就是从集合中创建出流 12345678910111213141516/** * 返回的都是流对象 * @param args */public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 从集合创建 Stream&lt;String&gt; stream = list.stream(); Stream&lt;String&gt; stream1 = list.parallelStream(); // 从数组创建 IntStream stream2 = Arrays.stream(new int[]{2, 3, 5}); // 创建数字流 IntStream intStream = IntStream.of(1, 2, 3); // 使用random创建 IntStream limit = new Random().ints().limit(10);} 2.2 执行中间操作常见的limit - skip其他的：allMatch、anyMatch、noneMatch 返回boolean值findFirst 和 findAny 2.3 执行最终操作常见的 12String str = \"my name is 007\";Stream.of(str.split(\" \")).peek(System.out::println).forEach(System.out::println) reduce的使用sum12List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b); 最大 最小1234// 最大值Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);// 最小值Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::min);","link":"/java/%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80-2.html"},{"title":"Java 集合2","text":"[toc] hashCode对于 hashCode，我们应该遵循如下规则：在一个应用程序执行期间，如果一个对象的 equals 方法做比较所用到的信息没有被修改的话，则对该对象调用 hashCode 方法多次，它必须始终如一地返回同一个整数。如果两个对象根据 equals(Object o) 方法是相等的，则调用这两个对象中任一对象的 hashCode 方法必须产生相同的整数结果。如果两个对象根据 equals(Object o) 方法是不相等的，则调用这两个对象中任一个对象的 hashCode 方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。即：如果 x.equals(y) 返回“true”，那么 x 和 y 的 hashCode() 必须相等。如果 x.equals(y) 返回“false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等。 TreeMap一、红黑树简介红黑树是一颗自平衡的排序二叉树。平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。 对于一棵有效的红黑树二叉树而言我们必须增加如下规则： 1、每个节点都只能是红色或者黑色 2、根节点是黑色 3、每个叶节点（NIL 节点，空节点）是黑色的。 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 下图为一颗典型的红黑二叉树。 对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。 左旋 右旋 1、红黑树系列集锦 2、红黑树数据结构剖析 3、红黑树 二、TreeMap 数据结构TreeMap 中同时也包含了如下几个重要的属性： 123456789101112//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制private final Comparator&lt;? super K&gt; comparator;//TreeMap红-黑节点，为TreeMap的内部类private transient Entry&lt;K,V&gt; root = null;//容器大小private transient int size = 0;//TreeMap修改次数private transient int modCount = 0;//红黑树的节点颜色--红色private static final boolean RED = false;//红黑树的节点颜色--黑色private static final boolean BLACK = true; 对于叶子节点 Entry 是 TreeMap 的内部类，它有几个重要的属性： 123456789101112//键K key;//值V value;//左孩子Entry&lt;K,V&gt; left = null;//右孩子Entry&lt;K,V&gt; right = null;//父亲Entry&lt;K,V&gt; parent;//颜色boolean color = BLACK; 三、TreeMap put() delete() 方法略 TreeSetceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 nullhigher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 nulllower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。 iterator：返回在此 set 中的元素上按升序进行迭代的迭代器descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器descendingSet：返回此 set 中所包含元素的逆序视图 pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 nullpollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。first：返回此 set 中当前第一个（最低）元素last：返回此 set 中当前最后一个（最高）元素 remove size isEmpty Java 集合细节（二）：asList 的缺陷一、避免使用基本数据类型数组转换为列表123456789101112public static void main(String[] args) { Integer[] ints = {1,2,3,4,5}; List list = Arrays.asList(ints); System.out.println(\"list'size：\" + list.size()); System.out.println(\"list.get(0) 的类型:\" + list.get(0).getClass()); System.out.println(\"list.get(0) == ints[0]：\" + list.get(0).equals(ints[0]));}----------------------------------------outPut:list'size：5list.get(0) 的类型:class java.lang.Integerlist.get(0) == ints[0]：true 二、asList 产生的列表不可操作asList 返回的列表只不过是一个披着 list 的外衣，它并没有 list 的基本特性（变长）。该 list 是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。 Java 集合细节（三）：subList 的缺陷一、subList 返回仅仅只是一个视图subList 返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上 二、subList 生成子列表后，不要试图去操作原列表对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表： 123456//通过subList生成一个与list1一样的列表 list3List&lt;Integer&gt; list3 = list1.subList(0, list1.size());//对list1设置为只读状态list1 = Collections.unmodifiableList(list1); 生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常 三、推荐使用 subList 处理局部列表在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在 1000 条记录，我们需要删除 100-200 位置处的数据 1list1.subList(100, 200).clear(); Java 集合细节（四）：保持 compareTo 和 equals 同步Collections.binarySearch(list, student);在 sorted list 中获取指定元素的索引 12345678910111213141516public static void main(String[] args){ List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(\"1\", \"chenssy1\", 24)); list.add(new Student(\"2\", \"chenssy1\", 26)); Collections.sort(list); //排序 Student student = new Student(\"2\", \"chenssy1\", 26); //检索student在list中的位置 int index1 = list.indexOf(student); int index2 = Collections.binarySearch(list, student); System.out.println(\"index1 = \" + index1); System.out.println(\"index2 = \" + index2);} 运行结果： 12index1 = 0index2 = 1 因为 indexOf 和 binarySearch 的实现机制不同indexOf 是基于 equals 来实现的, 只要 equals 返回 TRUE 就认为已经找到了相同的元素。binarySearch 是基于 compareTo 方法的，当 compareTo 返回 0 时就认为已经找到了该元素。在我们实现的 Student 类中我们覆写了 compareTo 和 equals 方法，但是我们的 compareTo、equals 的比较依据不同，一个是基于 age、一个是基于 name。比较依据不同那么得到的结果很有可能会不同。所以知道了原因，我们就好修改了：将两者之间的比较依据保持一致即可。 对于 compareTo 和 equals 两个方法我们可以总结为：compareTo 是判断元素在排序中的位置是否相等，equals 是判断元素是否相等，既然一个决定排序位置，一个决定相等，所以我们非常有必要确保当排序位置相同时，其 equals 也应该相等。 Iterator - Java 提高篇 - 极客学院Wiki若不使用iterator, 每一种集合对应一种遍历方法，客户端代码无法复用对于数组我们是使用下标来进行处理的: 12345int[] arrays = new int[10];for(int i = 0 ; i &lt; arrays.length ; i++){ int a = arrays[i]; //do something} 对于 ArrayList 是这么处理的: 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;();for(int i = 0 ; i &lt; list.size() ; i++){ String string = list.get(i); //do something} Iterator 模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由 Iterator 来维护。客户端从不直接和集合类打交道，它总是控制 Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。 12345Iterator iterator = list.iterator();while(iterator.hasNext()){ String string = iterator.next(); //do something} fail-fast 机制 - Java 提高篇 - 极客学院Wikifail-fast，它是 Java 集合的一种错误检测机制比如，若一个线程在遍历ArrayList, 另一个线程修改了ArrayList, 此时遍历的线程会触发fail-fast机制，抛出ConcurrentModificationException异常。 ArrayList 中无论 add、remove、clear 方法只要是涉及了改变 ArrayList 元素的个数的方法都会导致 modCount 的改变。ArrayList的迭代器在调用 next()、remove() 方法时都是调用 checkForComodification() 方法，该方法主要就是检测 modCount == expectedModCount 。 若不等则抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 两种解决方案：方案一：在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。方案二：使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。CopyOnWriteArrayList 为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用 CopyOnWriteArrayList 来替代 ArrayList 再适合不过了。","link":"/java/%E5%9F%BA%E7%A1%80/Java-%E9%9B%86%E5%90%882.html"},{"title":"Java提高篇","text":"[toc] 理解 Java 的三大特性之封装用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象（如 setter getter）封装可以使容易地修改类的内部实现，而无需修改使用了该类的客户代码封装里面也可以写一些逻辑判断 理解 Java 的三大特性之继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。继承所描述的是“is-a”的关系子类拥有父类非 private 的属性和方法。 构造器于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用 super() 即可。子类默认调用父类的默认构造器，如果父类没有默认的构造器，子类的构造方法的第一句必须调用父类的构造器 谨慎继承继承存在如下缺陷：1、父类变，子类就必须变。2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。3、继承是一种强耦合关系。《Think in Java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。 理解 Java 的三大特性之多态子类向上转型为父类，调用子类重写的方法。 Java 的四舍五入12.5 的四舍五入值：13-12.5 的四舍五入值：-12 12345678910// 方法一double f = 111231.5585;BigDecimal b = new BigDecimal(f);double f1 = b.setScale(2, RoundingMode.HALF_UP).doubleValue();// 方法二java.text.DecimalFormat df =new java.text.DecimalFormat(”#.00″);df.format(3.1415926);// 方法三double d = 3.1415926;String result = String.format(”%.2f”); 抽象类与接口抽象类1、抽象类不能被实例化2、子类必须重写抽象方法3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类4、抽象类中可以包含具体的方法，也可以不包含抽象方法。5、子类中的抽象方法不能与父类的抽象方法同名。6、abstract 不能与 final 并列修饰同一个类。7、abstract 不能与 private、static、final 或 native 并列修饰同一个方法 接口1、方法默认是 public2、成员变量默认是 public static final 二者的差别主要体现在：抽象层次不同。抽象类是对整个类的抽象，接口仅仅对行为抽象 使用序列化实现对象的拷贝1234567891011121314151617181920212223public class CloneUtils { @SuppressWarnings(\"unchecked\") public static &lt;T extends Serializable&gt; T clone(T obj){ T cloneObj = null; try { //写入字节流 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream obs = new ObjectOutputStream(out); obs.writeObject(obj); obs.close(); //分配内存，写入原始对象，生成新对象 ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ios); //返回生成的新对象 cloneObj = (T) ois.readObject(); ois.close(); } catch (Exception e) { e.printStackTrace(); } return cloneObj; } } 使用该工具类的对象必须要实现 Serializable 接口实现 Serializable 接口的必须显示地声明 serialVersionUID 字段 12345678910111213public class Person implements Serializable{ private static final long serialVersionUID = 2631590509760908280L; .................. //去除clone()方法}public class Email implements Serializable{ private static final long serialVersionUID = 1267293988171991494L; ....................} 使用 123456Person person1 = new Person(\"张三\",email);Person person2 = CloneUtils.clone(person1);person2.setName(\"李四\");Person person3 = CloneUtils.clone(person1);person3.setName(\"王五\");person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\"); 关键字 static 静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 static 修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以 static 方法必须实现，也就是说他不能是抽象方法 abstract。 被 static 修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。 局限1、它只能调用 static 变量。2、它只能调用 static 方法。3、不能以任何形式引用 this、super。4、static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。 详解内部类特点使用内部类最大的优点就在于它能够非常好的解决多重继承的问题内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。创建内部类对象的时刻并不依赖于外围类对象的创建。内部类提供了更好的封装，除了该外围类，其他类都不能访问。 成员内部类在成员内部类中要注意两点第一：成员内部类中不能存在任何 static 的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 点击查看代码 1234public class OuterClass { public void display(){ System.out.println(\"OuterClass...\"); } public class InnerClass{ public OuterClass getOuterClass(){ return OuterClass.this; } } public static void main(String[] args) { OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display();} 12345## }Output:OuterClass... OuterClassName.this，这样就能够产生一个正确引用外部类的引用了 局部内部类有这样一种内部类，它是嵌套在方法和作用域内的定义在方法里： 点击查看代码 12345678910111213141516171819public class Parcel5 { public Destionation destionation(String str){ class PDestionation implements Destionation{ private String label; private PDestionation(String whereTo){ label = whereTo; } public String readLabel(){ return label; } } return new PDestionation(str); } public static void main(String[] args) { Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(\"chenssy\"); }} 定义在作用域内： 点击查看代码 12345678910111213141516public class Parcel6 { private void internalTracking(boolean b){ if(b){ class TrackingSlip{ private String id; TrackingSlip(String s) { id = s; } String getSlip(){ return id; } } TrackingSlip ts = new TrackingSlip(\"chenssy\"); String string = ts.getSlip(); } } public void track(){ internalTracking(true); } public static void main(String[] args) { Parcel6 parcel6 = new Parcel6(); parcel6.track();} 12} 匿名内部类 点击查看代码 1234567891011121314151617181920212223public class OuterClass { public InnerClass getInnerClass(final int num,String str2){ return new InnerClass(){ int number = num + 3; public int getNumber(){ return number; } }; /* 注意：分号不能省 */ } public static void main(String[] args) { OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, \"chenssy\"); System.out.println(inner.getNumber()); }}interface InnerClass { int getNumber();}----------------Output:5 new 匿名内部类，这个类首先是要存在的。如果我们将那个 InnerClass 接口注释掉，就会出现编译出错。注意 getInnerClass() 方法的形参，第一个形参是用 final 修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为 final。匿名内部类是没有构造方法的 静态内部类1、它的创建是不需要依赖于外围类的。2、它不能使用任何外围类的非 static 成员变量和方法。 点击查看代码 123public class OuterClass { private String sex; public static String name = \"chenssy\"; /** *静态内部类 */ static class InnerClass1{ /* 在静态内部类中可以存在静态成员 */ public static String _name1 = \"chenssy_static\"; public void display(){ /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println(&quot;OutClass name :&quot; + name); }} /** 非静态内部类 /class InnerClass2{ /* 非静态内部类中不能存在静态成员 / public String _name2 = “chenssy_inner”; / 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display(){System.out.println(&quot;OuterClass name：&quot; + name); }} /** @desc 外围类方法 @author chenssy @data 2013-10-25 @return void /public void display(){ /* 外围类访问静态内部类：内部类. / System.out.println(InnerClass1._name1); / 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 / OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); / 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display();} public static void main(String[] args) { OuterClass outer = new OuterClass(); outer.display();} 12345678## }Output:chenssy_staticOutClass name :chenssychenssy_innerOuterClass name：chenssy","link":"/java/%E5%9F%BA%E7%A1%80/Java%E6%8F%90%E9%AB%98%E7%AF%87.html"},{"title":"Java基础","text":"Java 基础 [toc] 2018 年如何快速学 Java学习 JavaWeb 的路线如下：Tomcat(简单过一下)XML/注解(简单过一下)Servlet(重点理解)HTTP 协议(重点理解)Filter 过滤器(重点理解)Listener 监听器(简单过一下)JSP(简单过一下)AJAX、JSON(简单过一下) 泛型就这么简单为什么需要泛型 首先，我们来试想一下：没有泛型，集合会怎么样Collection、Map 集合对元素的类型是没有任何限制的。本来我的 Collection 集合装载的是全部的 Dog 对象，但是外边把 Cat 对象存储到集合中，是没有任何语法错误的。把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是 Object。因此在 get()的时候，返回的是 Object。外边获取该对象，还需要强制转换有了泛型以后：代码更加简洁【不用强制转换】程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现 ClassCastException 异常】可读性和稳定性【在编写集合的时候，就限定了类型】 3.1 泛型类1234567891011public class ObjectTool&lt;T&gt; { private T obj; public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; }} 3.2 泛型方法1234567891011121314151617//定义泛型方法..public &lt;T&gt; void show(T t) { System.out.println(t);}// 使用// 用户传递进来的是什么类型，返回值就是什么类型了public static void main(String[] args) { //创建对象 ObjectTool tool = new ObjectTool(); //调用方法,传入的参数是什么类型,返回值就是什么类型 tool.show(\"hello\"); tool.show(12); tool.show(12.5);} 3.4 类型通配符有个需求：方法接收一个集合参数，遍历集合并把集合元素打印出来 123456789101112// 1. 未指定类型// public void test(List list){// 2. 只能接收装着object的list// public void test(List&lt;Object&gt; list){// 3. ? 表示任意类型public void test(List&lt;?&gt; list){ for(int i=0;i&lt;list.size();i++){ System.out.println(list.get(i)); }} 注意： 使用？时，只能调用与类型无关的方法 3.4.1 类型通配符的上限需求：接收一个 List 集合，它只能操作数字类型的元素【Float、Integer、Double、Byte 等数字类型都行】，怎么做？？？设定通配符上限List&lt;? extends Number&gt; 123public static void test(List&lt;? extends Number&gt; list) {} 3.4.2 类型通配符的上限//传递进来的只能是 Type 或 Type 的父类 1&lt;? super Type&gt; 3.5 通配符和泛型方法通配符 和 泛型方法 实现的功能很接近，怎么选择？原则：通配符要求参数之间没有依赖关系 四、泛型的应用baseDAO 点击查看代码 1public abstract class BaseDao&lt;T&gt; { //模拟hibernate.... private Session session; private Class clazz; //哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要）public BaseDao(){ Class clazz = this.getClass(); //拿到的是子类 ParameterizedType pt = (ParameterizedType) clazz.getGenericSuperclass(); //BaseDao clazz = (Class) pt.getActualTypeArguments()[0]; System.out.println(clazz);}public void add(T t){ session.save(t);}public T find(String id){ return (T) session.get(clazz, id);}public void update(T t){ session.update(t);}public void delete(String id){ T t = (T) session.get(clazz, id); session.delete(t);} 12} CategoryDao 12public class CategoryDao extends BaseDao&lt;Category&gt; {} BookDao 12public class BookDao extends BaseDao&lt;Book&gt; {} 注解就这么简单二、为什么我们需要用到注解？注解可以给类、方法上注入信息 三、基本 Annotationjava.lang 包下存在着 5 个基本的 Annotation 3.1@Overridemailto:3.1@Override重写 3.2@Deprecatedmailto:3.2@Deprecated过时在程序中调用它的时候，在 IDE 上会出现一条横杠，说明该方法是过时的 3.3@SuppressWarningsmailto:3.3@SuppressWarnings抑制编译器警告 3.4@SafeVarargsmailto:3.4@SafeVarargsJava 7“堆污染”警告 ？什么是堆污染呢？？当把一个不是泛型的集合赋值给一个带泛型的集合的时候，这种情况就很容易发生堆污染…. 3.5@FunctionalInterfacemailto:3.5@FunctionalInterface@FunctionalInterface 用来指定该接口是函数式接口 四、自定义注解基础4.1 标记 Annotation没有任何成员变量的注解：标记注解。如@Overrided 12public @interface MyAnnotation{} 4.2 元数据 Annotation带有成员变量的注解：元数据 annotation。注解中声明成员变量类似于声明方法 1234public @interface MyAnnotation{ String username(); int age();} 注意：在注解上定义的成员变量只能是 String、数组、Class、枚举类、注解 4.3 使用自定义注解4.3.1 常规使用有一个 add 的方法，需要 username 和 age 参数，我们通过注解来让该方法拥有这两个变量 1234@MyAnnotation(username=\"Adam\", age=16)public void add(String username, int age){} 4.3.2 默认值注解可以声明默认值 1234public @Interface MyAnnotation{ String username() default \"abc\"; int age() default 11;} 修饰的时候就不用给出具体的值 123@MyAnnotation()public void add(String username, int age){} 4.3.3 注解属性为 value若注解中只有一个属性 value，则可以不指定 value，直接赋值 123@MyAnnotation(\"abd\")public void add(String value){} 4.4 把自定义注解的基本信息注入到方法上? 五、JDK 的元 Annotation5.1@Retentionmailto:5.1@Retention只能用于修饰其他的 Annotation, 用于指定被修饰的 Annotation 被保留多长时间。?5.2@Targetmailto:5.2@Target只能用于修饰其他的 Annotation, 用于指定被修饰的 Annotation 用于修饰哪些程序单元5.3@Documentedmailto:5.3@Documented@Documented 用于指定被该 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。5.4@Inheritedmailto:5.4@Inherited@Inherited 也是用来修饰其他的 Annotation 的，被修饰过的 Annotation 将具有继承性。。。 六、注入对象到方法或成员变量上6.1 把对象注入到方法上?6.2 把对象注入到成员变量? Object 对象你真理解了吗？一、Object 对象简介主要有一下方法registerNatives()【底层实现、不研究】hashCode()equals(Object obj)clone()toString()notify()notifyAll()wait(long timeout)【还有重载了两个】finalize() 二、equals 和 hashCode 方法重写 equals()方法，就必须重写 hashCode()的方法？equals()方法默认是比较对象的地址，使用的是 == 等值运算符hashCode()方法对底层是散列表的对象有提升性能的功能同一个对象(如果该对象没有被修改)：那么重复调用 hashCode()那么返回的 int 是相同的！hashCode()方法默认是由对象的地址转换而来的 2.1 equals 和 hashCode 方法重写一般来说，比较的是对象地址是没有意义的 2.2 String 实现的 equals 和 hashCode 方法String 已经实现了 equals 和 hashCode 方法了，可以直接使用 String.equals()来判断两个字符串是否相等！ 三、toString 方法四、clone 方法4.1 clone 用法如何克隆对象呢？无论是浅拷贝还是深拷贝都是这两步：1.克隆的对象要实现 Cloneable 接口2.重写 clone 方法，最好修饰成 public 1.浅拷贝12345678public class Person implements Cloneable{ private Date date; @Override public Object clone() throws ClonNotSupportedException { return super.clone(); }} 2.深拷贝12345678910public class Person implements Cloneable{ private Date date; @Override public Object clone() throws CloneNotSupportedException { Person person = (Person)super.clone(); person.date = (Date)date.clone(); return person; }} 五、wait 和 notify 方法无论是 wait、notify 还是 notifyAll()都需要由监听器对象(锁对象)来进行调用简单来说：他们都是在同步代码块中调用的，否则会抛出异常！notify()唤醒的是在等待队列的某个线程(不确定会唤醒哪个)，notifyAll()唤醒的是等待队列所有线程 导致 wait()的线程被唤醒可以有 4 种情况该线程被中断wait()时间到了被 notify()唤醒被 notifyAll()唤醒 调用 wait()的线程会释放掉锁 5.1 为什么 wait 和 notify 在 Object 方法上？锁对象是任意的，所以这些方法必须定义在 Object 类中 5.2 notify 方法调用后，会发生什么？5.3 sleep 和 wait 有什么区别？主要的区别在于 Object.wait()在释放 CPU 同时，释放了对象锁的控制。而 Thread.sleep()没有对锁释放 六、finalize()方法finalize()方法将在垃圾回收器清除对象之前调用，但该方法不知道何时调用，具有不定性。一般我们都不会重写它~一个对象的 finalize()方法只会被调用一次 JDK10都发布了，nio你了解多少？前言Java IO，硬骨头也能变软 - 知乎按操作方式分类结构图：按操作对象分类结构图 二、NIO 快速入门3 个核心部分buffer channel selector 2.1buffer 缓冲区和 Channel 管道Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区Channel–&gt; 运输Buffer–&gt; 数据相对于传统 IO 而言，流是单向的 2.1.1buffer 缓冲区核心要点Buffer 是抽象类ByteBuffer 是使用最多的实现类核心方法：put getBuffer 类有 4 个核心属性Capacity 容量缓冲区能够容纳的数据元素的最大数量Limit 上界缓冲区数据总数Position 位置下一个读写的位置Mark 标记记录上一次读写的位置 2.1.2buffer 代码演示1234567891011121314151617181920212223public static void main(String[] args) { // 创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 看一下初始时4个核心变量的值 System.out.println(\"初始时--&gt;limit---&gt;\"+byteBuffer.limit()); System.out.println(\"初始时--&gt;position---&gt;\"+byteBuffer.position()); System.out.println(\"初始时--&gt;capacity---&gt;\"+byteBuffer.capacity()); System.out.println(\"初始时--&gt;mark---&gt;\" + byteBuffer.mark()); System.out.println(\"--------------------------------------\"); // 添加一些数据到缓冲区中 String s = \"Java3y\"; byteBuffer.put(s.getBytes()); // 看一下初始时4个核心变量的值 System.out.println(\"put完之后--&gt;limit---&gt;\"+byteBuffer.limit()); System.out.println(\"put完之后--&gt;position---&gt;\"+byteBuffer.position()); System.out.println(\"put完之后--&gt;capacity---&gt;\"+byteBuffer.capacity()); System.out.println(\"put完之后--&gt;mark---&gt;\" + byteBuffer.mark()); } flip() 后，写模式转换为读模式clear() 后，读模式转换为写模式 2.1.3FileChannel 通道核心要点Channel 通道只负责传输数据、不直接操作数据的获取 channel 12345678// 1. 通过本地IO的方式来获取通道 FileInputStream fileInputStream = new FileInputStream(\"F:\\\\3yBlog\\\\JavaEE常用框架\\\\Elasticsearch就是这么简单.md\"); // 得到文件的输入通道 FileChannel inchannel = fileInputStream.getChannel(); // 2. jdk1.7后通过静态方法.open()获取通道 FileChannel.open(Paths.get(\"F:\\\\3yBlog\\\\JavaEE常用框架\\\\Elasticsearch就是这么简单2.md\"), StandardOpenOption.WRITE); channel 与 buffer 使用示例 2.1.4 直接与非直接缓冲区？ 2.1.5scatter 和 gather、字符集分散读取(scatter)：将一个通道中的数据分散读取到多个缓冲区中聚集写入(gather)：将多个缓冲区中的数据集中写入到一个通道中scatter gather 代码见原文 三、IO 模型理解3.0 学习 I/O 模型需要的基础3.1 阻塞 I/O 模型3.2 非阻塞 I/O 模型3.3I/O 复用模型3.4I/O 模型总结 四、使用 NIO 完成网络通信4.1NIO 基础继续讲解NIO 被叫为 no-blocking io，其实是在网络这个层次中理解的，对于 FileChannel 来说一样是阻塞。通常使用 NIO 是在网络中使用的，网上大部分讨论 NIO 都是在网络通信的基础之上的！说 NIO 是非阻塞的 NIO 也是网络中体现的 在网络中使用 NIO 往往是 I/O 模型的多路复用模型！Selector 选择器就可以比喻成麦当劳的广播。通过 selector，一个线程能够管理多个 Channel 的状态 4.2NIO 阻塞形态4.3NIO 非阻塞形态在客户端上要想获取得到服务端的数据，也需要注册在 register 上(监听读事件) 点击查看代码 1public class NoBlockClient2 { public static void main(String[] args) throws IOException { // 1. 获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666)); // 1.1切换成非阻塞模式 socketChannel.configureBlocking(false); // 1.2获取选择器 Selector selector = Selector.open(); // 1.3将通道注册到选择器中，获取服务端返回的数据 socketChannel.register(selector, SelectionKey.OP_READ); // 2. 发送一张图片给服务端吧 FileChannel fileChannel = FileChannel.open(Paths.get(&quot;X:\\\\Users\\\\ozc\\\\Desktop\\\\新建文件夹\\\\1.png&quot;), StandardOpenOption.READ); // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢 ByteBuffer buffer = ByteBuffer.allocate(1024); // 4.读取本地文件(图片)，发送到服务器 while (fileChannel.read(buffer) != -1) { // 在读之前都要切换成读模式 buffer.flip(); socketChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); } // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) { // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) { SelectionKey selectionKey = iterator.next(); // 8. 读事件就绪 if (selectionKey.isReadable()) { // 8.1得到对应的通道 SocketChannel channel = (SocketChannel) selectionKey.channel(); ByteBuffer responseBuffer = ByteBuffer.allocate(1024); // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收 int readBytes = channel.read(responseBuffer); if (readBytes &gt; 0) { // 切换读模式 responseBuffer.flip(); System.out.println(new String(responseBuffer.array(), 0, readBytes)); } } // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); } }} 12} 服务端 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class NoBlockServer { public static void main(String[] args) throws IOException { // 1.获取通道 ServerSocketChannel server = ServerSocketChannel.open(); // 2.切换成非阻塞模式 server.configureBlocking(false); // 3. 绑定连接 server.bind(new InetSocketAddress(6666)); // 4. 获取选择器 Selector selector = Selector.open(); // 4.1将通道注册到选择器上，指定接收“监听通道”事件 server.register(selector, SelectionKey.OP_ACCEPT); // 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪 while (selector.select() &gt; 0) { // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 7. 获取已“就绪”的事件，(不同的事件做不同的事) while (iterator.hasNext()) { SelectionKey selectionKey = iterator.next(); // 接收事件就绪 if (selectionKey.isAcceptable()) { // 8. 获取客户端的链接 SocketChannel client = server.accept(); // 8.1 切换成非阻塞状态 client.configureBlocking(false); // 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件) client.register(selector, SelectionKey.OP_READ); } else if (selectionKey.isReadable()) { // 读事件就绪 // 9. 获取当前选择器读就绪状态的通道 SocketChannel client = (SocketChannel) selectionKey.channel(); // 9.1读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建) FileChannel outChannel = FileChannel.open(Paths.get(\"2.png\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); while (client.read(buffer) &gt; 0) { // 在读之前都要切换成读模式 buffer.flip(); outChannel.write(buffer); // 读完切换成写模式，能让管道继续读取文件的数据 buffer.clear(); } } // 10. 取消选择键(已经处理过的事件，就应该取消掉了) iterator.remove(); } } }} 4.4 管道和 DataGramChannelCOW 奶牛！Copy On Write 机制了解一下一、Linux 下的 copy-on-write1.1 简单来用用 forkfork 用于创建子进程 1.2 再来看看 exec()函数exec 函数的作用就是：装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务 1.3 回头来看 Linux 下的 COW 是怎么一回事二、解释一下 Redis 的 COW三、文件系统的 COW？ 给女朋友讲解什么是 Optional【JDK 8 特性】一、基础铺垫1.1Lambda 简化代码例子创建线程：123456789101112public static void main(String[] args) { // 用匿名内部类的方式来创建线程 new Thread(new Runnable() { @Override public void run() { System.out.println(\"公众号：Java3y---回复1进群交流\"); } }); // 使用Lambda来创建线程 new Thread(() -&gt; System.out.println(\"公众号：Java3y---回复1进群交流\"));} 遍历 Map 集合：12345678910111213public static void main(String[] args) { Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(\"公众号\", \"Java3y\"); hashMap.put(\"交流群\", \"回复1\"); // 使用增强for的方式来遍历hashMap for (Map.Entry&lt;String, String&gt; entry : hashMap.entrySet()) { System.out.println(entry.getKey()+\":\"+entry.getValue()); } // 使用Lambda表达式的方式来遍历hashMap hashMap.forEach((s, s2) -&gt; System.out.println(s + \":\" + s2));} 在 List 中删除某个元素12345678910111213141516171819202122public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"Java3y\"); list.add(\"3y\"); list.add(\"光头\"); list.add(\"帅哥\"); // 传统的方式删除\"光头\"的元素 ListIterator&lt;String&gt; iterator = list.listIterator(); while (iterator.hasNext()) { if (\"光头\".equals(iterator.next())) { iterator.remove(); } } // Lambda方式删除\"光头\"的元素 list.removeIf(s -&gt; \"光头\".equals(s)); // 使用Lambda遍历List集合 list.forEach(s -&gt; System.out.println(s));} 1.1 函数式接口函数式接口的特点：有@FunctionalInterface 注解，接口有且仅有一个抽象方法！如 1234@FunctionalInterfacepublic interface Runnable { public abstract void run();} 二、Optional 类2.1 创建 Optional 容器创建 Optional 容器有两种方式：调用 ofNullable()方法，传入的对象可以为 null调用 of()方法，传入的对象不可以为 null，否则抛出 NullPointerException 2.2Optional 容器简单的方法1234567891011121314151617// 得到容器中的对象，如果为null就抛出异常public T get() { if (value == null) { throw new NoSuchElementException(\"No value present\"); } return value;}// 判断容器中的对象是否为nullpublic boolean isPresent() { return value != null;}// 如果容器中的对象存在，则返回。否则返回传递进来的参数public T orElse(T other) { return value != null ? value : other;} 2.3O ptional 容器进阶用法2.3.1 ifPresent 方法123456789public void ifPresent(Consumer&lt;? super T&gt; consumer) { if (value != null) consumer.accept(value);}@FunctionalInterfacepublic interface Consumer&lt;T&gt; { void accept(T t);} 用法 123456789101112131415public static void main(String[] args) { User user = new User(); user.setName(\"Java3y\"); test(user);}public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果存在user，则打印user的name optional.ifPresent((value) -&gt; System.out.println(value.getName())); // 旧写法 if (user != null) { System.out.println(user.getName()); }} 2.3.2 orElseGet 和 orElseThrow 方法123456789101112131415public static void main(String[] args) { User user = new User(); user.setName(\"Java3y\"); test(user);}public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果存在user，则直接返回，否则创建出一个新的User对象 User user1 = optional.orElseGet(() -&gt; new User()); // 旧写法 if (user != null) { user = new User(); }} 2.3.3 filter 方法12345public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果容器中的对象存在，并且符合过滤条件，返回装载对象的Optional容器，否则返回一个空的Optional容器 optional.filter((value) -&gt; \"Java3y\".equals(value.getName()));} 2.3.4 map 方法12345678910111213public static void test(User user) { Optional&lt;User&gt; optional = Optional.ofNullable(user); // 如果容器的对象存在，则对其执行调用mapping函数得到返回值。然后创建包含mapping返回值的Optional，否则返回空Optional。 optional.map(user1 -&gt; user1.getName()).orElse(\"Unknown\");}// 上面一句代码对应着最开始的老写法：public String tradition(User user) { if (user != null) { return user.getName(); }else{ return \"Unknown\"; }} 2.3.5 flatMap 方法2.3.6 总结 点击查看代码 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) { User user = new User(); user.setName(\"Java3y\"); System.out.println(test(user));}// 以前的代码 v1public static String test2(User user) {if (user != null) {String name = user.getName();if (name != null) {return name.toUpperCase();} else {return null;}} else {return null;}}// 以前的代码 v2public static String test3(User user) {if (user != null &amp;&amp; user.getName() != null) {return user.getName().toUpperCase();} else {return null;}}// 现在的代码public static String test(User user) {return Optional.ofNullable(user).map(user1 -&gt; user1.getName()).map(s -&gt; s.toUpperCase()).orElse(null);}","link":"/java/%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80.html"},{"title":"bio nio","text":"bio nio JavaGuide/BIO-NIO-AIO.md at master · Snailclimb/JavaGuide同步 异步？阻塞 非阻塞？ bioblocking IOsocket 和 serverSocketsocket.read() socket.accept() socket.write() 都是同步阻塞的服务端为一个客户端建立一个线程改进：线程池实现伪异步IO nionew IO可以理解为non-blocking IO实现了socketChannel serverSocketChannel nio与bio的区别：阻塞与非阻塞3个主要组件：buffer channel selectorbufferchannelchannel是双向的，而bio中的流是单向的 selector单个线程使用selector选择多个channel，已实现减少线程开销的目的 JDK自带的nio很难用，netty是一个很好地替代","link":"/java/%E5%9F%BA%E7%A1%80/bio-nio.html"},{"title":"Java提高篇2","text":"[toc] 详解匿名内部类1、匿名内部类中不能存在任何的静态成员变量和静态方法2、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法3、当所在的方法的形参需要被内部类里面使用时，该形参必须为 final4、我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。 1234567891011121314151617181920212223242526272829303132public class OutClass { public InnerClass getInnerClass(final int age,final String name){ return new InnerClass() { int age_ ; String name_; //构造代码块完成初始化工作 { if(0 &lt; age &amp;&amp; age &lt; 200){ age_ = age; name_ = name; } } public String getName() { return name_; } public int getAge() { return age_; } }; } public static void main(String[] args) { OutClass out = new OutClass(); InnerClass inner_1 = out.getInnerClass(201, \"chenssy\"); System.out.println(inner_1.getName()); InnerClass inner_2 = out.getInnerClass(23, \"chenssy\"); System.out.println(inner_2.getName()); }} 代码块静态代码块主要目的就是对静态属性进行初始化 12345public class Test { static{ System.out.println(\"静态代码块\"); }} 构造代码块12345public class Test { { System.out.println(\"执行构造代码块...\"); }} 静态代码块、构造代码块、构造函数执行顺序1、静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。2、构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。3、构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。 equals() 方法总结数组域 : 使用 Arrays.equals在 equals() 中使用 getClass 进行类型判断我们在覆写 equals() 方法时，一般都是推荐使用 getClass 来进行类型判断，不是使用 instanceof 异常(二) - Java 提高篇 - 极客学院Wiki结论一：尽可能的减小 try 块结论二：保证所有资源都被正确释放。充分运用 finally 关键词。结论三：catch 语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的 Exception 类。 不要一个 Exception 试图处理所有可能出现的异常。结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。 1234567public void test() throws XxxException{ try { //do something:可能抛出异常信息的代码块 } catch (Exception e) { throw new XxxException(e); }} 详解 Java 定时任务一、简介Timer 是一种定时器工具，用来在一个后台线程计划执行指定任务，而 TimerTask 一个抽象类，它的子类代表一个可以被 Timer 计划的任务 Timer 类Timer 类可以保证多个线程可以共享单个 Timer 对象而无需进行外部同步，所以 Timer 类是线程安全的 Timer 提供了 schedule 方法，该方法有多中重载方式来适应不同的情况，如下：schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务schedule(TimerTask task, Date firstTime, long period) ：安排指定的任务在指定的时间开始进行重复的固定延迟执行schedule(TimerTask task, long delay) ：安排在指定延迟后执行指定的任务。schedule(TimerTask task, long delay, long period) ：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。 scheduleAtFixedRate(TimerTask task, Date firstTime, long period)：安排指定的任务在指定的时间开始进行重复的固定速率执行。scheduleAtFixedRate(TimerTask task, long delay, long period)：安排指定的任务在指定的延迟后开始进行重复的固定速率执行。 [scheduleWithFixedDelay 和 scheduleAtFixedRate 的区别 - 简书](https://www.jianshu.com/p/2bed76de59a9) ScheduledExecutorService#scheduleAtFixedRate() 指的是“以固定的频率”执行，period（周期）指的是两次成功执行之间的时间 比如，scheduleAtFixedRate(command, 5, 2, second)，第一次开始执行是5s后，假如执行耗时1s，那么下次开始执行是7s后，再下次开始执行是9s后 而 ScheduledExecutorService#scheduleWithFixedDelay() 指的是“以固定的延时”执行，delay（延时）指的是一次执行终止和下一次执行开始之间的延迟scheduleWithFixedDelay(command, 5, 2, second)，第一次开始执行是 5s 后，假如执行耗时 1s，执行完成时间是 6s 后，那么下次开始执行是 8s 后，再下次开始执行是 11s 后 TimerTaskTimerTask 类是一个抽象类，有一个抽象方法 run() 方法还有两个非抽象的方法：boolean cancel()：取消此计时器任务。long scheduledExecutionTime()：返回此任务最近实际执行的安排执行时间 分析 schedule 和 scheduleAtFixedRateschedule 方法侧重保存间隔时间的稳定，而 scheduleAtFixedRate 方法更加侧重于保持执行频率的稳定 三、Timer 的缺陷3.1、Timer 的缺陷如果 TimerTask 抛出未检查的异常，Timer 将会停止整个线程 对于 Timer 的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer 是基于绝对时间的，对系统时间比较敏感，而 ScheduledThreadPoolExecutor 则是基于相对时间；Timer 是内部是单一线程，而 ScheduledThreadPoolExecutor 内部是个线程池，所以可以支持多个任务并发执行。 3.2、用 ScheduledExecutorService 替代 Timer对于 Timer 的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer 是基于绝对时间的，对系统时间比较敏感，而 ScheduledThreadPoolExecutor 则是基于相对时间；Timer 是内部是单一线程，而 ScheduledThreadPoolExecutor 内部是个线程池，所以可以支持多个任务并发执行。 旧方案 123456789101112131415161718public class TimerTest03 { Timer timer; public TimerTest03(){ timer = new Timer(); timer.schedule(new TimerTaskTest03(), 1000, 2000); } public static void main(String[] args) { new TimerTest03(); }}public class TimerTaskTest03 extends TimerTask{ @Override public void run() { Date date = new Date(this.scheduledExecutionTime()); System.out.println(\"本次执行该线程的时间为：\" + date); }} 新方案 12345678910111213141516171819202122232425262728293031323334353637public class ScheduledExecutorTest { private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest(){ this.scheduExec = Executors.newScheduledThreadPool(2); this.start = System.currentTimeMillis(); } public void timerOne(){ scheduExec.schedule(new Runnable() { public void run() { System.out.println(\"timerOne,the time:\" + (System.currentTimeMillis() - start)); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } },1000,TimeUnit.MILLISECONDS); } public void timerTwo(){ scheduExec.schedule(new Runnable() { public void run() { System.out.println(\"timerTwo,the time:\" + (System.currentTimeMillis() - start)); } },2000,TimeUnit.MILLISECONDS); } public static void main(String[] args) { ScheduledExecutorTest test = new ScheduledExecutorTest(); test.timerOne(); test.timerTwo(); }}","link":"/java/%E5%9F%BA%E7%A1%80/Java%E6%8F%90%E9%AB%98%E7%AF%872.html"},{"title":"java并发编程之美","text":"[toc] java并发编程之美","link":"/java/%E5%9F%BA%E7%A1%80/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E.html"},{"title":"nowcoder-examination-java","text":"2019-12-05 06 07static不能用来修饰类除非类是内部类，此时该类作为外部类的成员变量，可以用static来修饰 类方法&lt;-&gt;静态方法静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用 对象空间被收集前执行finalize（）方法而不是对象空间被收集之后再执行，如果这样的话执行finalize（）就没有意义了。 关于继承和实现1.类与类之间的关系为继承，只能单继承，但可以多层继承。2.类与接口之间的关系为实现，既可以单实现，也可以多实现。3.接口与接口之间的关系为继承，既可以单继承，也可以多继承。 面向对象方法的多态性是指相同类型的变量、调用同一个方法时呈现出多种不同的行为特征 Hashtable 和 HashMap 的区别是HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口Hashtable 线程安全的，而 HashMap 是线程不安全的Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 Hashtable：（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。（2）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。（3）HashTable直接使用对象的hashCode。HashMap：（1）由数组+链表组成的，基于哈希表的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。（3）HashMap重新计算hash值 java中将ISO8859-1字符串转成GB2312编码，语句为 ？new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”) java如何接受request域中的参数？request.getParameter() JAVA的跨平台特性表述为“一次编译，到处运行”Java的跨平台特性是因为JVM的存在， 它可以执行.class字节码文件，而不是.java源代码 下列关于JAVA多线程的叙述正确的是（）正确答案: B C 你的答案: A B D (错误)调用start()方法和run()都可以启动一个线程CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程Callable类的call()方法可以返回值和抛出异常新建的线程调用start()方法就能立即进行运行状态 A，start是开启线程，run是线程的执行体，run是线程执行的入口。B，CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。C，Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。D，start是把线程从new变成了runnable 2019-12-04下面的程序输出的结果是( )123456789101112public class A implements B{public static void main(String args[]){ int i; A a1=new A(); i =a1.k; System.out.println(\"i=\"+i); }}interface B{ int k=10；} 正确答案: i=10 在接口里面的变量默认都是public static final 的，它们是公共的,静态的,最终的常量.相当于全局常量，可以直接省略修饰符。实现类可以直接访问接口中的变量 以下叙述正确的是正确答案: D 你的答案: B (错误)实例方法可直接调用超类的实例方法实例方法可直接调用超类的类方法、实例方法可直接调用子类的实例方法实例方法可直接调用本类的实例方法 A错误，类的实例方法是与该类的实例对象相关联的，不能直接调用，只能通过创建超类的一个实例对象，再进行调用B错误，当父类的类方法定义为private时，对子类是不可见的，所以子类无法调用C错误，子类具体的实例方法对父类是不可见的，所以无法直接调用， 只能通过创建子类的一个实例对象，再进行调用D正确，实例方法可以调用自己类中的实例方法 下面代码的执行结果是 :12345678910111213class Chinese{ private static Chinese objref =new Chinese(); private Chinese(){} public static Chinese getInstance() { return objref; }}public class TestChinese { public static void main(String [] args) { Chinese obj1 = Chinese.getInstance(); Chinese obj2 = Chinese.getInstance(); System.out.println(obj1 == obj2);}} 正确答案: true 饿汉式单例模式，在类创建时，就已经实例化完成，在调用Chinese.getInstance()时，直接获取静态对象 JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：HttpSessionAttributeListener 以下哪几种方式可用来实现线程间通知和唤醒：( )12Object.wait/notify/notifyAllCondition.await/signal/signalAll wait()、notify()和notifyAll()是 Object类 中的方法 ；Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、 notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。 2019-12-03ArrayList是可改变大小的数组，而LinkedList是双向链接串列 命令javac-d参数的用途是？指定编译后类层次的根目录 -d destination 目的地-s source 起源地javac -d 指定放置生成的类文件的位置javac -s 指定放置生成的源文件的位置 以下代码执行后输出结果为（ ）public class Test { 123456789101112 public static void main(String[] args) { System.out.println(\"return value of getValue(): \" + getValue()); } public static int getValue() { try { return 0; } finally { return 1; } }} 当try，catch和finally中都有return时，先执行try中return，并暂存，再执行finnally中并返回最新的值 在jdk1.5之后，下列 java 程序输出结果为__。1234int i=0;Integer j = new Integer(0);System.out.println(i==j);System.out.println(j.equals(i)); true,true 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；2、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 说明输出结果。123456789101112ackage test;import java.util.Date; public class SuperTest extends Date{ private static final long serialVersionUID = 1L; private void test(){ System.out.println(super.getClass().getName()); } public static void main(String[]args){ new SuperTest().test(); } } test.SuperTest super.getClass().getName()返回的是test.SuperTest，与Date类无关要返回Date类的名字需要写super.getClass().getSuperclass() 以下哪些类是线程安全的（）正确答案: A D E 你的答案: 空 (错误)VectorHashMapArrayListStringBufferProperties A，Vector相当于一个线程安全的ListB，HashMap是非线程安全的，其对应的线程安全类是HashTableC，Arraylist是非线程安全的，其对应的线程安全类是VectorD，StringBuffer是线程安全的，相当于一个线程安全的StringBuilderE，Properties实现了Map接口，是线程安全的 2019-12-01javac的作用是（ ）。将源程序编译成字节码 12javac helloworld.javajava helloworld HashMap的数据结构是怎样的数组+链表 JDK8以后，HashMap的数据结构是数组+链表+红黑树HashMap内部包含了一个默认大小为 16 Entry 类型的数组 table,其中每个Entry 是一个链表，当链表长度大于等于 8 时会将链表转换为红黑树。HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 下面关于垃圾收集的描述哪个是错误的？a 使用垃圾收集的程序不需要明确释放对象b 现代垃圾收集能够处理循环引用问题c 垃圾收集能提高程序员效率d 使用垃圾收集的语言没有内在泄漏问题也会有内存泄露问题，例如访问资源文件，流不关闭，访问数据库等连接不关闭 重载的方法就是形参列表的不同，和返回值无关用户不能调用构造方法，只能通过new关键字自动调用。【X】 在类内部可以用户可以使用关键字this.构造方法名()调用（参数决定调用的是本类对应的构造方法）在子类中用户可以通过关键字super.父类构造方法名()调用（参数决定调用的是父类对应的构造方法。）反射机制对于任意一个类，都能够知道这个类的所有属性和方法，包括类的构造方法。 下面有关JSP内置对象的描述，说法错误的是？正确答案: C 你的答案: 空 (错误)session对象：session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止request对象：客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应application对象：多个一个application对象实现了用户间数据的共享，可存放全局变量response对象：response对象包含了响应客户请求的有关信息 volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性java程序内存泄露的最直接表现是（ ）正确答案: C 你的答案: 空 (错误)频繁FullGcjvm崩溃程序抛内存控制的Exceptionjava进程异常消失 java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.最终超出内存界限，抛出OutOfMemoryExpection 下面有关webservice的描述，错误的是？正确答案: B 你的答案: 空 (错误)Webservice是跨平台，跨语言的远程调用技术Webservice通信机制实质就是json数据交换Webservice采用了soap协议（简单对象协议）进行通信WSDL是用于描述 Web Services 以及如何对它们进行访问 Web service顾名思义是基于web的服务，它是一种跨平台，跨语言的服务。我们可以这样理解它，比如说我们可以调用互联网上查询天气信息的web服务，把它嵌入到我们的B/S程序中，当用户从我们的网点看到天气信息时，会认为我们为他提供很多的服务，但其实我们什么也没做，只是简单的调用了一下服务器上的一端代码而已。Web service 可以将你的服务发布到互联网上让别人去调用，也可以调用别人发布的web service，和使用自己的代码一样。它是采用XML传输格式化的数据，它的通信协议是SOAP(简单对象访问协议). java用（）机制实现了进程之间的同步执行正确答案: A 你的答案: C (错误)监视器虚拟机多个CPU异步调用 首先jvm中没有进程的概念 ，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。那这道题的问的就是jvm中线程如何异步执行 。 在jvm中 是使用监视器锁来实现不同线程的异步执行， 在语法的表现就是synchronized。 关于访问权限说法正确的是？类定义前面可以修饰public,protected和private内部类前面可以修饰public,protected和private局部内部类前面可以修饰public,protected和private以上说法都不正确 对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。1.成员内部类（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量 或 外部类.this.成员方法】；（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。2.局部内部类（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。3.匿名内部类（1）一般使用匿名内部类的方法来编写事件监听代码；（2）匿名内部类是不能有访问修饰符和static修饰符的；（3）匿名内部类是唯一一种没有构造器的类；（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。4.内部静态类（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；（2）不能使用外部类的非static成员变量或者方法。 throw thorws1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理。 以下可以正确获取结果集的有正确答案: A D 你的答案: 空 (错误) 12345678910Statement sta=con.createStatement();ResultSet rst=sta.executeQuery(“select * from book”);Statement sta=con.createStatement(“select * from book”); ResultSet rst=sta.executeQuery();PreparedStatement pst=con.prepareStatement();ResultSet rst=pst.executeQuery(“select * from book”);PreparedStatement pst=con.prepareStatement(“select * from book”);ResultSet rst=pst.executeQuery(); 创建Statement是不传参的，PreparedStatement是需要传入sql语句1、PreparedStatement 继承 Statement，PreparedStatement 实例包含已编译的 SQL 语句， 所以其执行速度要快于 Statement 对象。2、作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。三种方法execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数3、PreparedStatement尽最大可能提高性能. 最重要的一点是极大地提高了安全性. final、finally和finalize的区别中，下述说法正确的有？正确答案: A B 你的答案: A B C D (错误)final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。 A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。 在try中调用System.exit(0)，强制退出了程序，finally块不执行。 在进入try块前，出现了异常，finally块不执行。C，finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。 放一张图吧","link":"/java/%E5%9F%BA%E7%A1%80/nowcoder-examination-java.html"},{"title":"计算机操作系统 CS-Notes","text":"[toc]","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CS-Notes.html"},{"title":"HTTP CS-Notes","text":"[toc]","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-CS-Notes.html"},{"title":"计算机网络 CS-Notes","text":"[toc] [概述](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 概述)ISP互联网服务提供商（Internet Service Provider），ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等互联设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 主机之间的通信方式C-S 客户端-服务器 模式 P2P 电路交换与分组交换电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路，因此电路交换对线路的利用率很低，往往不到 10%。 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一封邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 时延总时延=排队时延+处理时延+传输时延+传播时延 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 传输时延主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 传播时延电磁波在信道中传输所需要的花费的时间，电磁波传播的速度接近光速。 delay = l / v 其中 l 表示信道长度(m)，v 表示电磁波速度(m/s) 计算机网络体系结构 五层协议应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文 传输层：为进程提供数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两层协议：TCP UDP。TCP: 传输控制协议，提供面向连接、可靠的数据传输服务，数据单位为报文段。UDP: 用户数据报协议，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供即时性服务。 网络层：为主机提供数据传输服务。网络层把数据层传递下来的报文段或用户数据报封装成分组。 数据链路层：网络层针对的是主机之间的数据传输服务，而主机之间可以有许多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层：考虑怎么在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI表示层和会话层，五层协议中没有这 2 层，而是将这些功能留给应用程序开发者处理。 TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 [物理层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 物理层)通信方式根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制模拟信号是连续的信号，数字信号是离散的信号。而带通调制把数字信号转换为模拟信号。 [链路层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 链路层)基本问题1. 封装成帧2. 透明传输帧使用首部和尾部进行定界，透明传输就是将与首部尾部相同的内容转义。接收端处理后还原出原始数据，用户察觉不到转移字符的存在，这个过程是透明传输。 3. 差错检测数据链路层使用循环冗余校验(CRC)来检查比特差错。 信道分类1. 广播信道一对多通信 有 2 种方法避免所有节点发送的数据，一个是信道复用技术，一是使用 CSMA/CD 协议。 2. 点对点信道使用 PPP 协议 信道复用技术1. 频分复用2. 时分复用由于计算机数据的突发性之，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。 3. 统计时分复用4. 波分复用5. 码分复用CSMA/CD 协议Carrier Sense Multiple Access with Collision Detection 载波监听多点接入/碰撞检测 载波监听：主机不停地监听信道，在发送前，如果监听到信道正在使用，就必须等待。 多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上。？ 碰撞检测：发送中，若监听到信道已有其他主机正在发送数据，就表示发生了碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，2τ 为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 MAC 地址Mac 地址是链路层地址，长度是 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网以太网目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 虚拟局域网[网络层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 网络层)概述IP协议 地址解析协议 ARP（Address Resolution Protocol） 网络控制报文协议 ICMP（Internet Control Message Protocol） 网络组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 地址解析协议 ARP由 IP 地址得到 MAC 地址 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。 1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 虚拟专用网 VPN网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 [传输层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 传输层)网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始 与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 2. 快重传 与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 [应用层](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层)域名系统DNS 提供主机名和 IP 地址之间相互转换的服务。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名 文件传送协议FTP 使用 TCP 进行连接，它需要 2 个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传送服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 [1. SMTP](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_1-smtp)SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 [2. POP3](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_2-pop3)POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 [3. IMAP](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=_3-imap)IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP Web 页面请求过程1. DHCP 配置主机信息假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS-Notes.html"},{"title":"socket CS-Notes","text":"[toc]","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket-CS-Notes.html"},{"title":"bitbar","text":"嗨，请准确无误地输入密码查看哟！ 9ec28ecf2c643e162dad2fda697938046a45fb2cbe7c8c6c04a044efd2ce918a2b5d3a1007cdb485c68e9214cd58cc419c5e7292cbbff5da3258e97f7a6ce86ff3c08fa12936eaed5d13277072a3e2ddcb595484118f2b0b886471cb717a47e785cca033802fb7f55eb30ee2f5b8519e6666c7c14889fcf909f4f4e89b5c1cd68d2dd8f2bf005a1955803cc4f16c54b6154ac87950c6ff381cb2af43986f532acf5bfe7252182f6f2c7cf8e74b6a8cc0644ff39d12e78e914e02a4ccfb2ca0d483816b72f3ae992a5c2dc81a744c3e731b056b329bf256aa40e496daad744270fae8ac3c615937320f32fe9b00c56777ca64af699e798a70737c6dc518a1fd2b4a2d641838d93f6e851b68801f58c67f062f83a3d2217f4ad981eabdf67b35901ad5987e28e1806a942f0951254197691f46fd54d589e9f280500ad429ffc2e4e52ea13380ffe65873fd42d97dcb623f51bca7a3826a1f8068213b350969b247a65ee36eaae3b97e6370667c20e2678e4e920a4780a5dc262e4b1ce4fc4cc787dda884b705d59acfd37b05c03102218053c34b9fa346f634f0bcf3bfd02eb066a783836efa8f92d7c9fe499685bd8f660b1c609e07103da78c493de3947e07d94d157491d740950fd0a2e5705ea867863d879a5349423cad46835f55cb11201487bf85f17f1fe571cbd78fbd8678981b19fdc4318b68343b9df8cc9ccdabbc2d453e927e1cf2b67026edfbbca14cd3ecd89a88d62aa07517e8687472e68b24aec8e9a040fd4b82a7516e2d50a1cfc5a39900b14d17b7aa98544999031232cf98a838ff4e63eeda47fa514906c2cfd41b990933ee619abf449b7e1ea74ef3c4528b15850155c91ae3d4c1678280f0980296759e995ddd24ff71e744b4a599dc61c90827e37946bc6293e9e553b507e7abaac6cb08a837eba0d25d4496c737d52691b5fbe9d0235eb7a65425544ccb7cb5d9e1fbb53789cdfc0000cfc196f2944545e6cdc87dc485fd248e17b1dc31283658cddf1452a9b641576cca80a92414d3b7a9fc6a1431cbb0626e0530d5213203fc33f6d01c7fa996c8dd5bc6bc369d70750464bd22805022ae8098fb2f580973ced65e392f27ff14c283e11868dadaa2317298a6e0dfa2f518464504913e399f1c5b995ff405f10cba634d1609c2cb862c56b7f1f4ad7a15999fedcfd7e244ead8cdd8ba930f7706c9743f3eac439f3deee6824f181e462c07ef2f4aee849688e11b787725f8f6357d96511d1b2a2c59931bc28646d19b82a35d0f0b149b3114bd487a418b12feecd52336d5a36784cfd93938676f73009ffebe88c8c5774044c57e67561e0a9758c19aeca175dcabcc76ba7ba8b76d13e58c9a2f7a9a83b50a5259308576d89d36a1134a247b61b09000e8b028856a823187739c6fd4f1593572cf4271436fa729d7e4b57c2a04e9102d4fefc4f01a4089357dedd155ef08f35fc49e534d8b9a78e75114cc4334d2a07f48250b387e86a5cf09150a1a9fb5f4e31a90a8e0b7010a6b39dfaa3c6455efce593699c06967ccd0873f8d1ad8912798d850dc81cdbee81afb6f80edcea65b4adedfdd5fd425d2f95cb8940c38da1e466fafb72860c8a971f2fed6c67d9993a8c4257a095fe067a2d31a5ab4f11a94e3369890faf150442fa33a1a884e146504bd8c51426705ea168680b78400b25befd6d0e9f6a005dc155c504a03101c43f946d1cee6bc56adbddd6e84d091a0932b9d1190653cf83c64b129152f41ceafd4275a698fb43638aea2b52bfe653def811de70079f9e56c28cd062774d9e71ac04910dc14c43ac59e3ccdcde8e5929320b9c0f865cdad87b09b3d03be24b616eb6447cd4437c76b62c643715d3f4f2b2710d052a09358213e7838176f6a25b21497c4afd9f6b1683f9615c8f9fd002e3005b0d897eedd214b560ee7318bab1b6ef31d470acde854af1c4060ab87577c8a1c8d8d456a73e5399b2dad7ff0ffb9f46560fe48312a943a4fd4ad56e15f8ca9c0133bbf4543f8553f86ccdfac1d8bc87c3842e763a8e87ce3ae7c7cce4c2ea81c8257231addec2efa317ba79691f30b228bb9093e33a5378a13cc1f8aee0e0a203c9db570702e027be28cd53b5fe5f48c30c9dbc2d70878f6b99ff2755c1935652983c1fb01f9699cf511508aa9931432577e29e063851f728f35e0eb9dd50f155181aaeeadc16cf7d6a76a59f5fc059ddc3c5d6a0dd6ef85e62f70ea9f8095f2b60e9263930a6303ff92816a6965247176bb80ac2c6d23b5e63a8c8dd8d20b6dca2578fd8eed5287213616c89636ff5e4bd90ba9cc6a809745e72b5e70d885993822b590bd7fa8967acc6227593cf87ee370767a36226ffb10a4979636a79e76d427a41e14f834bba73c06174bd80ca93161160c44579b59fc4a7c66442b24f3315596f816bd279800a28bf81d100a537c188552111111bbc7f3ad5661155c6510179a3e7fe6a2221f347da06150888c200765fa1d387e65d34d2d4b7fbaf4f7200bd9436c72ef33d2b395f7d2c2b21128013976fcd66506540e3395960b4353452346547198416275e18cf5bb0cd1342d4ed66b9251300cec3179127710a8a8c7756dbdb29ac3a9671dff5f50f046c20372ad1bd3d05be8933d3b89552a42534acfc2455a713c9fdfadbb68f97b8bc82b7b55ca8b78a83cedc821b304538214a7e9e46703d0b5d23ab8412d62cff8a227a59f33d8a9aa43c19d5d22921b4fa73054253dfa969202bd33268161d2315569c0eecee6175013368d1fb32e496f57701799e92fb239440cc676e685cdeb71bb47820f74afd684314d9dfea8c7faaab2b9c54fbe386994a55d7d7832a99db1c4289d388af9f1e66baa773368ca364d4e73890be124ba377aace428ae41512e993609c8778516e3228b09c4e2b855329b3e925253594d01ef0ca6328c993c1ea2f51a7acbdffd01238578b34d0ae49bf84a65e8375718c1d9259002618cb4c2370c8853ae2af274bd4df540529909be0f14ee14301bde42c1e367b28953","link":"/Mac/bitbar.html"},{"title":"CNCF × Alibaba云原生技术公开课","text":"CNCF x Alibaba 云原生技术公开课 - 云原生教程 - 阿里云大学 第1讲: “云原生”课知识点自测（一）：1.Kubernetes 并不支持为应用固定 IP，于是我自己通过编写网络插件把应用 IP 管理在了 etcd 里，然后上线。请问这破坏了云原生的理念了吗？* A. 否 5.我编写的容器化应用，会将日志文件写在某路径写死的目录里。请问这破坏了云原生理念了吗？* B. 是 6.以下哪些能力不是标准 Kubernetes 项目提供的？ A. 容器编排与调度 B. PaaS C. 资源管理 D. 服务注册与发现 PaaS是（Platform as a Service）的缩写，是指平台即服务。 把服务器平台作为一种服务提供的商业模式，通过网络进行程序提供的服务称之为SaaS(Software as a Service)， 单选 7.容器启动后，我会时常 SSH 进入到容器里然后写很多文件。请问这破坏了云原生理念了吗？ A. 否 B. 是 单选 9.以下哪些项目跟 Kubernetes 项目功能重合度最高？ A. Mesos B. Docker Swarm C. Docker Swarm 模式（SwarmKit） D. Cloud Foundry 正确答案： C 多选 10.以下哪些标准，可以用来考察一个应用的架构是不是云原生的？ A. 应用实例能否快速水平扩展 B. 应用是否使用镜像机制打包来保证环境一致性 C. 应用数据是否都写在容器数据卷中 D. 应用是否有状态 第2讲：容器基本概念 1234567891011121314151617181920212223242526272829303132333435363738394041Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 02. 03. -d, --detach=false 指定容器运行于前台还是后台，默认为false 04. -i, --interactive=false 打开STDIN，用于控制台交互 05. -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false 06. -u, --user=\"\" 指定容器的用户 07. -a, --attach=[] 登录容器（必须是以docker run -d启动的容器） 08. -w, --workdir=\"\" 指定容器的工作目录 09. -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 10. -e, --env=[] 指定环境变量，容器中可以使用该环境变量 11. -m, --memory=\"\" 指定容器的内存上限 12. -P, --publish-all=false 指定容器暴露的端口 13. -p, --publish=[] 指定容器暴露的端口 14. -h, --hostname=\"\" 指定容器的主机名 15. -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 16. --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 17. --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities 18. --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities 19. --cidfile=\"\" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 20. --cpuset=\"\" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU 21. --device=[] 添加主机设备给容器，相当于设备直通 22. --dns=[] 指定容器的dns服务器 23. --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 24. --entrypoint=\"\" 覆盖image的入口点 25. --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 26. --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 27. --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 28. --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 29. --name=\"\" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 30. --net=\"bridge\" 容器网络设置: 31. bridge 使用docker daemon指定的网桥 32. host //容器使用主机的网络 33. container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 34. none 容器使用自己的网络（类似--net=bridge），但是不进行配置 35. --privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities 36. --restart=\"no\" 指定容器停止后的重启策略: 37. no：容器退出时不重启 38. on-failure：容器故障退出（返回值非零）时重启 39. always：容器退出时总是重启 40. --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) 41. --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 知识点自测（二）：容器基本概念单选 2.已运行 docker run -d -t —name demo ubuntu top 命令, 在 demo 这个容器内看到 top 命令的 PID 是什么？ A. 随机数字 B. 1 单选 3.已运行 docker run -d -t —name demo ubuntu top 命令，以下哪个 docker 命令创建出的容器能看见 demo 容器进程？ A. docker run –name demo-x –net container:demo ubuntu ps B. docker run –name demo-x –pid container:demo ubuntu ps C. docker run –name demo-x –ipc container:demo ubuntu ps 4.已运行 docker run -d -t —name demo ubuntu top 和 docker run –name demo-x –pid container:demo ubuntu ps 命令，是否可以在 demo-x 容器内部停止容器？ A. 是 5.已运行 docker run -d -t —name demo ubuntu top 命令, 是否可以在 demo 这个容器内部停止容器？ A. 是 B. 否 ？？ 6.已运行 docker run -d —name demo busybox:1.25 top 命令，如何使用 docker 命令来获取容器 demo 的 Init 进程 PID？ 123# 两种方法docker container top &lt;container&gt;docker inspect -f '{{.State.Pid}}' &lt;container&gt; # 题目给的选项 单选 7.以下哪个 docker 命令可以用来创建一个使用宿主机主机名的容器？ A. docker run –uts=host ubuntu hostname B. docker run ubuntu hostname C. docker run –ipc host ubuntu ps 12--uts ??--ipc ?? 单选 8.已运行 docker run -d -t —name demo ubuntu top 和 docker run –name demo-x –pid container:demo ubuntu ps 命令，如果 demo 容器退出了，正在运行的 demo-x 容器是否会退出？ A. 是 9.以下哪个 docker 命令创建出来的容器可以自动重启？ A. docker run -d busybox top B. docker run –restart always busybox top C. docker run -d –restart always busybox top 课后实践：应用容器构建与部署","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC%201%202%E8%AE%B2.html"},{"title":"第3讲：Kubernetes 核心概念 实践","text":"初识 K8s，创建一个guestbook留言簿应用 【K8s | from zero to hero】木环 2019-11-07 876浏览量 简介： 本文介绍一个简单的K8s上手应用，希望通过这个简单的实践让大家对K8s的核心概念有更深入的理解。这个案例要在 Kubernetes 集群上部署一个名叫 guestbook 的 CURD 应用。guestbook 是 Kubernetes 社区的一个经典的应用示例，它有一个 Web 界面来让用户进行 CURD 操作，然后向一个 Redis 主节点写入数据，从多个 Redics 从节点读去数据。 课后实践：Kubernetes 核心概念1. 目标概述本文介绍一个简单的K8s上手应用，希望通过这个简单的实践让大家对K8s的核心概念有更深入的理解。 巩固 Kubernetes 的基本概念 学会使用 Kubernetes 部署一个标准的“多层（multi-tier）”应用 了解 Kubernetes 里如何通过 Pod，Deployment，Service 等 API 原语描述“应用” 2. 实验概览完成此实验后，可以掌握的能力有： 本实验主要在 Kubernetes 集群上部署一个名叫 guestbook 留言簿的 CURD (增查改删)应用。guestbook 是 Kubernetes 社区的一个经典的应用示例，它有一个 Web 界面来让用户进行 CURD 操作，然后向一个 Redis 主节点写入数据，从多个 Redics 从节点读去数据。 实验分以下几个步骤： 创建 Redis 主节点 创建 Redis 从节点集群 创建 guestbook 应用 将 guestbook 应用通过 Service 暴露出来并进行访问 水平扩展 guestbook 应用 3. 所需资源：一个完备的 Kubernetes 集群。您可以选择阿里云容器服务Kubernetes（ACK）进行上手操作。 可以用 Minikube 快速启动一个单节点集群（国内建议使用Minikube 中国版），也可以用云上的 Kubernetes 集群。本次实验演示将使用阿里云容器服务提供的 Kubernetes 集群，版本为 1.12。 你可以使用使用 kubectl version 查看你的集群版本同实验版本一致。 4. 实验详情4.1 创建 Redis 主节点在这里，我们使用一个叫做 Deployment 的 API 对象，来描述单实例的Redis 主节点。 1234567891011121314151617181920212223242526272829apiVersion: apps/v1kind: Deploymentmetadata: name: redis-master labels: app: redisspec: selector: matchLabels: app: redis role: master tier: backend replicas: 1 template: metadata: labels: app: redis role: master tier: backend spec: containers: - name: master image: registry.cn-hangzhou.aliyuncs.com/kubeapps/redis resources: requests: cpu: 100m memory: 100Mi ports: - containerPort: 6379 我们需要把这个上述内容保存为本地 YAML文件，名叫：redis-master-deployment.yaml。这个文件主要定义了两个东西：第一，Pod 里的容器的镜像是 redis；第二，这个 Deployment 的实例数（replicas）是 1，即指启动一个 Pod。 然后，我们使用 Kubernetes 的客户端，执行如下操作： 12$ kubectl apply -f redis-master-deployment.yamldeployment.apps/redis-master created 这一步完成后，Kubernetes 就会按照这个 YAML 文件里的描述为你创建对应的 Pod。这种使用方式就是声明式 API 的典型特征。 接下来，我们可以查看到这个 Pod： 123$ kubectl get podsNAME READY STATUS RESTARTS AGEredis-master-68979f4ddd-pg9cv 1/1 Running 0 49s 可以看到，Pod 已经进入了 Running 状态，表示一切正常。这时，我们就可以查看这个 Pod 里的 Redis 的日志： 12345678$ kubectl logs -f redis-master-68979f4ddd-pg9cv1:C 26 Apr 2019 18:49:29.303 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 26 Apr 2019 18:49:29.303 # Redis version=5.0.4, bits=64, commit=00000000, modified=0, pid=1, just started1:C 26 Apr 2019 18:49:29.303 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf1:M 26 Apr 2019 18:49:29.304 * Running mode=standalone, port=6379.1:M 26 Apr 2019 18:49:29.304 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.1:M 26 Apr 2019 18:49:29.304 # Server initialized1:M 26 Apr 2019 18:49:29.304 * Ready to accept connections 4.2 为 Redis 主节点创建 ServiceKubernetes 里要访问 Pod 最好通过 Service 的方式，这样客户端就不需要记录 Pod 的 IP 地址了。我们的 guestbook 网站需要访问 Redis 主节点的 Pod，所以也要通过 Service 来做。这个 Service API 对象的定义如下所示： 12345678910111213141516apiVersion: v1kind: Servicemetadata: name: redis-master labels: app: redis role: master tier: backendspec: ports: - port: 6379 targetPort: 6379 selector: app: redis role: master tier: backend 这个 Service 名叫 redis-master，它声明用自己的 6379 端口代理 Pod 的 6379端口。 我们还是把上述内容保存成文件然后让 Kubernetes 为我们创建它： 12$ kubectl apply -f redis-master-service.yamlservice/redis-master created 然后我们可以查看一下这个 Service： 1234$ kubectl get serviceNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 181dredis-master ClusterIP 10.107.220.208 &lt;none&gt; 6379/TCP 9s 这时候，你就可以通过 10.107.220.208:6379 访问到这个 Redis 主节点。 4.3 创建 Redis 从节点集群我们这个示例中，有多个 Redis 从节点来共同响应读请求。同样的，我们还是通过 Deployment 来描述”一个服务由多个相同的 Pod 实例副本组成”这种语义。 1234567891011121314151617181920212223242526272829303132apiVersion: apps/v1kind: Deploymentmetadata: name: redis-slave labels: app: redisspec: selector: matchLabels: app: redis role: slave tier: backend replicas: 2 template: metadata: labels: app: redis role: slave tier: backend spec: containers: - name: slave image: registry.cn-hangzhou.aliyuncs.com/kubeapps/gb-redisslave:v1 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: env ports: - containerPort: 6379 在这个 Deployment 中，我们指定了 replicas: 2，即这个 Deployment 会启动两个相同 Pod（Redis 从节点）。 此外，gb-redisslave:v1 这个镜像，会自动读取 REDIS_MASTER_SERVICE_HOST 这个环境变量的值，也就是 Redis 主节点的 Service 地址，然后用它来组建集群。这个环境变量是Kubernetes 自动根据 redis-master 这个 Service 名字，自动注入到集群的每一个 Pod 当中的。 然后，我们创建 Redis 从节点： 12$ kubectl apply -f redis-slave-deployment.yamldeployment.apps/redis-slave created 这时候，我们就可以查看这些从节点的状态： 12345$ kubectl get podsNAME READY STATUS RESTARTS AGEredis-master-68979f4ddd-pg9cv 1/1 Running 0 17mredis-slave-78b464f5cd-2kn7w 0/1 ContainerCreating 0 37sredis-slave-78b464f5cd-582bk 0/1 ContainerCreating 0 37s 4.4 为 Redis 从节点创建 Service类似的，为了让 guestbook 应用访问上述 Redis 从节点，我们还需要为它们创建一个 Service。在Kubernetes 里，Service 可以通过 selector 选择代理多个 Pod，并且负责负载均衡。这个Service 内容如下所示： 123456789101112131415apiVersion: v1kind: Servicemetadata: name: redis-slave labels: app: redis role: slave tier: backendspec: ports: - port: 6379 selector: app: redis role: slave tier: backend 创建和查看 Service（ 注意：这里 6379 端口使用了简化写法，就不需要写明 targetPort了）： 12345678$ kubectl apply -f redis-slave-svc.yamlservice/redis-slave created$ kubectl get servicesNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 181dredis-master ClusterIP 10.107.220.208 &lt;none&gt; 6379/TCP 16mredis-slave ClusterIP 10.101.244.239 &lt;none&gt; 6379/TCP 57s 这样，你就可以通过 10.10.101.244:6379 访问到任何一个 Redis 从节点了。 4.5 创建 guestbook 应用guestbook 应用本身，依然通过一个 Deployment 来描述，如下所示： 123456789101112131415161718192021222324252627282930apiVersion: apps/v1kind: Deploymentmetadata: name: frontend labels: app: guestbookspec: selector: matchLabels: app: guestbook tier: frontend replicas: 3 template: metadata: labels: app: guestbook tier: frontend spec: containers: - name: php-redis image: registry.cn-hangzhou.aliyuncs.com/kubeapps/gb-frontend:v4 resources: requests: cpu: 100m memory: 100Mi env: - name: GET_HOSTS_FROM value: env ports: - containerPort: 80 这个 YAML 定义了一个 3 副本的 Deployment，即 guestbook 应用会启动 3 个 Pod。 我们还是通过同样的步骤创建这个 Deployment： 12$ kubectl apply -f frontend.yamldeployment.apps/frontend created 查看 Pod 的状态： 12345$ kubectl get pods -l app=guestbook -l tier=frontendNAME READY STATUS RESTARTS AGEfrontend-78d6c59f4-2x24x 1/1 Running 0 3m4sfrontend-78d6c59f4-7mz87 1/1 Running 0 3m4sfrontend-78d6c59f4-sw7f2 1/1 Running 0 3m4s 4.6 为 guestbook 应用创建 Service为了能够让用户访问到 guestbook，我们也需要为 guestbook 来创建一个 Service，从而把这个应用以服务的形式暴露出来给用户使用。 而为了能够让 Kubernetes 集群以外的用户，这个 Service 就必须是一个外部可访问的 Service。这个在 Kubernetes 里有几种做法。在云上最常见的，是 LoadBalancer 模式。 12345678910111213141516apiVersion: v1kind: Servicemetadata: name: frontend labels: app: guestbook tier: frontendspec: # 自建集群只能使用 NodePort 模式 # type: NodePort type: LoadBalancer ports: - port: 80 selector: app: guestbook tier: frontend 由于我的集群由阿里云容器服务提供，所以像上面这样直接用 LoadBalancer 模式即可。 1234$ kubectl apply -f frontend-service.yaml$ kubectl get service frontendNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEfrontend ClusterIP 172.19.10.209 101.37.192.20 80:32372/TCP 1m 现在，你只要用浏览器打开 EXTERNAL-IP 对应的地址： http://101.37.192.20:31323 ，就可以访问到这个部署好的 guestbook 应用了。 而如果你是自建集群，那就只能用 NodePort 模式来实验（上面 YAML 的注释已经给出了使用方法）。需要注意的是 NodePort 由于安全性问题，不建议在生产环境中使用。 4.7 水平扩展 guestbook 应用要通过 Kubernetes 来水平扩展你的应用以响应更多的请求非常简单，只需要如下一条命令： 12$ kubectl scale deployment frontend --replicas=5deployment.extensions/frontend scaled 你就会立刻看到你的 guestbook 应用的实例从 3 个变成了 5 个： 1234567$ kubectl get pods -l app=guestbook -l tier=frontendNAME READY STATUS RESTARTS AGEfrontend-78d6c59f4-2x24x 1/1 Running 0 14mfrontend-78d6c59f4-7mz87 1/1 Running 0 14mfrontend-78d6c59f4-chxwd 1/1 Running 0 19sfrontend-78d6c59f4-jrvfx 1/1 Running 0 19sfrontend-78d6c59f4-sw7f2 1/1 Running 0 14m","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC3%E8%AE%B2%EF%BC%9AKubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%AE%9E%E8%B7%B5.html"},{"title":"第2讲：容器基本概念 实践","text":"你的第一个容器镜像，构建、分发、运行 [ K8s | from zero to hero ]木环 2019-11-07 106浏览量 简介： 再也不要当容器小白了！Build ship and run！ 什么是容器？因为虚拟机（vm）存在一定不足，容器技术的诞生后才如此受欢迎。以传统的Java应用架构而言，将一个应用程序生成一个war包，放到一个tomcat容器当中并在一台虚拟机（VM）中启动运行，然后配置nginx的负载均衡策略，将来自用户的请求转发到某个tomcat应用上，这种基于主机或虚拟机部署的应用会存在以下问题：可移植性差、可维护性差、可扩展性差、无法资源隔离。扩展阅读 而容器是什么呢？它就是一个视图隔离、资源可限制、独立文件系统的进程集合。所谓“视图隔离”就是能够看到部分进程以及具有独立的主机名等；控制资源使用率则是可以对于内存大小以及 CPU 使用个数等进行限制。容器就是一个进程集合，它将系统的其他资源隔离开来，具有自己独立的资源视图。 容器具有一个独立的文件系统，因为使用的是系统的资源，所以在独立的文件系统内不需要具备内核相关的代码或者工具，我们只需要提供容器所需的二进制文件、配置文件以及依赖即可。只要容器运行时所需的文件集合都能够具备，那么这个容器就能够运行起来。扩展阅读《详解 K8s 容器基本概念》 什么是容器镜像？从一个比较具体的角度去看，镜像就是一个多层存储的文件，相较于普通的ISO系统镜像来说，分层存储会带来两个优点： 一个是分层存储的镜像比较容易扩展，比如我们可以基于一个Ubuntu镜像去构建我们的Nginx镜像，这样我们只需要在Ubuntu镜像的基础上面做一些Nginx的安装配置工作。一个Nginx镜像工作就算制作完成了，我们不需要从头开始去制作各种镜像。 另一点是可以优化镜像存储空间，假如我们有两个镜像，Tag1.0镜像和 Tag2.0镜像，我们如果以传统方式去传这两个镜像，每个镜像大概130多兆，但如果我们以分层的方式去存储两个镜像，我们通过下面两个紫色的才能共享，可以节约大量的空间，两个镜像加起来只需要140多兆的空间就可以存下来。这样一是节省了存储空间，二是可以减少网络上的开销，比如我们已经把下面镜像下载了，我们要去下载上面镜像的时候，我们只需要去下10M的部分。 如果从抽象的角度去看，Docker镜像其实是Docker提供的一种标准化的交付手段，传统应用在交付的时候其实是交付一个可执行文j件。问题在于传统方式的这个可执行文件不包括它的运行环境，我们可能会因为32位系统或64位系统，或者开发测试使用1.0软件，结果交付时候发现用户的环境是2.0等各种各样的问题，导致我们要去花时间去排查；但是，如果我们以Docker镜像的标准化形式去交付，我们就会避免掉这些问题。 扩展阅读《Docker 镜像优化与最佳实践》 *好了，闲话少叙。下面开始实验时间。* 1. 实验概述本实验会使用 Dockerfile 将下面 golang 代码构建成镜像，并通过阿里云镜像服务将镜像分发到阿里云虚拟机，运行该镜像。 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &quot;Hello! World\\n&quot;) }) fmt.Println(&quot;start to serve...&quot;) http.ListenAndServe(&quot;:80&quot;, nil)} 2. 实验目标完成此实验后，可以掌握的能力有： Dockerfile 编写和使用 使用阿里云镜像服务来分发镜像。 NOTE: 学前建议: 了解 docker 的基本操作命令 以及 如何使用 ECS 实例。 3. 实验详情3.1 准备应用代码和 Dockerfile首先在本地生成一个文件夹 demo，并将 golang 代码拷贝到 demo 文件夹下的 main.go. 12345678910111213141516171819202122$ pwd/tmp/demo$ lsmain.go$ cat main.gopackage mainimport ( &quot;fmt&quot; &quot;net/http&quot;)func main() { http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &quot;Hello! World\\n&quot;) }) fmt.Println(&quot;start to serve...&quot;) http.ListenAndServe(&quot;:80&quot;, nil)} 在当前 demo 目录下编写 Dockerfile ，如下所示 1234567891011121314$ cat DockerfileFROM golang:1.12-alpine# change current working dirWORKDIR /go/src/app# copy main.go into /go/src/appCOPY . .# go build and install the appRUN go install -v ./...# run the app by defaultCMD [&quot;app&quot;] 3.2 构建镜像通常情况下，使用以下命令即可构建镜像 12345678910111213141516171819202122232425$ pwd/tmp/demo# demo:v1 表示镜像名字demo和标签v1$ docker build . -t demo:v1Sending build context to Docker daemon 3.072kBStep 1/5 : FROM golang:1.12-alpine ---&gt; 8ff3fd35cf82Step 2/5 : WORKDIR /go/src/appRemoving intermediate container ffd88a948413 ---&gt; 1056ea513b89Step 3/5 : COPY . . ---&gt; 9fc4655c973aStep 4/5 : RUN go install -v ./... ---&gt; Running in 928fc776a6e1appRemoving intermediate container 928fc776a6e1 ---&gt; a93f17a3a726Step 5/5 : CMD [&quot;app&quot;] ---&gt; Running in 9e3463aa81f6Removing intermediate container 9e3463aa81f6 ---&gt; 8697c7279c74Successfully built 8697c7279c74Successfully tagged demo:v1 NOTE: 在国内访问 Docker Hub 速度比较慢，可以在Docker引擎中设置镜像加速器加速对Docker Hub的访问。 更新 /etc/docker/daemon.json，添加如下参数，并重启Docker引擎。 123{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]} 1构建完毕之后，可以在本地运行验证下是否符合预期 映射容器内 80 端到宿主机上的 8000 端口$ docker run -d -p 8000:80 demo:v1 curl 一下查看结果$ curl localhost:8000Hello! World 123456789101112131415如果看到 `Hello! World` 字样，我们就可以进入下一个环节了。#### 3.3 推送镜像至阿里云容器镜像服务在推送之前，需要注册阿里云账号和开通阿里云容器镜像服务&gt; 阿里云注册链接： [注册阿里云](https://account.aliyun.com/register/register.htm)&gt; &gt; 阿里云登录链接： [登录阿里云](https://account.aliyun.com/login/login.htm)&gt; &gt; 阿里云容器镜像服务页面： [访问阿里云容器镜像服务](https://cr.console.aliyun.com) &gt; &gt; 容器镜像服务（Container Registry）提供安全的应用镜像托管能力，精确的镜像安全扫描功能，稳定的国内外镜像构建服务，便捷的镜像授权功能，方便用户进行镜像全生命周期管理。当我们拥有阿里云容器镜像服务账号之后呢，可以使用 docker 客户端来登陆服务。 $ docker login -username=**** registry.cn-hangzhou.aliyuncs.comPassword:Login Succeeded 1在推送到镜像之前，需要将本地镜像修改为对应的镜像仓库地址： mydemo 可以替换成自己的命名空间$ docker tag demo:v1 registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 $ docker push registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 123#### 3.4 登陆阿里云 ECS 机器来下载 demo:v1 镜像登陆 ECS 实例，通过 docker pull 来下载镜像 mydemo 请替换成 3.3 步骤中指定的命令空间$ docker pull registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 1下载完毕之后，我们就可以直接运行该镜像 $ docker run -d -p 8000:80 registry.cn-hangzhou.aliyuncs.com/mydemo/demo:v1 1并查看 ECS 机器的 `8000` 端口 $ curl localhost:8000 另外，可以移步 《课后实践：应用容器构建与部署》直接在阿里云大学沙箱实验环境中尝试哦！！ 本文由阿里云容器云平台团队撰写，如有问题或希望转载还请与我们沟通，谢谢！","link":"/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/%E7%AC%AC2%E8%AE%B2%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%AE%9E%E8%B7%B5.html"},{"title":"chrome 插件","text":"BlockTube - Chrome 网上应用店用很多规则屏蔽某些视频 recent history JSON Viewer Awesome - Chrome 网上应用店Linkclump-鼠标多选打开、复制标签页设置按住 z, 同时拖拽鼠标新标签页打开 c, 复制","link":"/Chrome/chrome-%E6%8F%92%E4%BB%B6.html"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"tricks","slug":"tricks","link":"/tags/tricks/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"you-get","slug":"you-get","link":"/tags/you-get/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","link":"/tags/Breadth-first-Search/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Depth-first Search","slug":"Depth-first-Search","link":"/tags/Depth-first-Search/"},{"name":"weekly","slug":"weekly","link":"/tags/weekly/"},{"name":"Union Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Backtracking","slug":"Backtracking","link":"/tags/Backtracking/"},{"name":"Greedy","slug":"Greedy","link":"/tags/Greedy/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/tags/Two-Pointers/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","link":"/tags/Hash-Table/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","link":"/tags/Divide-and-Conquer/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","link":"/tags/Bit-Manipulation/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"加密文章","slug":"加密文章","link":"/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"bio","slug":"bio","link":"/tags/bio/"},{"name":"nio","slug":"nio","link":"/tags/nio/"},{"name":"nowcoder","slug":"nowcoder","link":"/tags/nowcoder/"},{"name":"examination","slug":"examination","link":"/tags/examination/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"frontEnd","slug":"frontEnd","link":"/categories/frontEnd/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"private","slug":"private","link":"/categories/private/"},{"name":"theme","slug":"theme","link":"/categories/theme/"},{"name":"tricks","slug":"tricks","link":"/categories/tricks/"},{"name":"Collections","slug":"java/Collections","link":"/categories/java/Collections/"},{"name":"module test","slug":"java/module-test","link":"/categories/java/module-test/"},{"name":"other","slug":"java/other","link":"/categories/java/other/"},{"name":"taotao","slug":"java/taotao","link":"/categories/java/taotao/"},{"name":"基础","slug":"java/基础","link":"/categories/java/%E5%9F%BA%E7%A1%80/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"计算机基础/操作系统","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"天书","slug":"天书","link":"/categories/%E5%A4%A9%E4%B9%A6/"},{"name":"CNCF-×-Alibaba云原生技术公开课","slug":"天书/CNCF-×-Alibaba云原生技术公开课","link":"/categories/%E5%A4%A9%E4%B9%A6/CNCF-%C3%97-Alibaba%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"Chrome","slug":"Chrome","link":"/categories/Chrome/"}]}