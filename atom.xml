<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zronghui的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zronghui.github.io/"/>
  <updated>2020-08-20T12:58:17.000Z</updated>
  <id>https://zronghui.github.io/</id>
  
  <author>
    <name>zronghui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%A0%88.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%A0%88.html</id>
    <published>2020-08-19T12:14:51.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://leetcode-cn.com/tag/stack/">栈 - 力扣（LeetCode）</a></p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/submissions/">1019. 链表中的下一个更大节点 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/dan-diao-zhan-by-yi-wen-statistics-2/">单调栈 - 链表中的下一个更大节点 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/tag/stack/&quot;&gt;栈 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客 sql</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%89%9B%E5%AE%A2-sql.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%89%9B%E5%AE%A2-sql.html</id>
    <published>2020-08-17T09:10:44.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&&tqId=29753&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找最晚入职员工的所有信息_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by hire_date desc</span><br><span class="line">limit 1  -- 或者 limit 0, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&tqId=29753&rp=1&ru=%2Fta%2Fsql&qru=%2Fta%2Fsql%2Fquestion-ranking">查找入职员工时间排名倒数第三的员工所有信息_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by hire_date desc</span><br><span class="line">limit 2, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/6d35b1cd593545ab985a68cd86f28671?tpId=82&&tqId=29756&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有已经分配部门的员工的last_name和first_name以及dept_no_牛客网</a></p><p>三种等效的操作 , == join == inner join</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e, dept_emp AS d</span><br><span class="line">WHERE e.emp_no &#x3D; d.emp_no;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e JOIN dept_emp AS d</span><br><span class="line">ON e.emp_no&#x3D;d.emp_no;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e INNER JOIN dept_emp AS d</span><br><span class="line">ON e.emp_no&#x3D;d.emp_no;</span><br></pre></td></tr></table></figure><p>左连接：</p><p>left join 和 left outer join 是一样的，就是字面上有区别，执行结果是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name, first_name, dept_no</span><br><span class="line">from employees as e left join dept_emp as d</span><br><span class="line">on d.emp_no &#x3D; e.emp_no</span><br><span class="line">where d.dept_no not null;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&&tqId=29755&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找当前薪水详情以及部门编号dept_no_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s.*,d.dept_no</span><br><span class="line">from salaries as s inner join dept_manager as d</span><br><span class="line">on s.emp_no&#x3D;d.emp_no</span><br><span class="line">where d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by s.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/23142e7a23e4480781a3b978b5e0f33a?tpId=82&&tqId=29758&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有员工入职时候的薪水情况_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- group by  + having min(salary)</span><br><span class="line">select emp_no, salary</span><br><span class="line">from salaries</span><br><span class="line">group by emp_no</span><br><span class="line">having min(salary)</span><br><span class="line">order by emp_no desc</span><br><span class="line"></span><br><span class="line">-- e.hire_date&#x3D;s.from_date</span><br><span class="line">-- 注意，加上 s. e. </span><br><span class="line">select s.emp_no, s.salary</span><br><span class="line">from employees as e inner join salaries as s</span><br><span class="line">on e.emp_no&#x3D;s.emp_no and e.hire_date&#x3D;s.from_date</span><br><span class="line">order by s.emp_no desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/6d4a4cff1d58495182f536c548fee1ae?tpId=82&&tqId=29759&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找薪水变动超过15次的员工号emp_no以及其对应的变动次数t_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, count(salary) as t</span><br><span class="line">from salaries</span><br><span class="line">group by emp_no</span><br><span class="line">having count(salary)&gt;15</span><br><span class="line"></span><br><span class="line">-- 补充：如果考虑严格意义上的涨幅，应该写：</span><br><span class="line">select a.emp_no, count() t</span><br><span class="line">from salaries a inner join salaries b</span><br><span class="line">on a.emp_no&#x3D;b.emp_no and a.to_date&#x3D;b.from_date</span><br><span class="line">where a.salary &lt; b.salary</span><br><span class="line">group by a.emp_no</span><br><span class="line">having t&gt;15</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/ae51e6d057c94f6d891735a48d1c2397?tpId=82&&tqId=29760&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">找出所有员工当前薪水salary情况_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary</span><br><span class="line">from salaries</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by salary desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/4c8b4a10ca5b44189e411107e1d8bec1?tpId=82&&tqId=29761&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select d.dept_no, d.emp_no, s.salary</span><br><span class="line">from dept_manager as d inner join salaries as s</span><br><span class="line">on d.emp_no&#x3D;s.emp_no </span><br><span class="line">   and d.to_date&#x3D;&#39;9999-01-01&#39; </span><br><span class="line">   and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/32c53d06443346f4a2f2ca733c19660c?tpId=82&&tqId=29762&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有非manager的员工emp_no_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select emp_no</span><br><span class="line">from employees</span><br><span class="line">where emp_no not in (</span><br><span class="line">    select emp_no</span><br><span class="line">    from dept_manager</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82&&tqId=29763&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有员工当前的manager_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no</span><br><span class="line">from dept_emp as e inner join dept_manager as m</span><br><span class="line">on e.dept_no&#x3D;m.dept_no</span><br><span class="line">where e.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">      and m.to_date&#x3D;&#39;9999-01-01&#39; </span><br><span class="line">      and e.emp_no&lt;&gt;m.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&&tqId=29764&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取每个部门中当前员工薪水最高的相关信息_牛客网</a></p><p>用子查询，子查询内部可以在 where等地方 连接外部的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select d.dept_no, d.emp_no, s.salary</span><br><span class="line">from dept_emp as d inner join salaries as s</span><br><span class="line">on d.emp_no&#x3D;s.emp_no and d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">where s.salary&#x3D;(</span><br><span class="line">  select max(s1.salary)</span><br><span class="line">  from dept_emp as d1 inner join salaries as s1</span><br><span class="line">  on d1.emp_no&#x3D;s1.emp_no and d1.to_date&#x3D;&#39;9999-01-01&#39; and s1.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">  where d1.dept_no&#x3D;d.dept_no</span><br><span class="line">  group by d1.dept_no</span><br><span class="line">)</span><br><span class="line">order by d.dept_no asc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/72ca694734294dc78f513e147da7821e?tpId=82&&tqId=29765&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">从titles表获取按照title进行分组_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select title, count() as t</span><br><span class="line">from titles</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c59b452f420c47f48d9c86d69efdff20?tpId=82&&tqId=29766&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略。_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select title, count() as t</span><br><span class="line">from (</span><br><span class="line">    select distinct emp_no, title</span><br><span class="line">    from titles</span><br><span class="line">)</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p>补充：当DISTINCT应用到多个字段时，其应用范围是其后面的所有字段，而不是紧挨它的一个字段<br>注意：DISTINCT只能放在所有字段前面，所以上面的DISTINCT emp_no和title不可以交换</p><p>distinct 还能在 count 里面用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select title, count(distinct emp_no) as t</span><br><span class="line">from titles</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&&tqId=29767&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找employees表_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where last_name!&#x3D;&#39;Mary&#39;</span><br><span class="line">and emp_no%2&#x3D;1</span><br><span class="line">order by hire_date desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c8652e9e5a354b879e2a244200f1eaae?tpId=82&&tqId=29768&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">统计出当前各个title类型对应的员工当前薪水对应的平均工资_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select title, avg(salary)</span><br><span class="line">from titles as t inner join salaries as s</span><br><span class="line">on t.emp_no&#x3D;s.emp_no</span><br><span class="line">where t.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">group by title</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82&&tqId=29769&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取当前薪水第二多的员工的emp_no以及其对应的薪水salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary</span><br><span class="line">from salaries</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by salary desc</span><br><span class="line">limit 1, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&&tqId=29770&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取当前薪水第二多的员工的emp_no以及其对应的薪水salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 小于薪水最大的最大薪水</span><br><span class="line">select e.emp_no, max(salary), last_name, first_name</span><br><span class="line">from employees as e inner join salaries as s</span><br><span class="line">on e.emp_no&#x3D;s.emp_no</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39; and salary&lt;(</span><br><span class="line">    select max(salary)</span><br><span class="line">    from salaries</span><br><span class="line">    where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/5a7975fabe1146329cee4f670c27ad55?tpId=82&&tqId=29771&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有员工的last_name和first_name以及对应的dept_name_牛客网</a></p><p>好像不能直接三个表 join ，比如 a left join b on xx join c on xxx ，这是错误的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name, e.first_name, t.dept_name</span><br><span class="line">from employees as e left join (</span><br><span class="line">    select emp_no, dept_name</span><br><span class="line">    from dept_emp as de inner join departments as d</span><br><span class="line">    on d.dept_no&#x3D;de.dept_no</span><br><span class="line">) as t</span><br><span class="line">on e.emp_no&#x3D;t.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c727647886004942a89848e2b5130dc2?tpId=82&&tqId=29772&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找员工编号emp_no为10001其自入职以来的薪水salary涨幅(总共涨了多少)growth_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>blockchain/区块链共识算法的发展现状与展望-阅读笔记</title>
    <link href="https://zronghui.github.io/blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6%E4%B8%8E%E5%B1%95%E6%9C%9B-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
    <id>https://zronghui.github.io/blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6%E4%B8%8E%E5%B1%95%E6%9C%9B-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-08-14T00:38:15.000Z</published>
    <updated>2020-08-14T02:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链共识算法的发展现状与展望"><a href="#区块链共识算法的发展现状与展望" class="headerlink" title="区块链共识算法的发展现状与展望"></a><a href="https://kns.cnki.net/kcms/detail/detail.aspx?filename=MOTO201811009&dbcode=CJFD&dbname=CJFD2018&v=">区块链共识算法的发展现状与展望</a></h1><p>系统性地梳理和讨论了区块链发展过程中的32种重要共识算法</p><h2 id="主流共识算法"><a href="#主流共识算法" class="headerlink" title="主流共识算法"></a>主流共识算法</h2><h4 id="pow-工作量证明"><a href="#pow-工作量证明" class="headerlink" title="pow: 工作量证明"></a>pow: 工作量证明</h4><h4 id="PoS-权益证明"><a href="#PoS-权益证明" class="headerlink" title="PoS: 权益证明"></a>PoS: 权益证明</h4><p>由系统中具有最高权益而非最高算力的节点获得记账权, 其中权益体现为节点对特定数量货币的所有权, 称为币龄或币天数 (Coin days) .Po S一定程度上解决了PoW算力浪费的问题, 并能够缩短达成共识的时间, 因而比特币之后的许多竞争币都采用PoS共识算法.</p><p>PPC将PoW和PoS两种共识算法结合起来, 初期采用PoW挖矿方式以使得Token相对公平地分配给矿工, 后期随着挖矿难度增加, 系统将主要由PoS共识算法维护</p><h4 id="瑞波协议共识算法-RPCA"><a href="#瑞波协议共识算法-RPCA" class="headerlink" title="瑞波协议共识算法 ( RPCA)"></a>瑞波协议共识算法 ( RPCA)</h4><p>该共识算法解决了异步网络节点通讯时的高延迟问题, 通过使用集体信任的子网络 (Collectively-trusted subnetworks) , 在只需最小化信任和最小连通性的网络环境中实现了低延迟、高鲁棒性的拜占庭容错共识算法</p><h4 id="授权股份证明算法-DPoS"><a href="#授权股份证明算法-DPoS" class="headerlink" title="授权股份证明算法 (DPoS)"></a>授权股份证明算法 (DPoS)</h4><p>DPoS共识的基本思路类似于“董事会决策”, 即系统中每个节点可以将其持有的股份权益作为选票授予一个代表, 获得票数最多且愿意成为代表的前N个节点将进入“董事会”, 按照既定的时间表轮流对交易进行打包结算、并且签署 (即生产) 新区块</p><h4 id="Raft共识算法"><a href="#Raft共识算法" class="headerlink" title="Raft共识算法"></a>Raft共识算法</h4><h2 id="共识算法的模型与分类"><a href="#共识算法的模型与分类" class="headerlink" title="共识算法的模型与分类"></a>共识算法的模型与分类</h2><p>共识过程的核心是“选主”和“记账”两部分, 在具体操作过程中每一轮可以分为选主 (Leader election) 、造块 (Block generation) 、验证 (Data validation) 和上链 (Chain updation, 即记账) 4个阶段.4个阶段循环往复执行, 每执行一轮将会生成一个新区块</p><p>区块链共识算法可以根据其容错类型、部署方式和一致性程度等多个维度加以分类.</p><p>根据选主策略 (即函数f的具体实现方式) 将区块链共识算法分为选举类、证明类、随机类、联盟类和混合类共5种类型</p><p><strong>选举类共识</strong>:即矿工节点在每一轮共识过程中通过“投票选举”的方式选出当前轮次的记账节点, 首先获得半数以上选票的矿工节点将会获得记账权;多见于传统分布式一致性算法, 例如Paxos和Raft等.</p><p><strong>证明类共识</strong>:也可称为“Proof of X”类共识, 即矿工节点在每一轮共识过程中必须证明自己具有某种特定的能力, 证明方式通常是竞争性地完成某项难以解决但易于验证的任务, 在竞争中胜出的矿工节点将获得记账权;例如PoW和PoS等共识算法是基于矿工的算力或者权益来完成随机数搜索任务, 以此竞争记账权.</p><p><strong>随机类共识</strong>:即矿工节点根据某种随机方式直接确定每一轮的记账节点, 例如下文将要提到的Algorand和PoET共识算法等.</p><p><strong>联盟类共识</strong>:即矿工节点基于某种特定方式首先选举出一组代表节点, 而后由代表节点以轮流或者选举的方式依次取得记账权.这是一种以“代议制”为特点的共识算法, 例如DPoS等.</p><p><strong>混合类共识</strong>:即矿工节点采取多种共识算法的混合体来选择记账节点, 例如PoW+PoS混合共识、DPo S+BFT共识等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区块链共识算法的发展现状与展望&quot;&gt;&lt;a href=&quot;#区块链共识算法的发展现状与展望&quot; class=&quot;headerlink&quot; title=&quot;区块链共识算法的发展现状与展望&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://kns.cnki.net/kcms/detail
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pca 主成分分析</title>
    <link href="https://zronghui.github.io/python/pca-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html"/>
    <id>https://zronghui.github.io/python/pca-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.html</id>
    <published>2020-08-11T13:07:26.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use scikit-learn and perform PCA with k</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">pca1 = decomposition.PCA(n_components=<span class="number">1</span>)</span><br><span class="line">pc1 = pca1.fit_transform(X1)</span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'var'</span>:pca1.explained_variance_ratio_, <span class="string">'PC'</span>:[<span class="string">'PC1'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">pca2 = decomposition.PCA(n_components=<span class="number">2</span>)</span><br><span class="line">pc2 = pca2.fit_transform(X2)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'var'</span>:pca2.explained_variance_ratio_, <span class="string">'PC'</span>:[<span class="string">'PC1'</span>,<span class="string">'PC2'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">pca3 = decomposition.PCA(n_components=<span class="number">3</span>)</span><br><span class="line">pc3 = pca3.fit_transform(X3)</span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'var'</span>:pca3.explained_variance_ratio_, <span class="string">'PC'</span>:[<span class="string">'PC1'</span>,<span class="string">'PC2'</span>,<span class="string">'PC3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make a Scree plot</span></span><br><span class="line">print(<span class="string">'pca1.explained_variance_ratio_'</span>, pca1.explained_variance_ratio_)</span><br><span class="line">sns.barplot(x=<span class="string">'PC'</span>,y=<span class="string">"var"</span>, </span><br><span class="line">           data=df1, color=<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># make a Scree plot</span></span><br><span class="line">print(<span class="string">'pca2.explained_variance_ratio_'</span>, pca3.explained_variance_ratio_)</span><br><span class="line">sns.barplot(x=<span class="string">'PC'</span>,y=<span class="string">"var"</span>, </span><br><span class="line">           data=df2, color=<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># make a Scree plot</span></span><br><span class="line">print(<span class="string">'pca3.explained_variance_ratio_'</span>, pca3.explained_variance_ratio_)</span><br><span class="line">sns.barplot(x=<span class="string">'PC'</span>,y=<span class="string">"var"</span>, </span><br><span class="line">           data=df3, color=<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CPotnis/PCA_on_Breast_Cancer_Wisconsin_Data/blob/master/PCA_on_Breast_Cancer_Wisconsin.ipynb">PCA_on_Breast_Cancer_Wisconsin_Data/PCA_on_Breast_Cancer_Wisconsin.ipynb at master · CPotnis/PCA_on_Breast_Cancer_Wisconsin_Data</a><br><a href="https://cmdlinetips.com/2018/03/pca-example-in-python-with-scikit-learn/">PCA Example in Python with scikit-learn - Python and R Tips</a><br><a href="https://datascienceplus.com/principal-component-analysis-pca-with-python/">Principal Component Analysis (PCA) with Python | DataScience+</a><br><a href="https://medium.com/@skp2707/pca-on-cancer-dataset-4d7a97f5fdb8">PCA on Cancer dataset. Dimensionality reduction for… | by shekhar pandey | Medium</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zronghui.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>kmeans</title>
    <link href="https://zronghui.github.io/python/kmeans.html"/>
    <id>https://zronghui.github.io/python/kmeans.html</id>
    <published>2020-08-11T09:25:11.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://i.loli.net/2020/08/11/2p6PvxcKr1YhboQ.png" alt="image-20200811173514307"></p><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the random seed for repeatability</span></span><br><span class="line">np.random.seed(<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># set our constants for the dataset</span></span><br><span class="line">d = <span class="number">2</span>    <span class="comment"># dimensions</span></span><br><span class="line">m = <span class="number">100</span>  <span class="comment"># samples</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate m randomly-distributed d-dimensional samples</span></span><br><span class="line">X = np.random.random((m, d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the centers</span></span><br><span class="line">center_1 = [ <span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">center_2 = [<span class="number">-1</span>,<span class="number">2</span>]</span><br><span class="line">center_3 = [ <span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate 3 clusters each with m normally-distributed, 2-dimensional samples</span></span><br><span class="line">X1 = np.random.multivariate_normal(center_1, [[<span class="number">1</span>,  <span class="number">0.8</span>], [<span class="number">0.8</span>,  <span class="number">1</span>]],   size=m)</span><br><span class="line">X2 = np.random.multivariate_normal(center_2, [[<span class="number">0.3</span>,<span class="number">0.2</span>], [<span class="number">0.2</span>,<span class="number">0.3</span>]], size=m)</span><br><span class="line">X3 = np.random.multivariate_normal(center_3, [[<span class="number">1</span>,  <span class="number">0</span>],   [<span class="number">0</span>,  <span class="number">0.5</span>]], size=m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate the dataset matrix (3*m rows, d columns)</span></span><br><span class="line">X = np.append(X1, X2, axis=<span class="number">0</span>)</span><br><span class="line">X = np.append(X,  X3, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the scikit-learn model and pyplot</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### CODE HERE</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate and fit the model to the dataset using k clusters (your choice on how many -- I encourage you to do several and explore the performance)</span></span><br><span class="line">km = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">2</span>).fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the cluster centers and training examples using different colors for each cluster</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax.set_title(<span class="string">'K-Means'</span>)</span><br><span class="line">ax.scatter(X[:,<span class="number">0</span>], X[:,<span class="number">1</span>], c=km)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">km 是每个点分配的 label id 内容:</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=int32)</span><br></pre></td></tr></table></figure><p>结果：</p><img src="https://i.loli.net/2020/08/11/xzhR95BHVrFAIZb.png" alt="image-20200811173025348" style="zoom:25%;" /><p>random_state 的含义，为了设置 random.seed(random_state) 这样每次运行的结果就一致了</p><h2 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write your implementation of k-means clustering</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyKMeans</span><span class="params">(data, n_clusters=<span class="number">3</span>, max_iter=<span class="number">100</span>, random_state=<span class="number">2</span>)</span>:</span></span><br><span class="line">    random.seed(random_state)</span><br><span class="line">    <span class="comment"># 1. Randomly initialize the cluster centers</span></span><br><span class="line">    centers = random.choices(data, k=n_clusters)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestToCenter</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="comment"># return which center is (x, y) closest to</span></span><br><span class="line">        <span class="keyword">return</span> min(range(n_clusters), key=<span class="keyword">lambda</span> i: (x-centers[i][<span class="number">0</span>])**<span class="number">2</span>+(y-centers[i][<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. Repeat for `max_iter` iterations:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_iter):</span><br><span class="line">        <span class="comment"># 3. Assign training examples to the nearest cluster center</span></span><br><span class="line">        clusters = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_clusters)]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line">            clusters[closestToCenter(x, y)].append([x, y])</span><br><span class="line">        <span class="comment"># 4. Update the cluster centers by computing the mean of the cluster's assigned training examples</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_clusters):</span><br><span class="line">            <span class="keyword">if</span> len(clusters[i])!=<span class="number">0</span>:</span><br><span class="line">                centers[i][<span class="number">0</span>] = sum(x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> clusters[i])/len(clusters[i])</span><br><span class="line">                centers[i][<span class="number">1</span>] = sum(x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> clusters[i])/len(clusters[i])</span><br><span class="line">    <span class="keyword">return</span> [closestToCenter(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> data]</span><br><span class="line"><span class="comment"># generate and fit the model to the dataset using k clusters (your choice on how many -- I encourage you to do several and explore the performance)</span></span><br><span class="line">mykm = MyKMeans(data=X, n_clusters=<span class="number">3</span>, max_iter=<span class="number">100</span>, random_state=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the cluster centers and training examples using different colors for each cluster</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax.set_title(<span class="string">'My-K-Means'</span>)</span><br><span class="line">ax.scatter(X[:,<span class="number">0</span>], X[:,<span class="number">1</span>], c=mykm)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2020/08/11/vWutSNkz3JixjHG.png" alt="image-20200811172705457" style="zoom:25%;" />]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zronghui.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>matplotlib</title>
    <link href="https://zronghui.github.io/python/matplotlib.html"/>
    <id>https://zronghui.github.io/python/matplotlib.html</id>
    <published>2020-08-11T06:28:08.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h3 id="设置-xlabel-ylabel-title-显示网格线"><a href="#设置-xlabel-ylabel-title-显示网格线" class="headerlink" title="设置 xlabel ylabel title 显示网格线"></a>设置 xlabel ylabel title 显示网格线</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>)) <span class="comment">#</span></span><br><span class="line">ax = plt.gca() <span class="comment"># get current axes</span></span><br><span class="line">ax.set_xlabel(<span class="string">'theta'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'omega'</span>)</span><br><span class="line">ax.set_title(<span class="string">'theta_0=1/2, omega_0=0, n_end=200'</span>)</span><br><span class="line">ax.scatter(t1, t2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle = <span class="string">"-."</span>, color = <span class="string">"r"</span>, linewidth = <span class="string">"3"</span>)</span><br></pre></td></tr></table></figure><h3 id="设置-x-y-轴范围"><a href="#设置-x-y-轴范围" class="headerlink" title="设置 x y 轴范围"></a>设置 x y 轴范围</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br><span class="line">plt.ylim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br></pre></td></tr></table></figure><h3 id="画点、画线"><a href="#画点、画线" class="headerlink" title="画点、画线"></a>画点、画线</h3><h4 id="画线："><a href="#画线：" class="headerlink" title="画线："></a>画线：</h4><p>ax.plot(lx, ly, ‘r-‘) # 画红色实线</p><h4 id="画点"><a href="#画点" class="headerlink" title="画点:"></a>画点:</h4><p>ax.plot(x, y, marker=’.’, markersize=40, markerfacecolor=’red’)</p><p>更多 marker：</p><p><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.axes.Axes.plot.html">matplotlib.axes.Axes.plot — Matplotlib 3.1.2 documentation</a></p><p><strong>Markers</strong></p><table><thead><tr><th>character</th><th>description</th></tr></thead><tbody><tr><td><code>&#39;.&#39;</code></td><td>point marker</td></tr><tr><td><code>&#39;,&#39;</code></td><td>pixel marker</td></tr><tr><td><code>&#39;o&#39;</code></td><td>circle marker</td></tr><tr><td><code>&#39;v&#39;</code></td><td>triangle_down marker</td></tr><tr><td><code>&#39;^&#39;</code></td><td>triangle_up marker</td></tr><tr><td><code>&#39;&lt;&#39;</code></td><td>triangle_left marker</td></tr><tr><td><code>&#39;&gt;&#39;</code></td><td>triangle_right marker</td></tr><tr><td><code>&#39;1&#39;</code></td><td>tri_down marker</td></tr><tr><td><code>&#39;2&#39;</code></td><td>tri_up marker</td></tr><tr><td><code>&#39;3&#39;</code></td><td>tri_left marker</td></tr><tr><td><code>&#39;4&#39;</code></td><td>tri_right marker</td></tr><tr><td><code>&#39;s&#39;</code></td><td>square marker</td></tr><tr><td><code>&#39;p&#39;</code></td><td>pentagon marker</td></tr><tr><td><code>&#39;*&#39;</code></td><td>star marker</td></tr><tr><td><code>&#39;h&#39;</code></td><td>hexagon1 marker</td></tr><tr><td><code>&#39;H&#39;</code></td><td>hexagon2 marker</td></tr><tr><td><code>&#39;+&#39;</code></td><td>plus marker</td></tr><tr><td><code>&#39;x&#39;</code></td><td>x marker</td></tr><tr><td><code>&#39;D&#39;</code></td><td>diamond marker</td></tr><tr><td><code>&#39;d&#39;</code></td><td>thin_diamond marker</td></tr><tr><td>`’</td><td>‘`</td></tr><tr><td><code>&#39;_&#39;</code></td><td>hline marker</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t1, t2 = run_pendulum(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">xs = list(map(<span class="keyword">lambda</span> i: -sin(i), t1))</span><br><span class="line">ys = list(map(<span class="keyword">lambda</span> i: cos(i), t1))</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>)) <span class="comment">#</span></span><br><span class="line">ax = plt.gca() <span class="comment"># get current axes</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]:</span><br><span class="line">    x, y = xs[i], ys[i]</span><br><span class="line">    <span class="comment"># 画线 前一个列表是 x 后一个列表是 y </span></span><br><span class="line">    ax.plot([<span class="number">0</span>,x], [<span class="number">0</span>, y], <span class="string">"k"</span>) <span class="comment"># plot the black line</span></span><br><span class="line">    <span class="comment"># 画一个圆点，颜色是红，大小 40, 坐标 (x, y)</span></span><br><span class="line">    ax.plot(x, y, marker=<span class="string">'.'</span>, markersize=<span class="number">40</span>, markerfacecolor=<span class="string">'red'</span>) <span class="comment"># plot the red square</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the limits</span></span><br><span class="line">plt.xlim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br><span class="line">plt.ylim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br></pre></td></tr></table></figure><p><strong>Line Styles</strong></p><table><thead><tr><th>character</th><th>description</th></tr></thead><tbody><tr><td><code>&#39;-&#39;</code></td><td>solid line style</td></tr><tr><td><code>&#39;--&#39;</code></td><td>dashed line style</td></tr><tr><td><code>&#39;-.&#39;</code></td><td>dash-dot line style</td></tr><tr><td><code>&#39;:&#39;</code></td><td>dotted line style</td></tr></tbody></table><p>Example format strings:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#39;b&#39;    # blue markers with default shape</span><br><span class="line">&#39;or&#39;   # red circles</span><br><span class="line">&#39;-g&#39;   # green solid line</span><br><span class="line">&#39;--&#39;   # dashed line with default color</span><br><span class="line">&#39;^k:&#39;  # black triangle_up markers connected by a dotted line</span><br></pre></td></tr></table></figure><p><strong>Colors</strong></p><p>The supported color abbreviations are the single letter codes</p><table><thead><tr><th>character</th><th>color</th></tr></thead><tbody><tr><td><code>&#39;b&#39;</code></td><td>blue</td></tr><tr><td><code>&#39;g&#39;</code></td><td>green</td></tr><tr><td><code>&#39;r&#39;</code></td><td>red</td></tr><tr><td><code>&#39;c&#39;</code></td><td>cyan</td></tr><tr><td><code>&#39;m&#39;</code></td><td>magenta</td></tr><tr><td><code>&#39;y&#39;</code></td><td>yellow</td></tr><tr><td><code>&#39;k&#39;</code></td><td>black</td></tr><tr><td><code>&#39;w&#39;</code></td><td>white</td></tr></tbody></table><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>如果只有一个 plot 需要更新，直接返回就好</p><p>否则， updateALL 函数返回 plot 列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">t1, t2 = run_pendulum(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">xs = list(map(<span class="keyword">lambda</span> i: -sin(i), t1))</span><br><span class="line">ys = list(map(<span class="keyword">lambda</span> i: cos(i), t1))</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>)) <span class="comment">#</span></span><br><span class="line">ax = plt.gca() <span class="comment"># get current axes</span></span><br><span class="line">plot0, = ax.plot([<span class="number">0</span>,xs[<span class="number">0</span>]], [<span class="number">0</span>, ys[<span class="number">0</span>]], <span class="string">"k"</span>) <span class="comment"># plot the black line</span></span><br><span class="line">plot1, = ax.plot(xs[<span class="number">0</span>], ys[<span class="number">0</span>], marker=<span class="string">'.'</span>, markersize=<span class="number">40</span>, markerfacecolor=<span class="string">'red'</span>) <span class="comment"># plot the red square</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the limits</span></span><br><span class="line">plt.xlim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br><span class="line">plt.ylim((<span class="number">-1.1</span>, <span class="number">1.1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> FuncAnimation</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateALL</span><span class="params">(i)</span>:</span></span><br><span class="line">    plot1.set_xdata(xs[i])</span><br><span class="line">    plot1.set_ydata(ys[i])</span><br><span class="line">    plot0.set_xdata([<span class="number">0</span>, xs[i]])</span><br><span class="line">    plot0.set_ydata([<span class="number">0</span>, ys[i]])</span><br><span class="line">    <span class="keyword">return</span> [plot0, plot1]</span><br><span class="line">    </span><br><span class="line">anim = FuncAnimation(fig, updateALL, frames=range(<span class="number">0</span>, <span class="number">200</span>), interval=<span class="number">100</span>, repeat=<span class="literal">True</span>)</span><br><span class="line">HTML(anim.to_html5_video())</span><br></pre></td></tr></table></figure><h3 id="subplot-子图"><a href="#subplot-子图" class="headerlink" title="subplot 子图"></a>subplot 子图</h3><p><img src="https://i.loli.net/2020/08/11/ehdNzQDfJ96CF7s.png" alt="image-20200811162558483"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>, title=<span class="string">'"Neat" K-Means'</span>)</span><br><span class="line">plt.scatter(x_neat[:,<span class="number">0</span>], x_neat[:,<span class="number">1</span>], c=km_neat)</span><br><span class="line">plt.subplot(<span class="number">122</span>, title=<span class="string">'"Messy" K-Means'</span>)</span><br><span class="line">plt.scatter(x_messy[:,<span class="number">0</span>], x_messy[:,<span class="number">1</span>], c=km_messy)</span><br></pre></td></tr></table></figure><h3 id="设置-legend"><a href="#设置-legend" class="headerlink" title="设置 legend"></a>设置 legend</h3><p>legend 是啥：</p><p><a href="https://zhuanlan.zhihu.com/p/41781440">Matplotlib 系列之「Legend 图例」 - 知乎</a></p><img src="https://i.loli.net/2020/08/11/xRawbpZmgPCt7UT.jpg" alt="img" style="zoom:50%;" /><p>可以同时设置多条线的 legend </p><p>plt.legend(handles=[s1],labels=[‘theta_0=1/2, omega_0=0, n_end=200’],loc=’best’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>)) <span class="comment">#</span></span><br><span class="line">ax = plt.gca() <span class="comment"># get current axes</span></span><br><span class="line">ax.set_xlabel(<span class="string">'theta'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'omega'</span>)</span><br><span class="line"><span class="comment"># ax.set_title('theta_0=1/2, omega_0=0, n_end=200')</span></span><br><span class="line">s1 = ax.scatter(t1, t2)</span><br><span class="line">plt.legend(handles=[s1],labels=[<span class="string">'theta_0=1/2, omega_0=0, n_end=200'</span>],loc=<span class="string">'best'</span>)</span><br><span class="line">ax</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zronghui.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>石子游戏</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F.html</id>
    <published>2020-08-09T12:44:09.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="877-石子游戏-力扣（LeetCode）"><a href="#877-石子游戏-力扣（LeetCode）" class="headerlink" title="877. 石子游戏 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏 - 力扣（LeetCode）</a></h3><p>一把过，可以的。dp 初始化 0 是因为 gap 0时 dp 为 piles 的值，gap&gt;0时用的是 gap-1 的值，所以 dp 初始化成什么都无所谓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][j] = max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])# i&lt;j</span></span><br><span class="line">        <span class="comment"># 遍历顺序: 由短到长 dp[0][0] -&gt; dp[0][n-1] gap: 0~n-1</span></span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n-gap):</span><br><span class="line">                j = i+gap</span><br><span class="line">                <span class="keyword">if</span> gap==<span class="number">0</span>: dp[i][j] = piles[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(piles[i]-dp[i+<span class="number">1</span>][j], piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># for i in dp: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="1140-石子游戏-II-力扣（LeetCode）"><a href="#1140-石子游戏-II-力扣（LeetCode）" class="headerlink" title="1140. 石子游戏 II - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/stone-game-ii/">1140. 石子游戏 II - 力扣（LeetCode）</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameII</span><span class="params">(self, piles: List[int])</span> -&gt; int:</span></span><br><span class="line">        piles.reverse() <span class="comment"># 从后往前拿石子, 方便遍历</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 4 4 9 7 2</span></span><br><span class="line">        <span class="comment"># dp[i][m]: 前 i 个石子，M=m 时赢的石子数目 m&gt;=1</span></span><br><span class="line">        <span class="comment"># dp[i][m] = max(sum(piles[i+1-x:i+1])-dp[i-x][max(m, x)] for x in range(1, 2*m+1))</span></span><br><span class="line">        <span class="comment"># 推导公式解释：拿 x(1~2m) 个石子 newM = max(m, x)</span></span><br><span class="line">        <span class="comment"># 遍历顺序: i: 0-&gt;n-1  m:1-&gt;i+1</span></span><br><span class="line">        <span class="comment"># return dp[-1][1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            _sum = sum(piles[:i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span>*m&gt;=i+<span class="number">1</span>:</span><br><span class="line">                    dp[i][m] = _sum</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][m] = max(sum(piles[i+<span class="number">1</span>-x:i+<span class="number">1</span>])-dp[i-x][max([m, x])] <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">2</span>*m+<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># x+x+a = sum (x+a 比 x 多拿 a 个)</span></span><br><span class="line">        <span class="comment"># x+a = (sum+a)/2</span></span><br><span class="line">        <span class="keyword">return</span> (sum(piles)+dp[<span class="number">-2</span>][<span class="number">1</span>])//<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1406-石子游戏-III-力扣（LeetCode）"><a href="#1406-石子游戏-III-力扣（LeetCode）" class="headerlink" title="1406. 石子游戏 III - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/stone-game-iii/">1406. 石子游戏 III - 力扣（LeetCode）</a></h3><p>最近写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameIII</span><span class="params">(self, stones: List[int])</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(x)</span>:</span></span><br><span class="line">            print(x)</span><br><span class="line">            <span class="keyword">if</span> x&gt;<span class="number">0</span>: <span class="keyword">return</span> <span class="string">'Alice'</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span>: <span class="keyword">return</span> <span class="string">'Bob'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Tie'</span></span><br><span class="line"></span><br><span class="line">        n = len(stones)</span><br><span class="line">        nums = stones[::<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># dp[i]: alice 在 i 位置赢得石子数量</span></span><br><span class="line">        <span class="comment"># dp[i] = max(sum(nums[i-j:i+1])-dp[i-j] for j in range(3))</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i+<span class="number">1</span>] = max(sum(nums[i-j:i+<span class="number">1</span>])-dp[i-j] <span class="keyword">for</span> j <span class="keyword">in</span> range(min(n<span class="number">-1</span>, <span class="number">3</span>)))</span><br><span class="line">        <span class="keyword">return</span> score(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>4 月前写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameIII</span><span class="params">(self, l: List[int])</span> -&gt; str:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l))]</span><br><span class="line">        dp[<span class="number">-1</span>] = l[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(l)&gt;<span class="number">1</span>:</span><br><span class="line">            dp[<span class="number">-2</span>] = max(l[<span class="number">-2</span>]-dp[<span class="number">-1</span>], sum(l[<span class="number">-2</span>:]))</span><br><span class="line">        <span class="keyword">if</span> len(l)&gt;<span class="number">2</span>:</span><br><span class="line">            dp[<span class="number">-3</span>] = max(l[<span class="number">-3</span>]-dp[<span class="number">-2</span>], l[<span class="number">-3</span>]+l[<span class="number">-2</span>]-dp[<span class="number">-1</span>], sum(l[<span class="number">-3</span>:]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)<span class="number">-4</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = max(l[i]-dp[i+<span class="number">1</span>], l[i]+l[i+<span class="number">1</span>]-dp[i+<span class="number">2</span>], l[i]+l[i+<span class="number">1</span>]+l[i+<span class="number">2</span>]-dp[i+<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Alice'</span> <span class="keyword">if</span> dp[<span class="number">0</span>]&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">'Bob'</span> <span class="keyword">if</span> dp[<span class="number">0</span>]&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">'Tie'</span></span><br></pre></td></tr></table></figure><p>感觉都有点不好读</p><h3 id="1510-石子游戏-IV-力扣（LeetCode）"><a href="#1510-石子游戏-IV-力扣（LeetCode）" class="headerlink" title="1510. 石子游戏 IV - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/stone-game-iv/">1510. 石子游戏 IV - 力扣（LeetCode）</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">winnerSquareGame</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j*j&lt;=i:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dp[i-j*j]:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-201</title>
    <link href="https://zronghui.github.io/weekly-contest-201.html"/>
    <id>https://zronghui.github.io/weekly-contest-201.html</id>
    <published>2020-08-09T08:13:35.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">找出第 N 个二进制字符串中的第 K 位</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值的最大数目不重叠非空子数组数目</a><strong>6</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/">切棍子的最小成本</a><strong>7</strong></li></ul><p>公开处刑</p><p><img src="https://i.loli.net/2020/08/09/X9RbtwhnNxVi86q.png" alt="image-20200809191851010"></p><a id="more"></a><p><a href="https://www.bilibili.com/video/av754126490">[LeetCode] Weekly Contest 201 (rank 50)[1544,1545,1546,1547][OTTFF]_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>解释的很好</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeGood</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        t = abs(ord(<span class="string">'a'</span>)-ord(<span class="string">'A'</span>))</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> abs(ord(c)-ord(stack[<span class="number">-1</span>]))==t: stack.pop()</span><br><span class="line">            <span class="keyword">else</span>: stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = &#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">21</span>):</span><br><span class="line">            self.d[i] = self.d[i<span class="number">-1</span>]*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> n==k==<span class="number">1</span>: <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        a = self.d[n]//<span class="number">2</span> <span class="comment"># length = 2a+1</span></span><br><span class="line">        <span class="keyword">if</span> k==a+<span class="number">1</span>: <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;a: <span class="keyword">return</span> <span class="string">'10'</span>[int(self.findKthBit(n<span class="number">-1</span>, <span class="number">2</span>*a-k+<span class="number">2</span>))]</span><br><span class="line">        <span class="keyword">if</span> k&lt;=a: <span class="keyword">return</span> self.findKthBit(n<span class="number">-1</span>, k)</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># -1 3 5 1 4 2 -9</span></span><br><span class="line">        <span class="comment"># -1 2 7 8 12 14 5</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">2</span>)] <span class="comment"># 前 i 个数最多有多少个符合条件的</span></span><br><span class="line">        presum = &#123;<span class="number">0</span>: <span class="number">-2</span>&#125; <span class="comment"># presum: i  0~i 的和为 presum ，i 保留较大的</span></span><br><span class="line">        s = <span class="number">0</span>        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            s += nums[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> s-target <span class="keyword">in</span> presum:</span><br><span class="line">                p = presum[s-target]</span><br><span class="line">                dp[i] = max(dp[i<span class="number">-1</span>], dp[p+<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">            presum[s] = i<span class="number">-1</span></span><br><span class="line">        <span class="comment"># print(presum, dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, n: int, cuts: List[int])</span> -&gt; int:</span></span><br><span class="line">        cuts.extend([<span class="number">0</span>, n])</span><br><span class="line">        cuts.sort()</span><br><span class="line">        m = len(cuts)</span><br><span class="line">        <span class="comment"># dp[i][j] cut[i]~cut[j] 间最低成本</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i][k]+dp[k][j]+(cuts[j]-cuts[i]))  i&lt;k&lt;j</span></span><br><span class="line">        <span class="comment"># 要求 dp[i][j] 需要 dp[i][k] dp[k][j] 特点： 长度比 j-i 短</span></span><br><span class="line">        <span class="comment"># 所以遍历顺序 从短到长 j-i&lt;2 时 dp 为 0  如 0 1 2 3 中 dp[1][1]=dp[1][2]=0</span></span><br><span class="line">        dp = [[sys.maxsize]*m <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span>: dp[i][i<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;m<span class="number">-1</span>: dp[i][i+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(<span class="number">2</span>, m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m-gap):</span><br><span class="line">                j = i+gap</span><br><span class="line">                lenij = cuts[j]-cuts[i]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i+<span class="number">1</span>, j):</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+lenij)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/make-the-string-great/&quot;&gt;整理字符串&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/&quot;&gt;找出第 N 个二进制字符串中的第 K 位&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/&quot;&gt;和为目标值的最大数目不重叠非空子数组数目&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/&quot;&gt;切棍子的最小成本&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公开处刑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/09/X9RbtwhnNxVi86q.png&quot; alt=&quot;image-20200809191851010&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>biweekly-contest-32</title>
    <link href="https://zronghui.github.io/biweekly-contest-32.html"/>
    <id>https://zronghui.github.io/biweekly-contest-32.html</id>
    <published>2020-08-09T00:48:03.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/kth-missing-positive-number/">第 k 个缺失的正整数</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves/">K 次操作转变字符串</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/">平衡括号字符串的最少插入次数</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/find-longest-awesome-substring/">找出最长的超赞子字符串</a><strong>6</strong></li></ul><p>菜！</p><p><img src="https://i.loli.net/2020/08/09/Bf1OwNyg4ojLp9z.png" alt="image-20200809084943831"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthPositive</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        s = set(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3000</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt==k: <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConvertString</span><span class="params">(self, s: str, t: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n!=len(t): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            diffn = (ord(t[i])-ord(s[i]))%<span class="number">26</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> diffn: <span class="keyword">continue</span></span><br><span class="line">            d[diffn] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (d[diffn]<span class="number">-1</span>)*<span class="number">26</span>+diffn&gt;k: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/kth-missing-positive-number/&quot;&gt;第 k 个缺失的正整数&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/can-convert-string-in-k-moves/&quot;&gt;K 次操作转变字符串&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/&quot;&gt;平衡括号字符串的最少插入次数&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-longest-awesome-substring/&quot;&gt;找出最长的超赞子字符串&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;菜！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/09/Bf1OwNyg4ojLp9z.png&quot; alt=&quot;image-20200809084943831&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/SQL.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/SQL.html</id>
    <published>2020-08-08T10:45:31.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="176-第二高的薪水-力扣（LeetCode）"><a href="#176-第二高的薪水-力扣（LeetCode）" class="headerlink" title="176. 第二高的薪水 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水 - 力扣（LeetCode）</a></h3><p>ifnull(x，y)，若x不为空则返回x，否则返回y，这道题y=null<br>limit x，y </p><p>limit x offset y == limit x, y</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span></span><br><span class="line">    ((<span class="keyword">select</span> <span class="keyword">distinct</span> salary</span><br><span class="line">     <span class="keyword">from</span> Employee</span><br><span class="line">     <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">     <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>), <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>递增序列</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html</id>
    <published>2020-08-08T06:23:40.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="300-最长上升子序列-力扣（LeetCode）"><a href="#300-最长上升子序列-力扣（LeetCode）" class="headerlink" title="300. 最长上升子序列 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列 - 力扣（LeetCode）</a></h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">动态规划 、优化（以贪心和二分作为子过程） - 最长上升子序列 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">                    res = max(res, dp[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">动态规划 、优化（以贪心和二分作为子过程） - 最长上升子序列 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/">动态规划设计方法&amp;&amp;纸牌游戏讲解二分解法 - 最长上升子序列 - 力扣（LeetCode）</a></p><p>看到 2 种优化思路，虽然都是二分，但是感觉第一种好理解一些，第二种太扯了</p><p><strong><code>tail[i]</code> 表示长度为 <code>i+1</code> 的</strong>所有<strong>上升子序列的结尾的最小值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, insort</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        tails = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            idx = bisect_left(tails, nums[i])</span><br><span class="line">            <span class="keyword">if</span> idx==len(tails): tails.append(nums[i])</span><br><span class="line">            <span class="keyword">else</span>: tails[idx] = min(tails[idx], nums[i])</span><br><span class="line">        <span class="comment"># print(tails)</span></span><br><span class="line">        <span class="keyword">return</span> len(tails)</span><br></pre></td></tr></table></figure><h3 id="673-最长递增子序列的个数-力扣（LeetCode）"><a href="#673-最长递增子序列的个数-力扣（LeetCode）" class="headerlink" title="673. 最长递增子序列的个数 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数 - 力扣（LeetCode）</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 以 i 结尾的最长序列的长度</span></span><br><span class="line">        count = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># i 位置最长序列个数</span></span><br><span class="line">        m = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    m = max(m, dp[j]+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> dp[j]+<span class="number">1</span>&gt;dp[i]:</span><br><span class="line">                        dp[i] = dp[j]+<span class="number">1</span></span><br><span class="line">                        count[i] = count[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j]+<span class="number">1</span>==dp[i]:</span><br><span class="line">                        count[i] += count[j]</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="comment"># print(count)</span></span><br><span class="line">        <span class="keyword">return</span> sum(count[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> dp[i]==m)</span><br></pre></td></tr></table></figure><h3 id="354-俄罗斯套娃信封问题-力扣（LeetCode）"><a href="#354-俄罗斯套娃信封问题-力扣（LeetCode）" class="headerlink" title="354. 俄罗斯套娃信封问题 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/submissions/">354. 俄罗斯套娃信封问题 - 力扣（LeetCode）</a></h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/zui-chang-di-zeng-zi-xu-lie-kuo-zhan-dao-er-wei-er/">最长递增子序列扩展到二维而已 - 俄罗斯套娃信封问题 - 力扣（LeetCode）</a></p><p>宽度 w 升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序.之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案</p><img src="https://i.loli.net/2020/08/08/gDHSBoWCQi1ntqf.png" alt="image-20200808150728950" style="zoom:33%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span><span class="params">(self, envelopes: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 宽度 w 升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序</span></span><br><span class="line">        <span class="comment"># 之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> i: (i[<span class="number">0</span>], -i[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(envelopes)</span></span><br><span class="line">        <span class="keyword">return</span> self.lengthOfLIS([i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> envelopes])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        tails = [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            idx = bisect_left(tails, num)</span><br><span class="line">            <span class="keyword">if</span> idx==len(tails): tails.append(num)</span><br><span class="line">            <span class="keyword">else</span>: tails[idx] = min(tails[idx], num)</span><br><span class="line">        <span class="comment"># print(tails)</span></span><br><span class="line">        <span class="keyword">return</span> len(tails)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>统计矩形</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%BB%9F%E8%AE%A1%E7%9F%A9%E5%BD%A2.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%BB%9F%E8%AE%A1%E7%9F%A9%E5%BD%A2.html</id>
    <published>2020-08-08T02:29:27.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="221-最大正方形-力扣（LeetCode）"><a href="#221-最大正方形-力扣（LeetCode）" class="headerlink" title="221. 最大正方形 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形 - 力扣（LeetCode）</a></h3><p><a href="https://leetcode-cn.com/problems/maximal-square/solution/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/">理解 三者取最小+1 - 最大正方形 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, m = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">'0'</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    res = max(res, dp[i][j])</span><br><span class="line">        <span class="comment"># for i in dp: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure><h3 id="1277-统计全为-1-的正方形子矩阵-力扣（LeetCode）"><a href="#1277-统计全为-1-的正方形子矩阵-力扣（LeetCode）" class="headerlink" title="1277. 统计全为 1 的正方形子矩阵 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵 - 力扣（LeetCode）</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp[i][j]: 以 i,j 位置为右下角的最大正方形边长</span></span><br><span class="line">        <span class="comment"># dp[i][j] 同时也是以 i,j 位置为右下角的正方形个数</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, m = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">                    res += dp[i][j]</span><br><span class="line">        <span class="comment"># for i in dp: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1504-统计全-1-子矩形-力扣（LeetCode）"><a href="#1504-统计全-1-子矩形-力扣（LeetCode）" class="headerlink" title="1504. 统计全 1 子矩形 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/">1504. 统计全 1 子矩形 - 力扣（LeetCode）</a></h3><p><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/solution/5454-tong-ji-quan-1-zi-ju-xing-by-lin-miao-miao/">5454. 统计全 1 子矩形 - 统计全 1 子矩形 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmat</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># left[i][j]: (i.j)统计他这行左边到他这个位置最多有几个连续的1</span></span><br><span class="line">        <span class="comment"># 对于每个点(i.j)，我们固定子矩形的右下角为(i.j)，利用left从该行i向上寻找子矩阵左上角为第k行的矩阵个数。每次将子矩阵个数加到答案中即可</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n, m = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        left = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> mat[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                left[i][j] = left[i][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                _min = left[i][j]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> reversed(range(i+<span class="number">1</span>)):</span><br><span class="line">                    _min = min(_min, left[k][j])</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> _min: <span class="keyword">break</span></span><br><span class="line">                    res += _min</span><br><span class="line">        <span class="comment"># for i in mat: print(i)</span></span><br><span class="line">        <span class="comment"># for i in left: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1139-最大的以-1-为边界的正方形-力扣（LeetCode）"><a href="#1139-最大的以-1-为边界的正方形-力扣（LeetCode）" class="headerlink" title="1139. 最大的以 1 为边界的正方形 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/largest-1-bordered-square/">1139. 最大的以 1 为边界的正方形 - 力扣（LeetCode）</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largest1BorderedSquare</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录 i,j 位置 向左、向上 有多少连续的 1</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        l = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> grid[i<span class="number">-1</span>][j<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                l[i][j][<span class="number">0</span>] += l[i][j<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                l[i][j][<span class="number">1</span>] += l[i<span class="number">-1</span>][j][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> reversed(range(min(l[i][j]))):</span><br><span class="line">                    <span class="keyword">if</span> min(l[i-k][j][<span class="number">0</span>], l[i][j-k][<span class="number">1</span>])&gt;=k+<span class="number">1</span>:</span><br><span class="line">                        res = max(res, k+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># for i in grid: print(i)</span></span><br><span class="line">        <span class="comment"># for i in l: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 778. Swim in Rising Water</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-7**/leetcode-778-Swim-in-Rising-Water.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-7**/leetcode-778-Swim-in-Rising-Water.html</id>
    <published>2020-08-06T11:27:31.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/swim-in-rising-water/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/swim-in-rising-water/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that<br>point <code>(i,j)</code>.</p><p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is<br><code>t</code>. You can swim from a square to another 4-directionally adjacent square if<br>and only if the elevation of both squares individually are at most <code>t</code>. You<br>can swim infinite distance in zero time. Of course, you must stay within the<br>boundaries of the grid during your swim.</p><p>You start at the top left square <code>(0, 0)</code>. What is the least time until you<br>can reach the bottom right square <code>(N-1, N-1)</code>?</p><p><strong>Example 1:</strong></p><pre><code>Input: [[0,2],[1,3]]Output: 3Explanation:At time 0, you are in grid location (0, 0).You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.You cannot reach point (1, 1) until time 3.When the depth of water is 3, we can swim anywhere inside the grid.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]Output: 16Explanation:**0  1  2  3  4**24 23 22 21  **5****12 13 14 15 16****11** 17 18 19 20**10  9  8  7  6**The final route is marked in bold.We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</code></pre><p><strong>Note:</strong></p><ol><li><code>2 &lt;= N &lt;= 50</code>.</li><li>grid[i][j] is a permutation of [0, …, N*N - 1].</li></ol><p><strong>Tags:</strong> Binary Search, Heap, Depth-first Search, Union Find</p><p><strong>Difficulty:</strong> Hard</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><p><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/you-xian-dui-lie-fa-yi-ji-wei-he-hui-xiang-dao-you/">优先队列法，以及为何会想到优先队列法 - 水位上升的泳池中游泳 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> insort</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = deque() <span class="comment"># (value, i, j), ,</span></span><br><span class="line">        l.append((grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        n = len(grid)</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            v, i, j = l.popleft()</span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># print(v)</span></span><br><span class="line">            res = max(v, res)</span><br><span class="line">            <span class="keyword">if</span> i==j==n<span class="number">-1</span>: <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">-1</span>],[<span class="number">1</span>, <span class="number">0</span>],[<span class="number">-1</span>, <span class="number">0</span>]]:</span><br><span class="line">                ii, jj = i+di, j+dj</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=ii&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=jj&lt;n <span class="keyword">and</span> <span class="keyword">not</span> visited[ii][jj]:</span><br><span class="line">                    insort(l, [grid[ii][jj], ii, jj])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/swim-in-rising-water/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/swim-in-rising-water/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;On an N x N &lt;code&gt;grid&lt;/code&gt;, each square &lt;code&gt;grid[i][j]&lt;/code&gt; represents the elevation at that&lt;br&gt;point &lt;code&gt;(i,j)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now rain starts to fall. At time &lt;code&gt;t&lt;/code&gt;, the depth of the water everywhere is&lt;br&gt;&lt;code&gt;t&lt;/code&gt;. You can swim from a square to another 4-directionally adjacent square if&lt;br&gt;and only if the elevation of both squares individually are at most &lt;code&gt;t&lt;/code&gt;. You&lt;br&gt;can swim infinite distance in zero time. Of course, you must stay within the&lt;br&gt;boundaries of the grid during your swim.&lt;/p&gt;
&lt;p&gt;You start at the top left square &lt;code&gt;(0, 0)&lt;/code&gt;. What is the least time until you&lt;br&gt;can reach the bottom right square &lt;code&gt;(N-1, N-1)&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
**0  1  2  3  4**
24 23 22 21  **5**
**12 13 14 15 16**
**11** 17 18 19 20
**10  9  8  7  6**

The final route is marked in bold.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= N &amp;lt;= 50&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;grid[i][j] is a permutation of [0, …, N*N - 1].&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Binary Search, Heap, Depth-first Search, Union Find&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Hard&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-7**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-7/"/>
    
    
      <category term="Depth-first Search" scheme="https://zronghui.github.io/tags/Depth-first-Search/"/>
    
      <category term="Union Find" scheme="https://zronghui.github.io/tags/Union-Find/"/>
    
      <category term="Binary Search" scheme="https://zronghui.github.io/tags/Binary-Search/"/>
    
      <category term="Heap" scheme="https://zronghui.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%B9%B6%E6%9F%A5%E9%9B%86.html</id>
    <published>2020-08-05T09:08:28.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="721-账户合并-力扣（LeetCode）"><a href="#721-账户合并-力扣（LeetCode）" class="headerlink" title="721. 账户合并 - 力扣（LeetCode）"></a>721. 账户合并 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/accounts-merge/submissions/">721. 账户合并 - 力扣（LeetCode）</a><br><a href="https://leetcode.com/articles/accounts-merge/">Accounts Merge - LeetCode Articles</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">10001</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]: x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        email_id, email_name = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="comment"># account 里都在一个集合里</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> accounts:</span><br><span class="line">            name = l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> l[<span class="number">1</span>:]:</span><br><span class="line">                email_name[email] = name</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">not</span> <span class="keyword">in</span> email_id:</span><br><span class="line">                    email_id[email] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                dsu.union(email_id[l[<span class="number">1</span>]], email_id[email])</span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> email_name:</span><br><span class="line">            ans[dsu.find(email_id[email])].append(email)</span><br><span class="line">        <span class="keyword">return</span> [[email_name[i[<span class="number">0</span>]], *sorted(i)] <span class="keyword">for</span> i <span class="keyword">in</span> ans.values()]</span><br></pre></td></tr></table></figure><h3 id="684-冗余连接-力扣（LeetCode）"><a href="#684-冗余连接-力扣（LeetCode）" class="headerlink" title="684. 冗余连接 - 力扣（LeetCode）"></a>684. 冗余连接 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/redundant-connection/comments/">684. 冗余连接 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/">通俗讲解并查集，帮助小白快速理解 - 冗余连接 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""并查集"""</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    记录1到N的每个数的根，因为如果有环，导致环相连的[u, v]一定有相同的root，</span></span><br><span class="line"><span class="string">    我们可以理解为是一个节点的两个分支，通过[u,v]被连起来了，既然他们是一个节点的两个分支，那么他们一定有相同的root，所以直接移除[u,v]就好啦。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        root = list(range(len(edges)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i!=root[i]:</span><br><span class="line">                i = root[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            uroot, vroot = map(find, [u, v])</span><br><span class="line">            <span class="keyword">if</span> uroot!=vroot:</span><br><span class="line">                root[uroot] = vroot</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [u, v]</span><br></pre></td></tr></table></figure><h3 id="399-除法求值-力扣（LeetCode）"><a href="#399-除法求值-力扣（LeetCode）" class="headerlink" title="399. 除法求值 - 力扣（LeetCode）"></a>399. 除法求值 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值 - 力扣（LeetCode）</a></p><h4 id="flyod"><a href="#flyod" class="headerlink" title="flyod"></a>flyod</h4><p>不是用索引表示的 edges</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="comment"># flyod</span></span><br><span class="line">        edges = collections.defaultdict(dict)</span><br><span class="line">        verts = set()</span><br><span class="line">        <span class="keyword">for</span> (a, b), c <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            edges[a][b] = c</span><br><span class="line">            edges[b][a] = <span class="number">1</span>/c</span><br><span class="line">            verts.add(a)</span><br><span class="line">            verts.add(b)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> verts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> verts:</span><br><span class="line">                <span class="keyword">if</span> i==k: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> verts:</span><br><span class="line">                    <span class="comment"># 若存在 edges[i][j] 不用再计算一遍</span></span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">in</span> [i, k] <span class="keyword">or</span> j <span class="keyword">in</span> edges[i]: <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 同时存在 edges[i][k] edges[k][j] 时更新</span></span><br><span class="line">                    <span class="keyword">if</span> k <span class="keyword">in</span> edges[i] <span class="keyword">and</span> j <span class="keyword">in</span> edges[k]:</span><br><span class="line">                        edges[i][j] = edges[i][k]*edges[k][j]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> a==b <span class="keyword">and</span> a <span class="keyword">in</span> verts <span class="keyword">and</span> b <span class="keyword">in</span> verts: res.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> a <span class="keyword">in</span> edges <span class="keyword">and</span> b <span class="keyword">in</span> edges[a]: res.append(edges[a][b])</span><br><span class="line">            <span class="keyword">else</span>: res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        edges = collections.defaultdict(dict)</span><br><span class="line">        verts = set()</span><br><span class="line">        <span class="keyword">for</span> (a, b), c <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            edges[a][b] = c</span><br><span class="line">            edges[b][a] = <span class="number">1</span>/c</span><br><span class="line">            verts.add(a)</span><br><span class="line">            verts.add(b)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, t)</span>:</span></span><br><span class="line">            visited.add(s)</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> edges[s]: <span class="keyword">return</span> edges[s][t]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> edges[s]:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    temp = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> temp!=<span class="number">-1</span>:</span><br><span class="line">                        edges[s][t] = edges[s][node]*temp</span><br><span class="line">                        <span class="keyword">return</span> edges[s][t]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> verts <span class="keyword">and</span> b <span class="keyword">in</span> verts:</span><br><span class="line">                <span class="keyword">if</span> a==b:res.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited = set()</span><br><span class="line">                    res.append(dfs(a, b))</span><br><span class="line">            <span class="keyword">else</span>: res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="785-判断二分图-力扣（LeetCode）"><a href="#785-判断二分图-力扣（LeetCode）" class="headerlink" title="785. 判断二分图 - 力扣（LeetCode）"></a>785. 判断二分图 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/">BFS + DFS + 并查集，三种方法判断二分图 - 判断二分图 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 染色+xfs 或 并查集</span></span><br><span class="line">        <span class="comment"># 图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        l = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0 没访问，1 -1 表示2种颜色</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 染过色了，跳过</span></span><br><span class="line">            <span class="keyword">if</span> l[i]: <span class="keyword">continue</span></span><br><span class="line">            l[i] = <span class="number">1</span> <span class="comment"># 随便染个 1</span></span><br><span class="line">            <span class="comment"># i 染色后，把相关的所有节点都染上色</span></span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                v = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]:</span><br><span class="line">                    <span class="keyword">if</span> l[w]==<span class="number">0</span>:</span><br><span class="line">                        l[w] = -l[v]</span><br><span class="line">                        queue.append(w)</span><br><span class="line">                    <span class="keyword">elif</span> l[w]==l[v]: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 已经染的色不对劲</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>学会后，并查集还是很好写的，毕竟一半都是模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">101</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> len(graph[i])==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># graph[i] 是 i 顶点的所有邻接点，他们属于同一个集合</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[i]:</span><br><span class="line">                dsu.union(graph[i][<span class="number">0</span>], node)</span><br><span class="line">            <span class="comment"># 但是 i 与他们不是一个集合</span></span><br><span class="line">            <span class="keyword">if</span> dsu.same(i, graph[i][<span class="number">0</span>]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>相似的一道题</p><h3 id="886-可能的二分法-力扣（LeetCode）"><a href="#886-可能的二分法-力扣（LeetCode）" class="headerlink" title="886. 可能的二分法 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法 - 力扣（LeetCode）</a></h3><p>染色还是快很多的</p><p><img src="https://i.loli.net/2020/08/11/LseqQhjKOCMWawt.png" alt="image-20200811105513575"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        u, v = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> v!=u:</span><br><span class="line">            self.n -= <span class="number">1</span></span><br><span class="line">            self.p[u] = v</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> dislikes: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 有意思吗？说好的分成 2 组的</span></span><br><span class="line">        dsu = DSU(N+<span class="number">1</span>)</span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">            d[a].append(b)</span><br><span class="line">            d[b].append(a)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            h = d[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> d[i][<span class="number">1</span>:]:</span><br><span class="line">                dsu.union(h, j)</span><br><span class="line">            <span class="keyword">if</span> dsu.same(i, h): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dsu.n&gt;=<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> dislikes: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 有意思吗？说好的分成 2 组的</span></span><br><span class="line">        l = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">            d[a].append(b)</span><br><span class="line">            d[b].append(a)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> l[i]: <span class="keyword">continue</span></span><br><span class="line">            l[i] = <span class="number">1</span></span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[cur]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> l[j]:</span><br><span class="line">                        l[j] = -l[cur]</span><br><span class="line">                        queue.append(j)</span><br><span class="line">                    <span class="keyword">elif</span> l[j]==l[cur]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="959-由斜杠划分区域-力扣（LeetCode）"><a href="#959-由斜杠划分区域-力扣（LeetCode）" class="headerlink" title="959. 由斜杠划分区域 - 力扣（LeetCode）"></a>959. 由斜杠划分区域 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/submissions/">959. 由斜杠划分区域 - 力扣（LeetCode）</a></p><p>‘\\‘ \ 有转义的作用，需要写 2 个(md 里为了写 2 个\ 需要写 4 个\)</p><h4 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">30</span>*<span class="number">30</span>*<span class="number">4</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span><span class="params">(self, grid: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        <span class="comment"># 1格 划分为 0123 4个小区间:</span></span><br><span class="line">        <span class="comment"># \ 0 /</span></span><br><span class="line">        <span class="comment"># 1 x 3 </span></span><br><span class="line">        <span class="comment"># / 2 \</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">idx</span><span class="params">(i, j, t)</span>:</span></span><br><span class="line">            <span class="comment"># 返回 i, j 位置的区块在 t(0-3) 的索引</span></span><br><span class="line">            <span class="comment"># 前面有 i 行，左边有 j 大格</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*(m*i+j)+t</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="comment"># 当前格的0和上一行的格的2一定相连</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>: dsu.union(idx(i, j, <span class="number">0</span>), idx(i<span class="number">-1</span>, j, <span class="number">2</span>))</span><br><span class="line">                <span class="comment"># 当前格的1和上一列的格的3一定相连</span></span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>: dsu.union(idx(i, j, <span class="number">1</span>), idx(i, j<span class="number">-1</span>, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'/'</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">1</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">2</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">'\\'</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">1</span>), idx(i, j, <span class="number">2</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">' '</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">1</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">2</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n*m*<span class="number">4</span>)))</span><br></pre></td></tr></table></figure><h4 id="问题转化"><a href="#问题转化" class="headerlink" title="问题转化"></a>问题转化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGrid</span><span class="params">(grid)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> grid:</span><br><span class="line">        print(l)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span><span class="params">(self, grid: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集没学过，有点难</span></span><br><span class="line">        <span class="comment"># 取巧的办法</span></span><br><span class="line">        <span class="comment"># / 转换成  \ 转换成</span></span><br><span class="line">        <span class="comment"># 0 0 1   1 0 0</span></span><br><span class="line">        <span class="comment"># 0 1 0   0 1 0</span></span><br><span class="line">        <span class="comment"># 1 0 0   0 0 1</span></span><br><span class="line">        <span class="comment"># 再查找 0 组成的岛屿</span></span><br><span class="line">        <span class="comment"># 思路是不难了，但是解题过程也挺复杂</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">islandNum</span><span class="params">(grid)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> grid[i][j]==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                grid[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>]]:</span><br><span class="line">                    dfs(i+di, j+dj)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            n = len(grid)</span><br><span class="line">            <span class="keyword">return</span> sum(dfs(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        n = len(grid)</span><br><span class="line">        grid3 = [[<span class="number">0</span>]*(<span class="number">3</span>*n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>*n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        grid3[<span class="number">3</span>*i+k][<span class="number">3</span>*j+<span class="number">2</span>-k] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">'\\'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        grid3[<span class="number">3</span>*i+k][<span class="number">3</span>*j+k] = <span class="number">1</span></span><br><span class="line">        printGrid(grid3)</span><br><span class="line">        <span class="keyword">return</span> islandNum(grid3)</span><br></pre></td></tr></table></figure><h3 id="947-移除最多的同行或同列石头-力扣（LeetCode）"><a href="#947-移除最多的同行或同列石头-力扣（LeetCode）" class="headerlink" title="947. 移除最多的同行或同列石头 - 力扣（LeetCode）"></a>947. 移除最多的同行或同列石头 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/submissions/">947. 移除最多的同行或同列石头 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">1000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeStones</span><span class="params">(self, stones: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集的题目都这么难懂吗, 题意理解，见↓</span></span><br><span class="line">        <span class="comment"># [Python，DFS解法，用时仅为68ms，大量注释 - 移除最多的同行或同列石头 - 力扣（LeetCode）]</span></span><br><span class="line">        <span class="comment"># (https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythondfsjie-fa-yong-shi-jin-wei-68msda-liang-zhu-/)</span></span><br><span class="line">        <span class="comment"># 横坐标 或 纵坐标 相等即为连通</span></span><br><span class="line">        <span class="comment"># 对于任何容量为n 的一个连通分量，最后剩下 1 个石头，即可以移除的石头数都为n-1</span></span><br><span class="line">        <span class="comment"># 可以移走的石头数 = 总石头数 - 剩余石头数 = stones列表长度 - 连通分量个数</span></span><br><span class="line">        di, dj = &#123;&#125;, &#123;&#125; <span class="comment"># 同 i 或 同 j 的点, 记录一个就好</span></span><br><span class="line">        <span class="comment"># d = defaultdict(dict) # d[i][j] = idx # ij -&gt; dsu 的索引</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> stones:</span><br><span class="line">            <span class="comment"># i 行已经有元素的话，与那个元素合并</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> di: dsu.union(idx, di[i])</span><br><span class="line">            <span class="keyword">else</span>: di[i] = idx</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dj: dsu.union(idx, dj[j])</span><br><span class="line">            <span class="keyword">else</span>: dj[j] = idx</span><br><span class="line"></span><br><span class="line">            <span class="comment"># d[i][j] = idx</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(stones)-len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(idx)))</span><br></pre></td></tr></table></figure><h3 id="990-等式方程的可满足性-力扣（LeetCode）"><a href="#990-等式方程的可满足性-力扣（LeetCode）" class="headerlink" title="990. 等式方程的可满足性 - 力扣（LeetCode）"></a>990. 等式方程的可满足性 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/submissions/">990. 等式方程的可满足性 - 力扣（LeetCode）</a></p><p>不知为什么，我的并查集一直挺慢的</p><p>看其他解答里有个路径压缩，不知道是什么意思</p><p><img src="https://i.loli.net/2020/08/05/nEkIJP5tsApYUBG.png" alt="image-20200805172512601"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">26</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="comment"># 先遍历一遍，处理 ==</span></span><br><span class="line">        <span class="keyword">for</span> a, t, _, b <span class="keyword">in</span> equations:</span><br><span class="line">            a, b = ord(a)-ord(<span class="string">'a'</span>), ord(b)-ord(<span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">if</span> t==<span class="string">'!'</span>:</span><br><span class="line">                <span class="keyword">if</span> dsu.find(a)==dsu.find(b): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dsu.union(a, b)</span><br><span class="line">        <span class="keyword">for</span> a, t, _, b <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> t==<span class="string">'='</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> dsu.find(ord(a)-ord(<span class="string">'a'</span>))==dsu.find(ord(b)-ord(<span class="string">'a'</span>)): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.p[self.p[x]] <span class="comment"># 隔代路径压缩</span></span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="1319-连通网络的操作次数-力扣（LeetCode）"><a href="#1319-连通网络的操作次数-力扣（LeetCode）" class="headerlink" title="1319. 连通网络的操作次数 - 力扣（LeetCode）"></a>1319. 连通网络的操作次数 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/submissions/">1319. 连通网络的操作次数 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最少 n-1 根线</span></span><br><span class="line">        <span class="keyword">if</span> len(connections)&lt;n<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># return x-1  x:x个集群</span></span><br><span class="line">        dsu = DSU(n)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        <span class="keyword">return</span> len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)))<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>改进，在 dsu 里面维护连通分量的个数 n, 合并一个n就减一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        px, py = map(self.find, (x, y))</span><br><span class="line">        <span class="keyword">if</span> px!=py:</span><br><span class="line">            self.p[px] = py</span><br><span class="line">            self.n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最少 n-1 根线</span></span><br><span class="line">        <span class="keyword">if</span> len(connections)&lt;n<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># return x-1  x:x个连通分量</span></span><br><span class="line">        dsu = DSU(n)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        <span class="comment"># return len(set(dsu.find(i) for i in range(n)))-1</span></span><br><span class="line">        <span class="keyword">return</span> dsu.n<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1202-交换字符串中的元素-力扣（LeetCode）"><a href="#1202-交换字符串中的元素-力扣（LeetCode）" class="headerlink" title="1202. 交换字符串中的元素 - 力扣（LeetCode）"></a>1202. 交换字符串中的元素 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/submissions/">1202. 交换字符串中的元素 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 连通分量内字母排序</span></span><br><span class="line">        dsu = DSU(len(s))</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            d[dsu.find(i)].append(s[i])</span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> d:</span><br><span class="line">            d[root].sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            res.append(d[dsu.find(i)].pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="面试题-17-07-婴儿名字-力扣（LeetCode）"><a href="#面试题-17-07-婴儿名字-力扣（LeetCode）" class="headerlink" title="面试题 17.07. 婴儿名字 - 力扣（LeetCode）"></a>面试题 17.07. 婴儿名字 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/baby-names-lcci/submissions/">面试题 17.07. 婴儿名字 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trulyMostPopular</span><span class="params">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        l = [] <span class="comment"># idx -&gt; name</span></span><br><span class="line">        name_idx = &#123;&#125; <span class="comment"># name -&gt; idx</span></span><br><span class="line">        dsu = DSU(len(synonyms)*<span class="number">2</span>)</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> synonyms:</span><br><span class="line">            i = i.strip(<span class="string">'()'</span>).split(<span class="string">','</span>)</span><br><span class="line">            idxs = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> name_idx:</span><br><span class="line">                    name_idx[j] = idx</span><br><span class="line">                    idxs.append(idx)</span><br><span class="line">                    l.append(j)</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: idxs.append(name_idx[j])</span><br><span class="line">            dsu.union(*idxs)</span><br><span class="line">        d = collections.defaultdict(list) <span class="comment"># root -&gt; [names]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            d[dsu.find(i)].append(l[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            d[i] = [min(d[i])]</span><br><span class="line">        <span class="comment"># d: root-&gt; [min(names)]</span></span><br><span class="line">        <span class="comment"># d1: root-&gt; num</span></span><br><span class="line">        d1 = collections.defaultdict(int)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> names:</span><br><span class="line">            name, n = s.strip(<span class="string">')'</span>).split(<span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> name_idx:</span><br><span class="line">                res.append(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d1[dsu.find(name_idx[name])] += int(n)</span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> d1:</span><br><span class="line">            name = d[root][<span class="number">0</span>]</span><br><span class="line">            n = d1[root]</span><br><span class="line">            res.append(<span class="string">f'<span class="subst">&#123;name&#125;</span>(<span class="subst">&#123;n&#125;</span>)'</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="130-被围绕的区域-力扣（LeetCode）"><a href="#130-被围绕的区域-力扣（LeetCode）" class="headerlink" title="130. 被围绕的区域 - 力扣（LeetCode）"></a>130. 被围绕的区域 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/surrounded-regions/submissions/">130. 被围绕的区域 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 连接相通的元素，并记录边缘的元素</span></span><br><span class="line">        <span class="comment"># 排除与 边缘的元素 同 root 的元素（dsu 长度可以额外多一个，作为需要移除的集合）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]: <span class="keyword">return</span> board</span><br><span class="line">        n, m = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        dsu = DSU(n*m+<span class="number">1</span>)</span><br><span class="line">        exclude_idx = n*m</span><br><span class="line">        oidx = [] <span class="comment"># 是 O 的idx</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">border</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i <span class="keyword">in</span> [<span class="number">0</span>, n<span class="number">-1</span>] <span class="keyword">or</span> j <span class="keyword">in</span> [<span class="number">0</span>, m<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'X'</span>: <span class="keyword">continue</span></span><br><span class="line">                curidx = i*m+j</span><br><span class="line">                oidx.append(curidx)</span><br><span class="line">                <span class="keyword">if</span> border(i, j): dsu.union(curidx, exclude_idx)</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>: dsu.union(curidx, curidx-m)</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>: dsu.union(curidx, curidx<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> oidx:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dsu.same(idx, exclude_idx):</span><br><span class="line">                i, j = divmod(idx, m)</span><br><span class="line">                board[i][j] = <span class="string">'X'</span></span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>从这里学到的</p><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/shi-yong-bing-cha-ji-chu-li-bu-xiang-jiao-ji-he-we/">使用并查集处理不相交集合问题（Java、Python） - 等式方程的可满足性 - 力扣（LeetCode）</a></p><img src="https://i.loli.net/2020/08/05/P7AFpdojx1XRETK.png" alt="image-20200805173254139" style="zoom:50%;" /><p>一道题目路径压缩后的性能:</p><img src="https://i.loli.net/2020/08/05/8PAOY956GUrMZh4.png" alt="image-20200805173217140" style="zoom:50%;" /><h3 id="python-版的路径压缩"><a href="#python-版的路径压缩" class="headerlink" title="python 版的路径压缩"></a>python 版的路径压缩</h3><h3 id="隔代路径压缩"><a href="#隔代路径压缩" class="headerlink" title="隔代路径压缩"></a>隔代路径压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.p[self.p[x]]</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="完全路径压缩"><a href="#完全路径压缩" class="headerlink" title="完全路径压缩"></a>完全路径压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>打家劫舍</title>
    <link href="https://zronghui.github.io/leetcode/%E5%85%B6%E4%BB%96/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%85%B6%E4%BB%96/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</id>
    <published>2020-08-05T07:48:59.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>打家劫舍 三连击</p><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III - 力扣（LeetCode）</a></p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#   1 2 3 1</span></span><br><span class="line">        <span class="comment"># 0 1 2 4 4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        a, b = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            t = max(b, a+i)</span><br><span class="line">            a, b = b, t</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max(self.rob1(nums[<span class="number">1</span>:]), self.rob1(nums[:<span class="number">-1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob1</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#   1 2 3 1</span></span><br><span class="line">        <span class="comment"># 0 1 2 4 4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        a, b = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            t = max(b, a+i)</span><br><span class="line">            a, b = b, t</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/di-gui-chu-li-fan-hui-tou-yu-bu-tou-liang-chong-ji/">递归处理-返回偷与不偷两种结果（Python3） - 打家劫舍 III - 力扣（LeetCode）</a></p><p>递归处理，返回当前节点偷与不偷的两个结果，取其中最大的一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="comment"># [偷, 不偷]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            left, right = map(helper, [node.left, node.right])</span><br><span class="line">            <span class="keyword">return</span> [left[<span class="number">1</span>]+right[<span class="number">1</span>], left[<span class="number">0</span>]+right[<span class="number">0</span>]+node.val]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(helper(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="其他" scheme="https://zronghui.github.io/categories/leetcode/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode模板 by 负雪明烛</title>
    <link href="https://zronghui.github.io/leetcode/leetcode%E6%A8%A1%E6%9D%BF-by-%E8%B4%9F%E9%9B%AA%E6%98%8E%E7%83%9B.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode%E6%A8%A1%E6%9D%BF-by-%E8%B4%9F%E9%9B%AA%E6%98%8E%E7%83%9B.html</id>
    <published>2020-08-02T06:35:28.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729">blog.csdn.net</a></p></blockquote><p>本文的目的是收集一些典型的题目，记住其写法，理解其思想，即可做到一通百通。欢迎大家提出宝贵意见！</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>最明显的题目就是 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/83273084">34. Find First and Last Position of Element in Sorted Array</a></p><p>花花酱的二分查找专题视频：<a href="https://www.youtube.com/watch?v=v57lNF2mb_s">https://www.youtube.com/watch?v=v57lNF2mb_s</a></p><p>模板：</p><p>区间定义：<code>[l, r) 左闭右开</code></p><p>其中 f(m) 函数代表找到了满足条件的情况，有这个条件的判断就返回对应的位置，如果没有这个条件的判断就是 lowwer_bound 和 higher_bound.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(l, r)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = l + (r - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> f(m):    <span class="comment"># 判断找了没有，optional</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">if</span> g(m):</span><br><span class="line">            r = m   <span class="comment"># new range [l, m)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span> <span class="comment"># new range [m+1, r)</span></span><br><span class="line">    <span class="keyword">return</span> l    <span class="comment"># or not found</span></span><br></pre></td></tr></table></figure><p><strong>lower bound</strong>: find index of i, such that <code>A[i] &gt;= x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowwer_bound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="comment"># find in range [left, right)</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>upper bound</strong>: find index of i, such that <code>A[i] &gt; x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">higher_bound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="comment"># find in range [left, right)</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>比如，题目 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/79254648">69. Sqrt(x)</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, x + <span class="number">1</span></span><br><span class="line">        <span class="comment"># [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="排序的写法"><a href="#排序的写法" class="headerlink" title="排序的写法"></a>排序的写法</h1><p>C++ 的排序方法，使用 sort 并且重写 comparator，如果需要使用外部变量，需要在中括号中放入 &amp;。</p><p>题目 451. Sort Characters By Frequency。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string frequencySort(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (char c : s) ++m[c];</span><br><span class="line">        sort(s.begin(), s.end(), [&amp;](char&amp; a, char&amp; b)&#123;</span><br><span class="line">            return m[a] &gt; m[b] || (m[a] &#x3D;&#x3D; m[b] &amp;&amp; a &lt; b);</span><br><span class="line">        &#125;);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="BFS-的写法"><a href="#BFS-的写法" class="headerlink" title="BFS 的写法"></a>BFS 的写法</h1><p>下面的这个写法是在一个邻接矩阵中找出离某一个点距离是 k 的点。</p><p>来自文章：<a href="https://blog.csdn.net/fuxuemingzhu/article/details/82709619">【LeetCode】863. All Nodes Distance K in Binary Tree 解题报告（Python）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS</span></span><br><span class="line">bfs = [target.val]</span><br><span class="line">visited = set([target.val])</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">    bfs = [y <span class="keyword">for</span> x <span class="keyword">in</span> bfs <span class="keyword">for</span> y <span class="keyword">in</span> conn[x] <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">    visited |= set(bfs)</span><br><span class="line"><span class="keyword">return</span> bfs</span><br></pre></td></tr></table></figure><ol start="127"><li>Word Ladder</li></ol><p>在 BFS 中保存已走过的步，并把已经走的合法路径删除掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        wordset = set(wordList)</span><br><span class="line">        bfs = collections.deque()</span><br><span class="line">        bfs.append((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> bfs:</span><br><span class="line">            word, length = bfs.popleft()</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> length</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>:</span><br><span class="line">                    newWord = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newWord <span class="keyword">in</span> wordset <span class="keyword">and</span> newWord != word:</span><br><span class="line">                        wordset.remove(newWord)</span><br><span class="line">                        bfs.append((newWord, length + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82926674">778. Swim in Rising Water</a></p><p>使用优先级队列来优先走比较矮的路，最后保存最高的那个格子的高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        visited, pq = set((<span class="number">0</span>, <span class="number">0</span>)), [(grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            T, i, j = heapq.heappop(pq)</span><br><span class="line">            res = max(res, T)</span><br><span class="line">            directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">            <span class="keyword">if</span> i == j == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> dir <span class="keyword">in</span> directions:</span><br><span class="line">                x, y = i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> (x, y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                heapq.heappush(pq, (grid[x][y], x, y))</span><br><span class="line">                visited.add((x, y))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82939203">847. Shortest Path Visiting All Nodes</a></p><p>需要找出某顶点到其他顶点的最短路径。出发顶点不是确定的，每个顶点有可能访问多次。使用 N 位 bit 代表访问过的顶点的状态。如果到达了最终状态，那么现在步数就是所求。这个题把所有的节点都放入了起始队列中，相当于每次都是所有的顶点向前走一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathLength</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(graph)</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        goal = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span></span><br><span class="line">        visited = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; N)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            que.append((i, <span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            s = len(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">                node, state = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> state == goal:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                <span class="keyword">if</span> visited[node][state]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited[node][state] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> nextNode <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    que.append((nextNode, state | (<span class="number">1</span> &lt;&lt; nextNode)))</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/81022170">429. N-ary Tree Level Order Traversal</a> 多叉树的层次遍历，这个 BFS 写法我觉得很经典。适合记忆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, children):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        que.append(root)</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            level = []</span><br><span class="line">            size = len(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">                    que.append(child)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="DFS-的写法"><a href="#DFS-的写法" class="headerlink" title="DFS 的写法"></a>DFS 的写法</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82917210">329. Longest Increasing Path in a Matrix</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82917037">417. Pacific Atlantic Water Flow</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82926674">778. Swim in Rising Water</a></p><p>二分查找 + DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        left, right = <span class="number">0</span>, n * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs([[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], grid, mid, n, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, visited, grid, mid, n, i, j)</span>:</span></span><br><span class="line">        visited[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> directions:</span><br><span class="line">            x, y = i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> visited[x][y] <span class="keyword">or</span> max(mid, grid[i][j]) != max(mid, grid[x][y]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs(visited, grid, mid, n, x, y):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>下面这个题使用了回溯法，但是写的不够简单干练，遇到更好的解法的时候，要把这个题进行更新。</p><p>这个回溯思想，先去添加一个新的状态，看在这个状态的基础上，能不能找结果，如果找不到结果的话，那么就回退，即把这个结果和访问的记录给去掉。这个题使用了 return True 的方法让我们知道已经找出了结果，所以不用再递归了。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82945477">753. Cracking the Safe</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crackSafe</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="string">"0"</span>] * n</span><br><span class="line">        size = k ** n</span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(<span class="string">""</span>.join(res))</span><br><span class="line">        <span class="keyword">if</span> self.dfs(res, visited, size, n, k):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, res, visited, size, n, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) == size:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        node = <span class="string">""</span>.join(res[len(res) - n + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            node = node + str(i)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                res.append(str(i))</span><br><span class="line">                visited.add(node)</span><br><span class="line">                <span class="keyword">if</span> self.dfs(res, visited, size, n, k):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                res.pop()</span><br><span class="line">                visited.remove(node)</span><br><span class="line">            node = node[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82928879">312. Burst Balloons</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxCoins(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        nums.insert(0, 1)</span><br><span class="line">        nums.append(1)</span><br><span class="line">        c &#x3D; [[0] * (n + 2) for _ in range(n + 2)]</span><br><span class="line">        return self.dfs(nums, c, 1, n)</span><br><span class="line">        </span><br><span class="line">    def dfs(self, nums, c, i, j):</span><br><span class="line">        if i &gt; j: return 0</span><br><span class="line">        if c[i][j] &gt; 0: return c[i][j]</span><br><span class="line">        if i &#x3D;&#x3D; j: return nums[i - 1] * nums[i] * nums[i + 1]</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        for k in range(i, j + 1):</span><br><span class="line">            res &#x3D; max(res, self.dfs(nums, c, i, k - 1) + nums[i - 1] * nums[k] * nums[j + 1] + self.dfs(nums, c, k + 1, j))</span><br><span class="line">        c[i][j] &#x3D; res</span><br><span class="line">        return c[i][j]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countArrangement(int N) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        vector&lt;int&gt; visited(N + 1, 0);</span><br><span class="line">        helper(N, visited, 1, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void helper(int N, vector&lt;int&gt;&amp; visited, int pos, int&amp; res) &#123;</span><br><span class="line">        if (pos &gt; N) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123;</span><br><span class="line">            if (visited[i] &#x3D;&#x3D; 0 &amp;&amp; (i % pos &#x3D;&#x3D; 0 || pos % i &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                helper(N, visited, pos + 1, res);</span><br><span class="line">                visited[i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果需要保存路径的回溯法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        const int N &#x3D; nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        vector&lt;int&gt; visited(N, 0);</span><br><span class="line">        dfs(nums, 0, visited, res, path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;</span><br><span class="line">        const int N &#x3D; nums.size();</span><br><span class="line">        if (pos &#x3D;&#x3D; N) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                path.push_back(nums[i]);</span><br><span class="line">                dfs(nums, pos + 1, visited, res, path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                visited[i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79052953">617. Merge Two Binary Trees</a> 把两个树重叠，重叠部分求和，不重叠部分是两个树不空的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        newT = TreeNode(t1.val + t2.val)</span><br><span class="line">        newT.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        newT.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> newT</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/51284488">226. Invert Binary Tree</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/72575422">144. Binary Tree Preorder Traversal</a></p><p>迭代写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79294461">94. Binary Tree Inorder Traversal</a></p><p>迭代写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> answer</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            answer.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101079767">145. Binary Tree Postorder Traversal</a></p><p>迭代写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node &#x3D; st.top(); st.pop();</span><br><span class="line">            if (!node) continue;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构建完全二叉树"><a href="#构建完全二叉树" class="headerlink" title="构建完全二叉树"></a>构建完全二叉树</h1><p>完全二叉树是每一层都满的，因此找出要插入节点的父亲节点是很简单的。如果用数组 tree 保存着所有节点的层次遍历，那么新节点的父亲节点就是 tree[(N -1)/2]，N 是未插入该节点前的树的元素个数。<br>构建树的时候使用层次遍历，也就是 BFS 把所有的节点放入到 tree 里。插入的时候直接计算出新节点的父亲节点。获取 root 就是数组中的第 0 个节点。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82958284">919. Complete Binary Tree Inserter</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.tree = list()</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            self.tree.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _len = len(self.tree)</span><br><span class="line">        father = self.tree[(_len - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">        node = TreeNode(v)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> father.left:</span><br><span class="line">            father.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            father.right = node</span><br><span class="line">        self.tree.append(node)</span><br><span class="line">        <span class="keyword">return</span> father.val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CBTInserter(root)</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(v)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get_root()</span></span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>不包含 rank 的话，代码很简短，应该背会。</p><ol start="721"><li><p>Accounts Merge  </p><p><a href="https://leetcode.com/articles/accounts-merge/">https://leetcode.com/articles/accounts-merge/</a></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != self.par[x]:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br></pre></td></tr></table></figure><p>C++ 版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; map_; &#x2F;&#x2F;i的parent，默认是i</span><br><span class="line">int f(int a) &#123;</span><br><span class="line">    if (map_[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    return f(map_[a]);</span><br><span class="line">&#125;</span><br><span class="line">void u(int a, int b) &#123;</span><br><span class="line">    int pa &#x3D; f(a);</span><br><span class="line">    int pb &#x3D; f(b);</span><br><span class="line">    if (pa &#x3D;&#x3D; pb)</span><br><span class="line">        return;</span><br><span class="line">    map_[pa] &#x3D; pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含 rank 的，这里的 rank 表示树的高度：</p><p><a href="https://leetcode.com/articles/redundant-connection/">684. Redundant Connection</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">        self.rnk = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        xr, yr = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> xr == yr:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &lt; self.rnk[yr]:</span><br><span class="line">            self.par[xr] = yr</span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &gt; self.rnk[yr]:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">            self.rnk[xr] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>另外一种 rank 方法是，保存树中节点的个数。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/70258103">547. Friend Circles</a>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        N = len(M)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, N):</span><br><span class="line">                <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                    dsu.u(i, j)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> dsu.f(i) == i:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = range(<span class="number">201</span>)</span><br><span class="line">        self.r = [<span class="number">0</span>] * <span class="number">201</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a == self.d[a] <span class="keyword">else</span> self.f(self.d[a])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        pa = self.f(a)</span><br><span class="line">        pb = self.f(b)</span><br><span class="line">        <span class="keyword">if</span> (pa == pb):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.r[pa] &lt; self.r[pb]:</span><br><span class="line">            self.d[pa] = pb</span><br><span class="line">            self.r[pb] += self.r[pa]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d[pb] = pa</span><br><span class="line">            self.r[pa] += self.r[pb]</span><br></pre></td></tr></table></figure><h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>前缀树的题目可以使用字典解决，代码还是需要背一下的，C++ 版本的前缀树如下：</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79388432">208. Implement Trie (Prefix Tree)</a> 这个题是纯考 Trie 的。参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TrieNode*&gt; child;</span><br><span class="line">    bool isWord;</span><br><span class="line">    TrieNode() : isWord(false), child(26, nullptr) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TrieNode() &#123;</span><br><span class="line">        for (auto&amp; c : child)</span><br><span class="line">            delete c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root &#x3D; new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Inserts a word into the trie. *&#x2F;</span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : word) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                p-&gt;child[i] &#x3D; new TrieNode();</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if the word is in the trie. *&#x2F;</span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : word) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                return false;</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;</span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : prefix) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                return false;</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj &#x3D; new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * bool param_2 &#x3D; obj.search(word);</span><br><span class="line"> * bool param_3 &#x3D; obj.startsWith(prefix);</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79436619">677. Map Sum Pairs</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MapSum &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    MapSum() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void insert(string key, int val) &#123;</span><br><span class="line">        int inc &#x3D; val - vals_[key];</span><br><span class="line">        Trie* p &#x3D; &amp;root;</span><br><span class="line">        for (const char c : key) &#123;</span><br><span class="line">            if (!p-&gt;children[c])</span><br><span class="line">                p-&gt;children[c] &#x3D; new Trie();</span><br><span class="line">            p-&gt;children[c]-&gt;sum +&#x3D; inc;</span><br><span class="line">            p &#x3D; p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        vals_[key] &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sum(string prefix) &#123;</span><br><span class="line">        Trie* p &#x3D; &amp;root;</span><br><span class="line">        for (const char c : prefix) &#123;</span><br><span class="line">            if (!p-&gt;children[c])</span><br><span class="line">                return 0;</span><br><span class="line">            p &#x3D; p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    struct Trie &#123;</span><br><span class="line">        Trie():children(128, nullptr), sum(0)&#123;&#125;</span><br><span class="line">        ~Trie()&#123;</span><br><span class="line">            for (auto child : children)</span><br><span class="line">                if (child) delete child;</span><br><span class="line">            children.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;Trie*&gt; children;</span><br><span class="line">        int sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Trie root;</span><br><span class="line">    unordered_map&lt;string, int&gt; vals_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82862769">743. Network Delay Time</a> 这个题很详细。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>时间复杂度是 O(N ^ 2 + E)，空间复杂度是 O(N+E).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        K -= <span class="number">1</span></span><br><span class="line">        nodes = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</span><br><span class="line">            nodes[u - <span class="number">1</span>].append((v - <span class="number">1</span>, w))</span><br><span class="line">        dist = [float(<span class="string">'inf'</span>)] * N</span><br><span class="line">        dist[K] = <span class="number">0</span></span><br><span class="line">        done = set()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            smallest = min((d, i) <span class="keyword">for</span> (i, d) <span class="keyword">in</span> enumerate(dist) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> done)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> v, w <span class="keyword">in</span> nodes[smallest]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> done <span class="keyword">and</span> dist[smallest] + w &lt; dist[v]:</span><br><span class="line">                    dist[v] = dist[smallest] + w</span><br><span class="line">            done.add(smallest)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> dist <span class="keyword">else</span> max(dist)</span><br></pre></td></tr></table></figure><h2 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h2><p>时间复杂度 O(n^3)， 空间复杂度 O(n^2)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = [[float(<span class="string">'inf'</span>)] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">            u, v, w = time[<span class="number">0</span>] - <span class="number">1</span>, time[<span class="number">1</span>] - <span class="number">1</span>, time[<span class="number">2</span>]</span><br><span class="line">            d[u][v] = w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            d[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> d[K - <span class="number">1</span>] <span class="keyword">else</span> max(d[K - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>时间复杂度 O(ne)， 空间复杂度 O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dist = [float(<span class="string">'inf'</span>)] * N</span><br><span class="line">        dist[K - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">                u = time[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                v = time[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                w = time[<span class="number">2</span>]</span><br><span class="line">                dist[v] = min(dist[v], dist[u] + w)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> dist <span class="keyword">else</span> max(dist)</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101214765">1135. Connecting Cities With Minimum Cost</a></p><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; &amp; a,vector&lt;int&gt; &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int find(vector&lt;int&gt; &amp; f,int x)&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool uni(vector&lt;int&gt; &amp; f,int x,int y)&#123;</span><br><span class="line">        int x1 = find(f,x);</span><br><span class="line">        int y1 = find(f,y);</span><br><span class="line">        f[x1] = y1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minimumCost(int N, vector&lt;vector&lt;int&gt;&gt;&amp; conections) &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        int count = <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; father(N+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sort(conections.begin(),conections.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt;= N; ++i)&#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(auto conect : conections)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(father,conect[<span class="number">0</span>]) != find(father,conect[<span class="number">1</span>]))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                ans += conect[<span class="number">2</span>];</span><br><span class="line">                uni(father,conect[<span class="number">0</span>],conect[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(count == N<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct cmp &#123;</span><br><span class="line">    bool operator () (const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &gt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minimumCost(int N, vector&lt;vector&lt;int&gt;&gt;&amp; conections) &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        int selected = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; edgs(N+<span class="number">1</span>,vector&lt;pair&lt;int,int&gt;&gt;());</span><br><span class="line">        priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;,cmp&gt; pq;</span><br><span class="line">        vector&lt;bool&gt; visit(N+<span class="number">1</span>,false);</span><br><span class="line">        </span><br><span class="line">        /*initial*/</span><br><span class="line">        <span class="keyword">for</span>(auto re : conections)&#123;</span><br><span class="line">            edgs[re[<span class="number">0</span>]].push_back(make_pair(re[<span class="number">1</span>],re[<span class="number">2</span>]));</span><br><span class="line">            edgs[re[<span class="number">1</span>]].push_back(make_pair(re[<span class="number">0</span>],re[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(edgs[<span class="number">1</span>].size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*kruskal*/</span><br><span class="line">        selected = <span class="number">1</span>;</span><br><span class="line">        visit[<span class="number">1</span>] = true;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; edgs[<span class="number">1</span>].size(); ++i)&#123;</span><br><span class="line">            pq.push(vector&lt;int&gt;(&#123;<span class="number">1</span>,edgs[<span class="number">1</span>][i].first,edgs[<span class="number">1</span>][i].second&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!visit[curr[<span class="number">1</span>]])&#123;</span><br><span class="line">                visit[curr[<span class="number">1</span>]] = true;</span><br><span class="line">                ans += curr[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span>(auto e : edgs[curr[<span class="number">1</span>]])&#123;</span><br><span class="line">                    pq.push(vector&lt;int&gt;(&#123;curr[<span class="number">1</span>],e.first,e.second&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">                selected++;</span><br><span class="line">                <span class="keyword">if</span>(selected == N)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>BFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, N, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N,: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        indegrees = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[v].append(u)</span><br><span class="line">            indegrees[u] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            zeroDegree = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">if</span> indegrees[j] == <span class="number">0</span>:</span><br><span class="line">                    zeroDegree = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> zeroDegree: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            indegrees[j] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[j]:</span><br><span class="line">                indegrees[node] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>DFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, N, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N,: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">        <span class="comment"># 0 = Unknown, 1 = visiting, 2 = visited</span></span><br><span class="line">        visited = [<span class="number">0</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Can we add node i to visited successfully?</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, visited, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited[i] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果需要保存拓扑排序的路径：</p><p>BFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        indegrees = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[v].append(u)</span><br><span class="line">            indegrees[u] += <span class="number">1</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            zeroDegree = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(numCourses):</span><br><span class="line">                <span class="keyword">if</span> indegrees[j] == <span class="number">0</span>:</span><br><span class="line">                    zeroDegree = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> zeroDegree:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            indegrees[j] -= <span class="number">1</span></span><br><span class="line">            path.append(j)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[j]:</span><br><span class="line">                indegrees[node] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure><p>DFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">        <span class="comment"># 0 = Unknown, 1 = visiting, 2 = visited</span></span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, i, path):</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, visited, i, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, j, path):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited[i] = <span class="number">2</span></span><br><span class="line">        path.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82951771">207. Course Schedule</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83302328">210. Course Schedule II</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83548874">310. Minimum Height Trees</a></p><h1 id="查找子字符串，双指针模板"><a href="#查找子字符串，双指针模板" class="headerlink" title="查找子字符串，双指针模板"></a>查找子字符串，双指针模板</h1><p>这是一个[模板](<a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;">https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;</a> rel=)，里面的 map 如果是双指针范围内的字符串字频的话，增加和减少的方式如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int findSubstring(string s)&#123;</span><br><span class="line">        vector&lt;int&gt; map(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        int counter; // check whether the substring <span class="keyword">is</span> valid</span><br><span class="line">        int begin=<span class="number">0</span>, end=<span class="number">0</span>; //two pointers, one point to tail <span class="keyword">and</span> one  head</span><br><span class="line">        int d; //the length of substring</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>() &#123; /* initialize the hash map here */ &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line"></span><br><span class="line">            if(map[s[end++]]++ ?)&#123;  /* modify counter here */ &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(/* counter condition */)&#123; </span><br><span class="line">                 </span><br><span class="line">                 /* update d here <span class="keyword">if</span> finding minimum*/</span><br><span class="line"></span><br><span class="line">                //increase begin to make it invalid/valid again</span><br><span class="line">                </span><br><span class="line">                if(map[s[begin++]]-- ?)&#123; /*modify counter here*/ &#125;</span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            /* update d here <span class="keyword">if</span> finding maximum*/</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82931106">76. Minimum Window Substring</a></p><p>这个题的 map 是 t 的字频，所以使用 map 更方式和上是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        left, cnt, minLen = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        count = collections.Counter(t)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            count[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[c] &gt;= <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt == len(t):</span><br><span class="line">                <span class="keyword">if</span> minLen &gt; i - left + <span class="number">1</span>:</span><br><span class="line">                    minLen = i - left + <span class="number">1</span></span><br><span class="line">                    res = s[left : i + <span class="number">1</span>]</span><br><span class="line">                count[s[left]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count[s[left]] &gt; <span class="number">0</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态搜索"><a href="#状态搜索" class="headerlink" title="状态搜索"></a>状态搜索</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82747623">688. Knight Probability in Chessboard</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79337352">62. Unique Paths</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83154114">63. Unique Paths II</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83350880">913. Cat and Mouse</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83447155">576. Out of Boundary Paths</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            curStatus = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                    v1 = <span class="number">1</span> <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> dp[x - <span class="number">1</span>][y]</span><br><span class="line">                    v2 = <span class="number">1</span> <span class="keyword">if</span> x == m - <span class="number">1</span> <span class="keyword">else</span> dp[x + <span class="number">1</span>][y]</span><br><span class="line">                    v3 = <span class="number">1</span> <span class="keyword">if</span> y == <span class="number">0</span> <span class="keyword">else</span> dp[x][y - <span class="number">1</span>]</span><br><span class="line">                    v4 = <span class="number">1</span> <span class="keyword">if</span> y == n - <span class="number">1</span> <span class="keyword">else</span> dp[x][y + <span class="number">1</span>]</span><br><span class="line">                    curStatus[x][y] = (v1 + v2 + v3 + v4) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            dp = curStatus</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上加以考虑，他所作出的是在某种意义上的局部最优解。贪心算法和动态规划算法都是由局部最优导出全局最优，这里不得不比较下二者的区别</p><p>贪心算法：  </p><ol><li>贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。  </li><li>由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解</li></ol><p>动态规划算法：  </p><ol><li>全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解  </li><li>动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解  </li><li>边界条件：即最简单的，可以直接得出的局部最优解</li></ol><p>贪心是个思想，没有统一的模板。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-200</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-200.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-200.html</id>
    <published>2020-08-02T02:14:24.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/count-good-triplets/">统计好三元组</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">找出数组游戏的赢家</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a><strong>6</strong></li></ul><p>误触 command + enter 2 次，淦！</p><p>前 10% 都没弄上</p><p><img src="https://i.loli.net/2020/08/02/VpT8KPrOoAkqc2E.png" alt="image-20200802132822189"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countGoodTriplets</span><span class="params">(self, arr: List[int], a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">satisfy</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[i] - arr[j])&gt;a: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[j] - arr[k])&gt;b: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[i] - arr[k])&gt;c: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">return</span> sum(satisfy(i, j, k) <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n<span class="number">-1</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, n))</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinner</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="comment"># 比较 n 次后，arr 结构: max, n1, n2..... </span></span><br><span class="line">        <span class="comment"># 但是不用真实模拟移动过程，只需要记录下标即可</span></span><br><span class="line">        <span class="keyword">if</span> len(arr)==<span class="number">2</span>: <span class="keyword">return</span> max(arr)</span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i]&gt;arr[cur]:</span><br><span class="line">                m[i] += <span class="number">1</span></span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[cur] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> m[cur]==k: <span class="keyword">return</span> arr[cur]</span><br><span class="line">        <span class="keyword">return</span> arr[cur]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 记录每一行后面 0 的个数</span></span><br><span class="line">        <span class="comment"># 分配每一行应该贡献的 0 的个数</span></span><br><span class="line">        <span class="comment"># 如 0 2 2 实际算作 0 2 1</span></span><br><span class="line">        <span class="comment">#   0 2 2 4 4 5 算作 0 2 1 4 3 5</span></span><br><span class="line">        <span class="comment"># 就是说 遇到相同的数字，减一，加进去</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tailZeroNum</span><span class="params">(grid)</span>:</span></span><br><span class="line">            s = set()</span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n)):</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j]==<span class="number">0</span>: cur += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">                cur = min(n<span class="number">-1</span>, cur)</span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">in</span> s:</span><br><span class="line">                    cur -= <span class="number">1</span></span><br><span class="line">                s.add(cur)</span><br><span class="line">                l.append(cur)</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">        l = tailZeroNum(grid)</span><br><span class="line">        <span class="comment"># print(l)</span></span><br><span class="line">        <span class="keyword">if</span> set(range(n))!=set(l): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(l)):</span><br><span class="line">                <span class="keyword">if</span> l[idx]==i: <span class="keyword">break</span></span><br><span class="line">            res += len(l)<span class="number">-1</span>-idx</span><br><span class="line">            l.remove(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>没看清题，理解错了题意，实际上不算太难<a href="https://leetcode-cn.com/problems/get-the-maximum-score/solution/cshuang-zhi-zhen-fen-duan-tong-ji-zui-da-he-xiang-/">C++双指针 分段统计最大和 相加即可 - 最大得分 - 力扣（LeetCode）</a></p><img src="https://i.loli.net/2020/08/02/TpVlkxoeftSFW6P.png" alt="image-20200802135845039" style="zoom:50%;" /><p>借鉴排行榜的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSum</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">        s1, s2 = map(set, (nums1, nums2))</span><br><span class="line">        a1 = a2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(list(s1|s2)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> s1 <span class="keyword">and</span> i <span class="keyword">in</span> s2: a1 = a2 = max(a1, a2)+i</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> s1: a1 += i</span><br><span class="line">            <span class="keyword">else</span>: a2 += i</span><br><span class="line">        <span class="keyword">return</span> max(a1, a2)%int(<span class="number">1e9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/count-good-triplets/&quot;&gt;统计好三元组&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/&quot;&gt;找出数组游戏的赢家&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/&quot;&gt;排布二进制网格的最少交换次数&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/get-the-maximum-score/&quot;&gt;最大得分&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;误触 command + enter 2 次，淦！&lt;/p&gt;
&lt;p&gt;前 10% 都没弄上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/02/VpT8KPrOoAkqc2E.png&quot; alt=&quot;image-20200802132822189&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 148. Sort List</title>
    <link href="https://zronghui.github.io/leetcode-148-Sort-List.html"/>
    <id>https://zronghui.github.io/leetcode-148-Sort-List.html</id>
    <published>2020-08-01T13:26:55.000Z</published>
    <updated>2020-08-03T13:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/sort-list/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/sort-list/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Sort a linked list in <em>O</em> ( <em>n</em> log <em>n</em> ) time using constant space<br>complexity.</p><p><strong>Example 1:</strong></p><pre><code>Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><p><strong>Tags:</strong> Linked List, Sort</p><p><strong>Difficulty:</strong> Medium</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><h3 id="超时写法"><a href="#超时写法" class="headerlink" title="超时写法"></a>超时写法</h3><p>根据<a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表 - 力扣（LeetCode）</a>的 partition 写的</p><p>86题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># dummy1 存 小于 x 的值; dummy &gt;=</span></span><br><span class="line">        cur1, cur2 = dummy1, dummy2</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                cur1.next = head</span><br><span class="line">                cur1 = cur1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur2.next = head</span><br><span class="line">                cur2 = cur2.next</span><br><span class="line">            head = head.next</span><br><span class="line">        cur2.next = <span class="literal">None</span></span><br><span class="line">        cur1.next = dummy2.next</span><br><span class="line">        <span class="keyword">return</span> dummy1.next</span><br></pre></td></tr></table></figure><p>一开始写的死板解法，但是遇到一个 testcase 全是  1，2，3 的链表，超时了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 快速排序</span></span><br><span class="line">        <span class="comment"># return head tail</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="comment"># return head1,tail1,head2,tail2</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(head, x)</span>:</span></span><br><span class="line">                dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># cur 指向那条链最后一个非 None 节点</span></span><br><span class="line">                cur1, cur2 = dummy1, dummy2</span><br><span class="line">                <span class="keyword">while</span> head:</span><br><span class="line">                    <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                        cur1.next = head</span><br><span class="line">                        cur1 = cur1.next</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur2.next = head</span><br><span class="line">                        cur2 = cur2.next</span><br><span class="line">                    head = head.next</span><br><span class="line">                cur1.next = cur2.next = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># head1, head2 可能为 None, tail1, tail2 一定非 None </span></span><br><span class="line">                <span class="keyword">return</span> dummy1.next, cur1, dummy2.next, cur2</span><br><span class="line">            </span><br><span class="line">            tail = head</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head, tail</span><br><span class="line">            head1, tail1, head2, tail2 = partition(head.next, head.val)</span><br><span class="line">            head.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(head1, tail1, head2, tail2)</span></span><br><span class="line">            <span class="keyword">if</span> head1:</span><br><span class="line">                head1, tail1 = quickSort(head1)</span><br><span class="line">                tail1.next = head</span><br><span class="line">            <span class="keyword">if</span> head2:</span><br><span class="line">                head2, tail2 = quickSort(head2)</span><br><span class="line">                head.next = head2</span><br><span class="line">            <span class="keyword">return</span> head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head , tail2 <span class="keyword">if</span> head2 <span class="keyword">else</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quickSort(head)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="优化后的快排"><a href="#优化后的快排" class="headerlink" title="优化后的快排"></a>优化后的快排</h3><p>划分为 small equal large 3个链表，对 small large 递归, 再合并 3 个链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 快速排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># small equal large 的缩写</span></span><br><span class="line">        <span class="comment"># 都指向相应链表的 head</span></span><br><span class="line">        s = e = l = <span class="literal">None</span></span><br><span class="line">        target = head.val</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nxt = head.next</span><br><span class="line">            <span class="keyword">if</span> head.val&gt;target:</span><br><span class="line">                head.next = l</span><br><span class="line">                l = head</span><br><span class="line">            <span class="keyword">elif</span> head.val==target:</span><br><span class="line">                head.next = e</span><br><span class="line">                e = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = s</span><br><span class="line">                s = head</span><br><span class="line">            head = nxt</span><br><span class="line">        </span><br><span class="line">        s = self.sortList(s)</span><br><span class="line">        l = self.sortList(l)</span><br><span class="line">        <span class="comment"># 合并 3 个链表</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dummy <span class="comment"># cur: 非 None 的尾节点</span></span><br><span class="line">        <span class="comment"># p: 下一个需要连接的节点</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> [s, e, l]:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                cur.next = p</span><br><span class="line">                p = p.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>写归并排序是主流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(h)</span>:</span></span><br><span class="line">            slow = h</span><br><span class="line">            fast = h.next</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            t = slow.next</span><br><span class="line">            slow.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(h, t)</span></span><br><span class="line">            <span class="keyword">return</span> h, t</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> h1 <span class="keyword">or</span> h2:</span><br><span class="line">                v1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">                v2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">if</span> v1&lt;=v2:</span><br><span class="line">                    cur.next = h1</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h1 = h1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.next = h2</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h2 = h2.next</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 把链划分 2 半，递归排序</span></span><br><span class="line">        h1, h2 = map(self.sortList, split(head))</span><br><span class="line">        <span class="comment"># merge 2 条链</span></span><br><span class="line">        <span class="keyword">return</span> merge(h1, h2)</span><br></pre></td></tr></table></figure><p>优化合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(h)</span>:</span></span><br><span class="line">            slow = h</span><br><span class="line">            fast = h.next</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            t = slow.next</span><br><span class="line">            slow.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(h, t)</span></span><br><span class="line">            <span class="keyword">return</span> h, t</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> h1 <span class="keyword">and</span> h2:</span><br><span class="line">                <span class="keyword">if</span> h1.val&lt;h2.val:</span><br><span class="line">                    cur.next = h1</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h1 = h1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.next = h2</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h2 = h2.next</span><br><span class="line">            <span class="keyword">if</span> h1: cur.next = h1</span><br><span class="line">            <span class="keyword">if</span> h2: cur.next = h2</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 把链划分 2 半，递归排序</span></span><br><span class="line">        h1, h2 = map(self.sortList, split(head))</span><br><span class="line">        <span class="comment"># merge 2 条链</span></span><br><span class="line">        <span class="keyword">return</span> merge(h1, h2)</span><br></pre></td></tr></table></figure><h2 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h2><p>归并慢些</p><p><img src="https://i.loli.net/2020/08/02/jsFn69BiDbMo87c.png" alt="image-20200802095356739"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sort-list/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/sort-list/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Sort a linked list in &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ) time using constant space&lt;br&gt;complexity.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3
Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0
Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Linked List, Sort&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Medium&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
    
      <category term="Linked List" scheme="https://zronghui.github.io/tags/Linked-List/"/>
    
      <category term="Sort" scheme="https://zronghui.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%9B%BE.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%9B%BE.html</id>
    <published>2020-08-01T04:03:59.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="有向图-floyd-算法"><a href="#有向图-floyd-算法" class="headerlink" title="有向图 floyd 算法"></a>有向图 floyd 算法</h2><p>经验：</p><p>若求的是 2 个节点之间，往往用 xfs 或 并查集，因为用 Floyd 的复杂度过高，如<a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路 - 力扣（LeetCode）</a></p><p>若求的是 queries (要查询多个节点对)，这时候用 flyod 好一点，如<a href="https://leetcode-cn.com/problems/course-schedule-iv/">1462. 课程安排 IV - 力扣（LeetCode）</a></p><h3 id="1462-课程安排-IV-力扣（LeetCode）"><a href="#1462-课程安排-IV-力扣（LeetCode）" class="headerlink" title="1462. 课程安排 IV - 力扣（LeetCode）"></a>1462. 课程安排 IV - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-iv/">1462. 课程安排 IV - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, pres: List[List[int]], qs: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> pres: dp[a][b] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> [dp[a][b] <span class="keyword">for</span> a, b <span class="keyword">in</span> qs]</span><br></pre></td></tr></table></figure><h3 id="743-网络延迟时间-力扣（LeetCode）"><a href="#743-网络延迟时间-力扣（LeetCode）" class="headerlink" title="743. 网络延迟时间 - 力扣（LeetCode）"></a>743. 网络延迟时间 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/network-delay-time/submissions/">743. 网络延迟时间 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times: List[List[int]], N: int, S: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">-1</span>]*(N+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</span><br><span class="line">            dp[u][v] = w</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> (dp[i][k], dp[k][j]):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">-1</span>==dp[i][j] <span class="keyword">or</span> dp[i][j]&gt;dp[i][k]+dp[k][j]:</span><br><span class="line">                            dp[i][j] = dp[i][k]+dp[k][j]</span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i==S: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">-1</span>==dp[S][i]: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            res = max(res, dp[S][i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1334-阈值距离内邻居最少的城市-力扣（LeetCode）"><a href="#1334-阈值距离内邻居最少的城市-力扣（LeetCode）" class="headerlink" title="1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）"></a>1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/submissions/">1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[float(<span class="string">'inf'</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">            dp[i][j]=  w</span><br><span class="line">            dp[j][i]=  w</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment"># if i==k: continue</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="comment"># if j in [k, j]: continue</span></span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])</span><br><span class="line">        l = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 连通城市个数</span></span><br><span class="line">        mi = <span class="number">-1</span></span><br><span class="line">        m = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> j!=i <span class="keyword">and</span> dp[i][j]&lt;=distanceThreshold:</span><br><span class="line">                    l[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l[i]&lt;=m:</span><br><span class="line">                mi = i</span><br><span class="line">                m = l[i]</span><br><span class="line">        <span class="keyword">return</span> mi</span><br></pre></td></tr></table></figure><h2 id="无向图-dijkstra-算法"><a href="#无向图-dijkstra-算法" class="headerlink" title="无向图 dijkstra 算法"></a>无向图 dijkstra 算法</h2><h3 id="1514-概率最大的路径-力扣（LeetCode）"><a href="#1514-概率最大的路径-力扣（LeetCode）" class="headerlink" title="1514. 概率最大的路径 - 力扣（LeetCode）"></a>1514. 概率最大的路径 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">1514. 概率最大的路径 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProbability</span><span class="params">(self, n: int, e: List[List[int]], succProb: List[float], start: int, end: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># defaultdict 构造 graph</span></span><br><span class="line">        graph = collections.defaultdict(dict)</span><br><span class="line">        <span class="comment"># 因为这个题目比较特殊，权重是乘性的并且0-1之间，所以可以用一个dic记录从start开始到每个节点的最大权重。 然后每次你只需要判断pop出的节点的权重就可以。如果比曾经记录的dic中的权重小那就没必要继续（这里面包含了环，回头），如果比曾经记录的权重大，那么继续进行。</span></span><br><span class="line">        d = collections.defaultdict(float)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(e)):</span><br><span class="line">            p1, p2 = e[i]</span><br><span class="line">            graph[p1][p2] = succProb[i]</span><br><span class="line">            graph[p2][p1] = succProb[i]</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        stack.append([start, <span class="number">1</span>]) <span class="comment"># start 到 当前点 的 概率</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur, prob = stack.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur==end:</span><br><span class="line">                ans = max(ans, prob)</span><br><span class="line">            <span class="keyword">elif</span> prob&gt;ans:</span><br><span class="line">                <span class="keyword">for</span> point, _prob <span class="keyword">in</span> graph[cur].items():</span><br><span class="line">                    <span class="keyword">if</span> _prob*prob&gt;ans <span class="keyword">and</span> _prob*prob&gt;d.get(point, <span class="number">0</span>):</span><br><span class="line">                        d[point] = _prob*prob</span><br><span class="line">                        stack.append([point, _prob*prob])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="207-课程表-力扣（LeetCode）"><a href="#207-课程表-力扣（LeetCode）" class="headerlink" title="207. 课程表 - 力扣（LeetCode）"></a>207. 课程表 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/">课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解） - 课程表 - 力扣（LeetCode）</a><br><a href="https://www.bilibili.com/video/av17399461">拓扑排序_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        indegrees, adjacency = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[b] += <span class="number">1</span></span><br><span class="line">            adjacency[a].append(b)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># path = []</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            path.append(cur)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adjacency[cur]:</span><br><span class="line">                indegrees[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># print(path)</span></span><br><span class="line">        <span class="keyword">return</span> count==n</span><br></pre></td></tr></table></figure><h3 id="210-课程表-II-力扣（LeetCode）"><a href="#210-课程表-II-力扣（LeetCode）" class="headerlink" title="210. 课程表 II - 力扣（LeetCode）"></a>210. 课程表 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/submissions/">210. 课程表 II - 力扣（LeetCode）</a></p><p>依赖关系反过来了，而且需要记录 pop 的节点顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        indegrees, adjacency = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> b, a <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[b] += <span class="number">1</span></span><br><span class="line">            adjacency[a].append(b)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        path = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            path.append(cur)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adjacency[cur]:</span><br><span class="line">                indegrees[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># print(path)</span></span><br><span class="line">        <span class="keyword">return</span> path <span class="keyword">if</span> count==n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h3 id="802-找到最终的安全状态-力扣（LeetCode）"><a href="#802-找到最终的安全状态-力扣（LeetCode）" class="headerlink" title="802 找到最终的安全状态 - 力扣（LeetCode）"></a>802 找到最终的安全状态 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/submissions/">802. 找到最终的安全状态 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/solution/tuo-bu-pai-xu-cong-chu-du-wei-0de-hu-wei-fan-xiang/">拓扑排序：从出度为0的弧尾反向拓扑到弧头（muyi） - 找到最终的安全状态 - 力扣（LeetCode）</a></p><p>定义安全的点：路径终点，也就是出度为0的点</p><p>定义最终安全的点：从起始节点开始，可以沿某个路径到达终点，那么起始节点就是最终安全的点。</p><p>找到出度为0的顶点，这些点是安全的点<br>逆向删除以出度为0的顶点为弧头的边，弧尾的出度减一<br>重复上面两步，直到不存在出度为0的顶点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        outdegrees, adjacency = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> graph[a]:</span><br><span class="line">                outdegrees[a] += <span class="number">1</span></span><br><span class="line">                adjacency[b].append(a)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> outdegrees[i]: queue.append(i)</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># count = 0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            path.append(cur)</span><br><span class="line">            <span class="comment"># count += 1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adjacency[cur]:</span><br><span class="line">                outdegrees[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> outdegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># print(path)</span></span><br><span class="line">        <span class="keyword">return</span> sorted(path)</span><br></pre></td></tr></table></figure><h3 id="310-最小高度树-力扣（LeetCode）"><a href="#310-最小高度树-力扣（LeetCode）" class="headerlink" title="310. 最小高度树 - 力扣（LeetCode）"></a>310. 最小高度树 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/submissions/">310. 最小高度树 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>: <span class="keyword">return</span> list(range(n))</span><br><span class="line">        <span class="comment"># 每次移除所有的叶子节点，直到为空，返回最后一次非空的列表</span></span><br><span class="line">        <span class="comment"># 最后一次非空时，节点一定不大于 2 (等于 3 时， 一定有非叶子节点的节点)</span></span><br><span class="line">        degrees = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="comment"># 入度或出度</span></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> edges:</span><br><span class="line">            adjacency[i].append(j)</span><br><span class="line">            adjacency[j].append(i)</span><br><span class="line">            degrees[i] += <span class="number">1</span></span><br><span class="line">            degrees[j] += <span class="number">1</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> degrees[i]==<span class="number">1</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> n-len(s)&lt;<span class="number">3</span>: <span class="keyword">return</span> list(set(range(n))-s)</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                i = queue.popleft()</span><br><span class="line">                degrees[i] -= <span class="number">1</span></span><br><span class="line">                s.add(i)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> adjacency[i]:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">in</span> s: <span class="keyword">continue</span></span><br><span class="line">                    degrees[j] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> degrees[j]==<span class="number">1</span>:</span><br><span class="line">                        queue.append(j)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1042-不邻接植花-力扣（LeetCode）"><a href="#1042-不邻接植花-力扣（LeetCode）" class="headerlink" title="1042. 不邻接植花 - 力扣（LeetCode）"></a>1042. 不邻接植花 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gardenNoAdj</span><span class="params">(self, N: int, paths: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">chooseone</span><span class="params">(exclude)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> exclude: <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        m = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> paths:</span><br><span class="line">            m[a].append(b)</span><br><span class="line">            m[b].append(a)</span><br><span class="line">        res = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">            res[i<span class="number">-1</span>] = chooseone(exclude=[res[j<span class="number">-1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> m[i]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res[i]: res[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>简洁写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gardenNoAdj</span><span class="params">(self, N: int, paths: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        m = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> paths:</span><br><span class="line">            m[a<span class="number">-1</span>].append(b<span class="number">-1</span>)</span><br><span class="line">            m[b<span class="number">-1</span>].append(a<span class="number">-1</span>)</span><br><span class="line">        res = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            res[i] = (&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;-&#123;res[j] <span class="keyword">for</span> j <span class="keyword">in</span> m[i]&#125;).pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="997-找到小镇的法官-力扣（LeetCode）"><a href="#997-找到小镇的法官-力扣（LeetCode）" class="headerlink" title="997. 找到小镇的法官 - 力扣（LeetCode）"></a>997. 找到小镇的法官 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/find-the-town-judge/comments/">997. 找到小镇的法官 - 力扣（LeetCode）</a></p><p>晦涩的解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trust: </span><br><span class="line">            <span class="keyword">if</span> N==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># judge 不在 a 中</span></span><br><span class="line">        <span class="comment"># judge 出现 N-1 次</span></span><br><span class="line">        s = set(range(<span class="number">1</span>, N+<span class="number">1</span>))</span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> trust:</span><br><span class="line">            m[b] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> s: s.remove(a)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = s.pop()</span><br><span class="line">        <span class="keyword">if</span> m[res]==N<span class="number">-1</span>: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-the-town-judge/solution/yi-ge-shu-zu-gao-ding-tong-su-yi-dong-997-zhao-dao/">【一个数组搞定】通俗易懂（997. 找到小镇的法官） - 找到小镇的法官 - 力扣（LeetCode）</a></p><p>法官👩‍⚖️ 实际上就是出度为0，入度为 N - 1的节点。这固然没错，然而我们仍然可以换个角度来思考，法官👩‍⚖️ 同样是 入度 - 出度 == N - 1 的点，并且不是法官的人不可能是。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        l = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> trust:</span><br><span class="line">            l[a<span class="number">-1</span>] -= <span class="number">1</span></span><br><span class="line">            l[b<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> l[i]==N<span class="number">-1</span>: <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="841-钥匙和房间-力扣（LeetCode）"><a href="#841-钥匙和房间-力扣（LeetCode）" class="headerlink" title="841. 钥匙和房间 - 力扣（LeetCode）"></a>841. 钥匙和房间 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/keys-and-rooms/submissions/">841. 钥匙和房间 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 从 0 是否全部连通其他点</span></span><br><span class="line">        visited, queue = set(), [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            queue.extend(rooms[cur])</span><br><span class="line">        <span class="keyword">return</span> set(range(len(rooms)))==visited</span><br></pre></td></tr></table></figure><h3 id="1267-统计参与通信的服务器-力扣（LeetCode）"><a href="#1267-统计参与通信的服务器-力扣（LeetCode）" class="headerlink" title="1267. 统计参与通信的服务器 - 力扣（LeetCode）"></a>1267. 统计参与通信的服务器 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/submissions/">1267. 统计参与通信的服务器 - 力扣（LeetCode）</a></p><p>暴力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        rows, cols = defaultdict(int), defaultdict(int)</span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    rows[i] += <span class="number">1</span></span><br><span class="line">                    cols[j] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> max(rows[i], cols[j])&gt;<span class="number">1</span>:</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="133-克隆图-力扣（LeetCode）"><a href="#133-克隆图-力扣（LeetCode）" class="headerlink" title="133. 克隆图 - 力扣（LeetCode）"></a>133. 克隆图 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/clone-graph/submissions/">133. 克隆图 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/">DFS 和 BFS - 克隆图 - 力扣（LeetCode）</a></p><p>dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val = 0, neighbors = []):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> d: <span class="keyword">return</span> d[node]</span><br><span class="line">            clone = Node(node.val)</span><br><span class="line">            d[node] = clone</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                clone.neighbors.append(dfs(neighbor))</span><br><span class="line">            <span class="comment"># d[node] = clone 放这里    ↑ dfs 不断递归调用</span></span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(node) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="1306-跳跃游戏-III-力扣（LeetCode）"><a href="#1306-跳跃游戏-III-力扣（LeetCode）" class="headerlink" title="1306. 跳跃游戏 III - 力扣（LeetCode）"></a>1306. 跳跃游戏 III - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/jump-game-iii/">1306. 跳跃游戏 III - 力扣（LeetCode）</a></p><p>floyd 超时 用 bfs 解决</p><h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> arr[start]==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 有向图 判断 start 到 0 处是否可达</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        i0 = [] <span class="comment"># 0 的 index</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> arr[i]==<span class="number">0</span>:</span><br><span class="line">                i0.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i+arr[i]&lt;n:</span><br><span class="line">                dp[i][i+arr[i]] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i-arr[i]&gt;=<span class="number">0</span>:</span><br><span class="line">                dp[i][i-arr[i]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> i0:</span><br><span class="line">            <span class="keyword">if</span> dp[start][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        visited = set()</span><br><span class="line">        deque = [start]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            cur = deque.pop()</span><br><span class="line">            <span class="keyword">if</span> arr[cur]==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> [cur+arr[cur], cur-arr[cur]]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=nxt&lt;n <span class="keyword">and</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    deque.append(nxt)</span><br><span class="line">            <span class="comment"># print(visited, deque)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="面试题-04-01-节点间通路-力扣（LeetCode）"><a href="#面试题-04-01-节点间通路-力扣（LeetCode）" class="headerlink" title="面试题 04.01. 节点间通路 - 力扣（LeetCode）"></a>面试题 04.01. 节点间通路 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路 - 力扣（LeetCode）</a></p><p>flyod 超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWhetherExistsPath</span><span class="params">(self, n: int, graph: List[List[int]], start: int, target: int)</span> -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> graph:</span><br><span class="line">            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[start][target]</span><br></pre></td></tr></table></figure><p><del>xfs</del> dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWhetherExistsPath</span><span class="params">(self, n: int, graph: List[List[int]], start: int, target: int)</span> -&gt; bool:</span></span><br><span class="line">        visited = set()</span><br><span class="line">        m = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> graph:</span><br><span class="line">            m[i].add(j)</span><br><span class="line">        queue = [start]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            <span class="keyword">if</span> cur==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> m[cur]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="1361-验证二叉树-力扣（LeetCode）"><a href="#1361-验证二叉树-力扣（LeetCode）" class="headerlink" title="1361. 验证二叉树 - 力扣（LeetCode）"></a>1361. 验证二叉树 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/validate-binary-tree-nodes/submissions/">1361. 验证二叉树 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateBinaryTreeNodes</span><span class="params">(self, n: int, leftChild: List[int], rightChild: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 所有节点入度为 1， 除了 1 个节点没有入度（root）</span></span><br><span class="line">        <span class="comment"># 然后从 root 开始遍历，若能无环地遍历所有节点，则满足条件</span></span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            left, right = leftChild[i], rightChild[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">-1</span>!=left: indegrees[left] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">-1</span>!=right: indegrees[right] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> max(indegrees[left], indegrees[right])&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        root = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> indegrees[i]==<span class="number">0</span>: </span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                root = i</span><br><span class="line">                <span class="keyword">if</span> cnt&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> cnt==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        s = set()</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> s: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 已经遍历过，说明有环</span></span><br><span class="line">            s.add(cur)</span><br><span class="line">            <span class="keyword">if</span> leftChild[cur]!=<span class="number">-1</span>: queue.append(leftChild[cur])</span><br><span class="line">            <span class="keyword">if</span> rightChild[cur]!=<span class="number">-1</span>: queue.append(rightChild[cur])</span><br><span class="line">        <span class="keyword">return</span> len(s)==n</span><br></pre></td></tr></table></figure><h3 id="1162-地图分析-力扣（LeetCode）"><a href="#1162-地图分析-力扣（LeetCode）" class="headerlink" title="1162. 地图分析 - 力扣（LeetCode）"></a>1162. 地图分析 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/submissions/">1162. 地图分析 - 力扣（LeetCode）</a></p><p>bfs</p><p>python 无法跳出指定的外层 loop，可以用函数 return 实现同样的效果，且代码更清晰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        n = len(grid)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>&lt;=i&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> grid[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxDis</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> dis <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">2</span>*n):</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(dis+<span class="number">1</span>):</span><br><span class="line">                    y = dis-x</span><br><span class="line">                    <span class="keyword">if</span> any([valid(i+x, j+y), valid(i+x, j-y), valid(i-x, j+y), valid(i-x, j-y)]):</span><br><span class="line">                        <span class="keyword">return</span> dis</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># cur = -1</span></span><br><span class="line">                res = max(res, maxDis(i, j))</span><br><span class="line">                <span class="comment"># print(i, j, maxDis(i, j))</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>tricks-2020-08</title>
    <link href="https://zronghui.github.io/tricks-2020-08.html"/>
    <id>https://zronghui.github.io/tricks-2020-08.html</id>
    <published>2020-08-01T04:03:43.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="0c9c0dd3ca6833daa1e30cee95f7f4e8db2fe63a2db743726d7a1e1ae38e72b6">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dd85bdd0ba216a9a3ddb0ba4af683a3234740fdce8265b492f7f7c66e06ca477ca5eefea6853f46f0c4c21eba11069307a68c85baf47613206b7b7fa8342ba3e63b45f5e3027eb5393ad2a79dc1f9c6d3338a513824885d7bebc234bc31ad8ad14d441cf09b4d13cdb86bee7a2ca4835273ddadeb22d8717f48d46eab635fc3a98e8cd6e6c7050184b3de31048bfad0b31a2eeaf658a30f37f94238f9f2675fcd932c390b2a429344ae9c61be1585af84006dffd7109897fb63ee82e1fab38112a768f9958c63343c8a73556b04dfca139601ba171f9312675c1a15e34db68ad394a9ab09df093deced08a54f89b35bf63c8921997c6f0fc1620e46182430d24596b602f93253de0cd415e34178eccdfb7f1535aef8157a9b5c627ec92e398231b79294b374cfb5a9b57091387a294e702bdca9f8d30db6cc23c22b75be5b0b6697b5fa4e8d8e16a750816cd5944a261e3f0d1bde7a38860c4527cb68db6681643e44df6c5422aebe8b390b0ae2a4455a7073f440f7fa4ff15396b9505940c665de03191e0cb3bd50d12fd984fedf12340ecba13fce71bce0a6462ebc171d516145e022b6e34129a4dc32425052ffffd3552c034a91e1672445bcf867d5d25be7b3c1d23fc01d0e85e16bfc811404520d191a28f5b72d533fc4bba59aa0c1b64d68c3aebf648b0703343a99243e124abbceeca225197f4eef9f550bfb9311bc93d783f89ea6bceb0c86d4ca1b7b409421755c4193d7faa5a63c2e8c9772b52604db1fe8d10e7483838a7cdfa250802656303e03b70b033571413dff1c96a76cf9cc88c694afc9f338ffb515d95cbef1c9a8495a2667cbc1ed66227a079ef8c7823986c04890238f98125a9f7371276855156e58ad9f769e24e00826740d239b1ce8ca23d6182b4b7eb75506e8c9972bed206a8a62c08dbdde0621326783c4b1041e8949271d7b7b899818ebfef06d117fe1fe32265795dbd916138a61d9364f156cb6267ce304b4418409265f9508b126b186eb9913f4643f2b725ba169c7fcf677e01a67ca3208fd6abbaceff38baaf4aa3191e8a77bec84be52bf73a074a2b307f6873db8ad8aa6da1e226076064bd091c9295134b3c0722bae4c13da492ed36fcf2a9ac5bec809f4af9a08200f11382acced4dd147dd2ed11d21fb690edf8f8ffad2402df815e095c71458c682dc5d36bf19096e5d509ad4fd7ceca1d6ede2be5fe9fc49c28490fed2e4609e48663cc98bbea9f0d2cd468dd9462c8d7d1453d38d5d17d91460476a24ac6d3917786f077d1a770c9cc97f638157fd75ad6ac1d4b1dd96ba676cfb4b5f920e8043bff6edb26f2061303a9ae99519d3018619517cd5acb121eb7831d43c50fde8baf00883eb9f3bee71005adf8061c442af7e64711c9c3699ccfa24edf8843be2d9526e089ece1df673abcc22905393bad2da4956be255ff98d5867af52576e49c841ff189b0135d721a5abe5fecc5073a4fe6c1854d76bf2a05003522b4c33cb72ea8c2718b55e3f750ba263c65440a4604d5f836c579a9d84e38a39b85799bdc09ee46eed996bfcec1b9ea43aa9d667d93fad8cb8721340ba8c8698f8415fffa2338b8ad4ba139b7bef25ba78e0735e38d871c9fac5099072e87daa674c4443da65891b333de958df2b28a85b93c37e0454e50380671b7f8e8d5a00bfba0b4bbf8d55c440d0479169d8cf941aae47834dc4b127298ece43f8102e413b749b9a5872a44609e7179f292adc2e4ac800872d43d272d07306ff301bd4169d89690ef541a4bd8150fd8c953bf2dfc2a0bb3fe5dc7db67b2743564f8d1e4d600242517e13a158c5831b083a5a0614cefabc055750b873803184a8ffcecfb9322f3be61ff762ec997f15da03b90f5b5795c265a7fab48d0135c4535e283b8db74a5de2b89faef1aad228823175062aa5418787bbcb5acd146d9e7de3d56032c58af8d6fbb18341cc1bf7880c70e89e475e0d452a8cae78cd554cfa7d8b417997d9eaf68f58ab00fea73b4e7f6a7d0af993f044e19f5343846c4f39bcd52ef77b16b6a66e067636854190491c97d3809cd952d9702244dbc933163ed70f309d5435b4dde0c3b24c598da6a39b687c9c327c56e0fc55011acb9cf2361a7bb8f9469d967b9465a055475b4b786d2328dbdddef47fef832f677b9c8ccc2a8de85f4a25bfe290990fc395815984cad3a5779f7411aa050dd1e499cb20b2d999ac304e6618723120cb642296c04f8bcfa20a8fb72bbea5f14dea3b70a3473b3f04a277f0bcc1b612d720440db9b814d86f70ee9cc59879b53a645cfdd64e86e19df07e0364c0d9d33ff6d58dbe1736cf3890fe3d1461a3fa2b1a4811d6a112701111c66ca5ad782c84e1051728ee946dcd4156b836f1980eb7a09c82088454b6ad4671c81a3e576849359855065cd6d1932ff89d90ef857d5dbf9381e660b7a33af02c972ce297ea94b09468772128cc7d819fe872edb82a4dd3839f45aa54deaf1f9eb993584536fd963a8de5b5d44aeb54f638a2efdd3bf5198c61f91d552182a0e6bdf5729b3ea09ad0acb2358a0291af0827cdf40cc83b5c3c4a284564528febd4b3aaa6d096571f5034822ce107088d4d9fcd397246a72b38f9aacc62d80ea2534eb7a8ab3f91a5cdea87943c2a247027c223f6304972b0126379e73a7d31677007787730e26265814ba784d6676075292055fa0b4a80a414086d5fe0a349b77ffb4f0e2f148f7f5ecae598000b079aabc94661f2aacfd1559837e5b966f47a82139f19d268d33002e65006e3d89f2bdfcbbe316c81024493b02e07c90d18d3d8d77b2c40e93003ef9885d9ea8ae4c8962bf787aadbd02e82fc2c007266af8a9a6cd11987f408af517d7939e0e6bdd121c68bb2209f0c6e6d03e0d322a20ffe57b57b9b13bfdd904e40d0ba7ddb64a545ae502553a338dcb9f6e1046e861b14bfea7c5c6134e4241bf256ae7735bc0d11167bfa18bdc2a235ea41b1f38104f1f4a50b2f8f2b5e1d29df06521f4b72207454418b8b77320c6ecf4c98f5c6ec200dacd947c171b1a1cdb442ec7b04439fc29ae69f0c34346049ce0f9656902f8a0290bc48a3b2e0b55cb664f5e8a6c8dba72bcdbf7c51c8ad4f4c9c4834527eaa0aa526bd907f39171103f7e7eedfccdfc1f97f3fa6b10316f49428d854a8859ed6731e88ab6c4f8f13d87e39e5445be294ad5aa84e32e3501d0ecbef62929548252d6933e478fe8c8a5cbbb7714b915a534b0094234f30bb8fdf473b68c6e700fdc1a3fb806511d76e259ffc3f26e9af38979acb048d30c50d19631f23dc28258809e0f42b6ae986f5a361f9953480c2027cf16b854dda7a7d754a2ec80b53e058981e746f8c0aeccb357bc56768a8ae7f1f64c62f1e5c7c12aceba598620ebeefb3e619e2695c7c247441c57edb00af439f35aa7af7a21e59bb656bd0d2b7f6786215b85ed1ce1f41da3ec8dbf4153af909b8d145fe2617f4a58100aae5a2bf8e3b06e1e69ed7b331bd35e927b218fa8d9648f239d27e19ccfdb346e1565f725f34e4868620f96531c105ef3786db1555fdc1d820a1434f935f3f5b981f513d354ce2c0e33f28249e64e43ab80c643f1d430fb779e3f8e52e3e6a36a5f8a6980775ee90492a0eca696a1820c5d272f9d7c9dfdaf5c6b7c1ab59065f5fb03261089086d0038bc4a4f351e92403d62bd47854e497ac36caf1b17e86c940d23cb1f423f291cc2c7a0210d8c97b83ff03ef0ffa90a3bdfe6f499b7e432457e195a976123161f2265372fb91c3a4f58f366694ec16496536a730e133a69cfc32c05b946b304fca0e98785cc25b88bbd19e5afb7b5cc0e5581da4a6b6bc13afc913d31fc0ec8b330e78dd71925ea182f55cb7d43ce3e2e1d1ee700245341f5af1f55ed4c0765db5587f897357080fc68009237f3f08bfca9cb74bd52e4c286d6bfcf9b64c449a6f12362bda4469cf98253583cc8e2b51de47be07fe49fba2b38bf83a9a9388989ea2cecfab5af9604f0a068d1b3ddead977526225bd0701cad4e547a42e58805642c6ee67990fffe9d061db1183637231f993b68b111680914b31cb6e00dd7f610d6702c1495220893425124b3b3c09ed0b668239bbd0b287edf40c7a5af810b06a903f4bfb5717546c764cc6d2c94b9ccfdf9687ace02c7b9619e102839c74137a185b12e3ee1dd1758cdf6d99da8dff3bb50af4917800580fe4d3fbb4d2f5e095e45cccda7548d0d5bde503a320cecdaac2eb6aae0de7004b571ec34e6f7d9a05fe77927fd93639e4e71c3375e3466098228bf5d3b4bc2f70a461500807e1ed1c9066286f99682f0da3c0b653a7e59135fe36c9136e63557454f88956a69fd1b2333eae73c66bdc7b446ae95be67ecfb6c4ba90f17c9464f0c8e0c68e76741e8e20ba58b2cf5a07d2808cba0d5c406f027de92156d3a40c620aa052d4ec06fb68369d845592497bbb18b0e0355a7a35b3ffaacc97eb5a3b9cd86c436c1cf05cb4bf75ec01be89d0a09af53d680e8083478335a79bc3b037e216a99c939f6615b8f321244dc9c68eb1b479331c5848f720b620b431db483feec73bccd779c225017915f3736558c4f2411db2f3ed6cf64b59f0665ace2d490129d8668f3bfc6c7a83430e970444bf35c951161d3e14e7997cedbcc0afdb7e39f5d1f13c92bcced9057829f9b355086d949255935634523237f3c2c2edb4eba2d407c1c1974345fef6f601bad0190672f5596a7c4edba9465a93cc4f82c8b65bcade263741db7ac9cfc815e990f6132894ddb17928d2272bbc86ddb9d5083d4f85ed6622aeb0abfa4a05455bdc2111862d9cf74b54cae4602528fce8a035ed627caae2b580a9fc69067a8e3b7983a01e2ca1864a03ae8988efe205f5a6a34c28082d7db9301843ed718a3e13a8145e296bab95b6c257e89d8bbd8cda85bec82e71124d4e01e12c7eaebba598d44949bf355875fa92a50c605611e1228f7e022e4e5570c619108325f1e2b9464cfa1727a62505f76b755a5c7591d351b96175960fe108d3d1ebfdf18671fb62b50370b345cb59f623a1eb902178527d9085a2603215527f911c510083cba96704c6a952560b551c4b0460bc2aadc4b336a28009635de855ce44ec068edb4791ce87dc05c82ea1b23c897f2f8ff8f4c3ec58d4f4ffe7d92d6e2103a0212f7bb5fc89dfb4281245b38856e0749f76be5eff4eebe036b3a83104ac6fd965220f1d0574e27ab5373c8cd40cbfb3dac8fd3f041fbdc74d846a82f77c70041678cd2a858537bdfb6bed55b4d97c179ad964617d7b007348e124da04480729b92b8e37220245ca1b0cb09136b99a7536354a98993dc701000b1a596dc677ff226f8d9c25f73511b694e3196d3d63a0a2f276d42398b8d7082a0d979ad82e75d96ab70e13d4177963eea690c0296e03c767ad0f28950ae69854d8f1c78ef3d1633adc32d57c565d9f80f7eca98ba530943c51b3827e14d637c58d033473d9f03b5f0e0f21d1e20243f502fd6b5a231e2a6b1b1871aa3616f55010a0e08c4003f627a8616194dba417e1bb2a2cbb843d74eebfb9f4fc56115f9cc78405e44c46bda512d3508964bd0514437abeda1399fc98fc2dac6c8f7a0e81f27d45f192da43ee709fc3a0f075d8661ad7c5af2e0dbe05001164ba6f1b18e03e07349783756a879ec63e73660f142214128dbdb05c41cf4abfe1ce11ba6109d0ed79ad647165290e81e2c87cbc74f0de90ac4bbecff3631343f0417e2bbc42aa5bee0128b4babe2c09d3a1d923b5c05ba2addf991ee32f0ca25c98016d4bc959b8ac70f44d693ab9145a37aa7b59f4a043d581813f3a0328425252221306fb30cc1b9d71da0bfb3efa2cc061aad708071dc6506eb39a43741ca79c6e0877ae7c6a14981bb0a29d26c6550e629939bf7109ab0d51024f028277452ec8721627f070e98d697eff5f0a75ff80b7be354bf686df4f0ea1a4007df9b1ecfcda8d44be69b42ce296fee3758c8706bf90bc9e51bb4919d47fee2b2ecef334d65150e390fc940060ba9690e171cfd7de9a34b80f770f3f86388632c9ec47bcddcccb38c4b6f7ad2ba8a20762c4d40194ad4a7dadf35c2e554119504970021406b26a94bdca90f39486ffd108e882eb25ce1d7be44343f42b250b70c9db7113579ee6ac16a5011fd7d9ccdf3db66bbbf786ff6cdd5c2d311fa67869dce0da3a327a8859bcc74527655b3bee4aee5d437e1dcaeaa2b1d875df9aebfd4f694aa93536436f2f29ebebbe5f5004c9e0c76767eb6d78034ccc67e413c6913e07ff8cbe758721ccee33ab2372c507d47d60e37267ed908eac76176c008334d4df4e35ce04f45e98440ffe1cdcecd4400765e2e62f1eb703cfb186679e9dee88927623f80d31fb435009eca34fd6228e75a38c1d97b6bad470ee95859cdffb776cd9bc207f3441fa70ff9e4eddf04d518310cc77a97db5e4a4cb032782113923e2efc43922dc531ba53c918019180d8b642b4ab609ece646e2db060fbcff3851b566619713c290fb89456a080f6eb719b6ffce88256de65ff420cde578b32af15690d9d0f170c7f665e1c4f5a9a02bdf184742527e0e35e872418401bfb40596cd40c33e1166126040b74037363759385acf1a5fd2d15ff916bf9461822533a9a497d1b8e4a73e6afb63c7cf6009fffef2d4b17613aa5949e1aba4591c84d8d1a46cf6a7a4aef15287dffe96da6454f56d1926898b23070dd324a9f19b0c51a69d6068d9ae299190901817958b1749197c62143c3dc666f75e1f7896557493b1539d724b0d6c41c7157df738d48cbf9bb1fc52d641d8130860e803dce29f51115c6daaae6f182ee9ba7a062abbc22aa6096d4499e9364a2e3c02e09d207653fe73f1daf5d206982cac6936a79f435c62beb3b6b08a1e5a8603bb98291d7c5852a6e4c34880c3149f8303b9882b388a9d22a0e18a760da016091b532887f5a0ac38ce5b19d29dd87521a70e70b6baa95acaff93c71961cf3584554f6ca59cfe4a21c8c65d8d35483adb561799433785baeb9a912fbcd01f568c037d0cc37283650652ee56f2b7a68ad839a8919a9ad54a1ab842e69a498ea8d91afbe392071d6a0c5faad1228dce61d850b2ca4c235a8d7e5ccd82ca876eea699cc01da019a5b8f3a89f0554595393e19170e8b9e65b9f48a26bdf61f4e86cbe14cceeb416d5f15525b68d895550481e7fa94c61ca18cc63560f959ef8f9f8978c9750142dfa7f999091332b5bb1b656d98888a96ec6d719c3cd742cf0f1c53352df6e8b97b8777fc050153ab64f0c7963b087d492e45e1b9a46867d580df723154e7ee05fbccf4a77081c950742b22a9f74dda7314aa99257f1e3cbaeaf4d795539ae6f70fba729b57e33cc5d7307384051f4ef691efa93546969d73542be6cb66586476746912c93b99af2c355cf5812db623ab90a8d8b2d998560b87ac185c84ffa1a8c1db79d12ca852d1fe677b69f5f9c6a9eaf59a81c0365a3e9410f4ed3541424dbf180e47f7e020a98538ce20dcd36d2be2564925b124b1b9d4c056ca4404e1e65acd297e3024aea223d4ebe8c67e5f1033157196dafa5acadb2bd68814245337240229b0bc3a7c222383563772ea42b5b3cf32d032dfffe927cc57e1dc2181ad96ada94bedeb3468963ca9247dfe82eb7a40db218f9027da174203752c78c6263c819a585a7070e71f0330abfcc37256b0ad7642466f102d67ccb744d047cfb491abd9fd7b946e24ed72f8cc9e8689d8eeed5a2b83d3ecf693f5ff6c94227814c320938df25db90f6824346bffb3a94d4c4f2895db758b686b8e44f7adb12edf7cd3160ae008293282599f9f759c2f77e5ce5bc61266bd47bb3109ffdbec449c9b7dcf922840da0b5d0c531ad07d739075e503d7141a46bbcd68453b90f944787b73f6992134954575edfcc2ddaaebd5a68a9c51bac9d2a5fb912cce78ac59ca787ac7515f09effeba02983b568b4638d4b48c63843190ea0e85a7a2417679a49d08306e0e3d6b8c0ab18dc9390d1c547f048707a87aa54f79d791d79a54b7f32980bdc84e38fb077843595270831148acb22d61cab8459b019e9f40f8911488122acd60cccc88e6d7b6e2189015550d05bbb7e2af0e68447c71f77e69c5222785c7c28ca190b85c32bf2056cd224b43de76fc58c705fa222f6c774d19f25d6d673b72a22d923ee71b9a0b716f486251c13ad38b7fd86923b2424721720827e9e7176cde57726048cf90adc0e7594526d634c6fb09bfe9bde88b7ca6182c13bb660650314fd8244243bf7924a4406c1e93e6521bf16395462cc53f6afa078e6356354a92eebc55693976596fe70a2e300473676457673d056955b6d19840e10843de8d7edb96d7a10435a8f482707d2f794a66cbb8ea944f8a27c8183588ff152b4f9db0d374c8d8387f234a2ce766245d4eb8f14d6c9921845bf9f211301c4d14080aee180c5c5a1c5a2c1cadfdcc01b73e9f859ed93b2a864a600fa07acfd877a79872e9b651833036c344bba29de827333f374c1cadd296348e8edb3cac331112a48f1571c098077c57b7bb0f571e262169fa4506b157a3addb13b2425a5ae5651081e98a90eea55efb37bf039e9eb7e650016a031b2ae9e47caf6d04a5fe5394b5d92ec71404c73227653296c6f61bd07db076866f1454b3625e65bbe26c19f3f67973ff83df82f991215e8d42060269d4c99d758b925da024153bab529ba210ad00976094570f7443a7b32862b861cf2ac7503985ac31b09ae8d065f5bb01fa891659df9fc2499a9c09799d9453b82e649827791b8c7afeac6eba2f3abb4e146ad3b584ed0a734cda0877fdf96fa55ccc49019a3c7510c6a057590f28542471baa14265f7b02ea2327e420237dff4c5c18449ba04f181a0d33838d2a5d1ddfb1d2be97556f4dbbab64d2040fddb94b85f61397c38f5b201db57cb9fbf61db2d5c5aa04036c002e82aea5db4d1a5a7e9b101f7db9e538b398a26a0a874b678233c9cff179774157b02395eae771d755f65ffbc633b3740d6f5420cc8e0f96537b843e48dcfde430001ab335f4549558c538e76019844e03448a94120f627421db2c4808931ae3a487b39e00ac7035f977add12ebebd1cb4146890a7444d0b4f13f6ec62494204799d877652a3f3b7e36e4f65edac5ec3158594d3d2b23076073b3de7a548ba842e9f161f59fdc9638a12b529f11673471dcc204aa152a125e804a1d7436ed94a2f1b581da6aafd5025bbf3a7a2addd4c4483e21ad4b87d0d1346e6982959dafa1ef6abbea1b7037f7702b130f45a8c27e00353fd48635729c005d4fe01fc0e7a20ceb388cca0afe30fc97676200c94cf390423e22c632ef5bd766646507f12c889bbe60ce33b2b590b948439b6755bc84216321bf46304cad383b59393fc1759f4b1f845d9904c74e6e2cfe7e9d6b3c1069155e8fa7a196242e978c9bfeabe9724be244a2fa5b20a9be73efaed509b6c79b1b1b42a6423c540d5de8188a9cad9493c7d4a9a4ddb1ba91483c9b91a65d7b5ebff040f1b193c07bb8ec47971195d3b7ad96caa93a06c15fc835bec11549341a00b36dccb4bbfc9e308712b4e20cc322106fed2679a4bf5f338a97defaa1238ca0a8d0cc30fe56f73e4d7f5842faf6ba499e9cc10807f13062c7e9a4c13c690273f13390f93a0ed01356deb016c018d0596fd84fd98871a8f7d65ebec5931974b39a7eb220d77bd09efc5aeda7e6a6235732cd02af709929d878f8576c1a2765f3690ff2a30c907a20cbf2483d1ad980ebbf642877797161ddf5eac49ae490e44b46d7bbcc1b2b43d5f60282c2abe484eaf1e4d1fb61f673e4f2b74c1588aaf169ec8a4e7811595af48794a29a39dec6718612c431e3f76d477f3f9702c3e676d5f879916dbe4ee2b10566801212222ab26590f6c940bc3cb41af7ca07fa7e2eb944d357711a8993cbef1ea469a3faaa0f77b172ec3ac9c351b9c81f5d07d04c20d098c5dad9b8e3f038a05b37981a7b3ee8dce69560aeabdba8bd995a16b6d3fa6f19baf7b858fed3e4ad069a68e6dafb4a8cef2f3d6aa94b38d56848a009ddfe2dc6e41ba23da2e7f38130005ad3eb5cf9aa3103d2d3ba027014d2851bc84ef9785b9378e039f898dcd489d93a4e78522b6b45d747e128c2c6108d5298bab0ecc2a4c8647543b94c6202f80f8fa80bfcddae8c6f36e720a06d5203dd072ca89a51afb7d39241fe81518092e8de50245064f6354ac77adff0829cad98dbaadcf6427a0a9118e85cd23ed60c412c55fef5441985623afd047d7e3e249b824891b97de4e28a7c265517f4848bbcf5f1a961a888fd4d235177fdfb2d37d5c67d9cb4ed738141c6d5b9abaf47e690f7849d413d1465ca4be61f81fff721f9ad1888b3afdbeabf20f79e6d30e4350338d4076376eed9181e23087a4a48308809db0e675463e1148a7659ef4728d726eb6001d5d409be0698cf228b30900d30bd33b8a98c32bb2435402059473b811b88bc247d7fef37d607ccbee51e4ebb177a6bc8ad66007854633d26f900a6cd65ea220a8fd7b37fe2fbcf79a43bd92926472a339d734a839e6797982d03ec88c4271e863055e84d73ad25e9ccd2d77ae8a4487bd72761eb48f4993a4fc8165be7ab58e46d3588be9a81b287c97db39c6dc4f799d39b4300dd6a397a5eee369926550e5d32337dc5aa482016841a9347d571d4a6deb2f021f4b6124250d71bf31c2f78a8b3928811cc1ed07362a15fb5ce1625b57670cd3399280ca0751394650555b12323adb510e09de39dfec44cf942dc57ea2425201beebde02374d57f52aa374140c989bbdf264ecc87da18b3ee70e5c4e872c99967c703ec41cdf86c7b968bc37323d576b1d657a8cdfcf3970084366753f8460913889d608d336c57034c16e9f252e1dabc3330f6b30922d6ddd08e2b64be7a88b4a661ce40849de3aa5ff7ded16a2935f84fb4d832fa0ee845825c434b47688db0d455dd0f5aab6ac4757f1fa1bc3ef61180ba72bee5e66982cdfb1670fcb7612dd7a6c6ab138fbac9b5ca769442e3b8fd6126bafba013e0592458b3e425907311591b79a496232749d2d66371ca1e986cb471bd1d0c28b302b65b683a7f49ec62089bca5bd26a17e0449e0230f11a80224999ceaa9b61b79f8d53bc34f152e564c78953bb52aa0e8ad2992d8bd5f1c4122511b1e7f5a267e935b5187621c6b5a2600b587b13c937f2bb4bb5f4e30ff9a207e013fdecb3f006d101b83f00ccc060b0a6bfa4124c6df887e3690823bf8f052858f4b331c3d3afe079ccd47db65f6946241155c4a48405543dfcf728ecd8ee4feccf94a04579c0674450a7ff6f538389c3646f57e9c5a681aea8858b213dfa5267b1f300ab9a1b89167da15d3620fcf57628417875fc646cb900375708b8191ca13f5081e9e4125aa697b53282a68d5fd6fcfde261f675127474f2c91f15a8ae845e1bf6e32ae81c3137f6a36af6c339053273ae34711d3e7e08cca18fcf5d09de9575fb37ed952b5eeb1c8762b0bbb67a08ff5fe78961d83da69f40494d131411f9225d5f3fbbf9e0d9844d3813a837d2745b24ba3e7a4b77ff3821cb365fe2b54df9ccde8756a4746483257c0abb545d5e7ff848ee106ad79983954a7e368f44e53c3c48b21ed8a671134d0aa67a2f13fdda4c584ad912fb97aa795532fae743aece94b5657a6ea4c3270d5c38efce147f05d4e1e5f9fbacaaa6510c9f09d38ed3d992f446933a0996710f7addf05498c609ddbc749ca831bbf30c4d2195f45b91519d95b1dff5071764cecab6e55bdfc51b2eb7be0b4a8421fbc46b063a1571cf34d57b3c086244e3030a9625b07e120c7f14e04e99ef3dfd609be0f31d8263b07e792a454d169abcc5a3d670aa5aa7d9c1b5e551aaf3042a5aac15ccf9133ac70fdf3dbf3b87565e5c47c20535b153e443835eb52f00dfda3b818bf9b89ff99b54a10c78142b24231511ad5f7f1adbc082f580f229b127524dc97a0f51da59c656f78dc593ccd409e51b89ebdad62ec99a4112feb6d86333a916f2956448cf2a61ec762bd4cff2e2189bd335ae3207c7b4cd21991b170cca661848e32b87377766d4cca0e15fc88038ae7f95d0e3de4291712bba33cca9bafdcbd91aec21634b3e0ae06004bb482fc314d56ed3d92137cdc69583dc6dfa0d0a31bd7d4e2e8be57deaacc024f44cd72ece0c14271016480173ab8c681b3383fb21988e9273900c5eedc8ca6c7905fe90c633f48a242ee8298e9dfd548436a2a4eaa685e8fcffaaa8f8d612553ba0aaaf557f2c11f717e0cea2fd5db0c7d7e5246ebb0cb6427a8358f097b7b60a6161802827abeef23a93dda23db820a4cde4514bf4d8c2afec008a791348f0d6e550e5a2c3dae0a581a006b725fae2b00b4171440a66008faf1167eab5df465351f2cdf699c7f69101a275585fe919529f4e5d02da3dc913fbcd208dff4e9c38a24aa5c2ef9cbdf1813455f9163af9b159a6d440c26e122c1608f9becad9422b54f566c95a2be6a31fad0bdfd58e20a6bbfdc87c5c0edea7960793f3d1320443cd365b5c814611e783c353c7193c201591b70ca823d09a932ca7384e824ea7e21f7eaa6c5b06abb872c2d170bb6846f33c64280c71d287ca90f82b4eaa4c1df56224314a50253ef3eea26b9c88cbf9f9845ee875308ab47bbb7dbdc6cd3bfb89bdea32ce8d3f28cf947a43e66fd7997b8694070ad6cf34c47192bb5db735b1e633f0336f677667f3b359a2619c5547c4d16f6f1b57ee70bb13674a1974f51bc46bc49ca7fb5fcc33dd31cb91b264d75dac2e80b16ea9af6c43d50a29b547cf22a0ff9e24531015df979277a85c460b82cc326607333236149ee201843d100b07d80e886da75f5d1e2887b7c990d2943fc56d91081f9140451f643547745e2eeb26bb6083a18d0b307b43392c5439a09779d210f5713e3d877298bcefcc21bcfd04bbbb0f4c6300de198baccf4d0721aaacd4564d51a9d0de616e6bd90bcad8a102edd2cbf7487d829109caa17b18b3072d192c437f0860ef9bc8166e1d4fc1c9f407af69d64215eb794ea30dd0e222c0324381443531667d1cdb9c92858cb76d28cf287c38c36b3eed540e8851d1bb7b7a3c3d4e12d0fb5466ac84806227ce6ba27a03d3d80ac90790561e781d43f455664275a4b12c5249f2044a9d468d216bd9a056f7c0183ca2601a142b9f0ae57ea21821d9e57e499e4fe43f508d328909d07a31aa887eac30c6e7f534640295e3fbb2cbe5eefc711dfb5824e915c31a91b126700ac58d2dd21958934714ec66fd72e20e402eb54c5a6c9e133702305ad11aacd3cc03b47e66cd306279a07edea5be510d1b19f79879cc4ef06d7d0bdf9edd56238b1e97f5c18038415825b4ea130005ff13b2ae7163cfce26e262420ab212c8406da2a2a5838b0dda9d0a1c59fae770e820a6efbe49ab982144f448f1efaa0277dbaef66b8b76f926a452db9c29fc4629bc7f23c2d440f6ec27df154cf7ca18314c754917cc1cad5d77ffa6499a3dfda43db946090ff93fb70fd45c7513b308799ee9640a4dbee93dc71f9db196b92eb928317e9acf4b261beda003b2e0cb01f68ff64c09ae20c233a490fda34355635773c105ac0006a03590c0fb0ca44d7ceccb75c04e6d6c886cb288393dc42bd245c392f3ce543e53838752629a436a985f8d98a18ac6d7c373d65aa5eb8a965434ee4fa2f0c5eebfe47f8d5fc0207619d24085e101842e6f4290b4041aff96ee0f022d8c46537d9c90940962fe851bd4792e271b3fb6d9a519a99960cae03ca6e07b918338146070dba3f978bc5b4f11e30e547883fb2f5e6277d1c45b0dae0213908e816947202ddc28a5713b70aaa72a85dbfe948363885dad2153ac90e143826618b4121044dda2c9fb503c55ae93ed78a3050f5080bd3a06d801f87958de567d448f2579ec0d6b7b6b1cf3469d89f390f69af20a96cfe7c08bae6a15d11e945eb9d333f0cb6ed958222de6aa2e93e8dbd8a8ffcfd424ea4b992859217e1b751c4de9beb7c2586bd47aac1ede82766214e1a294b711b83d2ebfedd445faf863b6da474ac22e19e767f0645548d5f143856695ff2761045d0ecd6fcb53b14b7564fdb1a974dd2e530c2206ec1eec82d3f03bdbc1410b1feb7325a0f102a8f71d84cbf81288cedc618d3a1bb744812231007caccfef6c9333ea6f59806d7edd0980c8d0b9c6861325bf9aead863022058edc13c1ebb3dfdf317a7fa1a45d5d7450df830121197e40c39b94d7f5646b4abf3cb2a0c0777fdfa12cd6f04f05e2db0f2473b82c36f222e2a0977dd4e95c3dc240f8450d680ac26b108c472a5137ca1ed8ef887c3c8067786279bc8af4974a710468be63f197de084f415eebb72c2f81070fbd809865d09ca123e67985596fbf85235b52a54c4c7a73e8b9451d15c09b97277bd1a21786a1ccad36a96cc8eee3fb94d911d7594a43c39e09debc386660dab744cae5bd0c0a2b2fd381300fe92b32b0f07ddd73a26289db469da300a2b8f9c70046801986a2fd3da8d4f409a06fdd2a8f0a12f8e74dd2ceb13483a69f7f5fb32633c5f8b6571dd9447713c46d4827285f7019aaa97c0f744d2e437d9af8f697eb598e60c6865bd7538d7736924711283545f893a719a2819dc753ac92794c30f4120bf9f94c9c4a48be3481248c94acd09144f83d377d6a8e34a26202a389c7146e575a70c4498a5bf5a241b8fc82aa395e641d5f9ef755a06d7ecc39d5da2ae823d1100a671d9b1ad43c8568eff397c4989bc57ba1f058264e9618c99531b3004bd0223ac837c2eb7d88723571ddce89c0087e7141cdc7dddaec3ebd674c305ed11cdfeb3e7fa0540bfcb3fe0a56afdeb349eb0d2a923fa1ae7af1b312716f48b5b8d1c13f65aa0a0d7913269c06f86638ae10c4b3d80dadfdd45487c8ed0e16036a95cd4f3ae20727ef2a1fd9acf3548779a75259a8b2694cb23b2f9b69fa40ae37a2c013ad6ac1c67e1335f9c62450d09453a210e56d678d1e31ecbaf0c260077da8c1f15dbc3fc412bb06481f8f6393a5eb3c5b7f8b1779256765809aa60348a27c7d5af998a76ac019d7457f7fbe1e9831b1c647e25bc259ff2103ce94835acde5c4be54b327d5b8720abbdd89cd2425da6156a72b7110d9b70297932153c58854229ce7d44a51be28e6df46d5966f6460ed6266a7bfb6232cc4c5cb3f015a9cf98abcebefbd993632f7307c3d5e852d529d30dd21ce8d821a7b0078481450c0ef2fce9ddf627d1da0471a0432d5771da54f44a23fc31c54a876b5524f24691c44ad4e138178e60739df73784ece31d1c083f4f9bc21ee85b841dcddc875393ffb69a57249c0a0e1099337d927f87a74576c0f5053a1c4122d97299d31b3a8faace2298a38573ed7f24ef93854a86899d8bba6c4d67ec51bfa83d6f3186f5674d442d2ec29b883a2a615bea41427d376689472ee5123a1fd49bf54ad6883b0ab13e7cb9d6cf98f931e38243aa97238ae0466cb4501134799c99a5bf93e584c60f0ee2d54b25edc5455e01bd36c532b43e577313dc5ee01aed1b1c9b961754a8b572fec41c89c208628ad563f034611435391ec3353eddc42d67435f44590b0489d134d67137dbb0ddab1b4c3f1e80f38a012c153a3ce5744c26f5f39c6e31854290ce92df7aeb916d1e1a5040f02d4d979a980b4380cade276dd875e47f3ec9a5919f46f38f20851b10968ef2f024efc09e451d1224a6e0f68c2ac68f856c6787492c0745bc2ba9d4abe093b9848c0c3c374dc2531000e824a856b5b2447c2f0533baf97076a9928744721be98e231f1654965a7dca361d3b7a06ae15a24f650ecb97227eb514935cdb277df54b3932a5f2481b7e3390f7426dfd94c9bd7514c0e95f837e10c3a775bf71e58e55d03113059998e71b77ccc8e6f318015334811eef0702af2de5aa37d99696e0e41251f290b3e789b7580168e7420eeead07a7da78dc1f2b1c8237690eaf9e3aa009f1cb1b088953336330638eda2d892a85d2f500d0a1d9ddf3f1f8bf3e1b427bbfaff56fdb1402ceb8452cfdbe3e8a94fab922e56e0de1c964215ab98b1b1a655ccbeaf808adf05385c8f67487f65851897dd6e904fa594d872059954208730b9b6dfbfb0864169ad50bb491a154f24134f3fefc8dcd8f5302a57755c956f2626b7a3f0516848f95f42aa95b24c03eeefdfb05a55c6a13ae2b95b4e0d9f3917383b171b3af7333759933aaebe63749d3bd217c8ff92ca748000730db80d9cf0ffcf58c53467967e25eb8fafe008a387816ea0a60b53d2c9ae8b23a497dc198ce0edfbcccbbd988e99879713320e97c5e987e8834f85dba851784c5bbf42975bf4037f3f866d747af5dcc022087dd7269fb1aee994c9bb1c0555b10a87e998498181d8d0ae27cd69702ffbd58f8e4e0cb9865f612c7297f033fa575c3b5ed7b1df079fd5c7a061355c6620540a19e9b4bfc13ff2f682706f9ab98ce6e25918cb13b5b2d1e9c3ebd904e519567e2dd2ea991340c2f73535119e36e741b0b1264ef0c7ee0b7d2a8389a016a7d4e159d207869308b80b9582cceee8a7ab795a24fe2d3bdaf7a1e8aa0983dcc17b50e694e00c9beaa109f3c9efda7bdec6d24d245a30227c5842b6d5eb4bc6880dcfc4fe4e561a9f214e4c16bb3e99655404cced6de66d5b5274e91bf4f30067b1611ae683f44d4d639f57cfe449c34042de8f32d915e84dffb52b58c71555ac5d6f1d2c36c5fdd0347f304958d2c862cf7e1a037df9ede43f62d2e1b8ec81f0ae68753016c120f01f192d3cb811b37c0a4fe03a16c08c137d6da3b0a436b4049363401f39a3aecea9becc27ac1ae6622b8aab6fb2fdf01e63fd4b43b030ebe8895b1f1fb028d15b46ea88b3287f14b3ab145237d23a10a05bd71299369a82bdfd267207b0dff1135de7f64de65db94e83e95bc26be7c2737d2a1a3c23e194400cdcfc620f717ebc9d2e07eb11f8e5948d67ca30f4629b35dc2f83bc04793ba58105b050b0d159b5b4bbfdbf2a92df9c41f6131c1e98eb6e8d0d5fb3bb56d31dcec949dccde070b8f2289647aed18a051ade6acae31b3a331b4845f83898f23156eecce0d6a8525deadc881f5f7adc31a77a08da8b063b12bd79d2471e6b8408b53e8349eb6757460c76d6404a81a3366bb25e9694121cdca1a7c063394a56fd8e1d5ceda0e1e5cab8e6ccbbd8e56378c6aa60f050f6588ff63fed9534af227d5a9ef6bb89a8aa3a91e6712e18a6c09aba3a025c0c0f8d58311b6de3bf00199192d00acdd7fb65a422aabbbd2a061962b619254d8c6cf09a0f9feca54bc4916c45272618522379d3a6f5890ce9bf5f7767bb4b4a6765b5f5e6362bc521dfa6640e5e3645d71ce17acfb23b31b00fc35e4ad3af798da1e614577ae70c7fff622c53d65522d215a8f49a1d262fe8fbf73853b0d6102aad917973835d246c2da6c19078b731e2dac54221f76314a97b37e9bfea130a9073611e668806055fee95bb46df8bd1e3c558bbc2ef6c38a6c9d4f0aa9936cef9af2ebca020729a46b183678592f7c9029c7362dcad7f849c891bcfd6be73c2939924c956f8ae8c711cbbd9cf0ed6acdf0e490bc7fadda87a1ab9d93bf48223e612dbae9b779091b77de6595577d50a7b1cd907e35223f12b9e3b8a3ef7a05de16f902bab0993f7029d03740230d8023157d391004ea9d6fd78237ef3271ca20067c578ae4c295bc631cc40516055731830a7628d3bc8c4bd57a74bf273b1ac4d75248bb29548c6b2035bac4223fca5bf665e6f29bd6e0903a2e3320c715d96d275b737e060e68ed650b71d2a01c162cbd647d09cab7cffeb0c3412210056779bed4df57713a4d70b48b0ec88c256e8b2c02bb7fe01916f2d5aabee240fa0e79d08e8f106c9851699596c09427b9b0080d53e221c21d057cd34556c4e85f881cdb7f1e1784254c126b5e394b86761dccd4f9daa964f518ba8b82cea51a69edb7e54e9c3ed5c055c4d2224d15ad244a7c0c035321f36b83f3f4fa25da448ed6c49ed43c30263079aedb2b8d2bb9f7832f18094aabc930115a90685d1403724e7f9c0d018cbb103c30646b962e5ec02551d4beb36e70d5dbf7c7d0d5290d727613e0c7c58ad32e6611be043045c5dec5b48f7ca660052a513f70b0524fb818ac75f28c99de11dafa610787f3e691343c7bf06a3c33b07c003798d7ca17acb9d8f3b3df948d497b040849195da5ae6ec1a16de312a4cd83bc6479b5ab50925e788e4ce15ca28a4d7c349e4804f6d0c858fde33e81ed4716ff017047fd409b71a6030d17d727cb3ea8a9c9f659f4fbf35adfdf15982a8f96eba43bf4bd320e2e12b9d0bd3e515966221fdafbbfc83b762fd8cc28f78b59388fcc8abcee8fc1041596754984285c77efb119ed424d3f8939e0dcf5a114cd7730eab99c22230fb8f79dafaa99a501e3394e49e6e1416bf2649c038c9f46f231d830dec21af55df1a147ca75510aa914b6b47338a8c80a81dd1f6f2d86673cb8e8d1e4972d7c5073d2c987421a9bda82dae991833f7928f7a954dd31f1760381695a6c3efb13e35a6da8ff839cbeb17d127df328269a2eca8151bc6d01ebfe7894af8202c0466a171c0c64383f8d6920a54d222a1320152c1bb85aa7b5ce053be5e06c5807a975933bf5c578c67c42507ea4d45604886d0f1c80a66c6358f8424beb844e727e9bfb5e86fcb3e85c998a6e5b896c3699f078ee1252d7cce61cdc7b03803a059bf5e5bb45f77f2f39ff8c3b45deb0432d598727a74a0c1726c62f7317f55b6dc3e5accb18a07dd4736d29c10168dfbd25fb5d022f87b88d7a5431ecfa8252fdcd8bf8b4856cfa1e448b97c8ff732c0ab9494ccd13a18399861f706a105f655bb5212e8d3b73b361c66e30e225660e3d3855ea84f44f5e6ae9c5e39be6d5a3480bd2906cb018f06e5f0ffba5c2db67539938d1c43b7e3df6e1781e7cc2069359c1f331ae2c060274cb57e209ee92e55d2f298a4a99e23e6ec70ad2e30b4212696f7fe27106817361cf507bfbd99ca843e001d198057c549d0de76dc6df9f106b8b755133f835174bc618266b1a4eeae16bf7711c9490d6ef7f9094c852b9922a2facc6a728ee4b042c4a9f641960549528572da4cf6646ecc481c4495d99c8782455bdff9b6c350efc6c20e8ce884daa676646c6baa9f67fe563057b92d8fde15d463cded6ae94ec2796a116c215f8726c1f9622dfbd55dfd6297848ceb0b3f3db1c3efa4f9eb1cfacaebc3aae4b84c86b9ff582b1403ccb58455b464d97e04ff1b9d8b4b450c9b8028777449a8d968f443f71e06e2597cf19d53dcef656f4123f862526953f0d81822bcca10a50f3558183c79338a4232b30cd238f65b89672124398e06eadcbb9e8b2ebd3a90dafcb5882a7db2db879aebfa76d15b276f760d460751f538925678bb87e8eee3d29051a62f7fc0d3e6e711e20e6e2b36fec43389ca7eb933ef985be2768a1ecc58157df6b755bef69e18e2d1909ca0e636d85ea0bdf39175f461912ddc273e52733ab85010644797baf1d8ef357c27414f1cf0cd7b896eeccdabda88c80c6fbf2cb42fba790719b95bf4cfa250f7db5fc1c44e3a5a8cf19babd888f8de8c706dc59c2e78c79931c408973fb957977d27451e3ae68e4c58bb8ba490362e24ab9c2f13f6303cc3950da643967c1a3a9bc4a82dbff651b3e73287d25ddf899d3fadea01ee6061443328a9315899d7bb76e13ddb1cd6e2d277d169351cb0110e8473382645fe704c77e4d317d2a17976839d2efcbebbca341f02eacf5182147c48c4befbf465dcf07e7e03273bbe5a6d7c67f049fc956e0169117fd2d3a8e6d67a93464aa5c5eb54bf2f8dedbbcd8199928afcce67cc252a577d3462f71143279f7e9549b29e466b4aee06a10ca577a17e2dbcf07ed631992708218c15ee84677b26f576bb750fb4f524d3e3be95344bfce4340027d38497976c2437f04b1ce7afe28fb08dc180076af86b1f2893ec14a66ac9ce3ca0398ff94abc874177cb324e91c07e0715f67a4bc376b09ffcdb2ebabd98195804e507ed6fcdf45b3431349603344c0176a4ed8c0acad77ea86f3fe65d88eb9fed5fed2777ca82735433c7617973654dd4aabc31c4c33ec1f2902973bec877004e809126fb55195aada5c2438318334fe428781006431929963e85e75878c37cfbaba6a6c8d4800280c92262a97a9f94099754f5c3ab3ef23e285f43583ded4a3f9d1ec37fddb95665acdcd76f81448ff8ff0761d3c2c054bee54566d82b79ff8fec52860f6d8ac0df30d22cd38074dd6535f5e32932c3f3da062550fb2b2174812618bc29761910f13c91381a027f3994a48bb5386e8c8a8b44ca929b4456dd35b6a28c3522443c5c30363df69f0a907fffc8828e66bdfc1486761b1448463ff0b1c5592478564628d2146c609893693427f2b80e05adbafd55bdf60536823f86d330a5aec8dc267dde604eecb52326d0545960be67897aec1205d0b11e40ac65aac4a04d7a07fc84afa382ccc0985d7894a862ff7381cb80cbbfcd234a0fbd96cf693220151abacca933e1562c9db5f3a7d1719a2a3b47ed60ec3335b5bb3c18bb099ceec3d9c2f03448489adf73c7fa81e0cbb9dfa71e8982fd1fb8e52afb2ae51476753e4dc66e857511d9d36c67154b6faf196f466f44927ae7751b13641c826ee4bee16f98ae6e8cb99f900d7e98aef21833ba190bbf1660648a1ba33491874114cdbc89882367a7553f36b00d61e522986a534cb5c5c1a7d26f8416c9a840265882a28315b9ce9d9c8dd78839756507f3cb6b434c1848730f36be9e44613afde15948747e6333b47633e4eda02f3dd035b07b13af512410723d532d118cba91a0e56ea064ca59f5c34319b05d3c18afb3155909916793cf9a6cbd2282c0fefde75b9fdd00b818140a44c314fd99c4a7e81fc7efff18c090a0d50a4e3d687d9ec5f6722ab7c702b3fd0e5c54f746e3c13eff10bbcc944a166a52c47afd853c130f7dbfc729c778db048ca6fa492995de5507308e8c620c43dcbb83e60065f9ba5db04c05137204a09e65e4c002f793d3a30692c5c832db25699260edf7dadc60f71252588f9f6337eaacb5e440c3f93b17e50192cd29e27a1906df97f932087ac1933454702de3aac0a82fc1b8adc34dbb0ccd93822adbce414d96d805c08cc4c3b92469ac143f50bdbf60e7460d80f91fe7af148a81008e21d1a8d7aa8c572e91062b98d4b2d989dfa8d726422d3e781e8de37449f1915181679e81faa14cb6d29b0a03214459bf12702a8a0ccebcf4a03cc2ace08aa09d69808193701a1a52514da4fbbc23cd6b005496cfa9ffd5f858e3261c1ca29b85dc81f5a97d03399145d7407da8fd8b72008f5a6364dd65449286cc168304d3bb4173fc3bb3fae6968860f5eb143a928f078952c48cffaf05c2df734584b38c93434364c8c69c141a760ad831308a016140982c71dd9147c08d37318b981375d31501b5f2afd7e783c875e15dedf68ea17d22052d54a35a1dbf451f29636d746793c52efdc12b75b2dd138522c872cf0fef2d30d300b95d92be94f785d1e0974154afa648675a8ffbac6d426e25846ab5fac9204f64331311a5165dff7050e61a8e37cb3f00a7e86b24f9300de08b44ee58e164be9831947e7ad30bb70a81bec517da0941ef5be30acf3cd0688974c21dd00295d7710702dbd6654f78bb4022855333b329fe4a7f0e6618ad011b2d010d369fb56428225c04b590a29dc9ecf94ddf54e453e18410dc3287b2d87aaa921b98c4110984fd3813282375a4eb50048632aecdf0d5ded57f7dbc354a6aad3b902761199b7d0310b37e2a1d68f80df0deff52b07e77ee3e9026c9cba48a77f7048c7818a5179462085ada2146a8caef577a7a52e5342c9f4f94985b6fdfbd1f875e2283259b517cac3205cdf268d0a539a612485c63b6c2cc43553fc0d3f2c51fea6aa001a904f5667ef397ebda1a2c6bbb5c650ac7d3a9231408a8a22f6dd3ab49763cfde0229c801c23d2d0c0a8dad4e644a8fc473ee64bec972eda884fda9e1ec26982c5d333064e44c63f35fe08503d6aba8ed2eebb3820426eadebbccbd6bb146f3dce022023418b68cb92cd3f97d73af2578fa3096e364aaebc16c86ee9be2d0292e9f3d75a117fc7349649fbaeccb350b26781ba627d0d6f0ef20c6a371aa8283060721ef0b2caac9a1f0e7cea786aa8357f945c690d7caa932c43ffb543b84a8e5134b1dd70b23a429726d4c5d2fdda3508e74099e63770f6f1e7af026fb0e992f9afaf4d6b89181c297b32a1a9ce7202713e978eb1f90cbcb8c648ffa05f517f1cd3394d8bb62d351ab7abe0813b336315a61e79170e8b1ed4b6c366b86bc9d3e945a6ba0daee9b2dc4f4cb60cc76fa5edc68fc6e23d28c055aaa54b5e2bc12ae8b35009b505b7dfd18c0c56a7995b3075617bd6f94ae9581b96793132c3eaf306d9816e7d78bc0ff018cae7349e0f72130cabe3cca83639644547b93c9dc1a2db381678e9590892567417e4cd6dd8e1f3ebfdd9dc2a648d99b3ff4c6d3219fa8bbef9ef46ec05605645ad810be3b4b7e7c5ab9949f0a331475bcb27a377f4dcd59717136b42a23f4783f265c5c10c3dbf55b8132b86afeb9b6fc883dfabec4f1afcb45bd6cdae612419de57c948e460107eddfad5f400bb68e171fa04bd2a1fb741398339b2b94157791f6f509725f6623804b8993b8e167cae16bc576c3c5c9e84f6f1c10582b9782532abe272cea6ff2aa2946647274727c36e9d9d02f43f09c2cf68613b2811516b398cfd05bf51a0f3abd243e5b0294cc7847b24b9664258c7836846b7ca2b197500a590ba6ba3b1f30813a5623d8bbd5e19433e4052b8f8f7e91025948720404608eff934247dee58398ff11aabaf639341e86004b06de58528973d94827616d8c706b92087d75c0d78cf4d6d75a6143acf79408f6ac3413786ad05a58860ff9d3d218d305473d29e72935adf2c989b2ce41d736680518c2bdec74ab6d24f7db6ed8e33621990437375af1049bd0868559471645c290974480ee5b04f87493c45e0849ca8f423c765580cd5b186b52838102cc9c8b6e81da8f68d5831a5df8cb08f1fdb7663f57ab35ed337e3e18f2274046d290509df8a46116f1ad348a5667ff19766d67dae3c83123ccb7789402f51c264e6fae2fe0eb9e8e594a6510603c680b725b1d74ebff866cce76cbb4a60375e71e1bc755b30182701418d0082215cf1c3ff62e6a9baec7c83fff59edb1553c80e3109ce520a444ed125fc29df4bf7820f2d4c111cbb628a4c2c01b2bd76f1bdf5474a22f0b16bb3e3ef99f57047ca777c821f965a9b6a0962f17a082147afa7986191f22ef266edc08f059444029c1cc480bf392185bc7bae2c5d8616ac17f1e60244aba99a9e8248f8b4a329fff7e329ed58de28f3fcb54ddc7fef1a2bfaa9b5055f174eb501c940020bb2e96f6b5b99a05bf4fccd24e32b16eb0440fa8492384fed061107621a5db698bbf23c94ef52f9b969fc68fcd7ee3474f95ebd8ea67238032bde3112bb1039a3ddf886d812696faeba63cefb14250ca4ce29bf031c06926c9aa464721860188ad58a1bede38b950a49a1fc9939c2ca6aab204171bbb20b5e5cacf4ece23934f7d12fbb06f3211c1cafdeab5d589372149a70cd515b9c22243b56afd9a5f38c5bc749a280d83c317f53ed83ffa88c15cd1d9a78e3dbe7377fffa36d66266ce27892c4c805fe589ccba8749c894afc5fd0da22e9c580b717d007428d59e4bd46d38dea502a48a1bb50d1bf7841ef0cd0bc4c752eb871071ae6b0c1b9893b037cb366c791c816646fce39a71f2c5e0fdf148082d8968b4712c598e9e1a5ec3c79652ce4c036e669fef856cac8364caffb9821398edab85fe3eb3d40112fa226944f93b10743096c59820e1ff3877bd087f9b2e3c29fbfbdacae7ffae9c510ee4b4c3f154ac512791123c73110bb104b0adfa8460c45d1fb08bb33d824ae4e548756478c9ff49a590e8f27c056eb8f0cb84b12f6f2ac049937d9d768313e177021571f5294a389a323abda8ff18ab6bc7d54e52ab3cf76a3668f131d3dd5a6669d15de18b90498b0b684b3922f08a6648d4c34382ff715f6517600eec68ed15009bf7753e648c53c5785c7e63b623940d2b55aba3cb6b56c7ccff8de1abaf19fe4dbdec87cecdef1c88bf01f789aee0b2152e4df82f1def8b49d081931c5b370f3145bf98ec7b9fb0b4c7f371ebcb224ad2264c38ed51bf3183e9b2870284ceeea426d6e4b3e9a5dc3874523670e1cf6e3645dc488ed385b44d78d30d2edc9469f12b066384c0d115287a738bcd535b369bf6d2f4a970a0875d6e559f31c3a98f48177d531e49fecf8ebc36e1ae9c08d321f4e5f80e6de309cc872e4179e6bc8dc878a650ad96bdfb414735ab5e40a237dc9d4d77cd29e16811631091a89b733b7f48fd49a6d8e75e074dd0d61744825e548fa05eeb71890a1b57aee7d851c11e3dd0e700cc649e950d75e3509c8a89a62463d4555f421be3ae1833b383d48befa12c1230ad6a8c82eeeb47734a76a450389fa27de4dbe98c11ff82e671a3c72205c2faa126d1024e2c14ac6f57922367f833184a35b4564db7b7aa8360e048dacc230f9c04397cf3e08aefd0e50084faf6af10ceed9c53450aa6d27c23798d7228eca15d534d2e75a0d3dca34f314286ec81f8a8b03e18a649fd4eb9f12d278362a454909214a44775962197526d4155d733ea80ad2ef71e9416978a3335507040a0c98074daa55814198ae3751b59d7a557ce168c264388b58d61218b81b3aef916800c19b6f2fd928b44939ad88399f73f6986e03d1ec2317091c3f499dc45b0e66641c8c986a91af354f1c71ffbe0549090b5df144626a37ca9ade76521536211cad2d9c8354aa54da37cedadefb56026842f704f9c7a5a66857cb7d950da71ac38ceb2d65232572fb5727a9424a9641385f61919940459afa297a9fc4d61f002ef83fee86a9e261fa16616e385965ec850f47669f41bd7a9f91442c2aa1525306e1ef9473e8a68ae8208c13e69e0344000e62b446b22e253901a6cfa3e0b3a5cea5999356a53e2e787ff975c947de293d0eaa5a6189018926d0f9365e7e33f63c44a46c5f5ba3e636653f22b365223368dfd78f585802414989accc907e7093198f6d92062ed46d26e5f26fbbcbc47fad4e7206b6c04f033563f15f5100b35bd1c9a9606ce1b334af9d4766c706e402aeaff54fc97a82313f54d89edddbd1d4b41b62ab5f63516681ab7a37981ec0bf1d3c884ffca65a970ec8d89209fbef0f99762d6cd5c8a3dffc0667801a6707826cd208c52abda07eafee2d27fdc5e34951389540d329d8b584e4fe91fca5ab61c64884f2553cb520b5d3cf6c538d8cf0b3aba501d1e7befd1e5c7e8af9781c8151773995d49e6bcc5ceec80b5718d05523b72639812cf5ed16537f0ef2b3b9dfb205e83384a50d00b93816843ef6416674917758d15c34210c03f3449e4c419e487d49c8d8d2a587b452100445ded3454cc4e1ccc9da888400bc08545b59b4505d74d31ef8e05cbbcc025e8bc5cee1904419699b4a529c980e4350b63954c029f0f5765ba0bc143cc3b5753256615b5aed41a70a7abdcb0eaac6dc06cb0376dfef1015130eef36acd8c2b1f98ddce6f11020106e0b56cc869ca49b7938fc87e20feae64f147674bb939aac5d36f7887c6b1428f1ba3daf920ac30472aff6254bd87a45515a09b7d59e690b9c21b8a6eeb7e38935aecc630bfb278f98627b2781eb677ebf392343e753b1e52835b8358668cb0b350ba8ef2ea7027079fbd81e64f8ab4fa603b6e687bdbb3d8d538b35022b740ff98bb9061590f36f1de23865c3ff7b77e7f0f4be72956a12f0cdd3176e9720938cb21802968db2684804bd7bf44607a4530a84b568ecd947645999afb67f699ce8b4409107ec84fe22f9173e57e3affa0aad34bf0124f534d30f6ce1a95901a1378309c5d0c6aa4788d71ee67d2c08af3cff655ff41a62629388aa7c45de520cd1a5b42c62ae1d1b2ddd76c8885492a1eed0ad0487174fca569ad08bf127e4e09e802a51841869c3abd337775059e17af19e0d7bad583ab22f981ae7615c20bd122fc271d8207851204f2461a191c64f68244bc30a51e5a5ddec83de5f3b3c4068fba56f8668aaf4850311d48374425a0377182a50b119621eb9f05e2e0670d9716100c22f0ad97c1db1322a7b329d9f9912e0e29bddbb3d83fbbf327f7165d1769ff3c69e6f8ba6e6ca9b2e2d279fe6464cd295588f68c874cfbbd8035532620607077662d8117a6d1a9a7be954998952d80d68a9a0379dcaff7ecd3a78716e01bd03f82c60ff5645d23d547153eedb2a501b3c34926aebb64c7ca3e421aa56a636ed594d4fe22c5967cc107f42f1dc4eb3e0aceb000ca3862e3444779b49cd9e110071e5696b5b68cdab070a1acd8bc284689fe5c3d28f38f2cb106cf6eb38aaf50c2acc22f3d50b5c654b2b36f5e8239d0e4bef213721f43a4973cb62b543de376b242bf0a5e5cc121bdeff0539d732f9b14b9889b1a6047c946ba074eb91d81185fc4f595096ee3423791aec62c3766412b664883838de5ca2249e3257fffdac150c2007bbecf5b869050b64167317830ac183c62914250cb7bd7be75e4b2e8cacb6647b271a9f95170ffa2a174837613366b578521db68accf6ce526e0b1199b4324fb123650c1af9ba25c6259f351a67b620dfbc812f6cfb2e05977265dc5112f13c96766c3dff8bb938e4482c8b260e130d4e1979a090525e21e4fad366b3509b712adc9653a1ef42ea6f18aa3ad036db7e0cbd74299abd5d8c04c17f141124d8c305928946896b1bcb867dc941d966439d0a8cb86b7fb47d18e8ac2441855e81adab77f640ce0d6f7e4aa56f1a597ed5d27ceb702baeab05c886f6fc1d24f2fd71088309a3317558fb0a0bae516716f7caf00f0c7e4ce902da9994a98472354e0865d5b7021be623ff8faba0e83ac75db4476ec90391d588d50962cfb0875194506e4feddb6dd81ace09998125e4c1e4d0baa1c6c6738205c925b488b341a2eb05419ed59dc618fdd22959335b5a8d434e439a3279ff2c6212c6c17b3990cfbf1f72bed0f7308d451d8ad66e4ec413597b01e9861d64470ff4f0bb57d887e59d6f5098577a28e42751d1223c40ed80c3f7febc9dd18f65c2e013b743d4d4d481b36a432b0834146efb47578024c7b4d5ea4d9b9dfdc6962b58ea3fbd9aa26a01242af3bc738d01e15bae86a99d80a27239ea35a9fcdf77db368a89ee0f66a37cb24035a3460125dbe757e73c2e6ee977ace3c32aefc9dc0c2af92623f77817e7f388bd5486f69b7d6f1f4aa2039cfe9023a76f3f8ec60434054379792bbf68cf89cbfd0bb475302ad75fd15f48514f87b4abd8506206d7b2d16a3c3ba0b59628b94e9c430cd3e14575696e015b37fee16f504cd7113dbdd451bd8ebe042dc6f95137e056390156084b38bbf36958898d6c20fb4641cbfb8aa22b0097cb12d49ba96e31a2214f050c70c04b179000218968cd47e10d358685bf2996b43b85824832fbdd83eaa2019f635ffc9631997002217802a1bac31fbdd157d0287b965fb7be95377f6c0bd1c40e91af945e9ea1afa5b59d1b243a92b2fed2d92bf6b77e960f63185dd2f84b96ebc554d953d534d8c437af7f0672732b7cff829105b599f1bda1999b06e9682297ff2cb5501bfd740428ca8ec446a08b1e75f2399793639e667c87f04a74e4ec448b55b3da9c7c7be7d0765027e90ac0ea79fd81e8168c5b755db492d58004508f81512d6c6f52e2333609a1294aa9598db61a03371264e3f4d4b24ddb83451b9398d20bdb112f20c03859726e47ad9c9867600205e2b439670afcde9bbb87d098705e8881689384d8766d1b50e7ae6cf1cd75c4a9c05b92da72569d45e309768d40e2b2279fd3400d059b21d5291d26fd78a79d1f5adbbaf9727de77eb68f2529e5fa39d42227fced58316d1ae2ad88a4c646e42f936ccb85c2604e4849eece5b44caefc070858bbfc5e491a8f9092da590005d258e7efa037e0af5694a77b3eeef49cf67f940e670502eb336e653fc9400aa8bef1cc5388b409161fc5616bfafdc33ec9d9402868e4ad5ed235d4e4936636634cdf7971a0de196e37121b968b93b3d4482f00437a1f60e585488555ca1fe358cdefa3eb5b74abbcd9037d9d7bc9f39cddd95d8c5f3b59b4a805980b6cae272db22bfd9268403bd51e58dc812b26ea12047bd76cc959f23a2fcaae943d170f71683ada6549593939f5829c4813236cbcdf5028e9d44eceb2ee11ea7c926fca6093646d99184e9663c3ab856736421f7e4ea133838b34fc74092cd5b2eaebd3eb2a8536db10d0d4ea58daea328ea2f99ce469a2bfc7b016dd72ca015a074dbd69d4b11ee08e0ca36a3f4ef5f7b2318e15d8aa4390db4a7bd58fc91c57f811c4a3597e2b677e59c16929f5c3ea16a44d59d139f8258da79e1b850f71965bd7750d4a7871f7e7c89be8321e4e4fe8bc506d442c3ec0fa35caa0a33cb1fe55b3d7e24e631a3ea8a76d8f36c9f535b8676fcd77cabcf59325d126f6e10fa82ea35ebbc44e0d796c339e2cb493ce3f1cb08a9f060df27407159ce290b116de7deda18a9de312749f4e7c42b58ecf45be528aff3a3af0a58393e103b31a0c53a7d31d24e0549111a1bb1c541df7b304329dbb36a169ade5db0678c93d7b7a42cd10d1592218b05e914448a5b7509e40b7c71d9d7437b3db06574e905176c78fc74e3815318b8aa54b5aecccea8f447ea85088d4c6392453600d3224c629a6bfe5b08ce48e81bdce2516abd3b01704fdd1a7f0cbac63a69b66263d4f4145fce3a7b97f032512049497b5e33e157d9e09d9e32aa7c8eb4c5414d15ed533295c7c6aa3ae7a4a4ed9d2b1674e11779c2f852e75c24c66a719fbbfea94ac36fa1de35323fa9b9c394c1d74af37ff989f69ca51fadbeecf214ccf13a7d1ed4694c33b7286e254e46f4e323faf9e87941ecf9eb7290d738f7742aa196c6cad951eefce9f8f2f0926880e215dd9dca6b39ea7982e15221e53b31213168eece1ed7d5f51c1ed00ed11f22679e3c14873e3a1b66926daf694d408b5ca70815a902b99be8c4fffdfaed931c853e355f9dbde4dc85e1f262ce45ec029454d93408885cdff0d739205defa23ba4cc5478cfb30fe67d01a353350e463b566f933ddc29bbf8420a80133acda240ff2b958aba864a863595730a9d3474178c20e6c4ad7cb7ce4de0aeec69e5d94a93d3e439f236404284d1152ee3f6360835060b0d54c018ea53d5c98ec08d92c4558455e8063d9154aaa90e55304e2b10308b9a8017615786cfdbbf07c3ff0f303e7a98f323abdb1af554e6806a43670c6f803c0148e365763a0b282d34cf68069f44c328e288ccceb1157fbd9e4c0008546f2b5a819b9cb702f951b80ea6628bfe0d955d568f4dcd6dfdafbb927383b43e7858f4bdcb0da587c8fd8a692a924eb7c27da6369b85c3371368511351de55cf6301254fd534b2318ef6f7383a83d261b5e1b26a7513e7380dca2ccc2e80cb5faf02debf803b141e3beb29766ab2da3229404ed4f95e1986fd455c8421ca338f0f7cc0c4add0b5b75ab34054eda724ae122701d91c5c2aee165c13d1367a4f32011e61841763e7f20aa5315c933120dfee9da78654203905133dbd8a3ac541ec8d84776278038598918bbf59271f75e8c933d22cc0095166eb1b9bbed64302b281a316c3d4f4586f165974adf522d8f0208a5278af4f7150d234da9f743e8960a21b78ea7dc7f896fdd4753422a91490b3fac85995b84afa3a92f3baa513ceb3732af2c865338eb7f04e0f73756737308f11945169f05a0cf589c71860a32163f882668ebe4af47a11c9a3ebcb4df34b2db6a4a05a5f2931e94e3114739708b03dea6d481c1825ae7536b98f20563010c0eca6b0e9a82e5a95688ef94f34daaf93cfb57ed9504ac9cdd7672e0fb753d7837d26e7f8982ba844f2056acebef60200955efa1f546191fcfec97e561ac8143ba99b877cc11ca07a0cb35cdbe8338578b82b7c268aa0a9e7da6ac94f50b1d4bc5378b5b4fb63fcd6091c4fadd638f79d8ac1edcffb6fb8304a935e9721459add651e61f27a42b04b19256420d307747e979165a21042d23ff908ea0eecbbd07e6fdb1d68b0ef059a2160347a52b8a1c6d3a92645698f1ba652b5f0c104bcce297f4b655ae77b53f92c2094f5e2cb2de3fd6d556b4ec43ffc46bb1effce4f8e98744c4c785cc196af1e06af31af9e3d8348adb47708e4adb558a63bbbf6b4f6ed4cc2f1a5b1a68bd8a247f62b38608db4542e285d765053af80b0b7d15f9577abfdd46b6fd9da2172f5bfe4e53090c54e477da7811c0bc9ae33be87b797476504dc524d5939bb8031273c16c6890a6dc59e06a362cb3d133ab6653c6143eaabad147cb9223ef493e85d117a769cd76bb344f01fd55f5c570f4599e0e1add4a13eaf1a3025220fde45acf6e446a97da66807728b4efa37b55fc05c37e2280cc370565381b6a0f2b6d28f2bf89bdd6540a1b099113da3de5470efd3d883977896c89bc378a15b5b909706b75ca0b79255163ef30c0b78606d97d18f43661505687ad17616ef508e5ea4e7f335dbb543a2aeb5ae869462c406782f4638d5299a9e13b95e85e9248da258efb76337fc848f16fdf84cc67fb8f12a5788a39ac9fe8f20c7ab8348337742488d20d156fdd21ad80294af36a5dbe085948f2c81c703ebbdd35a2d7132d97f4025353f0a57ff2d7d9f704a53779de1669bfe224bbad3e0918898b94a40ceec02a2a496c22284e1381e6a9a1660274b63ca851f59de7ab2604f3fc1182c1b6b31e3170e32ff500d0446bce8701a1f6ea2bb7fa6cfc4af4eb162229963e1b57cbd0c090c7393bb87b099de36ca7396f6ef656e23729c5fadb0417cf38bb89e65380e8ea29767eb330acdd0fe587e8cf499c3fc9588954ac1e7f933000cd445f97b16ed93313d95d756dcae430c9ae46ff62d11057993f4e78da6f8a98fc23837bd17056068c6be197b71b12d1589607350d73185cad7ac5c779d198ab04db682623ac1d3848a60bfcb473852340139653d91272587c7bf3057d8511db9bb1e91f08bb2cec6e540fda0a1a4b49ad0d92fffb5d18fe85b785079ebdb6fc9d85a16ee34afe8133d43f7c12c31ad105c758b2b7c33f9859b1c992c9ab786fa0c649957ff6ad9a7358ab943dc2894c3d80916b1870060244dae750926c27685ab12c0fc819a9421a141b329e24664b6318dc78e70002626a50e5038e45e7e3b06e4d616fed01486c254dae8009fc4754ff792ba603429f9f655682cfeb203ace6f9b0175c443a882c42989a71e89a34d558a5dd0b0ee3974036ca9c71e813d81981fb026f0bb87a8d243f1cabbb55f0bae4aa710ef072853ae575367a06cd902d522c700c17e1032099c06ba8faca19c7755eb82263c9c935da713a60aeec8710481e93c29b25a22b1e06375ed4f92c942f01cc2ad858665eb10a868a0bbbd649af52bca70ef8271c43321fdf792c49c362425a7ba90f3196c2ae761e1f2f83decfe282ce6e9f85676ebc164928791d1f21f440b86c019a20caa7f2268af6894c3bff826f415b9f41f58a9148f6ab5cfc976f8f524be8c223cc96d2f7fd29ef375f75d8dc9b06166d37f2d05039a05be98bc18a78adf4d0830ab384297d2e62144827b987ddfb5d8d373b65433f91e9609a63c9d5f6ca1761adbf98b9d48ad4b8732b7e23ea67e028cd411e807a39ba18521f9e1977bc2fb6e750a2014fcee0248ffa9e4ebcf8da4a6e60efe47ac95b0c48a8c7a945c83d144aff853f63496a3a12d8b7b1fd3f5b019c2c2e648c0d02cbbbd6e162e5c575670339dddfbbda46def3f3fc16b5efcd6103843e7e5e85b2fddd545edefa6ccda475baf0f99b04717fc7bc4f5aaeca08841b19cccb98a06edaecee10c7c4791b6e44bfea663fe3fd7a26e255b5da6e581ddba3eccedf6412f3d20cfe6b21d833834c40d7cbc8230c80e7c729ffcdc6f2374ea3074893afc16f67dc93b8305f95f26b4dd1fa8b1d7076c6058dd4b092acb6374284a528f19e2499ca1aabf4287e28633a23ced3540189e23725a3da47d98b064d124ea4b7a8475feda4a99d31fdcd510bbd7a9a3f172394d3b5275a748e12e365e597ebe7449ff121d173098ca4659d4f55782364fc23fc504106d1b5670daad12c11f63dd4bef6671eb0b42cb9d00b0c73f4e04442474cc99d85ebcd94140eeac01604a3caadff3369a6bdfe483cc86cada114388ad7a54317cac21ea07241fcc38c38efbf18007d81f55cc1da12e9e0c9750cd39535a36ae52ae4e7f16997f2dab38f79c63db3134394c4524184e538dfacdfaad725ff2e88b1d1a1a57986995330ef68ab82af9240a66b9a004df63febbaffe2a247cfc78b631548634984aca00cab2106730aa125890053f40d1f209383230b77a8059360693cbc7593f7ef6ee2ad9cf9cce9409fdb323b530cb8263489bd4f6cba549e58a1549c26cb83f06267c2f13b2225d6c33c4bad0db09a7675b424e9f5b93de17f43a34e5451903107e6f3a36d9d79a9447a5a21db2261fefb3a6179ac0c47ec6159a2a04b27918fcf3a8efde3dc5e76df0f53b6b2886deeb3e084fc6fdc1fec2c5139446b7ac22b8019d20ef99522bdbe3a36205db19941cb46ab77a50f4c8092f01f583f502d2154aefdb2f13960481924f85005b059af2306322c74de51a0ef3c01f87a61d8dc7cf9f4b72e396a133130d94f8aa7820174ddf4e067bbd5c820e4b9b36c070718e64db81f557eb6534dd65ce16aabac992361a293d670fad2bac8ff12cac9ae8631580a9e53e0f93da51aa31aa9c161d78abe125fc583bd0c75297a0eff24c2d3fd27de20469da7dee10b670eb55064e2aab3134a7060f57f113686a0ce00687efad8e70732d56aff57085772bd596f7816fb88a58f1477372ed848d54078cad205a33e57ee607c58937d2dd4419f93b9c22daff06f3f4106d8262712a3fda8fedf5512fe3f5f0869961e0b790dcfdc8597b71707304887e670a71fe9a80c23391cde9dac2a6ae776b69e1a906744d540cd1eed1b4d82179acde18ddbaef530a8058f592c2c55ae29b3d33a8d8275ce9edc99d1c0ed05a2e9918bb64735fdb33f11762fa60d52fac2fe735f073816714bcff7cea16f38652ef476897369053229acd4ee5834a062bf7c355a3453a89516173d62689d8b9117103eb5fe7e64ce45a1f75a60fac283be86778bead43c98dba1a01cff7531516c986a2907064cc16d4cbd77f26b67b89872cda9765d4c5e609e2901d4b03c46820aa6fee2895b9374d301f20dd07a62f6487bf3cc9169863aeae657befa840b2b208da56c9f4b1bfafd0d71184c9e3a632801bd54956e9573fffd9762f307ae0f727f776370cd3e6b4349ec94870df3bceddd535e44679e35cd173b90494e19d6f8d60437506cf023e451b5604cda57d4169286f4fdc4086035986b7820287e77812db8790dcb5063b21eea74f0193b45f1c048719bd5eb1c1c89d7f215ddd2cba047e20ef1131f47f2a6bf558db7c5866af6b2747fddcbf5ef16703e9a14fbb19ce25272674412692f24107bff4da054bc9b8fb862c6dfe473b5437f43a3e6a414840ef1fa508737bff8c9dd6191fda20be68d8a2e86f788a03ec0442dc3f786ab8fee81ce34a4591bc1ee07bc35415e8db29059f9b6fe6ee18fd29a652fd7cfcceab4f33a625eb5a82a262e2b2bfee57f66a190b45310e7b15ce02706552376892e2eef0a51ba8d4cd8d52bf2a9b50da0395321310a7c4d300f06213b0560c0b16de8029a6359ba6b81902af439e6f2ee449f286fcb098524391daf64b4cd3d58d2db79ec8beaff0c1c84c5ecd9bebab503ba8b900d105a797b793406762c9e6824e7c5b8c9c1ac410a0d9b378ff1bfabe8e0f2172042c25f9202c0fba607847e464c6a0ea1f112875bee669d21b80bf8d046969e2e859abd6240d9b30a130919e2111dea99f6b656ed5d81385d8928864dda42a2c5afb2b6bc9b9952f879ac0252ce631dbfc54acaa373a380d420923b47321352af35e2693426a1a0a333bc3b58211ca5a57c4644a75ee7500409904cad3d031715361d5e4ed74c1a52ef79c0d1fc24c85a9bf33047323ca555967b76f88a87627e54b10bff1b019917a2b26b4f40c7115174457ed899bba257863af359b3b4dfa5e9fe071baa39e6d68bc83e52b6ed1d6c57aa97ac27ad70d51eac7aaeb549247828639e461411ddb16ac1d9ce44b695cf1b1df820357cbb7ef298cd151a293016b9f79fa9ae8e2e82cc0d74f3d88221b0aacaead640e1a159793c832eaf9423542c7cff5770d65648bae873da3aaa902feaf29ad13987bb6da70ff47562fc2f801fa7d273fb64f251d93be7ce3fe0aa1e6a1a335a6c1fce82d601069656fe3c903bd5b55030682aafb18501022671befed04fab5e6cae9264afae1c07ec4a03278e0edc0c9468671acff1707781120551fea07d3bb526931378ed936942a4ed9e89a20794b87c11dbd24a29b824611dd9bb0d6cbb95627c9773956adea8685a3e542af1e5f95b12b5cb1cedeb438bb01e85994c500d06263eb2e60c4cb79fe13a54ee3bc08045897ccfb67a324308b2b8add9d12087d8e015a693e8ae122e3460f0cf6bf68d738ceee5b86f92daa485f30477486ca1e8c7d52687fff9065b6f5b2626e50b755d1956749981f3c45f870450c8899508bca8829bedc8506ea33e10e2e29592be61cd4fb83e1f7b7d70ef89bbad8393b8b88da7ff330a2d65ec55351dd1cc2cc4b80f42259bc5e9e8e5243aadc183d19edcd3a5c7bf2b625bde0a3db367e5d286949daa1d52429d2dc0d2c1dccf0347be7392262403d249092ad394ca154c8976415403a46ff1ea7e16df2a89578a08d323af066deddc41e91e5aa91fcc45d1cba4c05ac6b189da1a104183e74a4335abfaa0f4fb2f98e2208ace9e5fa2adf99af21e7b0a76d27da511904bad3b6434b4bb40e22790bb05b79eab89200ffb0bd3abe5d433ff8b203ea408b3407aad255d542d9780599a35fa32fc624e993955c3c8bc17005eebc198f9049be739bc97ec09b719d443694ae5fdb667ae22e25a6d60e77b8e502e94bb04259ff313d076eb7d8e93319f9b645d13cb5a19b5ccf6fe75d0f9e3b660bc13bc4606dfc305fe78cb755f9c3efc7abda692b2fda5eb74b7e06876d9a6ce8b6bae0d0ebcc946d3a6802d75c27a110236f6f519f132bae5e650e4f4026fea5370085ad567355ebfbcb2af72484c28a214af792347fea4087de3b9836cbfda83040cca1f7d13d5d7027d271cbd601dd1104f2184766b85cda17012f0b2da9d0c50e8de569b2071bfa571c7154e9a7bdabd04af2cd8df46539c1c360f631e2b31f9f67adc07c1eed3e6356759963237944d673cb5930785cd9ba72608516b7121373350f4de265144eb8fd5d0e848d758db09970c2711282e86d802ddbde1a5be99dd5ae71bf3cfb88b4b82e44bef374f07977c7222671a9096ef12ebc374c19d4af8739af50e3e70372ce75416cf2068048440f0435c8b2db745f2736ef624ea0b5c96a0e7e8135daff06077d037ba18d88860cc67d8c994be2a759f459a4e9fca7ff47884056ad1b3633584e71c1dd098186e3d7cbd5036a2bdd929ea87581f74f7d82193ffe1dc773e616f5a13d84fe76f9854ed3cf40a2b77fd0874dae474eb33945e447c6727d728798e86f421c3e40ccf9608612a459ee21c2dfcaed0a18c6dfdcc1e1a848e462e0a067ac59c1f0a1d54fdb8fb0d1d57a43f3dcd28d65fc060d61c853fb5e72d902ae56973d1387727a8317fce8de34807f431193b868144ad34021f1fbb3c94d1171dcd7178d3e86082a1157db93158648792ea1f4f562399179a758cc4ff22a9bafc539a973c7055207dd388196c1eb1fd8a8fb5628bb052d3aae93a771b5ea1f3c82e268a7a3270e6dc2b48dbc2a8363d3b1afbcb0d462be7e6f640acdd9f8b7ca56aba1cdff3710a42a172dfc2a80426f31a25ac5fc715d62b787638bdff308bae3beb13c405df580a5ab68cc7c8a92729ba96bad32c4f5ef303e5b73541cdf7e1af5898c0fedce1b3aeaea39d762128d0cf603891ca5d683f54e659dc7ad3247cf1c487b04e5786c277f2624c98a0f27577531a420671ca23f28e754a2183534a6c534ed61db9043cd30d227ea12c60fd1f1d7176e0228121374054fa3412b1284ff2513bba1c02421dd2ca5d19489ec8a5a97453333311234f7b0fb5fd0a9e4c5044ec0870d3e1123161e8f8c238e69f75232ae8031b8f6ca33b7ede501537c2a5e5298e1d4f8afc591d690526c77dea4c61b75aa154f4821a42716b1f6f09e5e76b61e3c7da5786b07bd04d9a16b47c8bdf1d8580e7a06a5762f1544db315aa29edd8e5eb952a776fbcae59acd09c4ed86a7bebb6f9d01a1e19b578e858e5cfb22de5d016007a3567140273c73be515c97313d9353fb45fc3c36f9699acf111ee25c08f629121e7b3e162d5354ca4f56d4edbc2a9d0c06fba06744040d28b06d0622e2b0d7459d0086ce04025e1875198c7071d095338d96c7f0a5663114fc4003cea79304f94621f401adac4f47c49e6c6c53fbbe1d7f9b07f28c4bf944507534713b93a39744a6e12daa11d266faf5a976c6bcdbd04b40fec3bbe08057bfc385f021cc006e1def80cd8b4fea01b735d77ef432277a779933920a3a13207900c4c52d77deb21dd26bcec3cafc9ccf1176f966f601ba5290e2f88887da3a9820de23410c6bcbc4c0e6918b5f1e9858ed77b026dc297d6e733eacdc477c4b02514b7412e8bb067f32e96be45b1e2e0baa82901ed689ced137035cb99f03b7385e35462ab02cb500008aaebed74cbe6640cadded49e99863425e0040ff75f1feae9214447833786b822f22a01b0bd900f62e2f9f4ab856047ad126c08e87ee238eb0ca1a31cb086afddd7aa010020e19928f04d52f9313f09e73822b00413fd1ed03a062484fe209fbb912f12e62c2002331ab923ac7f36f27754fdcb0ffd03bca8f236d0fe5a21be77fa9958e35ad55b3a3580b9b8df19a11677172259b75aa4659df508f3521a62354fb8da392bae55d6d5cb6120558432870ec1812997f0725d99c30dd3f2b890f53f5db0da7de63e8dc49a37ca31328ea3adba70be7657a74b146db507837bf52106dd2404cee95848f253066e06d1daaf46b8234d408f8db058d13b6d1e0ccdeca32f7b2a4431d2000bdbf8060c324dd4a1a8fc23d434c2309b25668a57c6f72cf83a925b61abd96124ec8b26018b98231ae84fa80d03ef48388618c81b4f0ef13876206708a28ac1d7ebdd05057065a5207d25a5f0b237cc24bfcd7b68e87961624b5d6e42f9e25e1070b2d0e6f7c04ce6c357f88b422a5285e906ab79fce794313bfd26c1ab244cc77a248b8700e65c04dc993ee90a419c02c510adc5e519946debc83a222f6f175b8262bbe3585a0eaa6fbc1e70d6c7a55b61659a8f012216a1de52703d179455fa22a350ff1cd28ac868976fd22bd6bde2e2329224ad2bab0b611605f78ac7335d11ecccbf068572f3b93f91a953c7160aa8cd7156ebed6cbe77ab187766fbbc8fc7bc109d7eb2e5ef52604eb7e4f63e25d35cf29a8ff57d16e02cb594a8feec69c41f577f051affea765619a246aa5cb6f1e0d6901391c9a34efab599ff5858f79651ab6c7b035842215ad5d971b693a57a4ef22603ae31412d3dadc91830dad8f56f6bd7bf81246c0f8c7e7f3a3d237c84f4ff6a289e6db143b112f1921ea95215106c6d0ab63b279f30ca793985ac7994a879994c1d2264b18ac2dadf7a7a037be8ebd22e017ea02dfa8391f6aa3644f8321ab589dc590e1aa8b8548baba1b08219c55c988d1866583a8534e65cfa75036d56840b146506e95ba4c0eb5c612c7e6173ab141c286c6f3c5ed88d582544387dbaf45208199fece53c76db5bb9b1878f305ef2ce876e4d4bebcba6d7d05fe7d98e09b79b637e0c984590b82c2462f0ac53abbed57328be8e2d8d425baf83939c7d77cbf4da829acaed71f5ea938b561ee8c9f2247ac794f8e8bdf4e77a38c5d8b03876870c30308cf6576c2d8ae87218d88e68bb01ac91bcad42949854d7eef6452f40229d26c9f89ad3ebdcc1706db8a6cf52ca9b6d757baac45de6df0bc6c567851095b130340cb1db509bf778920ff88a9fa652e69a03de84833823d08f228638bdd5bada54e24d5bd36b1d9ccb9cfe4033759d750571ac5b747a94f93415db7a8f941162400ce987c3e68eff563446d7bee8a31a5b465c37beec2a77a23813bb69a2e870f53201f8a9aa661abd44363e27222913ec3d5ae697424c6a94f907b00ea7e5c9f3aa817d4807f8bab0059eeb42fbd464945dc62f1942f1a5169baff7a46e9e07b0657466adfe88c0c468e2b2cfcc3e2b56140dc05cfe27e128cb9c9b1d08dee184240cba8f931a87dc01dce2522382d6164dadcdc81e089e4660198f67ea5fcd0992fd0403a9d7e1fccce3fd7a2dd66dabdb861200a09fe98d69ab413813d5df79bff37c62699bb40fa2da1cebd027b9b6a39a9ea087470f88df534106dfe7860e4f8f2740c0f96a9a7fffc8f4706df03b3fed7b37727013003b557750810272ad407ba80e94e68306e1b4efd21576e07405148afedad2953b0fcb7f0188541a59ded5cfe3a0ac1f402efca9e53c74c827445a585e424dbca560e495fbdc7c2fd29ec22e2ac401246a42a96ce19a9806f5b1273c5a90cdcb69d050daf6825be24a5af17a78e3b02d80ace06f269adbabf95ede113b242bda83a67f4ff62f7c1332fa1c52682d78b57a64c8ce58c5a4cf67b61952ee0c3fa0941d6c9c9c68882ad97b02cb8f098a3a64d0f3d52a266cbba34cfe319d1f736955d7a98e4321aa2541a623a5b56429307913b3bc31a9e1813c8d9c018c55fc372708302eabe92a56e2ed8b0f609e3baef1d97c584a2add1ec19085e67a00ebfb23c66777a6f0d3c2df13a82d5c56ca2bc7ef531d2939754cf1b5f792f71e2636f43e19e14d122ea468bfa81a3f5408ba8dca957348c24190f4716b4594bfa9246f68f98929ad2e5b3815d463df1c77ee9c00f2a8789fcb2bc54749067953c60be154a0f9f7ad74ec6f4f5a5d8f20a5d831f0c4c0a85e304d93606c0ba5f7ff81c89dbbc655e137ffcf0be937de99d12464043615e90a074704fb6cf5527079727600c43c2a342bb3a68e9d4a7f8ada066d019c0991ae7d26d46498511231a330a3fb207c685593b23108f2ffeabcf45d3b8abaa68171626172b19d7692fa71b9cf366fdffe71870bf67eb9db40f3e5b078637e37bdd311b1899ec8d43ecdcf2e4ace01fb3d3ac471d19df54117984149ad8342ea6bd93936f6e386c28fb8664f7407fa737c70c981f06e9efc87078942d12482d4d3ce48bb95139bce2b024c5623da69e85c22f526ccf1d9fef7b6c1c7e50ef411040756662584bd75d1d28b6c7bbf04cf599d2f94d458fa81668cbc2d56d3a714a46c236d5a7f4a2b4fe39f60cb0fd928311685f5b90f2bc37687b00c7c1b6610e5c215bdfb59d27138dba6dbd8deba186d9ef44a6019edddab1ba01b104f45aee6f3e1daced323a44d618c61ff13b52247f3eb446f915a19966ee660ceca295fde7649f88b688f698eb7184909c572cbe32f4cec787813c6a24a55f7c8054fbfeb933b0a396c16e928f789c2568fec1b07f146b1455d76f528ddde9b2a80080b21a854b82f6f702d484a1551e70bd9573d79d4e6eb46d9ad639091a0c2ef45c70c6b0a7846f46d801890326193a67a9eb40ef2598e8fcd7ee72d05ffe434c3a2d3ec9c00b14fb4283d0badef516bd0aeb32e5f5776b3290f9e0182f38b681894b3d15986b39e06f0ade935b58fc50b01347313848cb514f3bc9524528007e10222621a67bb3f15e9375a979f9c7ce0dfa0157cb26e112c28e802972c0d2dd9d1d20340c6ee4d4f0e3840ac62d35d14cf11b86297bfb9941a2b50abbd348ade2172cbab21b60ba854ad46f5968f474e2a4e9a5163231eb6a56105024a94d9c0c640dd4aa0b1da02bf203251b4965250d06bede8af06d09a14c7348b8eac922b6313287cf708a5ca7e9ba544b9f2e3515f3ff1a4359ce949ce17ae85be1b1c22194a0d2369091fced68301ac317c5fee1c30f88426700de1dee46a7721df5132ca3b9d08d13604e2bf1bf6f961bfbed441625314515d77ca06b8fb158aea2fb159442d39fc9384a69010637aa231ad8fa95cc8f14982a5dc732159de22f9f92a16eeb60c25a27e48cd8899146d495232b497308557b0f56b053a1f0ecdacba1ba82838de8c0c3c2d09aaa2374a7ecf7c3c1abd585a9659cd477ad1cc84ace1b21cec5060524fb7ec18f7dcdb37d012387ec5aeb69fe3a8a2f312695ab170fb4cc1920a5b314d0262750ca53116798a8ec931a592a4f9bc2cd03c4c3cdefc69ab4ec6c7f7aeb9a126060f639c0d904538f1b72150ed8921791fea89eabdfca52de96dbccb7df41aedd20fd841d65021c8cb5ae0a7e3cdcc61e15bc1bc992df289016b8341da471449139b76b549ef2565adc834b9ebda041a6f63f4069245e4a0c26f96e45ecf7960adfdef9d1f525b9a7e28b1d88ba568ef9bc48e3571568b7ef9c4d12a74ddf5b8df90c99f516147ca427c772615d0a13145ffcd04a5ca94e2bbacf60a832d8dbd6986e1007cba559b8447c63f06707441e9675272858ad124b1f13d03dafa61487b21ef3039c6be47893c6d3f1a3d51180a6a07374b2e4d5956af8369c8c63a30d9c5fde064205b2fc13572514f0030e2d73b1cc6698847f1775ed65614bf1f5048b069aa6f0023d5736577adf6c5db74eeb0569356d2fe5765e3de594e17b8f5185805d1f51ec593c239d627bcaaf378c43978a91a66e268ecb0869e5bfa33788f1f4d5cb636ee768978ade9a794fdacb75607f9768c553ea3b5b10b2312330ceb33525f73d221e56edc286b981f7b41c9bb215fe6d780cdfca41da769226dbf35aa59c9303768f0a98aaff8a7596b232751267f2c2c3d2731e3394f39fe0666133ca2af37553b8425035766e0a10b31ec7eb1ae49bf861e3a7fdfac4f438af1614036c06cc93c30c39d0f9ce542ee9ccf411a7690baf2672ff108552a2cf6e58ac936a5236a6e0064d364093d1589a515a699f8d0da8fb2f03f44354f3b93a3a88eed3ed11a6adb3455b051d99f86106f84abc16a32885c7ec8f0d127319653a7df507ed16a374ac27124ff8212b8e7e4b9819439dfe5d6d86a14b30598e6db6957c5f72617571537799ccda103fc4800ff6d36572a25bc9d9f9bba574aee4210e9ed918f81160ba35defbded1b47f446fe79087cbabe170bdfb4bc12fb41a4cd8fe0c760a2e0c9eeb8eb88b2bafd5e6c29b43db7475c58afefef6fa81f2ae14767aa50a798bc5eae0b8f5b1012d0f136cc24da8b6e46f2e6e9a6d451b2915026f83290ea166e954b88e6f1c48c35e5a7780ced12b787ad9f39fc9be4d9513cb80793bd07b5ef008f832f20ac1142471d2ff904d1006c2919bf2d6f7c6446c52069de24826863f1090987d9c14ac21ed359ae1a80edb97161c60ea7a5b0dde58afada399182131491a322ecbe495e61754c3e8f3c4ff7036c2ea2f7be394a93bf5e4ac2c654d876d10ef88ec1994dd959a4c626aa95b0a9a2955e35cecdb86c338502b2c9891aac95b5106b1a4378ba194ac22affb45a4c1c6706a99443aab3bc27a830c0896afa485471d29bc9612b7f1a249fb5875aa2ef3ee3f8859cbfd71cf16251985741fd0038abfaaaa90c28dc8aec8a3366394902f56eccb4cd07eca4ff8dc6452f82b3cf6b85d5f100d764975c461bd8680591cf2d5c01310d3974787c4f4952d7c55026f2fd52262d87564a4c8d5d40f91d1833cb585049ca405358f5814f40c5a69338c6eb8367a137faf3072de02c40c50f69c02b7ad1e966c6ec5e81a0483fe8a4edadb2779b7c9fa0b12f08b256d122204bc324e3b7ca03811b1be8262150ca1fd9671d445e0b5822e0b9daad4900c37d8e15398418742bbfcdcf13185c84ef7757a9cb654059991c7a186ce9737040886d66b7d0970410ef69dde45510647f0b4edbdfa6549af4df5a781ad0c7daac1e74626e87b490c997e1983e00f71d21f43fce8cc6ab227ff2fb6f44f669749cd0aa9edce0f991e28df43c3ad5a77c3f736ab60f96a4e54e6b6622853e5f4bdc2b9dcec1890e8daa5a26d61e58bcafd897e156d36d7d1e7713e4961def57942cfdee941689ee45a3a4f29d147cb0e7d1c03a806d5a85374573a504bb5402852dca08d7380a5633106d6c7ff035ab0ae45f7cf92fd1397c0a3b841b9e5e706be5b742eceae76f84c0041144cfa6ed1b43b9d96c97210417797e719f19ed8218f8e284bde979f4442c0555ecfea18afc6a4c4062cf845c2c8b967b80fdea856230dc419dbfe08537ad916c12c15dfc9e73bc7bb8ee532c95d804dbfa49ae67b635d822b14c615c4ae1a3f6a3d41e16951c139d64be8bb637f7c2e5250027ab001ea85885f1f672e8884b0797501411f8bf12379e2d5416f55239251e8c1e92117f2bff50fb75a33910897e37dc1e0becbccd576313beeca28ea369e908ed6b3b9b283a02e8f4b8147830e9377023d7a0ebccb6ff9c450db6f8c50e48fd21726c9e8e44c5278ccdec2af91f7863ad4b19ec3b895906a089370c8f6debb77603e9f47adb31b36e30482cbf4b06833ce98a86fb053a6201297df67e710014589bc4e0787a51ced8c415907ff4d213d738dfc13d391d29b1f68f5911408ac41fc4cfc7a119f756e3937229161bfecea5421fe4169622636d0d0b6f226aeecb064b33ce926e146600afbbd44099689ab011675af056043b5f419d7781a0921c87797073aae0c635a499739a09b9218911994e445d4b1488b8c965cdf81aedf6865e6aa84efff9684f35da9725c5d4c09cdc0a718a6d3f9c62c352b4e0c228f31f63966c5d67c2645b7a11ee8964f2bef470d1585594d787636701de1945e90adc065b4a11fa45fd0f6c0d2d2aa8cc23142aae4f208782f501655731560b3ee9235dbb04a24924e09ccf0ae969c23ed379f5e07b8fcecf915e7f42d684d327f2d89a834e47779a34b4f1746c95d7c6796333816f8ba32c8430e90a4ae4cafc98b8e7f96afce7cc73ff2d38770da25181aa44d7ed519793ab2da8f725950f920d5876f2dc2a322a6dab6d4194c0f518f8bc7965e0fb9c5f04223c2f405ffb9cc94fe2468e440ab27c1efdf7a62f782cffd40482b967c9747f581a023f9acd0b0f703d3895cd02002bb3d3fcbaf29bae0be7dd34d940426d50eeded4c1686849cd9e27eb017772fc3159dc6374e6a77d88f9d74f274303b3a116a3d6c2074d6d9a8bc359cf21bf4c237f8b67f2dd87a900e740a0d25f80595b76c760e53f3416d1d9084b1eda16b0b1fdf095a438c8bb94d74639de8abb017126e03b33f3b31f6d49ab62b2640988fa22454cd376790fdd1a3359f5e3c97716f42dc57b11adae198e78c3a4817560561d485586b7d17dfe2b8f685c375bec22e471d4ceea90a2669a7cf947bacb7657473771d9784a6078e0dace1ecdcaa3d9382679aed7b2d19ad5dff9d4a583e0858d9ac6cf5e43d47efeca98e7be54d3af5bda5ae20c68a338fd6112921fd9c9ec6387ea8cd4717168f5940268bcd8457c6ff87ed8d6914638cfe79667c75eb31246ffeaf467cb02c6627f9734617c9da57ffb7469322f7a03c0350d6fc3fd483a21d55bc19c462e0141a81dcc07bc02a361e066e1e57ad4005fbcb08d1002fc7912e6a8b6a18ff0312ce84feb7c22b38dc835f3d11d91cf9783885fc8363f0fe3e139f696b7f709c97e5522eae3d2117e5f5e5e195d04c3186e598d4c6b3f54fb96aaac8974b10cfca82bac610d6eb0398b9a1109efb5c627c333c0a94e03f8841036cc800107c0977591a76feb9dd487980b6d3f78e64546d9b8453149159160a8cff9a590be97b6981156afadd893612e9e1eb1b0bb8e99fe2da61a8a60169e9d6bd70783cfe3a6c24c7734b54dc7c95cbb7a318d871a2ce27914d41809bd9616b7ace2af4d7577c0a9dd5d454e949316ce924285a9b0384f265c301b427677f0626ca28232167b198fad69e8cae469140ac84c918b0b3105b2eeb55e3cff9be07d3781b37ad97858002a7de3400fb6daf4303006244c1fda5e6f8e6c1ceaf56902a0ee98d633d47ac98e39198875676e144e1c5c4bd2856938b29976ec8f8f20869c1967b3016650493378c2420c33e4d886af8210e2c55c49e155a7e5dcff6e9ffa45afad1019d7c43c5e17ea14f7c19ee0206f775560cf5c3f7c2cf15bc4e7f5a79f7c7cbc21bfab05eba504e4929a28bbe7d7083b4d1affe1f9b143f6ad9c75fd2ca22bd81d81478e7820614e273b82ff5cfb63e4431322cd834704da4d1c626ba9073e18d23c8603371367930c8bfb4952bb3b2e961e3ba261fac60e8591144c8362cd8f98ecc02ad1d4f5d5b4ab8877051b76c0993bea2d47f2f67c64ab83432f7e2b8f8afe500ccbf1497448de3f92e8d9336e2880816e7e02c30915e9e5f93915b6f7bb1f3991bfe4d4babd94d7e1229289b0f9806ea5891dfa6cd1a7f52c1f33e85699f864ac89958e46f649e726944a4ecb9513e40e469223f0613b6963c2c221bc1db4368fc7937719385ce0c4340646c4b0e7e107d3531fbd15e19e584c2ae2be2a616637bf4eb0eb372a16b438562780c4d66a438c1a26c44424234efee0819906275a26d8dbc14c870d0a22e4aa64f751af9a8119f3df09ef78364c5709ffa092d63584311b5acb69d636a88f04e41e807d3a63762ac4c1d962fe07b35792acf3e0bfced14ba06e0ae4ccd42fdf0e86f35f450736562fd34c62bd1a8df3ca037ba60553bec69a4e9b0967b299aee4961f7c60a72a94449e85cdc4453d312bb0a6234c7fd5a85684705bb79742b9f4191ffbc64bcd14cffb880280e7a364198db8ca9a40ac152c7939ae55d25c8612472d30380e3a98a48a5424c7d9b7283c8d194407bdce85d5ce5f5e8918c1fb04a51700c1ef40eb38935cc0449f693568bd39b96a941df0f898ba15ad1658ca782d21bc9822f8c976ecc825f519d756ee6b9d6aee86a4c0cf7556c6d82277aab1bd67d041da4cf819c9db599226e8f6475485d6d3cfb7f32f49ab47fb061650323c9754c0e79bdc34e9d9a3d4ce6cfa4ae7cfc81efd54063db082e4a8274abe778dd16fc3ea094f8c2ecca26ab9e903fc6ec71490f431b9f6cb3e6bf1c49d23a327d611e9bba8e76dc5690bbefda76e6d89f82d769e5c1bade559f9b341007e0f907e1bb3c874c8941876b968d2deba78ca27b99f7cd7a2eb97d337beb130a2deda56b5e5f0fb43add42736f4bd72f3dc4b3f527e537320c502cb4d751bedc581125bca052eff73dbb3a326af2af8e50582f81afed937893d9827ea94d3e0062199f7d57393ed63ef9e835d9a7ed1e5e19e62f0a8499489feeaa494baec1c687cf4015c8d770c439b34fafcf07fb4aa36abe01c6893204bc952aed59e4ae8a8bd22f4f9f47573d1cd88ca950357087fb2e8e4c20a36b0ad5e039e83ce2f2fe72286e772c41522d688a319285802be411aa370bd595adab428a7034db5f5fe50a838709d4ffe5ecb73be65199efae0a49eb69464e0c472f9a374d555ac99f271eb0c87930473b60950b296d7f9277000e67560c8b1b1a29c88a350cbeac6cca7a42abb2747b174f26d04b361a407bce0b22442ed10ea78566f741930785c2ab93f159c641f5975888dea0851edf4d0971781600ad489f193a9df7600f45746029a3ef923e19fb744730675ac3f1972d86404c02578f6f0eac3d05f29f28e9a861dcde1bc8ef5785118a45e7785ff15210319bc70ccfab8c5367926d6b463e5b279325f9f707c52381d3ca1b24e5a27602c33597385e421a5a627e78377fff939827e8c0f251b419b3b892d1f6167adbd03e38c529d4dc045925304a467bfcbcb3bc041d01665722e2e9dca9a6c098fe4d7744e9a54080b27af9f0dd58a2b0458c7229b6bf8c735b6bfe60e0d75377d3214ad1bb3fc1f9660f55f5ad65bda0ea0fb3e039f459e51f8044a157d8cc297643b507c7d84475f2159f2bfb6f5574c1124150244738f075ca3a07845e3db430810526d17d74eb53ff03342ade18d49f6d47c56cf343c7f1c063966ab5eee983452e936336e42435fb606ac1a1dc2b8fac37e924132440e01ebfcf557031e910eaa97b908df33aad4119c2f487e50bee52ffa4e992839e31e51d16347f87cd1dbcb853b2a101d06a59028201a4e64a459673b67e227102adc83ad5e59ce3628174ecba8f46bfdbd20ac92f92881e0d00c8911ac8699304cee85a09a75c4bc435df86929ce57b2be023f39a06231d96ad81e01e4df03c40b4726628b9c2d680eadbf198b45458a7a5fc6f2f7925fe4a6d6ebbc80e054d76c10b984f25c438133575c8e0d43fa3bde1c0abc3f6d6a3f2cd8a6943b968e163894693e71ff3a05749c72d2b201a6b84fa4467c93deb2ff7d3c0f10792de5e9c68efc06b1bc033107d8cfc935c3a4146bf3cdf731710db7c1b3e9ecb99c89362cf0f790b0028e9bdb0f9d5fa460b2aef6116c015fb0b522cb4463bc0bcf6c645b4244561d44a1f9d5cfd4a4d28c4121d45eaedbdebf5d972e4a3d0dd4d83170ae03151d50963b433fa5be5ba95f9c28edd0f230ee7de1c7a38c120f8605e755f72280a6af8367cc80ce2114a074e467bffcb763412f38bb13f7ee8eaa1d7c0ae7ba5373a2d09dc6c44b4455649fd27acea45d72492cdbb25ddd22dc69bbb61e1bc695b6255d6b5878a8197c889fa3ae942a74fe4aa47bae784a68fb72be439b54ec4afca1ea25a895cb569954be3cf6a1c8bbb6dcff649c14da2b175344de272111b9cf2b0c58a7d035de16a653913b5ce5a0f1a3957a0aa35cafada50cc74003fde8579adc58b5c0696f996ddaa498968ff56c34d0ab6bd07c3e0fb528dec0ae6ec6f8f67a61f6a7f6757e87e6f96f3d290c8db171a8c67cb59c2c647a47c76890d1f1350d79abf6bb885cb7f3378f13ea184cdce9f548f9ddaa2bf05daabbb4ca7c040c5c697c185451cb0792d22212856bf7c6f2db2058b1bec01e982c6b70338dc8dc97608e1c1ee50d40b946e91277f03d7fc540aaee120c05e63836ba7d036cb2ebcea1048a71aab8d6ef6a9bd3586d95a5657c2130664764a9d06b3265ba8df0a582e573b3a62396082446a0a2e8c172bca79091866a5a7879cceaaf0db08c1f97bcfabec59a43f3bcf94dae34c628c357f9aaa36eee973569d4ab7c5c2dc0f12b3373686a888502d8a4380ba563d6f04fa0a172e62223973f6dc2aae93bc5f2337ca1b949b95399966e6f3932d00000b3d3e0e13e48dd00f1097a096b957cd0906b7f6a09e5bf5eb9a165caf22a4e8d7660e9ef1a60b94d6a40b13f11d4dfe5332cb92ae88fbbcae7b726e0b19f772db6015aa2ba8331490d5855d1dec60bdb4b05fe6e6a4db9825742488b0257f0e43252e0c7d78d66a57e64742deb0c8aa3994c6d42cfd7dcee09691bb42189d78f07e87c1d051f74cbf2b9bd7d6d1925cfee2d1aa3a5273e2a3e128ce2d013b844eab826d14c31567df231133a896201f2257590dd8dfe850d52adbdf092578c9a342176adc0e36e322889e62878df54463129e6dc914dc68423378f4bbde363ba064674dcdcc6c6ffb5e03f2a957f33b15d23700da4e8013e403507cd9bafab6baa3d7d2c31da26f68a85630ba94c10b03f26beb1568d448f73ae6d902b5f0fb2b0b3a517913bcaeb2872128ff17ed892f0b50393b9264759ff16fdf9fdb952d819d90dfdf9c4223b2e5d9fe2a81d05104f7ff6795ce3f2bc0498f536de8d64fa9e2075adebbb21f61a7d0677841f396e3530f2a8dcc3fe273fdf00e045316b05307859ee88e70929c38b2c0a6aeb7b15643120cbae1148b238741b98126dc8a66b7d5bb9bff5d42d4798bd8e4329342c5e1430408a81033efa7a76a79ace1122f70d4422570766be499c4e944de73e19adfedd1075b27c3a03aceec7995d025197652ec4c257b15efd0f6b24dba6eea54147b6858682d69759d341d79280468b2bd7d3ff6304e418f11693cb68b52b169f53a37b9c6015180a8b0de5f507ccc9ece466d6e3094ab3559fc0123613dce73955e97cfbdec7210b97a3e14e25d0df13cc75f8c281edc16f07ff0df03981dabd2095043f652bfd72888a191948480548c6f10a6b54a740eb021972ebcd145f82b8dac10e6dbb8a007558d70c31a7cd8740fff736d2be2f47874bf3736bba58a0530ce87206ffe17b80cc7af587e071f3652a91da5937dcb3c745f34671a5526e74bd10cd5ff767c7d21cedb514db03e189a2a3eda8d375b00263c31e3dacc41bf165a094b4ccb1d64a22a21399246bb0fa68ce2ee63e3aec9a3362747c841b5b4dd0f30503d984f64aae10eb3ef4f941b646e554da3ad538f31e13ae98c8d6d0b96dd228d76a61514e9052a04c234576fef87e112db1278e25e636fb224d76fec72d8086ba841921dbe8fab360a14fb048e84b207c67b1bf3c75937ef05df2f89322e0acbe4f55735b18e1f1f7cf2e0bc4f0e571131d910e389e5ccdbccd21def0d27f1ac66397e04c03536d5f9d9677c8a8fe68486d06ab4dff32391a5b10f1b7a20eb88a76eb8293656673c3e264649ed3dd4978cc60f9010797f9d30e3bc30deaf4ec9a5951222e12364d4a0db25dc998967d109446284a69a130ef368dbca03b993b466880bcf69d10c6d9163726da0ca90f6d11e66f623d41b6ec68baf47361064e6b097e1dc2c3e6213b8d5d26babfc49d4ee48d4a2bd1d9f0271785d51a88f0daefcee4e5ba78e22f27dc28c23325924b2b13890482e06ce277ee6d92cec4c9a7918329cb0552b92a3172d191069d8acb6c596da736bc153fbae4c3ca64e75dab61f68177336b78dbce10cf51dba7b6d99ab9227b37e7ca809df394bec4631249590ffa9158c80d2beded9cc640799d984295dc33373df8264fc7bd14e9ea53f9c7042245c59ce0faca17be330bd4b8e1503783937aef026023818a817c7925b55222e4be5e160f63a8e89fb765f8c31ef2996a48e784ab5b01d46abf560cdf16a9099a6d272d5c24f9b82a60abebda145196d90253cc310408965695b56a9fe6926436c45f4bda114aac5a99c93a5f4a66b818659fe2e299500388fba3e41b01126f43988ac6f594e3cfcc4801971d19a56eed9710d25dddd0d5094f402f7f96ba9060612de14319db30e38e95f0a1b07d2e0fb0ddb4de738c26960c847166f5342f45d11c4e488c94917d92d209e49277af32d1941444f5f0b08d670a7326a6cb0f2a157f663f6d1f51f45d44d623ba9bbdee10f593bd9eb00d83c66e20d303295faee186df8cf8020cb0d93b32be1b698644e29f6ed53f4881db1cdb62e81715b4abe8fd61c39f49a4d3149bfc4a84783e634cad8a571bc216c693b116b722ec3cee65d25e70da24b99b3504216cfe984cb1ac5d803e7d7ea85886855e5ccfe437a181c9e34c44022623e856a673f8609222552068c6387560b6effd6ba9c5af014a33e259413c6266356db8bb9738960a1e6363d6e2b7315e4e355f6794695b167731959f08432feadb670cd9deb241d88d97f9c0ec005fe5cdcd270f3e3204225f8f70f094df3bd912e223864f6c52291b9413eeba790b54b87e3bf3f78283574fa16a137ae3ca6c8c34afa0794e90f263d60ac4df7d7760982ca5931f8ba57674d6cbfe5f866baf0a730a15eb909285926131dbe7c80f26d41c29339b73d3afe2dd7b1c21c204761bf78df79bc2ce06825199e73fa4919f30891ece4d7cc5339f26138b094f100da89b465ff62cf58be3082e50b85c18026009789ed29de1cda12a7a24e27a85e32bd45c04e3f62ce26d2fc3ce6719d65a90d02194278ec1f5c6aad896aefbdf1cb5bd52b52cc3eec72fe05cf1ddfb0abdb5b73bfedd9e6723d99d5f033ac82894857d1b5e16882b1c860c5dcf6a67ba91aac0332e4a59497f221d5e6abd7e40550efce2da8437611fb3af642b433696a147495d5d187cc597b6a5ca06b57118b8f17e7314ab82008b6129aa63d2b4498f5ad35</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
    
  </entry>
  
</feed>
