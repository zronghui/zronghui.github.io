<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zronghui的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zronghui.github.io/"/>
  <updated>2020-09-08T15:47:13.000Z</updated>
  <id>https://zronghui.github.io/</id>
  
  <author>
    <name>zronghui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tricks-2020-09</title>
    <link href="https://zronghui.github.io/tricks-2020-09.html"/>
    <id>https://zronghui.github.io/tricks-2020-09.html</id>
    <published>2020-09-08T15:45:17.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c4c9a332231d56e4d4e3d499e8959e501074c5a6d94c93914eca3027176a226c">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dd85bdd0ba216a9a3ddb0ba4af683a3234740fdce8265b492f7f7c66e06ca477ca5eefea6853f46f0c4c21eba11069307a68c85baf47613206b7b7fa8342ba3e63b45f5e3027eb5393ad2a79dc1f9c6d3338a513824885d7bebc234bc31ad8ad14d441cf09b4d13cdb86bee7a2ca4835273ddadeb22d8717f48d46eab635fc3a98e8cd6e6c7050184b3de31048bfad0b31a2eeaf658a30f37f94238f9f2675fcd5086dd29c97860e5be6a71235f894f8285d5eebd7fc1d8b7ea340b1bdefa77663d9d5b5e05f0d3b152a90809472fff9b88061e88b37b8780ee01cced06890fe3643ecb30157fa7f07987dfb0c4e125381d2e7acc32c4e547a3dcce00cd3d527f04c793bf57901eb5f24eb78fea0cc88d1d33d351b522aed5ecdf3737a014bc77c4c974821765386560da5988f33343d5dae62d4e719e4e25f6a127318c7e03adc3bb29adfd1d861385cc992080564d48543439f25235b602f09d5083607195a6c974ca71339ceaa7a085c91d2112e2090700a3c191e9b03339b1a7389292d8284035d331d45c770d24a4e9c9a9edab918b8ef456e38b1c868d23c14e5c0dd9c17a2fecdf142f953654e397aa8b8beb06fb53f8b090553643d1f7e728b55d9cd4c10b264ede551be48641483200a48c7a6a384b1eef35448d02aa8693976fa16214911cc995d464bb77b0e55bdfcc845a62bcffa06452384ad8e91b41703eeb65c857ecee0b6fd582e1ac333e1859fd089bc5ebb84994854f05bf78e5bf1bff3cfb416d89af09e9146e789066e77be22cc3503d3a7dfdfa7f548ca54257c029d7592ae04eb02528b6da0bce0e0f3e958a437b045595a96efcb57f011c3a6302495ef564e8eda1826b336207d643d527a312812704cee610d35e19ce78515c072fa1fbf3ab696dd63a0ceba1f54393483fc591abafb2229d8e339676ce504c494233ecd5a99e2056d9110891e9c3a620539631ed752d2020374652dc45682ed9dd47413b5a0443074b635cc85aab96cf452e09be6ba6605df051eb7bc254f6781880631a5d6622076dea203bee10c9365e3b0d050abf4169a37ec661ea89a5a70d435727623a9c706c721a692e682a54797119c736608df045fda8eda328cab38a6e520508be2426152bd2ab49bcac11a71c6135def6ea3ab1562dd2d2e516631de3f2a5daaca79453b1aeb187e8bd7007485e67d25613e9c0b86a0798d84c1a469354f5f298a7793c8bf646b5f23912ee92d1fa4c33c71bcbf5d207e0a4a393989c3d96b58bbe4946e22d815316fafb8600bc5f2651e604b7806e053a26653e3df28e03080cb6215749fe6ba3fa809d1653bff85ccd436f4044e4a905e8947ce31301aeca136595f1a8b4b36bb26122549c62a616e442ec7a066a9e0efab82194cc71e56c78660f55b91f24f56f5b9ae5a532fb66620e4cd717cfd9710d25c816a2d76734241320f852df60e407e948355841947852c361b7e9ccb62e645d3e457fa3ee3a46d2aca6809c5c4294096a386fd8a3be95dba520f3b21fee1326e2c52529af57f900217e6841ea9d2bdd2c6cc18a6cc6be638930692250ae0b256d47c023b8909149eecabfe977df3327a128614052f30ff9d9af7ccd3a051f2a5afe8bccd59d26a74665de2a989a5fd2f8d115be521a335cd2278b4195ff7cca02348d08f655aa2f06f63f7f340ee1cecc6b83f8425bd05c0e6179206f873d5445d392de644659de53d643b31f8370cc41e59b20b08f4aeae121b36a4467c127bfe577948db9d2ea82bb083c0b4343c2c74c7432fd9962ea7ce2c3244dafe240aed6654142087bc21cbc48381a7abe81d433fd4dfe2b353c9ddc9dc91b49d534e8ee7539e9b8eb9335f1533464683fda49709bf77b945bf2ea592fbd29673ec4b577a58ec2207a0e881d80224003f910cfb46748230ba8e4ae01aa2e1a54caca92f6b5a56c87ca1e3b753d3864fdc9c1be1ca463a72c7e38882c6e9590a094d7c77226bacecc42decb39ebcab0aaeaf7570895d3a6a80100baf9cd11693b06e9dcbb1d4f4c0f7d93f5904a03e2446406fea36041c4a5b15b6fc2fa5c979b426ec94ef53610b1a32a275752b3ff32dab764e260e82f52d95c8854e48459f533442155</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java基础-CSNotes</title>
    <link href="https://zronghui.github.io/Java%E5%9F%BA%E7%A1%80-CSNotes.html"/>
    <id>https://zronghui.github.io/Java%E5%9F%BA%E7%A1%80-CSNotes.html</id>
    <published>2020-09-08T15:37:24.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>&gt; 本文由 [简悦 SimpRead](<a href="http://ksria.com/simpread/">http://ksria.com/simpread/</a>) 转码， 原文地址 [cyc2018.github.io](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80</a>)</p><blockquote><p>缓存池</p></blockquote><blockquote><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul></blockquote><blockquote><p>Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k);</p></blockquote><blockquote><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p></blockquote><blockquote><p>public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</p></blockquote><blockquote><ul><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul></blockquote><blockquote><p><a href="#/notes/Java%20%E5%9F%BA%E7%A1%80?id=new-stringquotabcquot">new String(“abc”)</a></p><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul></blockquote><blockquote><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p></blockquote><blockquote><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p></blockquote><blockquote><p>1.1f 字面量才是 float 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float f &#x3D; 1.1f;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">short s1 &#x3D; 1;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 +&#x3D; 1;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 &#x3D; (short) (s1 + 1);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>String s = “a”; switch (s) { case “a”: System.out.println(“aaa”); break; case “b”: System.out.println(“bbb”); break; }</p></blockquote><blockquote><p>switch 不支持 long</p></blockquote><blockquote><p>final</p></blockquote><blockquote><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul></blockquote><blockquote><p>final int x = 1; final A y = new A(); y.a = 1;</p></blockquote><blockquote><p>1. 数据</p></blockquote><blockquote><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p></blockquote><blockquote><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p></blockquote><blockquote><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p></blockquote><blockquote><p>静态变量：又称为类变量</p></blockquote><blockquote><p>可以直接通过类名来访问它。静态变量在内存中只存在一份。</p></blockquote><blockquote><p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p></blockquote><blockquote><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p></blockquote><blockquote><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p></blockquote><blockquote><p>静态语句块在类初始化时运行一次。</p></blockquote><blockquote><p>静态内部类</p></blockquote><blockquote><p>InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass();</p></blockquote><blockquote><p>InnerClass innerClass = outerClass.new InnerClass();</p></blockquote><blockquote><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static String staticField &#x3D; &quot;静态变量&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line"> System.out.println(&quot;静态语句块&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String field &#x3D; &quot;实例变量&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> System.out.println(&quot;普通语句块&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InitialOrderTest() &#123;</span><br><span class="line"> System.out.println(&quot;构造函数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</p></blockquote><blockquote><p>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p></blockquote><blockquote><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul></blockquote><blockquote><p>@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; }</p></blockquote><blockquote><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p></blockquote><blockquote><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p></blockquote><blockquote><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p></blockquote><blockquote><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line"> int result &#x3D; 17;</span><br><span class="line"> result &#x3D; 31 * result + x;</span><br><span class="line"> result &#x3D; 31 * result + y;</span><br><span class="line"> result &#x3D; 31 * result + z;</span><br><span class="line"> return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample implements Cloneable &#123;</span><br><span class="line"> private int a;</span><br><span class="line"> private int b;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">     return super.clone();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p></blockquote><blockquote><p>浅拷贝</p></blockquote><blockquote><p>return (ShallowCloneExample) super.clone();</p></blockquote><blockquote><p>深拷贝</p></blockquote><blockquote><p>DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) { result.arr[i] = arr[i]; } return result;</p></blockquote><blockquote><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CloneConstructorExample &#123;</span><br><span class="line"></span><br><span class="line"> private int[] arr;</span><br><span class="line"></span><br><span class="line"> public CloneConstructorExample() &#123;</span><br><span class="line">     arr &#x3D; new int[10];</span><br><span class="line">     for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">         arr[i] &#x3D; i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public CloneConstructorExample(CloneConstructorExample original) &#123;</span><br><span class="line">     arr &#x3D; new int[original.arr.length];</span><br><span class="line">     for (int i &#x3D; 0; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">         arr[i] &#x3D; original.arr[i];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void set(int index, int value) &#123;</span><br><span class="line">     arr[index] &#x3D; value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public int get(int index) &#123;</span><br><span class="line">     return arr[index];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的参数还可以是自身，学到了</p></blockquote><blockquote><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p></blockquote><blockquote><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p></blockquote><blockquote><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替</p></blockquote><blockquote><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AccessExample &#123;</span><br><span class="line"></span><br><span class="line"> private int id;</span><br><span class="line"></span><br><span class="line"> public String getId() &#123;</span><br><span class="line">     return id + &quot;&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void setId(String id) &#123;</span><br><span class="line">     this.id &#x3D; Integer.valueOf(id);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p></blockquote><blockquote><p>接口</p></blockquote><blockquote><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了</p></blockquote><blockquote><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p></blockquote><blockquote><p>接口的字段默认都是 static 和 final 的。</p></blockquote><blockquote><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为</p></blockquote><blockquote><p><strong>重写（Override）</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法</p></blockquote><blockquote><p>重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line"> protected List&lt;Integer&gt; func() throws Throwable &#123;</span><br><span class="line">     return new ArrayList&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public ArrayList&lt;Integer&gt; func() throws Exception &#123;</span><br><span class="line">     return new ArrayList&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li></ul></blockquote><blockquote><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line"> public void show(A obj) &#123;</span><br><span class="line">     System.out.println(&quot;A.show(A)&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void show(C obj) &#123;</span><br><span class="line">     System.out.println(&quot;A.show(C)&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void show(A obj) &#123;</span><br><span class="line">     System.out.println(&quot;B.show(A)&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends C &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"> A a &#x3D; new A();</span><br><span class="line"> B b &#x3D; new B();</span><br><span class="line"> C c &#x3D; new C();</span><br><span class="line"> D d &#x3D; new D();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> a.show(a); </span><br><span class="line"> </span><br><span class="line"> a.show(b); </span><br><span class="line"> </span><br><span class="line"> b.show(c); </span><br><span class="line"> </span><br><span class="line"> b.show(d); </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> A ba &#x3D; new B();</span><br><span class="line"> ba.show(c); </span><br><span class="line"> ba.show(d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p></blockquote><blockquote><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p></blockquote><blockquote><p>也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p></blockquote><blockquote><p>JRE：Java Runtime Environment</p></blockquote><blockquote><p>JDK：Java Development Kit</p></blockquote><blockquote><p>JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题 - 云+社区 - 腾讯云</a></p><p>TODO：写一段泛型程序来实现LRU缓存?</p><p>LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解Annotation实现原理与自定义注解例子 - 贾树丙 - 博客园</a></p><p>&gt; 本文由 [简悦 SimpRead](<a href="http://ksria.com/simpread/">http://ksria.com/simpread/</a>) 转码， 原文地址 [<a href="http://www.cnblogs.com\](https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html)">www.cnblogs.com\](https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html)</a></p><blockquote><p>注解的用处：</p></blockquote><blockquote><p>1、生成文档</p></blockquote><blockquote><p>2、跟踪代码依赖性，实现替代配置文件功能。</p></blockquote><blockquote><h3 id="元注解："><a href="#元注解：" class="headerlink" title="元注解："></a>元注解：</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：<br>   @Documented – 注解是否将包含在 JavaDoc 中<br>   @Retention – 什么时候使用该注解<br>   @Target – 注解用于什么地方<br>   @Inherited – 是否允许子类继承该注解</p></blockquote><blockquote><p>自定义注解类编写的一些规则:</p></blockquote><blockquote><p>1. Annotation 型定义为 @interface</p></blockquote><blockquote><p>2. 参数成员只能用 public 或默认 (default) 这两个访问权修饰</p></blockquote><blockquote><p>3. 参数成员只能用基本类型 byte、short、char、int、long、float、double、boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组.</p></blockquote><blockquote><p>4. 要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="number">2</span> <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="number">3</span> <span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="number">4</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.FIELD;</span><br><span class="line"><span class="number">5</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"><span class="number">8</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">9  * 水果供应者注解</span></span><br><span class="line"><span class="comment">10  */</span></span><br><span class="line"><span class="number">11</span> <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="number">12</span> <span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="number">13</span> <span class="meta">@Documented</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line"><span class="number">15</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">16      * 供应商编号</span></span><br><span class="line"><span class="comment">17      */</span></span><br><span class="line"><span class="number">18</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"><span class="number">20</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">21      * 供应商名称</span></span><br><span class="line"><span class="comment">22      */</span></span><br><span class="line"><span class="number">23</span>     <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="number">25</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">26      * 供应商地址</span></span><br><span class="line"><span class="comment">27      */</span></span><br><span class="line"><span class="number">28</span>     <span class="function"><span class="keyword">public</span> String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="number">3</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">4  * 注解处理器</span></span><br><span class="line"><span class="comment">5  */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInfoUtil</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFruitInfo</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line"><span class="number">9</span>         String strFruitName=<span class="string">" 水果名称："</span>;</span><br><span class="line"><span class="number">10</span>         String strFruitColor=<span class="string">" 水果颜色："</span>;</span><br><span class="line"><span class="number">11</span>         String strFruitProvicer=<span class="string">"供应商信息："</span>;</span><br><span class="line"><span class="number">13</span>         Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="number">15</span>         <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line"><span class="number">16</span>             <span class="keyword">if</span>(field.isAnnotationPresent(FruitName<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line"><span class="number">17</span>                 FruitName fruitName = (FruitName) field.getAnnotation(FruitName<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="number">18</span>                 strFruitName=strFruitName+fruitName.value();</span><br><span class="line"><span class="number">19</span>                 System.out.println(strFruitName);</span><br><span class="line"><span class="number">20</span>             &#125;</span><br><span class="line"><span class="number">21</span>             <span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(FruitColor<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line"><span class="number">22</span>                 FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="number">23</span>                 strFruitColor=strFruitColor+fruitColor.fruitColor().toString();</span><br><span class="line"><span class="number">24</span>                 System.out.println(strFruitColor);</span><br><span class="line"><span class="number">25</span>             &#125;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(FruitProvider<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line"><span class="number">27</span>                 FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="number">28</span>                 strFruitProvicer=<span class="string">" 供应商编号："</span>+fruitProvider.id()+<span class="string">" 供应商名称："</span>+fruitProvider.name()+<span class="string">" 供应商地址："</span>+fruitProvider.address();</span><br><span class="line"><span class="number">29</span>                 System.out.println(strFruitProvicer);</span><br><span class="line"><span class="number">30</span>             &#125;</span><br><span class="line"><span class="number">31</span>         &#125;</span><br><span class="line"><span class="number">32</span>     &#125;</span><br><span class="line"><span class="number">33</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> test.FruitColor.Color;</span><br><span class="line"><span class="number">3</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">4  * 注解使用</span></span><br><span class="line"><span class="comment">5  */</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"><span class="number">8</span>     <span class="meta">@FruitName</span>(<span class="string">"Apple"</span>)</span><br><span class="line"><span class="number">9</span>     <span class="keyword">private</span> String appleName;</span><br><span class="line"><span class="number">11</span>     <span class="meta">@FruitColor</span>(fruitColor=Color.RED)</span><br><span class="line"><span class="number">12</span>     <span class="keyword">private</span> String appleColor;</span><br><span class="line"><span class="number">14</span>     <span class="meta">@FruitProvider</span>(id=<span class="number">1</span>,)</span><br><span class="line"><span class="number">15</span>     <span class="keyword">private</span> String appleProvider;</span><br><span class="line"><span class="number">17</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleColor</span><span class="params">(String appleColor)</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>         <span class="keyword">this</span>.appleColor = appleColor;</span><br><span class="line"><span class="number">19</span>     &#125;</span><br><span class="line"><span class="number">20</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getAppleColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">21</span>         <span class="keyword">return</span> appleColor;</span><br><span class="line"><span class="number">22</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleName</span><span class="params">(String appleName)</span> </span>&#123;</span><br><span class="line"><span class="number">25</span>         <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getAppleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">28</span>         <span class="keyword">return</span> appleName;</span><br><span class="line"><span class="number">29</span>     &#125;</span><br><span class="line"><span class="number">31</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleProvider</span><span class="params">(String appleProvider)</span> </span>&#123;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">this</span>.appleProvider = appleProvider;</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getAppleProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">35</span>         <span class="keyword">return</span> appleProvider;</span><br><span class="line"><span class="number">36</span>     &#125;</span><br><span class="line"><span class="number">38</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">39</span>         System.out.println(<span class="string">"水果的名字是：苹果"</span>);</span><br><span class="line"><span class="number">40</span>     &#125;</span><br><span class="line"><span class="number">41</span> &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">2  * 输出结果</span></span><br><span class="line"><span class="comment">3  */</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitRun</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>         FruitInfoUtil.getFruitInfo(Apple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="number">7</span>     &#125;</span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="https://zronghui.github.io/Java%E5%AE%B9%E5%99%A8.html"/>
    <id>https://zronghui.github.io/Java%E5%AE%B9%E5%99%A8.html</id>
    <published>2020-09-08T15:37:00.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// size &gt; loadFactor * capacity 时需要扩充 capacity(默认*2)</span></span><br><span class="line"><span class="comment">// accessOrder 默认为 false，维护 插入顺序</span></span><br><span class="line"><span class="comment">//             为 true 时，在调用 afterNodeAccess() 方法时，会将当前访问的节点移到链表尾部</span></span><br><span class="line"><span class="comment">// 所以，链表头部是最旧的元素，尾部是最新的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span></span><br><span class="line"><span class="comment">//     super(initialCapacity, loadFactor);</span></span><br><span class="line"><span class="comment">//     this.accessOrder = accessOrder;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> cacheSize)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此方法在 afterNodeInsertion 中调用，所以此时已经插入新节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size()&gt;cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-205</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-205.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-205.html</id>
    <published>2020-09-06T08:14:11.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">替换所有的问号</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/">数的平方等于两数乘积的方法数</a><strong>5</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/">避免重复字母的最小删除成本</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">保证图可完全遍历</a><strong>6</strong></li></ul><p><img src="https://i.loli.net/2020/09/06/hqcnGTL9xymlZt6.png" alt="image-20200906161557664"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">'?'</span>: <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">if</span> s.startswith(<span class="string">'??'</span>):</span><br><span class="line">            s = <span class="string">'a?'</span>+s[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> s.startswith(<span class="string">'?'</span>):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ab'</span>:</span><br><span class="line">                <span class="keyword">if</span> x!=s[<span class="number">1</span>]:</span><br><span class="line">                    s = x+s[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> s.endswith(<span class="string">'??'</span>):</span><br><span class="line">            s = s[:<span class="number">-2</span>]+<span class="string">'?a'</span></span><br><span class="line">        <span class="keyword">if</span> s.endswith(<span class="string">'?'</span>):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ab'</span>:</span><br><span class="line">                <span class="keyword">if</span> x!=s[<span class="number">-2</span>]:</span><br><span class="line">                    s = s[:<span class="number">-1</span>]+x</span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=<span class="string">'?'</span>:</span><br><span class="line">                res += s[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t = set(<span class="string">'abc'</span>)-set([res[i<span class="number">-1</span>], s[i+<span class="number">1</span>]])</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span>:</span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">in</span> t:</span><br><span class="line">                        res += x</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        res += s[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTriplets</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">                i2 = i*i</span><br><span class="line">                l, r = <span class="number">0</span>, len(l2)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                    mul = l2[l]*l2[r]</span><br><span class="line">                    <span class="keyword">if</span> l2[r]==l2[l]:</span><br><span class="line">                        <span class="keyword">if</span> mul==i2:</span><br><span class="line">                            res += (r-l)*(r-l+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> mul==i2:</span><br><span class="line">                        newl = l</span><br><span class="line">                        newr = r</span><br><span class="line">                        <span class="keyword">while</span> l2[newl+<span class="number">1</span>]==l2[newl]:</span><br><span class="line">                            newl += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l2[newr<span class="number">-1</span>]==l2[newr]:</span><br><span class="line">                            newr -= <span class="number">1</span></span><br><span class="line">                        print(l, r, newl, newr)</span><br><span class="line">                        res += (newl-l+<span class="number">1</span>)*(r-newr+<span class="number">1</span>)</span><br><span class="line">                        <span class="comment"># print(res, (newl-l+1)*(r-newr+1))</span></span><br><span class="line">                        l, r = newl, newr<span class="number">-1</span></span><br><span class="line">                    <span class="keyword">elif</span> mul&gt;i2:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> mul&lt;i2:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> helper(nums1, nums2)+helper(nums2, nums1)</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, s: str, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> itertools.groupby(s):</span><br><span class="line">            l = len(list(v))</span><br><span class="line">            <span class="keyword">if</span> l&gt;<span class="number">1</span>:</span><br><span class="line">                res += sum(cost[i:i+l])-max(cost[i:i+l])</span><br><span class="line">            i += l</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/&quot;&gt;替换所有的问号&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/&quot;&gt;数的平方等于两数乘积的方法数&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/&quot;&gt;避免重复字母的最小删除成本&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/&quot;&gt;保证图可完全遍历&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/06/hqcnGTL9xymlZt6.png&quot; alt=&quot;image-20200906161557664&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>biweekly-contest-34</title>
    <link href="https://zronghui.github.io/biweekly-contest-34.html"/>
    <id>https://zronghui.github.io/biweekly-contest-34.html</id>
    <published>2020-09-05T15:56:45.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/matrix-diagonal-sum/">矩阵对角线元素的和</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/">分割字符串的方案数</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a><strong>5</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/count-all-possible-routes/">统计所有可行路径</a><strong>6</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSum</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(mat)</span><br><span class="line">        <span class="keyword">return</span> sum(mat[i][i] <span class="keyword">if</span> n<span class="number">-1</span>-i==i <span class="keyword">else</span> mat[i][i]+mat[i][n<span class="number">-1</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = sum(<span class="number">1</span> <span class="keyword">if</span> c==<span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> math.comb(len(s)<span class="number">-1</span>, <span class="number">2</span>)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        t = n//<span class="number">3</span></span><br><span class="line">        <span class="comment"># 找到 t t+1 的 1 的位置</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">'1'</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur==t:</span><br><span class="line">                    it = i</span><br><span class="line">                <span class="keyword">elif</span> cur==t+<span class="number">1</span>:</span><br><span class="line">                    it1 = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 倒着数 t t+1 1 的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(s))):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">'1'</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur==t:</span><br><span class="line">                    rit = i</span><br><span class="line">                <span class="keyword">elif</span> cur==t+<span class="number">1</span>:</span><br><span class="line">                    rit1 = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ((it1-it)*(rit-rit1))%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, insort</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 确定首部递增序列的尾部 l</span></span><br><span class="line">        <span class="keyword">while</span> l+<span class="number">1</span>&lt;n <span class="keyword">and</span> nums[l+<span class="number">1</span>]&gt;=nums[l]:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l==n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(l)</span></span><br><span class="line">        <span class="comment"># 2. 确定尾部递增序列的首部 minr</span></span><br><span class="line">        minr = r</span><br><span class="line">        <span class="keyword">while</span> minr<span class="number">-1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[minr]&gt;=nums[minr<span class="number">-1</span>]:</span><br><span class="line">            minr -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        res = min(n-l<span class="number">-1</span>, minr)</span><br><span class="line">        <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[l]&gt;nums[r]:</span><br><span class="line">                res = min(res, (r-l))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> r<span class="number">-1</span>&gt;=minr <span class="keyword">and</span> nums[r<span class="number">-1</span>]&gt;=nums[l]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                res = min(res, (r-l<span class="number">-1</span>))</span><br><span class="line">            <span class="comment"># print(l, r)</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countRoutes</span><span class="params">(self, nums: List[int], start: int, end: int, fuel: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s, e, f)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> f &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> (sum(helper(i, end, f-abs(nums[s]-nums[i])) <span class="keyword">if</span> i!=s <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>) + (<span class="number">1</span> <span class="keyword">if</span> s==end <span class="keyword">else</span> <span class="number">0</span>))%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(start, end, fuel)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-34/problems/matrix-diagonal-sum/&quot;&gt;矩阵对角线元素的和&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/&quot;&gt;分割字符串的方案数&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-34/problems/shortest-subarray-to-be-removed-to-make-array-sorted/&quot;&gt;删除最短的子数组使剩余数组有序&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-34/problems/count-all-possible-routes/&quot;&gt;统计所有可行路径&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>字节跳动面试准备</title>
    <link href="https://zronghui.github.io/other/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html"/>
    <id>https://zronghui.github.io/other/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html</id>
    <published>2020-09-03T15:44:37.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="**MySQL"></a>**MySQL</h3><p><a href="https://yfzjay.github.io/2020/02/19/%E7%B4%A2%E5%BC%95%E5%92%8Cb+%E6%A0%91.html#htmlup">b+/b/红黑树-&gt;索引和文件系统</a></p><p><a href="https://yfzjay.github.io/2020/04/01/Mysql%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B.html#htmlup">Mysql索引简介</a></p><h3 id="MySQL-事务的隔离级别"><a href="#MySQL-事务的隔离级别" class="headerlink" title="MySQL 事务的隔离级别"></a>MySQL 事务的隔离级别</h3><p><strong>一个正确的事务应该具备的 4 个特性</strong>：</p><p><em>ACID</em> (<em>atomicity, consistency, isolation, durability</em>) </p><p><a href="https://developer.aliyun.com/article/743691">彻底搞懂 MySQL 事务的隔离级别-阿里云开发者社区</a><br><a href="https://github.com/hongwen1993/all/blob/master/database/Isolation.md">all/Isolation.md at master · hongwen1993/all</a></p><p><strong>事务并发可能出现的三个问题</strong></p><p>1.脏读</p><p>一个事务读到了另一个未提交事务修改过的数据 （破坏了隔离性）</p><p>2.不可重复读</p><p>一个事务多次读取结果不相同，因为在这期间有其他事务 修改/删除 了符合条件的数据（破坏了一致性）</p><p>3.幻读</p><p>一个事务多次读取结果不同，因为在这期间有其他事务 插入 了符合条件的数据（破坏了一致性）</p><p><strong>四种事务的隔离级别</strong></p><p>1.read uncommitted</p><p>没有解决以上三个问题，可以读取到其他未提交事务的数据</p><p>2.read committed</p><p>只能读取其他已经提交事务的数据。解决了脏读的问题</p><p>3.repeatable read （MySQL default）</p><p>事务在 commit 之前，其他事务对数据库的修改对当前事务不可见（行锁）</p><p>4.serialable</p><p>2 个读取操作不会阻塞，其他的如读写、写写操作会阻塞（表锁）</p><p><strong>查看隔离级别</strong></p><p>select @@transaction_isolation</p><p>show variables like “transaction_isolation”</p><p><strong>设置隔离级别</strong></p><p>SET GLOBAL/SESSION TRANSACTION ISOLATION LEVEL level</p><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>第一范式 1Nf: 数据库的字段都是单一属性，不可再分</p><p>第二范式 2NF: 所有非关键字段都完全依赖于任意一组候选关键字（没有部分依赖）</p><p>第三范式 3NF: 在第二范式的基础上，不存在非关键字段对任一候选关键字段的传递函数依赖（没有传递依赖）</p><h3 id="小顶堆（TopK大）、大顶堆（BtmK小）"><a href="#小顶堆（TopK大）、大顶堆（BtmK小）" class="headerlink" title="小顶堆（TopK大）、大顶堆（BtmK小）"></a>小顶堆（TopK大）、大顶堆（BtmK小）</h3><p><a href="https://www.coder4.com/archives/3844">Python使用heapq实现小顶堆（TopK大）、大顶堆（BtmK小） | 四号程序员</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopkHeap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Push</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.data) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.data, elem)</span><br><span class="line">        <span class="keyword">elif</span> self.data[<span class="number">0</span>] &lt; elem:</span><br><span class="line">            heapq.heapreplace(self.data, elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TopK</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> list((heapq.heappop(self.data) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.k) <span class="keyword">if</span> self.data))[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    list_rand = random.sample(range(<span class="number">1000000</span>), <span class="number">100</span>)</span><br><span class="line">    th = TopkHeap(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list_rand:</span><br><span class="line">        th.Push(i)</span><br><span class="line">    print(th.TopK())</span><br><span class="line">    print(list(sorted(list_rand, reverse=<span class="literal">True</span>)[:<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>大顶堆的话, push pop 的时候取负值，就能将小顶堆转换成大顶堆</p><p>heapq.heappush(self.data, -elm)</p><p>-heapq.pop(self.data)</p><p>TODO：手写小顶堆</p><p><a href="https://zhuanlan.zhihu.com/p/105624690">Python实现堆排序及原理详解 + TopK面试题（多图解释） - 知乎</a></p><p><a href="https://leetcode-cn.com/tag/heap/">堆 - 力扣（LeetCode）</a></p><h2 id="tcp-udp"><a href="#tcp-udp" class="headerlink" title="tcp udp"></a>tcp udp</h2><p><strong>三次握手、四次挥手</strong></p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">两张动图-彻底明白TCP的三次握手与四次挥手_qzcsu的博客-CSDN博客</a></p><h3 id="三次握手的个人浅薄理解"><a href="#三次握手的个人浅薄理解" class="headerlink" title="三次握手的个人浅薄理解"></a>三次握手的个人浅薄理解</h3><p><strong>三次握手的目的</strong>：a b 收到对方 对自己发送的 isn 的确认</p><p>发送方(A)和确认方(B)需要确认 发送和接受 的通道正常后, 就可以开始发送数据</p><p>   1      2    3</p><p>A -&gt; B-&gt;A-&gt;B</p><p>1: SYN=1 seq=x (隐含 ACK=0)  (ISN随时间而变化)  (发出时 a 进入 syn_send 状态，到达时 b 进入 syn_revd 状态)</p><p>2: ACK=1  ack=x+1; SYN=1 seq=y  (到达 a 时，a 进入 established 状态)(是 ack=1 与 syn=1 seq=y 的合并，也是为什么没有采用四次握手的原因, 为了节省资源)</p><p>3: ACK=1 ack=y+1 seq=x+1 (由于 a 已经知道连接已经建立，所以从这个包开始a可以发送数据给 b 了，前 2 步握手不可以)</p><p>↑，可以看出，经过三次握手之后，A 知道 A的 发送(1 A-B)和接受(2 B-A) 都正常</p><p>(所以第三步握手时，已经可以携带数据了，因为 a 已经处于 established 状态)</p><p>B 也确认了发送(2 B-A)和接受(3 A-B)都正常，此时连接建立，可以开始传输数据</p><p>1: a 给 b 发送 isn(初始序列号，initial sequence number)</p><p>2: b给 a 发送 isn, 同时 a 确认b收到自己发送的 isn</p><p>3: b 确认 a 收到自己发的 isn </p><p><strong>为什么不是两次握手？</strong></p><p>两次握手是 aba  </p><p>引发的问题 1：b 不知道发给 a 的通道是否畅通</p><p>问题 2: 对 b(服务端) 来说，只要接收到a的连接请求，就立马进入 established 状态。若因网络迟滞导致 a 发送了 2 个连接请求，当 1 个连接关闭后，另一个连接才到达，此时 b 发送确认给 a后，b 再次进入established 状态，而 a 由于此时没有发送连接请求，则忽略 b 的确认。而 b 一直处于 established 状态，一直等待 a 传输数据或四次挥手关闭连接，极大浪费资源。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>客户端或服务端均可发起挥手</p><p>  1      2      3     4</p><p>a -&gt; b -&gt;  a </p><p>​                 -&gt; a -&gt; b</p><ol><li>FIN=1 seq=u (与握手不同， 这里的 seq =前面已经接受到的最后一个字节序号+1)</li><li>ACK=1 ack=u+1 seq=v</li><li>数据传输完，FIN=1 ACK=1 seq=w ack=u+1</li><li>ACK=1 ack=w+1</li></ol><p>4 中，客户端发送报文后，等待 2MSL(maximum segment lifetime 最长报文段)，后 close</p><p><strong>为什么要等待 2MSL</strong></p><p>可能步骤 4 的报文没有到达，b 由于过了一段时间没有收到确认，就会重新发送报文，然后 a 就可以在 2MSL 时间内重发确认，重新开始计时 2MSL。如果没有 2MSL，b 会一直重发报文，导致系统资源的浪费.</p><p><strong>半连接队列</strong></p><p>服务器端 处于 SYN_RCVD 状态的 tcp 请求会被放到一个队列中</p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html#syn%E6%94%BB%E5%87%BB"> SYN攻击 TCP 协议 · 笔试面试知识整理</a></p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>如何检测：当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击</p><p>如何防御：SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp keepalive"></a>tcp keepalive</h3><p>tcp 连接建立起来之后，若通信某一方掉线，另一方则一直处于等待状态。</p><p>keepalive 的原理是每隔一段时间给对方发送一个包，等待确认，如果超时后重发，重发超过一定次数后，判定连接无效，丢弃连接。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>序号、校验、确认、超时、重传</p><h3 id="流量控制-拥塞控制"><a href="#流量控制-拥塞控制" class="headerlink" title="流量控制 拥塞控制"></a>流量控制 拥塞控制</h3><p>流量控制：接收方在发送确认的时候在窗口字段设置发送方的滑动窗口()大小</p><p>拥塞控制：主要维护一个拥塞窗口(cwnd :Congestion window)的变量，而发送方实际的发送窗口大小为 min(接收窗口，拥塞窗口)</p><p>慢开始 拥塞避免 快重传 快恢复</p><p><strong>慢开始与拥塞避免</strong>：1 2 4 8 12 13 14</p><p> (慢开始门限 slow start threshold )ssthresh=12 </p><p>用Python 写了个模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> timeout:</span><br><span class="line">        <span class="keyword">if</span> cwnd&lt;ssthresh:</span><br><span class="line">            <span class="comment"># 慢开始</span></span><br><span class="line">        ​    cwnd = min(<span class="number">2</span>*cwnd, ssthresh)  <span class="comment"># 如 1 2 4 8 12</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 拥塞避免</span></span><br><span class="line">            cwnd = ssthresh+<span class="number">1</span></span><br><span class="line">            ssthresh += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cwnd = <span class="number">1</span></span><br><span class="line">        ssthresh //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这张图示意的很棒：</p><p><img src="https://i.loli.net/2020/09/04/4gJqGDRUdLBYlEc.png" alt="img"></p><p><strong>快重传与快恢复</strong></p><p>发送方收到 3 个重复确认，可以知道下个报文丢失。立即重传下一个报文（快重传）</p><p>同时，cwnd = ssthresh = cwnd//2 (快恢复（因为只是丢失，而不是网络拥塞）)，直接进入拥塞避免状态</p><p>参考</p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">两张动图-彻底明白TCP的三次握手与四次挥手_qzcsu的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/24853633">(9 封私信 / 46 条消息) TCP 为什么是三次握手，而不是两次或四次？ - 知乎</a><br><a href="https://developer.aliyun.com/article/742739">阿里面试官： HTTP、HTTPS、TCP/IP、Socket通信、三次握手四次挥手过程？（附全网最具深度的三次握手、四次挥手讲解）-阿里云开发者社区</a><br><a href="https://my.oschina.net/u/4385759/blog/3235018">如何回答TCP三次握手和四次挥手 含大量面试题 - osc_l8yszczz的个人空间 - OSCHINA</a></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p><strong>划分:</strong>网络号+主机号(子网号+主机号)</p><p><strong>子网掩码 IP 子网号</strong></p><p>子网掩码的意义就在于求子网号，告诉你子网号是 IP 号的前n位 所以子网掩码的前 n 位都是 1，后面 32-n 位是 0</p><p>a -&gt; b, 此时可以用来判断b 是否与 a 在同一个子网中</p><p><a href="https://www.jianshu.com/p/1d900d1c4d45">计算机网络如何计算子网掩码 - 简书</a></p><h3 id="地址解析协议-ARP-https-cyc2018-github-io-CS-Notes-notes-计算机网络-网络层-id-地址解析协议-arp"><a href="#地址解析协议-ARP-https-cyc2018-github-io-CS-Notes-notes-计算机网络-网络层-id-地址解析协议-arp" class="headerlink" title="[地址解析协议 ARP](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 网络层?id=地址解析协议-arp)"></a>[地址解析协议 ARP](<a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络">https://cyc2018.github.io/CS-Notes/#/notes/计算机网络</a> - 网络层?id=地址解析协议-arp)</h3><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p>每个主机都有 ARP 高速缓存，里面有<strong>本局域网</strong>的各个主机和路由器的 ip-&gt;mac 映射表</p><h3 id="网络地址转换-NAT-https-cyc2018-github-io-CS-Notes-notes-计算机网络-网络层-id-网络地址转换-nat"><a href="#网络地址转换-NAT-https-cyc2018-github-io-CS-Notes-notes-计算机网络-网络层-id-网络地址转换-nat" class="headerlink" title="[网络地址转换 NAT](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 网络层?id=网络地址转换-nat)"></a>[网络地址转换 NAT](<a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络">https://cyc2018.github.io/CS-Notes/#/notes/计算机网络</a> - 网络层?id=网络地址转换-nat)</h3><p>将本地 IP 与全球 IP 一一对应（用上了端口号）</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><h3 id="Web-页面请求过程-https-cyc2018-github-io-CS-Notes-notes-计算机网络-应用层-id-web-页面请求过程"><a href="#Web-页面请求过程-https-cyc2018-github-io-CS-Notes-notes-计算机网络-应用层-id-web-页面请求过程" class="headerlink" title="[Web 页面请求过程](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络 - 应用层?id=web-页面请求过程)"></a>[Web 页面请求过程](<a href="https://cyc2018.github.io/CS-Notes/#/notes/计算机网络">https://cyc2018.github.io/CS-Notes/#/notes/计算机网络</a> - 应用层?id=web-页面请求过程)</h3><p><a href="https://juejin.im/post/6844903809576239118#heading-8">【面试】Web 页面请求历程 - 掘金</a></p><p><strong>1.DHCP</strong></p><p>如果主机开始没有 IP 地址，那么先通过 DHCP 获取。</p><p>主机生成 DHCP 请求报文，放入 UDP 报文段中。再放入广播的 IP 数据报(0.0.0.0-&gt;255.255.255.255)，再放入以太网帧中（目的 MAC 地址 FF:FF:FF:FF:FF:FF)</p><p>连接在交换机的 DHCP 服务器收到广播帧后，向上分解得到 DHCP 请求报文，后生成 DHCP ACK 报文（包括 IP 地址、DNS 服务器的 IP 地址、路由器的 IP地址和子网掩码），放入 MAC 帧中（目的地址就是主机的 MAC 地址）（交换机由于可以自学习，就记下 该主机 MAC-&gt; 接口 的映射）</p><p>主机配置 IP地址、DNS 服务器地址、路由器 IP、子网掩码</p><img src="https://i.loli.net/2020/09/04/Ohsg26o7CwmtjFx.png" alt="image-20200904210215691" style="zoom: 25%;" /><p><strong>2.ARP 解析 MAC 地址</strong></p><p>↑DHCP 中想要发送给网关路由器的以太网帧的目的 MAC 地址是 FF:FF:FF:FF:FF:FF , DHCP 请求结束了还不知道。所以需要ARP 获得网关路由器的 MAC 地址。</p><p>主机生成 ARP 请求报文，封装成广播目的地址(FF:FF:FF:FF:FF:FF)的以太网帧 给交换机，交换机收到后，转发给所有连接的设备，包括网关路由器。</p><p>路由器收到该帧后，发送 ARP 响应报文给主机。</p><p>主机收到后就能解析出路由器的 MAC 地址</p><p><strong>3.DNS 解析域名</strong></p><p>DNS 是为了将目标域名解析为 IP 地址</p><p> 主机发送 DNS 查询报文给网关路由器，路由器转发给本地 DNS 服务器，递归查询目标域名的 IP 地址。（根域名.-&gt; 顶级域名 如 com-&gt; …）</p><p><strong>DNS 优化</strong>: 多级缓存，浏览器缓存、系统缓存、路由器缓存、IPS 服务器缓存、根域名缓存、顶级域名服务器缓存、主域名服务器缓存</p><p><strong>4.TCP 三次握手</strong></p><p><strong>5.HTTP 请求</strong></p><p><strong>6.浏览器解析渲染页面</strong></p><p><strong>7.TCP 四次挥手</strong></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%951">CS-Notes</a></p><p><a href="https://segmentfault.com/a/1190000021250088">Python协程与Go协程的区别二 - 个人文章 - SegmentFault 思否</a></p><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><p>管道：速度慢，只有父子进程能通讯</p><p>FIFO：（命名管道）任何进程间都能通讯，但是速度慢</p><p>消息队列：</p><p>信号量：一个计数器，不能传递复杂消息，只能用来同步</p><p>共享存储：通过将共同的一份文件映射到进程拥有的内存中，实现共享内存</p><p>socket 通信：可用于不同机器之间的进程通信</p><p><strong>python 提供 2 中进程间通信的机制：</strong></p><p>Queue 和 Pipe: 如 multiprocessing.Queue() multiprocessing.Pipe()</p><p><strong>python go 协程的区别：</strong></p><p>协程是用户管理线程运行顺序</p><p>go 中的 goroutine 是由go 控制</p><p>python 中的协程： yield 、yield from、 asyncio、 gevent</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><a href="https://blog.csdn.net/ThinkWon/article/details/103522351">Redis面试题（2020最新版）_ThinkWon的博客-CSDN博客</a></p><p><a href="https://juejin.im/post/6844904033589657607">Redis zset实现原理 - 掘金</a></p><p>skiplist</p><p><a href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项 - 知乎</a></p><h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p>考的底层和集群经验，告辞。</p><p><a href="https://juejin.im/post/6844904031555420167">2019年常见ElasticSearch 面试题解析（上） - 掘金</a></p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode）</a></li></ul><p>(这道题总体来说并不难,但是面试官在中间穿插了垃圾回收的知识,这就很难受了,具体的就是大家要判断一下对象在什么时候会回收,可达性分析什么时候对这个对象来说是不可达的,还有在递归函数中内存如何变化,这个是让我们来对这个函数进行执行过程的建模,只看栈帧大小变化的话,应该有是两个峰值,中间会有抖动的情况)</p><ul><li><input checked="" disabled="" type="checkbox"> 给定target和一个升序的数组,寻找下一个比target大的数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_bigger</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> nums[<span class="number">-1</span>]&lt;=target: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">        m = (l+r)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m]&lt;=target:</span><br><span class="line">            l = m+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m]&gt;target:</span><br><span class="line">            r = m</span><br><span class="line">        <span class="keyword">if</span> nums[l]&gt;target: <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">else</span>: l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(next_bigger([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>))</span><br><span class="line">print(bisect.bisect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>一二道是连在一起的.给定一个规则S_0 = {1} S_1={1,2,1} S_2 = {1,2,1,3,1,2,1} S_n = {S_n-1 , n + 1, S_n-1}.第一个问题是他们的个数有什么关系(1 3 7 15… 2 的 n 次方-1,用位运算解决).第二个问题是给定数组个数下标 n 和索引 k,让我们求出 S_n(k)所指的数,假如S_2(2) = 1,我在做的时候没有什么好的思路,如果有的话大家可以分享一下</p><p>??? 题目都没看懂</p><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next permutation"></a>next permutation</h3><p><a href="https://leetcode-cn.com/problems/next-permutation">https://leetcode-cn.com/problems/next-permutation</a></p><p>2 1 3 2 1</p><p>找后缀的非递增序列，321 前面的 1 与后面最后一个比 1 大的数(2)交换，然后后面 3 位(311)排序就好</p><p>21321-&gt; 22311 -&gt; 22113</p><p>helper1 用二分快些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>: <span class="keyword">return</span> nums</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="comment"># return i: i ~ -1 是非递增序列</span></span><br><span class="line">            <span class="comment"># 如 1 3 2 2 return 3的index 1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(nums)<span class="number">-1</span>)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2 1 3 2 1</span></span><br><span class="line">        <span class="comment"># [2]+[2]+[1,1,3]</span></span><br><span class="line">        i = helper()</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 找到第一个比 1 大的数字索引</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;=nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> j<span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">        t = helper1(i)</span><br><span class="line">        nums[i<span class="number">-1</span>], nums[t] = nums[t], nums[i<span class="number">-1</span>]</span><br><span class="line">        nums[i:] = sorted(nums[i:])</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> <p>最近公共祖先</p></li><li><input checked="" disabled="" type="checkbox"> <p>回行矩阵遍历</p><p>非递归先序遍历、中序、后续</p></li></ul><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                stack.extend([cur.right, cur.left])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></li></ul><p>后续难一点</p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-die-dai-fa-by-da-da-m/">二叉树的后序遍历（迭代法） - 二叉树的后序遍历 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left <span class="keyword">if</span> cur.left <span class="keyword">else</span> cur.right</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].left==cur:</span><br><span class="line">                cur = stack[<span class="number">-1</span>].right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>自己觉得需要掌握的：</p><p>常见排序算法</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>问输入<a href="http://www.qq.com然后按下回车，浏览器作为客户端会发生什么？">www.qq.com然后按下回车，浏览器作为客户端会发生什么？</a></p><p>浏览器的DNS缓存 -&gt; 操作系统的DNS缓存 -&gt; host文件 -&gt; 本地DNS解析服务器，TCP三次握手 -&gt; http传输数据 -&gt; html文件、css文件渲染</p><p>第二次输入<a href="http://www.qq.com，和第一次有什么不同？">www.qq.com，和第一次有什么不同？</a></p><p>DNS缓存、http/1.0下长链接复用、静态文件缓存、携带cookie</p><p>四次挥手中TIME_WAIT状态存在的目的是什么</p><p>TCP是通过什么机制保障可靠性的？（从四个方面进行回答，ACK确认机制、超时重传、滑动窗口以及流量控制，深入的话要求详细讲出流量控制的机制。）</p><p>描述线程、进程以及协程的区别？ </p><p> 5、GO语言中的协程与Python中的协程的区别？ </p><p> 6、网络IO模型有哪些？（5种网络I/O模型，阻塞、非阻塞、I/O多路复用、信号驱动IO、异步I/O） </p><p> 7、I/O多路复用中select/poll/epoll的区别？ </p><p> 8、客户端访问url到服务器，整个过程会经历哪些？ </p><p> 9、描述HTTPS和HTTP的区别。 </p><p> 10、HTTP协议的请求报文和响应报文格式。 </p><p> 11、HTTP的状态码有哪些？ </p><p> 12、描述一下redis有哪些数据结构。（基础的数据结构有5种，String/List/Hash/Set/Zset；高级数据结构有：HyperLogLog/BitMap/BloomFilter/GeoHash） </p><p> 13、面试官还问了BloomFilter的原理以及Zset的实现原理。 </p><p> 14、MySQL场景题目（面试官提供场景，要求写出查询SQL，考察联合语句，如何分页以及复杂语句的优化） </p><p>描述HTTP的版本之间的区别，主要是1.0/1.1/2.0三个版本的区别</p><p>TCP怎么做流量控制？</p><p>脑筋急转弯：1到10层电梯，每层电梯门口有1颗钻石，从1楼坐电梯到10楼，只能拿一次，怎么拿才能拿到最大的钻石？</p><p><a href="https://www.zhihu.com/question/20641620">1楼到n楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从1楼到n楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到「最大」的一颗？ - 知乎</a></p><p>10 颗钻石大小都是随机的话：</p><p>概率解决：先放弃前 37%（就是1/e）的钻石，此后选择比前 37% 都大的第一颗钻石。</p><p>以前面3个最大的那个为基准，4-10楼里面看到比这个大的就可以取了，没有取第 10 颗</p><p><strong>可能会考的</strong></p><p>描述Elasticsearch的一些架构原理，比如倒排索引的原理。</p><p>Redis问数据结构，延时队列如何实现，分布式锁原理。</p><p>发送窗口、接收窗口、拥塞窗口三者的关系</p><p>拥塞窗口的变化规律</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://zronghui.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>三次握手四次挥手</title>
    <link href="https://zronghui.github.io/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"/>
    <id>https://zronghui.github.io/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html</id>
    <published>2020-09-03T11:40:40.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-204</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-204.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-204.html</id>
    <published>2020-08-30T03:20:41.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/">重复至少 K 次且长度为 M 的模式</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">乘积为正数的最长子数组长度</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island/">使陆地分离的最少天数</a><strong>6</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/">将子数组重新排序得到同一个二叉查找树的方案数</a><strong>7</strong></li></ul><p><img src="https://i.loli.net/2020/08/30/qUCh3Zd6VfxJsAj.png" alt="image-20200830181438578"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsPattern</span><span class="params">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr)&lt;m*k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(k):</span><br><span class="line">                    <span class="keyword">if</span> arr[i+x+y*m]!=arr[i+x]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)-m*k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> helper(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>超时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLen</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> max(self.getMaxLen(nums[:i]), self.getMaxLen(nums[i+<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = [] <span class="comment"># 左侧的负数个数</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            l.append(cur)</span><br><span class="line">        <span class="comment"># 最后一位是偶数：数组本身乘积就是正数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l[<span class="number">-1</span>]&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(l)</span><br><span class="line">        <span class="comment"># l 中 找到第一个 奇数（1）； 最后一个偶数（l[-1]-1）</span></span><br><span class="line">        firstOdd = lastEven = <span class="number">-1</span></span><br><span class="line">        <span class="comment"># firstEven = -1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            <span class="comment"># if l[i]==0:</span></span><br><span class="line">            <span class="comment">#     firstEven = i</span></span><br><span class="line">            <span class="keyword">if</span> l[i]==<span class="number">1</span>:</span><br><span class="line">                firstOdd = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(l))):</span><br><span class="line">            <span class="keyword">if</span> l[i]==l[<span class="number">-1</span>]<span class="number">-1</span>:</span><br><span class="line">                lastEven = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        res = max(lastEven+<span class="number">1</span>, len(l)<span class="number">-1</span>-firstOdd)</span><br><span class="line">        <span class="comment"># print(l, lastEven, firstOdd, lastEven-firstEven, len(l)-1-firstOdd)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>优化1: </p><p>仍然超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLen</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> max(self.getMaxLen(nums[:i]), self.getMaxLen(nums[i+<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># l = [] # 左侧的负数个数</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="comment"># l 中 找到第一个 奇数（1）； 最后一个偶数（l[-1]-1）</span></span><br><span class="line">        firstOdd = lastEven = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur==<span class="number">1</span> <span class="keyword">and</span> firstOdd==<span class="number">-1</span>:</span><br><span class="line">                firstOdd = index</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur&amp;<span class="number">1</span>:</span><br><span class="line">                lastEven = index</span><br><span class="line">            <span class="comment"># l.append(cur)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        </span><br><span class="line">        res = max(lastEven+<span class="number">1</span>, len(nums)<span class="number">-1</span>-firstOdd)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>优化 2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLen</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.append(<span class="number">0</span>)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        firstOdd = lastEven = <span class="number">-1</span></span><br><span class="line">        lastZero = <span class="number">-1</span> <span class="comment"># 上一个 0 的位置</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur&amp;<span class="number">1</span>:</span><br><span class="line">                    res = max(res, index<span class="number">-1</span>-lastZero)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = max(res, lastEven-lastZero, index<span class="number">-1</span>-firstOdd)</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">                lastZero = firstOdd = lastEven = index</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur==<span class="number">1</span> <span class="keyword">and</span> firstOdd==lastZero:</span><br><span class="line">                firstOdd = index</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur&amp;<span class="number">1</span>:</span><br><span class="line">                lastEven = index</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/&quot;&gt;重复至少 K 次且长度为 M 的模式&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/&quot;&gt;乘积为正数的最长子数组长度&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island/&quot;&gt;使陆地分离的最少天数&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/&quot;&gt;将子数组重新排序得到同一个二叉查找树的方案数&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/30/qUCh3Zd6VfxJsAj.png&quot; alt=&quot;image-20200830181438578&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-189</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-189.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-189.html</id>
    <published>2020-08-29T03:43:43.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, A: List[int], B: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(<span class="number">1</span> <span class="keyword">if</span> a&lt;=k&lt;=b <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(A, B))</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrangeWords</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        text = text[<span class="number">0</span>].lower()+text[<span class="number">1</span>:]</span><br><span class="line">        words = text.split()</span><br><span class="line">        words.sort(key=len)</span><br><span class="line">        res = <span class="string">' '</span>.join(words)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>].upper()+res[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peopleIndexes</span><span class="params">(self, fcs: List[List[str]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 数据规模不大，意味着暴力</span></span><br><span class="line">        <span class="comment"># 稍微优化一下</span></span><br><span class="line">        <span class="comment"># fcs 内每个元素按照 长度+字典序 排列</span></span><br><span class="line">        <span class="comment"># 然后判断一个列表是不是另一个列表的子列表时，用双指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> fcs:</span><br><span class="line">            i.sort(key=<span class="keyword">lambda</span> i: (-len(i), i))</span><br><span class="line">        <span class="comment"># 添加原序号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(fcs)):</span><br><span class="line">            fcs[i].append(i)</span><br><span class="line">        <span class="comment"># fcs 按列表元素长度排序</span></span><br><span class="line">        fcs.sort(key=len, reverse=<span class="literal">True</span>)</span><br><span class="line">        print(fcs)</span><br><span class="line">        res = [fcs[<span class="number">0</span>][<span class="number">-1</span>]]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSubList</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># j issublist of i</span></span><br><span class="line">            p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> p1&lt;len(i)<span class="number">-1</span> <span class="keyword">and</span> p2&lt;len(j)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> i[p1]==j[p2]:</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(i[p1])&lt;len(j[p2]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p2==len(j)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> fcs:</span><br><span class="line">                <span class="keyword">if</span> len(j)&lt;=len(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> isSubList(j, i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> fcs[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(i):</span><br><span class="line">                res.append(i[<span class="number">-1</span>])</span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>人家就直接用 set 做。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peopleIndexes</span><span class="params">(self, favoriteCompanies)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(favoriteCompanies) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(favoriteCompanies)):</span><br><span class="line">            <span class="comment"># 判断 列表i 是否为其他列表的子集，非则记录下标，是则无操作</span></span><br><span class="line">            isFlag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(favoriteCompanies)):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> set(favoriteCompanies[i]).issubset(favoriteCompanies[j]):</span><br><span class="line">                    <span class="comment"># 如果为其他人子集，则停止</span></span><br><span class="line">                    isFlag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isFlag:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>毕设/基于艾宾浩斯遗忘曲线的在线学习网站</title>
    <link href="https://zronghui.github.io/%E6%AF%95%E8%AE%BE/%E5%9F%BA%E4%BA%8E%E8%89%BE%E5%AE%BE%E6%B5%A9%E6%96%AF%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99.html"/>
    <id>https://zronghui.github.io/%E6%AF%95%E8%AE%BE/%E5%9F%BA%E4%BA%8E%E8%89%BE%E5%AE%BE%E6%B5%A9%E6%96%AF%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99.html</id>
    <published>2020-08-27T12:44:38.000Z</published>
    <updated>2020-08-28T12:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于艾宾浩斯遗忘曲线的在线学习平台"><a href="#基于艾宾浩斯遗忘曲线的在线学习平台" class="headerlink" title="基于艾宾浩斯遗忘曲线的在线学习平台"></a>基于艾宾浩斯遗忘曲线的在线学习平台</h2><hr><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>开发一个web端的学习平台，合理安排学习内容与复习计划，从而科学的规划学习内容，达到高效的记忆的目的。</p><hr><h2 id="同类软件调研"><a href="#同类软件调研" class="headerlink" title="同类软件调研"></a>同类软件调研</h2><p>ios: memory helper</p><p>win: anki</p><hr><h2 id="有什么功能"><a href="#有什么功能" class="headerlink" title="有什么功能"></a>有什么功能</h2><hr><p>1.创建新的记忆卡片集，设置 private 或 public、设置间隔大小等级（越小复习的越频繁），分别设置每日学习新卡片与旧卡片的数目</p><hr><p>2.添加记忆卡片，选择卡片类型（问答型、实践型）（一个有答案，一个没答案），编辑卡片，支持长传图片</p><hr><p>3.响应式设计，匹配各个终端，随时随地进行学习</p><hr><p>4.多用户(用户注册登录) ；private 的记忆卡片集的分享(分享给用户)；</p><p>用户可以从社区 public 的记忆卡片集 或者其他用户分享的 private 的记忆卡片集  fork 一份</p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p> springboot mvc框架<br>+SpringSecurity 认证和授权框架<br>+Mybatis ORM框架<br>+Elasticsearch    搜索引擎<br>+RabbitMQ    消息队列<br>+Redis    分布式缓存<br>+MongoDB    NoSql数据库<br>+Docker    应用容器引擎</p><hr><p>+JWT JWT登录支持<br>+LogStash 日志收集工具<br>+OSS 对象存储<br>+Jenkins    自动化部署</p><p>1 是把机器学习 或者 nlp 那一套加入我的系统，2 是做很多个 feature，很复杂的那种</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于艾宾浩斯遗忘曲线的在线学习平台&quot;&gt;&lt;a href=&quot;#基于艾宾浩斯遗忘曲线的在线学习平台&quot; class=&quot;headerlink&quot; title=&quot;基于艾宾浩斯遗忘曲线的在线学习平台&quot;&gt;&lt;/a&gt;基于艾宾浩斯遗忘曲线的在线学习平台&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 332. Reconstruct Itinerary</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-3**/leetcode-332-Reconstruct-Itinerary.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-3**/leetcode-332-Reconstruct-Itinerary.html</id>
    <published>2020-08-27T12:00:07.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reconstruct-itinerary/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/reconstruct-itinerary/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a list of airline tickets represented by pairs of departure and arrival<br>airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets<br>belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with<br><code>JFK</code>.</p><p><strong>Note:</strong></p><ol><li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li><li>All airports are represented by three capital letters (IATA code).</li><li>You may assume all tickets form at least one valid itinerary.</li></ol><p><strong>Example 1:</strong></p><pre><code>Input:[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output:[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code></pre><p><strong>Example 2:</strong></p><pre><code>Input:[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output:[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].             But it is larger in lexical order.</code></pre><p><strong>Tags:</strong> Depth-first Search, Graph</p><p><strong>Difficulty:</strong> Medium</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从起点出发，进行深度优先搜索。</span></span><br><span class="line"><span class="comment"># 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</span></span><br><span class="line"><span class="comment"># 如果没有可移动的路径，则将所在节点加入到栈中，并返回。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> tickets:</span><br><span class="line">            graph[a].append(b)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph:</span><br><span class="line">            graph[i].sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> graph[i]:</span><br><span class="line">                search(graph[i].pop())</span><br><span class="line">            res.append(i)</span><br><span class="line">        search(<span class="string">'JFK'</span>)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-itinerary/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/reconstruct-itinerary/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Given a list of airline tickets represented by pairs of departure and arrival&lt;br&gt;airports &lt;code&gt;[from, to]&lt;/code&gt;, reconstruct the itinerary in order. All of the tickets&lt;br&gt;belong to a man who departs from &lt;code&gt;JFK&lt;/code&gt;. Thus, the itinerary must begin with&lt;br&gt;&lt;code&gt;JFK&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary &lt;code&gt;[&amp;quot;JFK&amp;quot;, &amp;quot;LGA&amp;quot;]&lt;/code&gt; has a smaller lexical order than &lt;code&gt;[&amp;quot;JFK&amp;quot;, &amp;quot;LGB&amp;quot;]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;All airports are represented by three capital letters (IATA code).&lt;/li&gt;
&lt;li&gt;You may assume all tickets form at least one valid itinerary.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:[[&amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;], [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;], [&amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;], [&amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;]]
Output:[&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:[[&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;],[&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]]
Output:[&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]
Explanation: Another possible reconstruction is [&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;].
             But it is larger in lexical order.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Depth-first Search, Graph&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Medium&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-3**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-3/"/>
    
    
      <category term="Depth-first Search" scheme="https://zronghui.github.io/tags/Depth-first-Search/"/>
    
      <category term="Graph" scheme="https://zronghui.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>POETRY 学习和使用</title>
    <link href="https://zronghui.github.io/python/POETRY-%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>https://zronghui.github.io/python/POETRY-%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html</id>
    <published>2020-08-26T01:52:11.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>原文地址 [testerhome.com](<a href="https://testerhome.com/topics/20929">https://testerhome.com/topics/20929</a>)</p><h2 id="Poetry-是啥？"><a href="#Poetry-是啥？" class="headerlink" title="Poetry 是啥？"></a>Poetry 是啥？</h2><p>是一个 Python 虚拟环境和依赖管理工具，另外它还提供了包管理功能，比如打包和发布。<br>可以用来管理 python 库和 python 程序。</p><h2 id="安装-Poetry"><a href="#安装-Poetry" class="headerlink" title="安装 Poetry"></a>安装 Poetry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;sdispater&#x2F;poetry&#x2F;master&#x2F;get-poetry.py | python3</span><br></pre></td></tr></table></figure><h2 id="使用-pip-安装"><a href="#使用-pip-安装" class="headerlink" title="使用 pip 安装"></a>使用 pip 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --user poetry</span><br></pre></td></tr></table></figure><h2 id="确认是否安装成功以及查看版本号"><a href="#确认是否安装成功以及查看版本号" class="headerlink" title="确认是否安装成功以及查看版本号"></a>确认是否安装成功以及查看版本号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></table></figure><h2 id="在-python-项目中使用-Poetry"><a href="#在-python-项目中使用-Poetry" class="headerlink" title="在 python 项目中使用 Poetry"></a>在 python 项目中使用 Poetry</h2><h3 id="在现有项目中使用："><a href="#在现有项目中使用：" class="headerlink" title="在现有项目中使用："></a>在现有项目中使用：</h3><p>如果是在已有项目中使用 poetry，你只需要执行一下命令来创建一个 pyproject.toml 文件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure><h3 id="使用-poetry-创建一个新项目："><a href="#使用-poetry-创建一个新项目：" class="headerlink" title="使用 poetry 创建一个新项目："></a>使用 poetry 创建一个新项目：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry new project\_name (项目名字）</span><br></pre></td></tr></table></figure><h4 id="项目结构如下图："><a href="#项目结构如下图：" class="headerlink" title="项目结构如下图："></a>项目结构如下图：</h4><p><a href="https://testerhome.com/uploads/photo/2019/f80f2f6e-a54c-40e4-8981-742f8f9f0db1.png!large"><img src="https://testerhome.com/uploads/photo/2019/f80f2f6e-a54c-40e4-8981-742f8f9f0db1.png!large" alt=""></a></p><h3 id="结构介绍"><a href="#结构介绍" class="headerlink" title="结构介绍"></a>结构介绍</h3><ul><li>*<em>pyproject.toml *</em>: 使用此文件管理依赖列表和项目的各种 meta 信息，用来替代 Pipfile、requirements.txt、setup.py、setup.cfg、MANIFEST.in 等等各种配置文件。</li></ul><h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><p>Tips: 确保当前目录存在 pyproject.toml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install</span><br></pre></td></tr></table></figure><p>这个命令会读取 pyproject.toml 中的所有依赖并安装（包括开发依赖），如果不想安装开发依赖可以附加：–no-dev 选项。如果项目根目录有 poetry.lock 文件，会安装这个文件中列出的锁定版本的依赖。如果执行 add/remove 命令的时候没有检测到虚拟环境，也会为当前目录自动创建虚拟</p><h2 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure><h2 id="查看-python-版本"><a href="#查看-python-版本" class="headerlink" title="查看 python 版本"></a>查看 python 版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run python -V</span><br></pre></td></tr></table></figure><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run python app.py</span><br></pre></td></tr></table></figure><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add flask</span><br></pre></td></tr></table></figure><p>_添加 –dev 参数为开发依赖_：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add pytest --dev</span><br></pre></td></tr></table></figure><h2 id="追踪-amp-更新包"><a href="#追踪-amp-更新包" class="headerlink" title="追踪 &amp; 更新包"></a>追踪 &amp; 更新包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry show</span><br></pre></td></tr></table></figure><p>_添加 –tree 参数选项可以查看依赖关系_：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry show --tree</span><br></pre></td></tr></table></figure><p>_查看可以更新的依赖_：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry show --outdated</span><br></pre></td></tr></table></figure><h3 id="更新所有锁定版本的依赖："><a href="#更新所有锁定版本的依赖：" class="headerlink" title="更新所有锁定版本的依赖："></a>更新所有锁定版本的依赖：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry update</span><br></pre></td></tr></table></figure><h3 id="更新某个指定的依赖："><a href="#更新某个指定的依赖：" class="headerlink" title="更新某个指定的依赖："></a>更新某个指定的依赖：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry update dep\_name (依赖名字）</span><br></pre></td></tr></table></figure><h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry remove dep\_name</span><br></pre></td></tr></table></figure><h2 id="让-poetry-使用-python3"><a href="#让-poetry-使用-python3" class="headerlink" title="让 poetry 使用 python3"></a>让 poetry 使用 python3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env use python3.7</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/sdispater/poetry/issues/655">Poetry using the wrong Python version (not related to pyenv) #655</a></li></ul><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1, 推荐使用 python3</p><p>2, poetry 版本很重要，最好使用最新版本</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zronghui.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E9%93%BE%E8%A1%A8.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E9%93%BE%E8%A1%A8.html</id>
    <published>2020-08-24T07:35:15.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="430-扁平化多级双向链表-力扣（LeetCode）"><a href="#430-扁平化多级双向链表-力扣（LeetCode）" class="headerlink" title="430. 扁平化多级双向链表 - 力扣（LeetCode）"></a>430. 扁平化多级双向链表 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表 - 力扣（LeetCode）</a></p><p>就是递归</p><p>如果有child, 把 child flatten , 放到 head 后面, 把 next flatten，还要把 child 置为 0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, prev, next, child):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.prev = prev</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.child = child</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.child:</span><br><span class="line">            self.flatten(head.next)</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        nxt = self.flatten(head.next)</span><br><span class="line">        self.flatten(head.child)</span><br><span class="line">        tail = head.child</span><br><span class="line">        <span class="keyword">while</span> tail.next:</span><br><span class="line">            tail = tail.next</span><br><span class="line">        head.next = head.child</span><br><span class="line">        head.child.prev = head</span><br><span class="line">        head.child = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> nxt:</span><br><span class="line">            tail.next = nxt</span><br><span class="line">            nxt.prev = tail</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="445-两数相加-II-力扣（LeetCode）"><a href="#445-两数相加-II-力扣（LeetCode）" class="headerlink" title="445. 两数相加 II - 力扣（LeetCode）"></a>445. 两数相加 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/">445. 两数相加 II - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getNum</span><span class="params">(head)</span>:</span></span><br><span class="line">            s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                s += str(head.val)</span><br><span class="line">                head = head.next</span><br><span class="line">            <span class="keyword">return</span> int(s)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildListNode</span><span class="params">(n)</span>:</span></span><br><span class="line">            s = str(n)</span><br><span class="line">            cur = dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                cur.next = ListNode(c)</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        a, b = map(getNum, [l1, l2])</span><br><span class="line">        <span class="keyword">return</span> buildListNode(a+b)</span><br></pre></td></tr></table></figure><h3 id="707-设计链表-力扣（LeetCode）"><a href="#707-设计链表-力扣（LeetCode）" class="headerlink" title="707. 设计链表 - 力扣（LeetCode）"></a>707. 设计链表 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/design-linked-list/submissions/">707. 设计链表 - 力扣（LeetCode）</a></p><p>尾指针+单链表</p><p>拼的是细节。需要另写一个 LinkList 类， 需要 dummyNode，函数复用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.dummy = LinkList(<span class="number">0</span>)</span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.dummy.next</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            l.append(str(cur.val))</span><br><span class="line">            cur = cur.next</span><br><span class="line">        l.append(<span class="string">'None'</span>)</span><br><span class="line">        print(<span class="string">'-&gt;'</span>.join(l))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNode</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cur = self.dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(index+<span class="number">1</span>):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># print('getNode', cur.val)</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=index&lt;self.size: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.getNode(index).val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = self.dummy.next</span><br><span class="line">        newHead = LinkList(val)</span><br><span class="line">        self.dummy.next = newHead</span><br><span class="line">        newHead.next = head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            self.tail = newHead</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.print()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.tail:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newTail = LinkList(val)</span><br><span class="line">            self.tail.next = newTail</span><br><span class="line">            self.tail = newTail</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.print()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span><span class="params">(self, index: int, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> index&lt;<span class="number">0</span>: </span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">elif</span> index&lt;self.size:</span><br><span class="line">            node = self.getNode(index<span class="number">-1</span>)</span><br><span class="line">            newNext = LinkList(val)</span><br><span class="line">            nxt = node.next</span><br><span class="line">            node.next = newNext</span><br><span class="line">            newNext.next = nxt</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> index==self.size:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="comment"># self.print()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span><span class="params">(self, index: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=index&lt;self.size:</span><br><span class="line">            node = self.getNode(index<span class="number">-1</span>)</span><br><span class="line">            nxt = node.next</span><br><span class="line">            node.next = nxt.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.next:</span><br><span class="line">                self.tail = node</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.print()</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/submissions/">725. 分隔链表 - 力扣（LeetCode）</a></p><p>思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = divmod(length, k)</span><br><span class="line"><span class="comment"># 前 b 个数 a+1 个 node</span></span><br><span class="line"><span class="comment"># 后面的数字， a 个 node</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span><span class="params">(self, root: ListNode, k: int)</span> -&gt; List[ListNode]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getLen</span><span class="params">(root)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                root = root.next</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        length = getLen(root)</span><br><span class="line">        a, b = divmod(length, k)</span><br><span class="line">        <span class="comment"># 前 b 个数 a+1 个 node</span></span><br><span class="line">        <span class="comment"># 后面的数字， a 个 node</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">splitList</span><span class="params">(root, k)</span>:</span></span><br><span class="line">            <span class="comment"># 分离前 k 个 nodes</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>, root</span><br><span class="line">            t = root</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">                t = t.next</span><br><span class="line">            newRoot = t.next</span><br><span class="line">            t.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> newRoot, root</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i&lt;=b:</span><br><span class="line">                root, head = splitList(root, a+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root, head = splitList(root, a)</span><br><span class="line">            res.append(head)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1171-从链表中删去总和值为零的连续节点-力扣（LeetCode）"><a href="#1171-从链表中删去总和值为零的连续节点-力扣（LeetCode）" class="headerlink" title="1171. 从链表中删去总和值为零的连续节点 - 力扣（LeetCode）"></a>1171. 从链表中删去总和值为零的连续节点 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/">1171. 从链表中删去总和值为零的连续节点 - 力扣（LeetCode）</a></p><p>记录前缀和 presum ，若 _sum 已经在 presum 中，移除中间这部分节点（改变指针），更新 presum </p><p>注意 _sum 为0 的情况，从头到 i 和为 0, 但是 0 不在 presum 中，所以再 index 中做了额外的判断，也可以一开始就在 presum 中放个 0，index return 的时候-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 1 2 3 -3 -2</span></span><br><span class="line">        <span class="comment"># 1 3 6 3  1</span></span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getNode</span><span class="params">(k)</span>:</span></span><br><span class="line">            <span class="comment"># -1 -&gt; dummy 0 -&gt; head</span></span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(l, n)</span>:</span></span><br><span class="line">            <span class="comment"># _sum==0 说明 0~i 和为 0 </span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(l):</span><br><span class="line">                <span class="keyword">if</span> v==n:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        presum =[]</span><br><span class="line">        _sum = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            _sum += cur.val</span><br><span class="line">            idx = index(presum, _sum)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="comment"># 存在相同的前缀和，说明 idx+1~len(presum)+1 和为 0</span></span><br><span class="line">            <span class="keyword">if</span> idx!=<span class="number">-2</span>:</span><br><span class="line">                presum = presum[:idx+<span class="number">1</span>]</span><br><span class="line">                preNode = getNode(idx)</span><br><span class="line">                preNode.next = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                presum.append(_sum)</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="1367-二叉树中的列表-力扣（LeetCode）"><a href="#1367-二叉树中的列表-力扣（LeetCode）" class="headerlink" title="1367. 二叉树中的列表 - 力扣（LeetCode）"></a>1367. 二叉树中的列表 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/submissions/">1367. 二叉树中的列表 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head: ListNode, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSame</span><span class="params">(head, root)</span>:</span></span><br><span class="line">            <span class="comment">#  head 与 从 root 开始的一条路径 值相同</span></span><br><span class="line">            <span class="comment"># head 为 None 为终止递归条件，就是说链表遍历完了都依序存在于root中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> head.val!=root.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> isSame(head.next, root.left) <span class="keyword">or</span> isSame(head.next, root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> isSame(head, root):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isSubPath(head, root.left) <span class="keyword">or</span> self.isSubPath(head, root.right)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n)):</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>]&gt;nums[i]:</span><br><span class="line">                    res[i] = stack[<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            stack.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="817-链表组件-力扣（LeetCode）"><a href="#817-链表组件-力扣（LeetCode）" class="headerlink" title="817. 链表组件 - 力扣（LeetCode）"></a>817. 链表组件 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/linked-list-components/submissions/">817. 链表组件 - 力扣（LeetCode）</a></p><p>题意：链表元素都 unique，G 里的元素都在链表中，求 G 的元素在链表中组成的子序列 个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numComponents</span><span class="params">(self, head: ListNode, G: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 链表上的值有序</span></span><br><span class="line">        d = &#123;&#125; <span class="comment"># 链表上节点的值 -&gt; i</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            d[head.val] = i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="comment"># 然后把 G 按照 d 排序，排成 head 的子序列的样子</span></span><br><span class="line">        G.sort(key=<span class="keyword">lambda</span> i: d[i])</span><br><span class="line">        <span class="comment"># print(G)</span></span><br><span class="line">        <span class="comment"># 再遍历一遍 G，寻找连续序列的个数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(G):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i+<span class="number">1</span>&lt;len(G) <span class="keyword">and</span> d[G[i+<span class="number">1</span>]]==d[G[i]]+<span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-203</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-203.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-203.html</id>
    <published>2020-08-23T03:53:15.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/most-visited-sector-in-a-circular-track/">圆形赛道上经过次数最多的扇区</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/maximum-number-of-coins-you-can-get/">你可以获得的最大硬币数目</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/find-latest-group-of-size-m/">查找大小为 M 的最新分组</a><strong>6</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-203/problems/stone-game-v/">石子游戏 V</a><strong>7</strong></li></ul><p>打回原形，排名又要下降了</p><p><img src="https://i.loli.net/2020/08/23/dsOEcbUFDyzvYaK.png" alt="image-20200823115729402"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>模拟，比较慢，不知道有没有快点的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostVisited</span><span class="params">(self, n: int, rounds: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        m[rounds[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 后面不算起点</span></span><br><span class="line">        cur = rounds[<span class="number">0</span>]</span><br><span class="line">        rounds.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> rounds:</span><br><span class="line">            <span class="keyword">while</span> cur!=rounds[<span class="number">0</span>]:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur&gt;n: cur = <span class="number">1</span></span><br><span class="line">                m[cur] += <span class="number">1</span></span><br><span class="line">            rounds.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># print(m, max(m.values()))</span></span><br><span class="line">        res = []</span><br><span class="line">        ma = max(m.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">if</span> m.get(i)==ma:</span><br><span class="line">                res.append(i)</span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>每次扔个最大的，扔个最小的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># [2,4,1,2,7,8]</span></span><br><span class="line">        <span class="comment"># 1 2 2 4 7 8</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> nums:</span><br><span class="line">            res += nums[<span class="number">-2</span>]</span><br><span class="line">            nums.pop()</span><br><span class="line">            nums.pop()</span><br><span class="line">            nums.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>写的是对的，但是超时</p><p>复杂度: 500^3</p><p>哎，不知道哪里可以优化。遍历顺序还是什么地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameV</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># dp[i][j] i~j 石子的分数</span></span><br><span class="line">        <span class="comment"># return dp[0][n-1]</span></span><br><span class="line">        <span class="comment">#   dp[i][j] = max(min(_sum(), _sum() + dp[]) for k in range(i+1, j))</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        presum = list(itertools.accumulate(nums))</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_sum</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># i~j 的 sum</span></span><br><span class="line">            <span class="keyword">return</span> presum[j]-presum[i]+nums[i]</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getCur</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> _sum(i, k)&gt;_sum(k+<span class="number">1</span>, j):</span><br><span class="line">                cur = _sum(k+<span class="number">1</span>, j)+dp[k+<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">elif</span> _sum(i, k)&lt;_sum(k+<span class="number">1</span>, j):</span><br><span class="line">                cur = _sum(i, k)+dp[i][k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = max(_sum(i, k)+dp[i][k], _sum(k+<span class="number">1</span>, j)+dp[k+<span class="number">1</span>][j])</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n-gap):</span><br><span class="line">                j = i+gap</span><br><span class="line">                <span class="keyword">if</span> gap==<span class="number">1</span>: dp[i][j] = min(nums[i:j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 划分为 [i, k] [k+1, j]-&gt; i&lt;=k&lt;j</span></span><br><span class="line">                    dp[i][j] = max(getCur(i, j, k) <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dp: print(i)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>比赛完了，别人用的一样的思路，也是 O(n^3) 就是 LeetCode 对时间要求苛刻了一些，需要做一些优化:</p><p>从上往下的 记忆化递归 可以减少许多不必要的状态</p><p>比如上面代码运行完的 dp 数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0, 2, 7, 10, 13, 18]</span><br><span class="line">[0, 0, 2, 4, 7, 13]</span><br><span class="line">[0, 0, 0, 3, 5, 10]</span><br><span class="line">[0, 0, 0, 0, 4, 5]</span><br><span class="line">[0, 0, 0, 0, 0, 5]</span><br><span class="line">[0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure><p>记忆化递归 的 dp 数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0, 2, 7, 0, 0, 18]</span><br><span class="line">[0, 0, 2, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 5]</span><br><span class="line">[0, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure><p>presum 前面加个 0，方便计算前缀和 _sum(i, j) = presum[j+1]-presum[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameV</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># dp[i][j] i~j 石子的分数</span></span><br><span class="line">        <span class="comment"># return dp[0][n-1]</span></span><br><span class="line">        <span class="comment">#   dp[i][j] = max(min(_sum(), _sum() + dp[]) for k in range(i+1, j))</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        presum = list(itertools.accumulate(nums))</span><br><span class="line">        presum.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_sum</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># i~j 的 sum</span></span><br><span class="line">            <span class="keyword">return</span> presum[j+<span class="number">1</span>]-presum[i]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getCur</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            l, r = _sum(i, k), _sum(k+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> l&gt;r:</span><br><span class="line">                cur = r+dfs(k+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">elif</span> l&lt;r:</span><br><span class="line">                cur = l+dfs(i, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = max(l+dfs(i, k), r+dfs(k+<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">                    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]: <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            <span class="keyword">if</span> j-i==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j-i==<span class="number">1</span>: </span><br><span class="line">                dp[i][j] = min(nums[i], nums[j])</span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            dp[i][j] = max(getCur(i, j, k) <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j))</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># for i in dp: print(i)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>此外，记忆化递归 在 Python 中可以不借助 map 或数组，可以用 lru_cache 来实现，代码更简短，而且速度上还更快</p><p><img src="https://i.loli.net/2020/08/24/lk2uy8qNw37ZIAt.png" alt="image-20200824143033457"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameV</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># dp[i][j] i~j 石子的分数</span></span><br><span class="line">        <span class="comment"># return dp[0][n-1]</span></span><br><span class="line">        <span class="comment">#   dp[i][j] = max(min(_sum(), _sum() + dp[]) for k in range(i+1, j))</span></span><br><span class="line">        presum = list(itertools.accumulate(nums))</span><br><span class="line">        presum.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_sum</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># i~j 的 sum</span></span><br><span class="line">            <span class="keyword">return</span> presum[j+<span class="number">1</span>]-presum[i]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getCur</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            l, r = _sum(i, k), _sum(k+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> l&gt;r:</span><br><span class="line">                cur = r+dfs(k+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">elif</span> l&lt;r:</span><br><span class="line">                cur = l+dfs(i, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = max(l+dfs(i, k), r+dfs(k+<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> j-i==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j-i==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> min(nums[i], nums[j])</span><br><span class="line">            <span class="keyword">return</span> max(getCur(i, j, k) <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-203/problems/most-visited-sector-in-a-circular-track/&quot;&gt;圆形赛道上经过次数最多的扇区&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-203/problems/maximum-number-of-coins-you-can-get/&quot;&gt;你可以获得的最大硬币数目&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-203/problems/find-latest-group-of-size-m/&quot;&gt;查找大小为 M 的最新分组&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-203/problems/stone-game-v/&quot;&gt;石子游戏 V&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打回原形，排名又要下降了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/23/dsOEcbUFDyzvYaK.png&quot; alt=&quot;image-20200823115729402&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 201. Bitwise AND of Numbers Range</title>
    <link href="https://zronghui.github.io/leetcode-201-Bitwise-AND-of-Numbers-Range.html"/>
    <id>https://zronghui.github.io/leetcode-201-Bitwise-AND-of-Numbers-Range.html</id>
    <published>2020-08-23T01:07:07.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/bitwise-and-of-numbers-range/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND<br>of all numbers in this range, inclusive.</p><p><strong>Example 1:</strong></p><pre><code>Input: [5,7]Output: 4</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [0,1]Output: 0</code></pre><p><strong>Tags:</strong> Bit Manipulation</p><p><strong>Difficulty:</strong> Medium</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><p>bin(45)</p><p>int(‘12’, base=10)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        shift = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;m:</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">            m = m&gt;&gt;<span class="number">1</span></span><br><span class="line">            shift += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n&lt;&lt;shift</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd1</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 5   7</span></span><br><span class="line">        <span class="comment"># 101 111 -&gt; 100</span></span><br><span class="line">        <span class="comment"># m n 的二进制的共同前缀，不同比特填充 0</span></span><br><span class="line">        a = bin(m)[<span class="number">2</span>:]</span><br><span class="line">        b = bin(n)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> len(b)&gt;len(a):</span><br><span class="line">            <span class="comment"># 1 10101 -&gt; 0</span></span><br><span class="line">            <span class="comment"># 长度不同，return 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(a, b):</span><br><span class="line">            <span class="keyword">if</span> i==j:</span><br><span class="line">                pre += i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(<span class="string">'0b'</span>+pre+<span class="string">'0'</span>*(len(b)-len(pre)), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 到这里，表示 m==n</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/bitwise-and-of-numbers-range/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/bitwise-and-of-numbers-range/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND&lt;br&gt;of all numbers in this range, inclusive.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [5,7]
Output: 4&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [0,1]
Output: 0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Bit Manipulation&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Medium&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
    
      <category term="Bit Manipulation" scheme="https://zronghui.github.io/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>biweekly-contest-33</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-33.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-33.html</id>
    <published>2020-08-22T15:23:44.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/thousand-separator/">千位分隔数</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-number-of-vertices-to-reach-all-nodes/">可以到达所有点的最少点数目</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/">得到目标数组的最少函数调用次数</a><strong>5</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/">二维网格图中探测环</a><strong>6</strong></li></ul><p>还可以，都不算太难，速度有些慢了</p><p><img src="https://i.loli.net/2020/08/22/hUQrkCzwIqeYGa1.png" alt="image-20200822232459723"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thousandSeparator</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">1000</span>:</span><br><span class="line">            n, cur = divmod(n, <span class="number">1000</span>)</span><br><span class="line">            l.append(str(cur).zfill(<span class="number">3</span>))</span><br><span class="line">        l.append(str(n))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'.'</span>.join(l[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>脑筋急转弯</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSmallestSetOfVertices</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 所有入度为 0 的点</span></span><br><span class="line">        indegrees = collections.defaultdict(int)</span><br><span class="line">        points = set()</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> edges:</span><br><span class="line">            points.add(a)</span><br><span class="line">            points.add(b)</span><br><span class="line">            indegrees[b] += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> indegrees.get(p, <span class="number">0</span>)==<span class="number">0</span>:</span><br><span class="line">                res.append(p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 问题简化：nums 的每个元素都最少经过 a 次 +1,  b 次 *2</span></span><br><span class="line">        <span class="comment"># 结果等同于 max(*2次数)+sum(+1 次数)</span></span><br><span class="line">        <span class="comment">#   3 2 2 4</span></span><br><span class="line">        <span class="comment"># a 2 1 1 1 (+1)</span></span><br><span class="line">        <span class="comment"># b 1 1 1 2 (*2)</span></span><br><span class="line">        <span class="comment"># max(b) + sum(a) = 2+5</span></span><br><span class="line">        a, b = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getab</span><span class="params">(n)</span>:</span></span><br><span class="line">            x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">                    n -= <span class="number">1</span></span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    n //=<span class="number">2</span></span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x, y</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            x, y = getab(i)</span><br><span class="line">            a.append(x)</span><br><span class="line">            b.append(y)</span><br><span class="line">        <span class="comment"># print(a, b, max(b), sum(a))</span></span><br><span class="line">        <span class="keyword">return</span> max(b) + sum(a)</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsCycle</span><span class="params">(self, grid: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 0: 没访问过 其他数字表示同一轮的搜索轮次</span></span><br><span class="line">        visited = [[<span class="number">0</span>]*m <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.cur = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(i0, j0)</span>:</span></span><br><span class="line">            <span class="comment"># bfs 遍历上下左右</span></span><br><span class="line">            visited[i0][j0] = self.cur</span><br><span class="line">            queue = [[i0, j0, <span class="number">0</span>, <span class="number">0</span>]] <span class="comment"># 后 2 位记录方向</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                _i, _j, x, y = queue.pop()</span><br><span class="line">                <span class="keyword">for</span> a, b <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>]]:</span><br><span class="line">                    i, j = _i+a, _j+b</span><br><span class="line">                    <span class="keyword">if</span> (a==-x <span class="keyword">and</span> b==-y) <span class="keyword">or</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=i&lt;n) <span class="keyword">or</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;m): <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 如果已经访问过，并且格子内值相同，并且 cur 与 visited 值相同，表示有环</span></span><br><span class="line">                    <span class="keyword">if</span> visited[i][j]:</span><br><span class="line">                        <span class="keyword">if</span> visited[i][j]==self.cur:</span><br><span class="line">                            <span class="comment"># for i in visited: print(i)</span></span><br><span class="line">                            <span class="comment"># print()</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> grid[i][j]==grid[i0][j0]:</span><br><span class="line">                        visited[i][j] = self.cur</span><br><span class="line">                        queue.append([i, j, a, b])</span><br><span class="line">            self.cur += <span class="number">1</span></span><br><span class="line">            <span class="comment"># for i in visited: print(i)</span></span><br><span class="line">            <span class="comment"># print()</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> any(bfs(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(m))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-33/problems/thousand-separator/&quot;&gt;千位分隔数&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-number-of-vertices-to-reach-all-nodes/&quot;&gt;可以到达所有点的最少点数目&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/&quot;&gt;得到目标数组的最少函数调用次数&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-33/problems/detect-cycles-in-2d-grid/&quot;&gt;二维网格图中探测环&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以，都不算太难，速度有些慢了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/22/hUQrkCzwIqeYGa1.png&quot; alt=&quot;image-20200822232459723&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 679. 24 Game</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-6**/leetcode-679-24-Game.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-6**/leetcode-679-24-Game.html</id>
    <published>2020-08-21T23:48:43.000Z</published>
    <updated>2020-09-08T15:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/24-game/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/24-game/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You have 4 cards each containing a number from 1 to 9. You need to judge<br>whether they could operated through <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code> to get the<br>value of 24.</p><p><strong>Example 1:</strong>  </p><pre><code>Input: [4, 1, 8, 7]Output: TrueExplanation: (8-4) * (7-1) = 24</code></pre><p><strong>Example 2:</strong>  </p><pre><code>Input: [1, 2, 1, 2]Output: False</code></pre><p><strong>Note:</strong>  </p><ol><li>The division operator <code>/</code> represents real division, not integer division. For example, 4 / (1 - 2/3) = 12.</li><li>Every operation done is between two numbers. In particular, we cannot use <code>-</code> as a unary operator. For example, with <code>[1, 1, 1, 1]</code> as input, the expression <code>-1 - 1 - 1 - 1</code> is not allowed.</li><li>You cannot concatenate numbers together. For example, if the input is <code>[1, 2, 1, 2]</code>, we cannot write this as 12 + 12.</li></ol><p><strong>Tags:</strong> Depth-first Search</p><p><strong>Difficulty:</strong> Hard</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub, mul, truediv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">                print(nums)</span><br><span class="line">                <span class="keyword">return</span> math.isclose(nums[<span class="number">0</span>], <span class="number">24</span>)</span><br><span class="line">            <span class="comment"># 选定前 2 个进行运算</span></span><br><span class="line">            (a, b), nums = nums[:<span class="number">2</span>], nums[<span class="number">2</span>:]</span><br><span class="line">            ops = [add, sub, mul, truediv]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b: ops.pop()</span><br><span class="line">            _abs = [op(a, b) <span class="keyword">for</span> op <span class="keyword">in</span> ops]</span><br><span class="line">            <span class="comment"># 把 ab 运算的结果插进 剩余数的可能位置</span></span><br><span class="line">            <span class="keyword">return</span> any(</span><br><span class="line">                dfs(nums[:i]+(ab,)+nums[i:])</span><br><span class="line">                <span class="keyword">for</span> ab <span class="keyword">in</span> _abs</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)+<span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> any(dfs(permu) <span class="keyword">for</span> permu <span class="keyword">in</span> itertools.permutations(nums, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/24-game/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/24-game/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;You have 4 cards each containing a number from 1 to 9. You need to judge&lt;br&gt;whether they could operated through &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt; to get the&lt;br&gt;value of 24.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [4, 1, 8, 7]
Output: True
Explanation: (8-4) * (7-1) = 24&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [1, 2, 1, 2]
Output: False&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The division operator &lt;code&gt;/&lt;/code&gt; represents real division, not integer division. For example, 4 / (1 - 2/3) = 12.&lt;/li&gt;
&lt;li&gt;Every operation done is between two numbers. In particular, we cannot use &lt;code&gt;-&lt;/code&gt; as a unary operator. For example, with &lt;code&gt;[1, 1, 1, 1]&lt;/code&gt; as input, the expression &lt;code&gt;-1 - 1 - 1 - 1&lt;/code&gt; is not allowed.&lt;/li&gt;
&lt;li&gt;You cannot concatenate numbers together. For example, if the input is &lt;code&gt;[1, 2, 1, 2]&lt;/code&gt;, we cannot write this as 12 + 12.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Depth-first Search&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Hard&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-6**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-6/"/>
    
    
      <category term="Depth-first Search" scheme="https://zronghui.github.io/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>weekly-contest-190</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-190.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-190.html</id>
    <published>2020-08-21T06:22:10.000Z</published>
    <updated>2020-09-08T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/">检查单词是否为句中其他单词的前缀</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">定长子串中元音的最大数目</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/">二叉树中的伪回文路径</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/">两个子序列的最大点积</a><strong>6</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, ss: str, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, si <span class="keyword">in</span> enumerate(ss.split()):</span><br><span class="line">            <span class="keyword">if</span> si.startswith(s):</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxVowels</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'aeiou'</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        l, r = <span class="number">0</span>, k<span class="number">-1</span></span><br><span class="line">        cur = sum(vowel(s[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r+<span class="number">1</span>))</span><br><span class="line">        res = cur</span><br><span class="line">        <span class="keyword">while</span> r+<span class="number">1</span>&lt;len(s):</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vowel(s[r]): cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vowel(s[l<span class="number">-1</span>]): cur -= <span class="number">1</span></span><br><span class="line">            res = max(res, cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dfs + 记录所有的奇数节点</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        odd = set()</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">flip</span><span class="params">(odd, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> odd: odd.remove(n)</span><br><span class="line">            <span class="keyword">else</span>: odd.add(n)</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            flip(odd, root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> len(odd)&lt;<span class="number">2</span>:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            flip(odd, root.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>注意 num1 nums2 中都至少取 1 个数</p><p>nums1[i]*nums2[j] 表示只拿 i j 2个数相乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], nums1[i]*nums2[j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>], nums1[i]*nums2[j])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDotProduct</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, m = map(len, [nums1, nums2])</span><br><span class="line">        <span class="comment"># dp[i][j]: nums1[:i+1] 与 nums2[:j+1] 的点积最大值</span></span><br><span class="line">        <span class="comment"># 约束：i&lt;n, j&lt;m</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [[float(<span class="string">'-inf'</span>)]*m <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 至少相乘一次</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums1[<span class="number">0</span>]*nums2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], nums1[i]*nums2[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[<span class="number">0</span>][j] = max(dp[<span class="number">0</span>][j<span class="number">-1</span>], nums1[<span class="number">0</span>]*nums2[j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], nums1[i]*nums2[j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>], nums1[i]*nums2[j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/&quot;&gt;检查单词是否为句中其他单词的前缀&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/&quot;&gt;定长子串中元音的最大数目&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/&quot;&gt;二叉树中的伪回文路径&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/&quot;&gt;两个子序列的最大点积&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%A0%88.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%A0%88.html</id>
    <published>2020-08-19T12:14:51.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://leetcode-cn.com/tag/stack/">栈 - 力扣（LeetCode）</a></p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/submissions/">1019. 链表中的下一个更大节点 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/dan-diao-zhan-by-yi-wen-statistics-2/">单调栈 - 链表中的下一个更大节点 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/tag/stack/&quot;&gt;栈 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客 sql</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%89%9B%E5%AE%A2-sql.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E7%89%9B%E5%AE%A2-sql.html</id>
    <published>2020-08-17T09:10:44.000Z</published>
    <updated>2020-08-20T12:58:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&&tqId=29753&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找最晚入职员工的所有信息_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by hire_date desc</span><br><span class="line">limit 1  -- 或者 limit 0, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&tqId=29753&rp=1&ru=%2Fta%2Fsql&qru=%2Fta%2Fsql%2Fquestion-ranking">查找入职员工时间排名倒数第三的员工所有信息_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">order by hire_date desc</span><br><span class="line">limit 2, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/6d35b1cd593545ab985a68cd86f28671?tpId=82&&tqId=29756&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有已经分配部门的员工的last_name和first_name以及dept_no_牛客网</a></p><p>三种等效的操作 , == join == inner join</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e, dept_emp AS d</span><br><span class="line">WHERE e.emp_no &#x3D; d.emp_no;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e JOIN dept_emp AS d</span><br><span class="line">ON e.emp_no&#x3D;d.emp_no;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name, e.first_name, d.dept_no</span><br><span class="line">FROM employees AS e INNER JOIN dept_emp AS d</span><br><span class="line">ON e.emp_no&#x3D;d.emp_no;</span><br></pre></td></tr></table></figure><p>左连接：</p><p>left join 和 left outer join 是一样的，就是字面上有区别，执行结果是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select last_name, first_name, dept_no</span><br><span class="line">from employees as e left join dept_emp as d</span><br><span class="line">on d.emp_no &#x3D; e.emp_no</span><br><span class="line">where d.dept_no not null;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&&tqId=29755&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找当前薪水详情以及部门编号dept_no_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s.*,d.dept_no</span><br><span class="line">from salaries as s inner join dept_manager as d</span><br><span class="line">on s.emp_no&#x3D;d.emp_no</span><br><span class="line">where d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by s.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/23142e7a23e4480781a3b978b5e0f33a?tpId=82&&tqId=29758&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有员工入职时候的薪水情况_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- group by  + having min(salary)</span><br><span class="line">select emp_no, salary</span><br><span class="line">from salaries</span><br><span class="line">group by emp_no</span><br><span class="line">having min(salary)</span><br><span class="line">order by emp_no desc</span><br><span class="line"></span><br><span class="line">-- e.hire_date&#x3D;s.from_date</span><br><span class="line">-- 注意，加上 s. e. </span><br><span class="line">select s.emp_no, s.salary</span><br><span class="line">from employees as e inner join salaries as s</span><br><span class="line">on e.emp_no&#x3D;s.emp_no and e.hire_date&#x3D;s.from_date</span><br><span class="line">order by s.emp_no desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/6d4a4cff1d58495182f536c548fee1ae?tpId=82&&tqId=29759&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找薪水变动超过15次的员工号emp_no以及其对应的变动次数t_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, count(salary) as t</span><br><span class="line">from salaries</span><br><span class="line">group by emp_no</span><br><span class="line">having count(salary)&gt;15</span><br><span class="line"></span><br><span class="line">-- 补充：如果考虑严格意义上的涨幅，应该写：</span><br><span class="line">select a.emp_no, count() t</span><br><span class="line">from salaries a inner join salaries b</span><br><span class="line">on a.emp_no&#x3D;b.emp_no and a.to_date&#x3D;b.from_date</span><br><span class="line">where a.salary &lt; b.salary</span><br><span class="line">group by a.emp_no</span><br><span class="line">having t&gt;15</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/ae51e6d057c94f6d891735a48d1c2397?tpId=82&&tqId=29760&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">找出所有员工当前薪水salary情况_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary</span><br><span class="line">from salaries</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by salary desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/4c8b4a10ca5b44189e411107e1d8bec1?tpId=82&&tqId=29761&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select d.dept_no, d.emp_no, s.salary</span><br><span class="line">from dept_manager as d inner join salaries as s</span><br><span class="line">on d.emp_no&#x3D;s.emp_no </span><br><span class="line">   and d.to_date&#x3D;&#39;9999-01-01&#39; </span><br><span class="line">   and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/32c53d06443346f4a2f2ca733c19660c?tpId=82&&tqId=29762&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有非manager的员工emp_no_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select emp_no</span><br><span class="line">from employees</span><br><span class="line">where emp_no not in (</span><br><span class="line">    select emp_no</span><br><span class="line">    from dept_manager</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82&&tqId=29763&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取所有员工当前的manager_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no</span><br><span class="line">from dept_emp as e inner join dept_manager as m</span><br><span class="line">on e.dept_no&#x3D;m.dept_no</span><br><span class="line">where e.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">      and m.to_date&#x3D;&#39;9999-01-01&#39; </span><br><span class="line">      and e.emp_no&lt;&gt;m.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&&tqId=29764&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取每个部门中当前员工薪水最高的相关信息_牛客网</a></p><p>用子查询，子查询内部可以在 where等地方 连接外部的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select d.dept_no, d.emp_no, s.salary</span><br><span class="line">from dept_emp as d inner join salaries as s</span><br><span class="line">on d.emp_no&#x3D;s.emp_no and d.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">where s.salary&#x3D;(</span><br><span class="line">  select max(s1.salary)</span><br><span class="line">  from dept_emp as d1 inner join salaries as s1</span><br><span class="line">  on d1.emp_no&#x3D;s1.emp_no and d1.to_date&#x3D;&#39;9999-01-01&#39; and s1.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">  where d1.dept_no&#x3D;d.dept_no</span><br><span class="line">  group by d1.dept_no</span><br><span class="line">)</span><br><span class="line">order by d.dept_no asc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/72ca694734294dc78f513e147da7821e?tpId=82&&tqId=29765&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">从titles表获取按照title进行分组_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select title, count() as t</span><br><span class="line">from titles</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c59b452f420c47f48d9c86d69efdff20?tpId=82&&tqId=29766&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略。_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select title, count() as t</span><br><span class="line">from (</span><br><span class="line">    select distinct emp_no, title</span><br><span class="line">    from titles</span><br><span class="line">)</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p>补充：当DISTINCT应用到多个字段时，其应用范围是其后面的所有字段，而不是紧挨它的一个字段<br>注意：DISTINCT只能放在所有字段前面，所以上面的DISTINCT emp_no和title不可以交换</p><p>distinct 还能在 count 里面用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select title, count(distinct emp_no) as t</span><br><span class="line">from titles</span><br><span class="line">group by title</span><br><span class="line">having t&gt;1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&&tqId=29767&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找employees表_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where last_name!&#x3D;&#39;Mary&#39;</span><br><span class="line">and emp_no%2&#x3D;1</span><br><span class="line">order by hire_date desc</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c8652e9e5a354b879e2a244200f1eaae?tpId=82&&tqId=29768&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">统计出当前各个title类型对应的员工当前薪水对应的平均工资_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select title, avg(salary)</span><br><span class="line">from titles as t inner join salaries as s</span><br><span class="line">on t.emp_no&#x3D;s.emp_no</span><br><span class="line">where t.to_date&#x3D;&#39;9999-01-01&#39; and s.to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">group by title</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82&&tqId=29769&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取当前薪水第二多的员工的emp_no以及其对应的薪水salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary</span><br><span class="line">from salaries</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">order by salary desc</span><br><span class="line">limit 1, 1</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&&tqId=29770&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">获取当前薪水第二多的员工的emp_no以及其对应的薪水salary_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 小于薪水最大的最大薪水</span><br><span class="line">select e.emp_no, max(salary), last_name, first_name</span><br><span class="line">from employees as e inner join salaries as s</span><br><span class="line">on e.emp_no&#x3D;s.emp_no</span><br><span class="line">where to_date&#x3D;&#39;9999-01-01&#39; and salary&lt;(</span><br><span class="line">    select max(salary)</span><br><span class="line">    from salaries</span><br><span class="line">    where to_date&#x3D;&#39;9999-01-01&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/5a7975fabe1146329cee4f670c27ad55?tpId=82&&tqId=29771&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找所有员工的last_name和first_name以及对应的dept_name_牛客网</a></p><p>好像不能直接三个表 join ，比如 a left join b on xx join c on xxx ，这是错误的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name, e.first_name, t.dept_name</span><br><span class="line">from employees as e left join (</span><br><span class="line">    select emp_no, dept_name</span><br><span class="line">    from dept_emp as de inner join departments as d</span><br><span class="line">    on d.dept_no&#x3D;de.dept_no</span><br><span class="line">) as t</span><br><span class="line">on e.emp_no&#x3D;t.emp_no</span><br></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/practice/c727647886004942a89848e2b5130dc2?tpId=82&&tqId=29772&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking">查找员工编号emp_no为10001其自入职以来的薪水salary涨幅(总共涨了多少)growth_牛客网</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
