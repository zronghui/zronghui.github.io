<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zronghui的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zronghui.github.io/"/>
  <updated>2020-08-07T14:45:26.000Z</updated>
  <id>https://zronghui.github.io/</id>
  
  <author>
    <name>zronghui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 778. Swim in Rising Water</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-7**/leetcode-778-Swim-in-Rising-Water.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-7**/leetcode-778-Swim-in-Rising-Water.html</id>
    <published>2020-08-06T11:27:31.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/swim-in-rising-water/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/swim-in-rising-water/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that<br>point <code>(i,j)</code>.</p><p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is<br><code>t</code>. You can swim from a square to another 4-directionally adjacent square if<br>and only if the elevation of both squares individually are at most <code>t</code>. You<br>can swim infinite distance in zero time. Of course, you must stay within the<br>boundaries of the grid during your swim.</p><p>You start at the top left square <code>(0, 0)</code>. What is the least time until you<br>can reach the bottom right square <code>(N-1, N-1)</code>?</p><p><strong>Example 1:</strong></p><pre><code>Input: [[0,2],[1,3]]Output: 3Explanation:At time 0, you are in grid location (0, 0).You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.You cannot reach point (1, 1) until time 3.When the depth of water is 3, we can swim anywhere inside the grid.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]Output: 16Explanation:**0  1  2  3  4**24 23 22 21  **5****12 13 14 15 16****11** 17 18 19 20**10  9  8  7  6**The final route is marked in bold.We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</code></pre><p><strong>Note:</strong></p><ol><li><code>2 &lt;= N &lt;= 50</code>.</li><li>grid[i][j] is a permutation of [0, …, N*N - 1].</li></ol><p><strong>Tags:</strong> Binary Search, Heap, Depth-first Search, Union Find</p><p><strong>Difficulty:</strong> Hard</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><p><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/you-xian-dui-lie-fa-yi-ji-wei-he-hui-xiang-dao-you/">优先队列法，以及为何会想到优先队列法 - 水位上升的泳池中游泳 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> insort</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = deque() <span class="comment"># (value, i, j), ,</span></span><br><span class="line">        l.append((grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        n = len(grid)</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            v, i, j = l.popleft()</span><br><span class="line">            visited[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># print(v)</span></span><br><span class="line">            res = max(v, res)</span><br><span class="line">            <span class="keyword">if</span> i==j==n<span class="number">-1</span>: <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">-1</span>],[<span class="number">1</span>, <span class="number">0</span>],[<span class="number">-1</span>, <span class="number">0</span>]]:</span><br><span class="line">                ii, jj = i+di, j+dj</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=ii&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=jj&lt;n <span class="keyword">and</span> <span class="keyword">not</span> visited[ii][jj]:</span><br><span class="line">                    insort(l, [grid[ii][jj], ii, jj])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/swim-in-rising-water/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/swim-in-rising-water/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;On an N x N &lt;code&gt;grid&lt;/code&gt;, each square &lt;code&gt;grid[i][j]&lt;/code&gt; represents the elevation at that&lt;br&gt;point &lt;code&gt;(i,j)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now rain starts to fall. At time &lt;code&gt;t&lt;/code&gt;, the depth of the water everywhere is&lt;br&gt;&lt;code&gt;t&lt;/code&gt;. You can swim from a square to another 4-directionally adjacent square if&lt;br&gt;and only if the elevation of both squares individually are at most &lt;code&gt;t&lt;/code&gt;. You&lt;br&gt;can swim infinite distance in zero time. Of course, you must stay within the&lt;br&gt;boundaries of the grid during your swim.&lt;/p&gt;
&lt;p&gt;You start at the top left square &lt;code&gt;(0, 0)&lt;/code&gt;. What is the least time until you&lt;br&gt;can reach the bottom right square &lt;code&gt;(N-1, N-1)&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
**0  1  2  3  4**
24 23 22 21  **5**
**12 13 14 15 16**
**11** 17 18 19 20
**10  9  8  7  6**

The final route is marked in bold.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= N &amp;lt;= 50&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;grid[i][j] is a permutation of [0, …, N*N - 1].&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Binary Search, Heap, Depth-first Search, Union Find&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Hard&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-7**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-7/"/>
    
    
      <category term="Depth-first Search" scheme="https://zronghui.github.io/tags/Depth-first-Search/"/>
    
      <category term="Union Find" scheme="https://zronghui.github.io/tags/Union-Find/"/>
    
      <category term="Binary Search" scheme="https://zronghui.github.io/tags/Binary-Search/"/>
    
      <category term="Heap" scheme="https://zronghui.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%B9%B6%E6%9F%A5%E9%9B%86.html</id>
    <published>2020-08-05T09:08:28.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="721-账户合并-力扣（LeetCode）"><a href="#721-账户合并-力扣（LeetCode）" class="headerlink" title="721. 账户合并 - 力扣（LeetCode）"></a>721. 账户合并 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/accounts-merge/submissions/">721. 账户合并 - 力扣（LeetCode）</a><br><a href="https://leetcode.com/articles/accounts-merge/">Accounts Merge - LeetCode Articles</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">10001</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]: x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        email_id, email_name = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="comment"># account 里都在一个集合里</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> accounts:</span><br><span class="line">            name = l[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> l[<span class="number">1</span>:]:</span><br><span class="line">                email_name[email] = name</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">not</span> <span class="keyword">in</span> email_id:</span><br><span class="line">                    email_id[email] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                dsu.union(email_id[l[<span class="number">1</span>]], email_id[email])</span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> email_name:</span><br><span class="line">            ans[dsu.find(email_id[email])].append(email)</span><br><span class="line">        <span class="keyword">return</span> [[email_name[i[<span class="number">0</span>]], *sorted(i)] <span class="keyword">for</span> i <span class="keyword">in</span> ans.values()]</span><br></pre></td></tr></table></figure><h3 id="684-冗余连接-力扣（LeetCode）"><a href="#684-冗余连接-力扣（LeetCode）" class="headerlink" title="684. 冗余连接 - 力扣（LeetCode）"></a>684. 冗余连接 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/redundant-connection/comments/">684. 冗余连接 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/redundant-connection/solution/tong-su-jiang-jie-bing-cha-ji-bang-zhu-xiao-bai-ku/">通俗讲解并查集，帮助小白快速理解 - 冗余连接 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""并查集"""</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    记录1到N的每个数的根，因为如果有环，导致环相连的[u, v]一定有相同的root，</span></span><br><span class="line"><span class="string">    我们可以理解为是一个节点的两个分支，通过[u,v]被连起来了，既然他们是一个节点的两个分支，那么他们一定有相同的root，所以直接移除[u,v]就好啦。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        root = list(range(len(edges)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i!=root[i]:</span><br><span class="line">                i = root[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            uroot, vroot = map(find, [u, v])</span><br><span class="line">            <span class="keyword">if</span> uroot!=vroot:</span><br><span class="line">                root[uroot] = vroot</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [u, v]</span><br></pre></td></tr></table></figure><h3 id="399-除法求值-力扣（LeetCode）"><a href="#399-除法求值-力扣（LeetCode）" class="headerlink" title="399. 除法求值 - 力扣（LeetCode）"></a>399. 除法求值 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值 - 力扣（LeetCode）</a></p><h4 id="flyod"><a href="#flyod" class="headerlink" title="flyod"></a>flyod</h4><p>不是用索引表示的 edges</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="comment"># flyod</span></span><br><span class="line">        edges = collections.defaultdict(dict)</span><br><span class="line">        verts = set()</span><br><span class="line">        <span class="keyword">for</span> (a, b), c <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            edges[a][b] = c</span><br><span class="line">            edges[b][a] = <span class="number">1</span>/c</span><br><span class="line">            verts.add(a)</span><br><span class="line">            verts.add(b)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> verts:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> verts:</span><br><span class="line">                <span class="keyword">if</span> i==k: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> verts:</span><br><span class="line">                    <span class="comment"># 若存在 edges[i][j] 不用再计算一遍</span></span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">in</span> [i, k] <span class="keyword">or</span> j <span class="keyword">in</span> edges[i]: <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 同时存在 edges[i][k] edges[k][j] 时更新</span></span><br><span class="line">                    <span class="keyword">if</span> k <span class="keyword">in</span> edges[i] <span class="keyword">and</span> j <span class="keyword">in</span> edges[k]:</span><br><span class="line">                        edges[i][j] = edges[i][k]*edges[k][j]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> a==b <span class="keyword">and</span> a <span class="keyword">in</span> verts <span class="keyword">and</span> b <span class="keyword">in</span> verts: res.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> a <span class="keyword">in</span> edges <span class="keyword">and</span> b <span class="keyword">in</span> edges[a]: res.append(edges[a][b])</span><br><span class="line">            <span class="keyword">else</span>: res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        edges = collections.defaultdict(dict)</span><br><span class="line">        verts = set()</span><br><span class="line">        <span class="keyword">for</span> (a, b), c <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            edges[a][b] = c</span><br><span class="line">            edges[b][a] = <span class="number">1</span>/c</span><br><span class="line">            verts.add(a)</span><br><span class="line">            verts.add(b)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, t)</span>:</span></span><br><span class="line">            visited.add(s)</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> edges[s]: <span class="keyword">return</span> edges[s][t]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> edges[s]:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    temp = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> temp!=<span class="number">-1</span>:</span><br><span class="line">                        edges[s][t] = edges[s][node]*temp</span><br><span class="line">                        <span class="keyword">return</span> edges[s][t]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> verts <span class="keyword">and</span> b <span class="keyword">in</span> verts:</span><br><span class="line">                <span class="keyword">if</span> a==b:res.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited = set()</span><br><span class="line">                    res.append(dfs(a, b))</span><br><span class="line">            <span class="keyword">else</span>: res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="785-判断二分图-力扣（LeetCode）"><a href="#785-判断二分图-力扣（LeetCode）" class="headerlink" title="785. 判断二分图 - 力扣（LeetCode）"></a>785. 判断二分图 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/">BFS + DFS + 并查集，三种方法判断二分图 - 判断二分图 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 染色+xfs 或 并查集</span></span><br><span class="line">        <span class="comment"># 图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        l = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0 没访问，1 -1 表示2种颜色</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 染过色了，跳过</span></span><br><span class="line">            <span class="keyword">if</span> l[i]: <span class="keyword">continue</span></span><br><span class="line">            l[i] = <span class="number">1</span> <span class="comment"># 随便染个 1</span></span><br><span class="line">            <span class="comment"># i 染色后，把相关的所有节点都染上色</span></span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                v = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]:</span><br><span class="line">                    <span class="keyword">if</span> l[w]==<span class="number">0</span>:</span><br><span class="line">                        l[w] = -l[v]</span><br><span class="line">                        queue.append(w)</span><br><span class="line">                    <span class="keyword">elif</span> l[w]==l[v]: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 已经染的色不对劲</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>学会后，并查集还是很好写的，毕竟一半都是模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">101</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> len(graph[i])==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># graph[i] 是 i 顶点的所有邻接点，他们属于同一个集合</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[i]:</span><br><span class="line">                dsu.union(graph[i][<span class="number">0</span>], node)</span><br><span class="line">            <span class="comment"># 但是 i 与他们不是一个集合</span></span><br><span class="line">            <span class="keyword">if</span> dsu.same(i, graph[i][<span class="number">0</span>]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="959-由斜杠划分区域-力扣（LeetCode）"><a href="#959-由斜杠划分区域-力扣（LeetCode）" class="headerlink" title="959. 由斜杠划分区域 - 力扣（LeetCode）"></a>959. 由斜杠划分区域 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/submissions/">959. 由斜杠划分区域 - 力扣（LeetCode）</a></p><p>‘\\‘ \ 有转义的作用，需要写 2 个(md 里为了写 2 个\ 需要写 4 个\)</p><h4 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">30</span>*<span class="number">30</span>*<span class="number">4</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span><span class="params">(self, grid: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        <span class="comment"># 1格 划分为 0123 4个小区间:</span></span><br><span class="line">        <span class="comment"># \ 0 /</span></span><br><span class="line">        <span class="comment"># 1 x 3 </span></span><br><span class="line">        <span class="comment"># / 2 \</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">idx</span><span class="params">(i, j, t)</span>:</span></span><br><span class="line">            <span class="comment"># 返回 i, j 位置的区块在 t(0-3) 的索引</span></span><br><span class="line">            <span class="comment"># 前面有 i 行，左边有 j 大格</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*(m*i+j)+t</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="comment"># 当前格的0和上一行的格的2一定相连</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>: dsu.union(idx(i, j, <span class="number">0</span>), idx(i<span class="number">-1</span>, j, <span class="number">2</span>))</span><br><span class="line">                <span class="comment"># 当前格的1和上一列的格的3一定相连</span></span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>: dsu.union(idx(i, j, <span class="number">1</span>), idx(i, j<span class="number">-1</span>, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'/'</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">1</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">2</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">'\\'</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">1</span>), idx(i, j, <span class="number">2</span>))</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">' '</span>:</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">1</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">2</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">                    dsu.union(idx(i, j, <span class="number">0</span>), idx(i, j, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n*m*<span class="number">4</span>)))</span><br></pre></td></tr></table></figure><h4 id="问题转化"><a href="#问题转化" class="headerlink" title="问题转化"></a>问题转化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGrid</span><span class="params">(grid)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> grid:</span><br><span class="line">        print(l)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span><span class="params">(self, grid: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集没学过，有点难</span></span><br><span class="line">        <span class="comment"># 取巧的办法</span></span><br><span class="line">        <span class="comment"># / 转换成  \ 转换成</span></span><br><span class="line">        <span class="comment"># 0 0 1   1 0 0</span></span><br><span class="line">        <span class="comment"># 0 1 0   0 1 0</span></span><br><span class="line">        <span class="comment"># 1 0 0   0 0 1</span></span><br><span class="line">        <span class="comment"># 再查找 0 组成的岛屿</span></span><br><span class="line">        <span class="comment"># 思路是不难了，但是解题过程也挺复杂</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">islandNum</span><span class="params">(grid)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=i&lt;n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">or</span> grid[i][j]==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                grid[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>]]:</span><br><span class="line">                    dfs(i+di, j+dj)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            n = len(grid)</span><br><span class="line">            <span class="keyword">return</span> sum(dfs(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        n = len(grid)</span><br><span class="line">        grid3 = [[<span class="number">0</span>]*(<span class="number">3</span>*n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>*n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'/'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        grid3[<span class="number">3</span>*i+k][<span class="number">3</span>*j+<span class="number">2</span>-k] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> grid[i][j]==<span class="string">'\\'</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        grid3[<span class="number">3</span>*i+k][<span class="number">3</span>*j+k] = <span class="number">1</span></span><br><span class="line">        printGrid(grid3)</span><br><span class="line">        <span class="keyword">return</span> islandNum(grid3)</span><br></pre></td></tr></table></figure><h3 id="947-移除最多的同行或同列石头-力扣（LeetCode）"><a href="#947-移除最多的同行或同列石头-力扣（LeetCode）" class="headerlink" title="947. 移除最多的同行或同列石头 - 力扣（LeetCode）"></a>947. 移除最多的同行或同列石头 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/submissions/">947. 移除最多的同行或同列石头 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">1000</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeStones</span><span class="params">(self, stones: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 并查集的题目都这么难懂吗, 题意理解，见↓</span></span><br><span class="line">        <span class="comment"># [Python，DFS解法，用时仅为68ms，大量注释 - 移除最多的同行或同列石头 - 力扣（LeetCode）]</span></span><br><span class="line">        <span class="comment"># (https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/pythondfsjie-fa-yong-shi-jin-wei-68msda-liang-zhu-/)</span></span><br><span class="line">        <span class="comment"># 横坐标 或 纵坐标 相等即为连通</span></span><br><span class="line">        <span class="comment"># 对于任何容量为n 的一个连通分量，最后剩下 1 个石头，即可以移除的石头数都为n-1</span></span><br><span class="line">        <span class="comment"># 可以移走的石头数 = 总石头数 - 剩余石头数 = stones列表长度 - 连通分量个数</span></span><br><span class="line">        di, dj = &#123;&#125;, &#123;&#125; <span class="comment"># 同 i 或 同 j 的点, 记录一个就好</span></span><br><span class="line">        <span class="comment"># d = defaultdict(dict) # d[i][j] = idx # ij -&gt; dsu 的索引</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> stones:</span><br><span class="line">            <span class="comment"># i 行已经有元素的话，与那个元素合并</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> di: dsu.union(idx, di[i])</span><br><span class="line">            <span class="keyword">else</span>: di[i] = idx</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> dj: dsu.union(idx, dj[j])</span><br><span class="line">            <span class="keyword">else</span>: dj[j] = idx</span><br><span class="line"></span><br><span class="line">            <span class="comment"># d[i][j] = idx</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(stones)-len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(idx)))</span><br></pre></td></tr></table></figure><h3 id="990-等式方程的可满足性-力扣（LeetCode）"><a href="#990-等式方程的可满足性-力扣（LeetCode）" class="headerlink" title="990. 等式方程的可满足性 - 力扣（LeetCode）"></a>990. 等式方程的可满足性 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/submissions/">990. 等式方程的可满足性 - 力扣（LeetCode）</a></p><p>不知为什么，我的并查集一直挺慢的</p><p>看其他解答里有个路径压缩，不知道是什么意思</p><p><img src="https://i.loli.net/2020/08/05/nEkIJP5tsApYUBG.png" alt="image-20200805172512601"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.p = list(range(<span class="number">26</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="comment"># 先遍历一遍，处理 ==</span></span><br><span class="line">        <span class="keyword">for</span> a, t, _, b <span class="keyword">in</span> equations:</span><br><span class="line">            a, b = ord(a)-ord(<span class="string">'a'</span>), ord(b)-ord(<span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">if</span> t==<span class="string">'!'</span>:</span><br><span class="line">                <span class="keyword">if</span> dsu.find(a)==dsu.find(b): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dsu.union(a, b)</span><br><span class="line">        <span class="keyword">for</span> a, t, _, b <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> t==<span class="string">'='</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> dsu.find(ord(a)-ord(<span class="string">'a'</span>))==dsu.find(ord(b)-ord(<span class="string">'a'</span>)): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.p[self.p[x]] <span class="comment"># 隔代路径压缩</span></span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="1319-连通网络的操作次数-力扣（LeetCode）"><a href="#1319-连通网络的操作次数-力扣（LeetCode）" class="headerlink" title="1319. 连通网络的操作次数 - 力扣（LeetCode）"></a>1319. 连通网络的操作次数 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/submissions/">1319. 连通网络的操作次数 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最少 n-1 根线</span></span><br><span class="line">        <span class="keyword">if</span> len(connections)&lt;n<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># return x-1  x:x个集群</span></span><br><span class="line">        dsu = DSU(n)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        <span class="keyword">return</span> len(set(dsu.find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)))<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>改进，在 dsu 里面维护连通分量的个数 n, 合并一个n就减一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        px, py = map(self.find, (x, y))</span><br><span class="line">        <span class="keyword">if</span> px!=py:</span><br><span class="line">            self.p[px] = py</span><br><span class="line">            self.n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最少 n-1 根线</span></span><br><span class="line">        <span class="keyword">if</span> len(connections)&lt;n<span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># return x-1  x:x个连通分量</span></span><br><span class="line">        dsu = DSU(n)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        <span class="comment"># return len(set(dsu.find(i) for i in range(n)))-1</span></span><br><span class="line">        <span class="keyword">return</span> dsu.n<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1202-交换字符串中的元素-力扣（LeetCode）"><a href="#1202-交换字符串中的元素-力扣（LeetCode）" class="headerlink" title="1202. 交换字符串中的元素 - 力扣（LeetCode）"></a>1202. 交换字符串中的元素 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/submissions/">1202. 交换字符串中的元素 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 连通分量内字母排序</span></span><br><span class="line">        dsu = DSU(len(s))</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.union(a, b)</span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            d[dsu.find(i)].append(s[i])</span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> d:</span><br><span class="line">            d[root].sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            res.append(d[dsu.find(i)].pop())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="面试题-17-07-婴儿名字-力扣（LeetCode）"><a href="#面试题-17-07-婴儿名字-力扣（LeetCode）" class="headerlink" title="面试题 17.07. 婴儿名字 - 力扣（LeetCode）"></a>面试题 17.07. 婴儿名字 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/baby-names-lcci/submissions/">面试题 17.07. 婴儿名字 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trulyMostPopular</span><span class="params">(self, names: List[str], synonyms: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        l = [] <span class="comment"># idx -&gt; name</span></span><br><span class="line">        name_idx = &#123;&#125; <span class="comment"># name -&gt; idx</span></span><br><span class="line">        dsu = DSU(len(synonyms)*<span class="number">2</span>)</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> synonyms:</span><br><span class="line">            i = i.strip(<span class="string">'()'</span>).split(<span class="string">','</span>)</span><br><span class="line">            idxs = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> name_idx:</span><br><span class="line">                    name_idx[j] = idx</span><br><span class="line">                    idxs.append(idx)</span><br><span class="line">                    l.append(j)</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: idxs.append(name_idx[j])</span><br><span class="line">            dsu.union(*idxs)</span><br><span class="line">        d = collections.defaultdict(list) <span class="comment"># root -&gt; [names]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">            d[dsu.find(i)].append(l[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">            d[i] = [min(d[i])]</span><br><span class="line">        <span class="comment"># d: root-&gt; [min(names)]</span></span><br><span class="line">        <span class="comment"># d1: root-&gt; num</span></span><br><span class="line">        d1 = collections.defaultdict(int)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> names:</span><br><span class="line">            name, n = s.strip(<span class="string">')'</span>).split(<span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> name_idx:</span><br><span class="line">                res.append(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d1[dsu.find(name_idx[name])] += int(n)</span><br><span class="line">        <span class="keyword">for</span> root <span class="keyword">in</span> d1:</span><br><span class="line">            name = d[root][<span class="number">0</span>]</span><br><span class="line">            n = d1[root]</span><br><span class="line">            res.append(<span class="string">f'<span class="subst">&#123;name&#125;</span>(<span class="subst">&#123;n&#125;</span>)'</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="130-被围绕的区域-力扣（LeetCode）"><a href="#130-被围绕的区域-力扣（LeetCode）" class="headerlink" title="130. 被围绕的区域 - 力扣（LeetCode）"></a>130. 被围绕的区域 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/surrounded-regions/submissions/">130. 被围绕的区域 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.p = list(range(n))</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.p[self.find(x)] = self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)==self.find(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 连接相通的元素，并记录边缘的元素</span></span><br><span class="line">        <span class="comment"># 排除与 边缘的元素 同 root 的元素（dsu 长度可以额外多一个，作为需要移除的集合）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]: <span class="keyword">return</span> board</span><br><span class="line">        n, m = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        dsu = DSU(n*m+<span class="number">1</span>)</span><br><span class="line">        exclude_idx = n*m</span><br><span class="line">        oidx = [] <span class="comment"># 是 O 的idx</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">border</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i <span class="keyword">in</span> [<span class="number">0</span>, n<span class="number">-1</span>] <span class="keyword">or</span> j <span class="keyword">in</span> [<span class="number">0</span>, m<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'X'</span>: <span class="keyword">continue</span></span><br><span class="line">                curidx = i*m+j</span><br><span class="line">                oidx.append(curidx)</span><br><span class="line">                <span class="keyword">if</span> border(i, j): dsu.union(curidx, exclude_idx)</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>: dsu.union(curidx, curidx-m)</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>: dsu.union(curidx, curidx<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> oidx:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dsu.same(idx, exclude_idx):</span><br><span class="line">                i, j = divmod(idx, m)</span><br><span class="line">                board[i][j] = <span class="string">'X'</span></span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>从这里学到的</p><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/shi-yong-bing-cha-ji-chu-li-bu-xiang-jiao-ji-he-we/">使用并查集处理不相交集合问题（Java、Python） - 等式方程的可满足性 - 力扣（LeetCode）</a></p><img src="https://i.loli.net/2020/08/05/P7AFpdojx1XRETK.png" alt="image-20200805173254139" style="zoom:50%;" /><p>一道题目路径压缩后的性能:</p><img src="https://i.loli.net/2020/08/05/8PAOY956GUrMZh4.png" alt="image-20200805173217140" style="zoom:50%;" /><h3 id="python-版的路径压缩"><a href="#python-版的路径压缩" class="headerlink" title="python 版的路径压缩"></a>python 版的路径压缩</h3><h3 id="隔代路径压缩"><a href="#隔代路径压缩" class="headerlink" title="隔代路径压缩"></a>隔代路径压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.p[self.p[x]]</span><br><span class="line">            x = self.p[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="完全路径压缩"><a href="#完全路径压缩" class="headerlink" title="完全路径压缩"></a>完全路径压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>打家劫舍</title>
    <link href="https://zronghui.github.io/leetcode/%E5%85%B6%E4%BB%96/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%85%B6%E4%BB%96/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</id>
    <published>2020-08-05T07:48:59.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>打家劫舍 三连击</p><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III - 力扣（LeetCode）</a></p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#   1 2 3 1</span></span><br><span class="line">        <span class="comment"># 0 1 2 4 4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        a, b = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            t = max(b, a+i)</span><br><span class="line">            a, b = b, t</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max(self.rob1(nums[<span class="number">1</span>:]), self.rob1(nums[:<span class="number">-1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob1</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#   1 2 3 1</span></span><br><span class="line">        <span class="comment"># 0 1 2 4 4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        a, b = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            t = max(b, a+i)</span><br><span class="line">            a, b = b, t</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><a href="https://leetcode-cn.com/problems/house-robber-iii/solution/di-gui-chu-li-fan-hui-tou-yu-bu-tou-liang-chong-ji/">递归处理-返回偷与不偷两种结果（Python3） - 打家劫舍 III - 力扣（LeetCode）</a></p><p>递归处理，返回当前节点偷与不偷的两个结果，取其中最大的一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="comment"># [偷, 不偷]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            left, right = map(helper, [node.left, node.right])</span><br><span class="line">            <span class="keyword">return</span> [left[<span class="number">1</span>]+right[<span class="number">1</span>], left[<span class="number">0</span>]+right[<span class="number">0</span>]+node.val]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(helper(root))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="其他" scheme="https://zronghui.github.io/categories/leetcode/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode模板 by 负雪明烛</title>
    <link href="https://zronghui.github.io/leetcode/leetcode%E6%A8%A1%E6%9D%BF-by-%E8%B4%9F%E9%9B%AA%E6%98%8E%E7%83%9B.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode%E6%A8%A1%E6%9D%BF-by-%E8%B4%9F%E9%9B%AA%E6%98%8E%E7%83%9B.html</id>
    <published>2020-08-02T06:35:28.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729">blog.csdn.net</a></p></blockquote><p>本文的目的是收集一些典型的题目，记住其写法，理解其思想，即可做到一通百通。欢迎大家提出宝贵意见！</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>最明显的题目就是 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/83273084">34. Find First and Last Position of Element in Sorted Array</a></p><p>花花酱的二分查找专题视频：<a href="https://www.youtube.com/watch?v=v57lNF2mb_s">https://www.youtube.com/watch?v=v57lNF2mb_s</a></p><p>模板：</p><p>区间定义：<code>[l, r) 左闭右开</code></p><p>其中 f(m) 函数代表找到了满足条件的情况，有这个条件的判断就返回对应的位置，如果没有这个条件的判断就是 lowwer_bound 和 higher_bound.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(l, r)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = l + (r - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> f(m):    <span class="comment"># 判断找了没有，optional</span></span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="keyword">if</span> g(m):</span><br><span class="line">            r = m   <span class="comment"># new range [l, m)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span> <span class="comment"># new range [m+1, r)</span></span><br><span class="line">    <span class="keyword">return</span> l    <span class="comment"># or not found</span></span><br></pre></td></tr></table></figure><p><strong>lower bound</strong>: find index of i, such that <code>A[i] &gt;= x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowwer_bound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="comment"># find in range [left, right)</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>upper bound</strong>: find index of i, such that <code>A[i] &gt; x</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">higher_bound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    <span class="comment"># find in range [left, right)</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>比如，题目 <a href="https://blog.csdn.net/fuxuemingzhu/article/details/79254648">69. Sqrt(x)</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, x + <span class="number">1</span></span><br><span class="line">        <span class="comment"># [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> mid ** <span class="number">2</span> &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="排序的写法"><a href="#排序的写法" class="headerlink" title="排序的写法"></a>排序的写法</h1><p>C++ 的排序方法，使用 sort 并且重写 comparator，如果需要使用外部变量，需要在中括号中放入 &amp;。</p><p>题目 451. Sort Characters By Frequency。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string frequencySort(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (char c : s) ++m[c];</span><br><span class="line">        sort(s.begin(), s.end(), [&amp;](char&amp; a, char&amp; b)&#123;</span><br><span class="line">            return m[a] &gt; m[b] || (m[a] &#x3D;&#x3D; m[b] &amp;&amp; a &lt; b);</span><br><span class="line">        &#125;);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="BFS-的写法"><a href="#BFS-的写法" class="headerlink" title="BFS 的写法"></a>BFS 的写法</h1><p>下面的这个写法是在一个邻接矩阵中找出离某一个点距离是 k 的点。</p><p>来自文章：<a href="https://blog.csdn.net/fuxuemingzhu/article/details/82709619">【LeetCode】863. All Nodes Distance K in Binary Tree 解题报告（Python）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS</span></span><br><span class="line">bfs = [target.val]</span><br><span class="line">visited = set([target.val])</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">    bfs = [y <span class="keyword">for</span> x <span class="keyword">in</span> bfs <span class="keyword">for</span> y <span class="keyword">in</span> conn[x] <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">    visited |= set(bfs)</span><br><span class="line"><span class="keyword">return</span> bfs</span><br></pre></td></tr></table></figure><ol start="127"><li>Word Ladder</li></ol><p>在 BFS 中保存已走过的步，并把已经走的合法路径删除掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        wordset = set(wordList)</span><br><span class="line">        bfs = collections.deque()</span><br><span class="line">        bfs.append((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> bfs:</span><br><span class="line">            word, length = bfs.popleft()</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> length</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>:</span><br><span class="line">                    newWord = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newWord <span class="keyword">in</span> wordset <span class="keyword">and</span> newWord != word:</span><br><span class="line">                        wordset.remove(newWord)</span><br><span class="line">                        bfs.append((newWord, length + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82926674">778. Swim in Rising Water</a></p><p>使用优先级队列来优先走比较矮的路，最后保存最高的那个格子的高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        visited, pq = set((<span class="number">0</span>, <span class="number">0</span>)), [(grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            T, i, j = heapq.heappop(pq)</span><br><span class="line">            res = max(res, T)</span><br><span class="line">            directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">            <span class="keyword">if</span> i == j == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> dir <span class="keyword">in</span> directions:</span><br><span class="line">                x, y = i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> (x, y) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                heapq.heappush(pq, (grid[x][y], x, y))</span><br><span class="line">                visited.add((x, y))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82939203">847. Shortest Path Visiting All Nodes</a></p><p>需要找出某顶点到其他顶点的最短路径。出发顶点不是确定的，每个顶点有可能访问多次。使用 N 位 bit 代表访问过的顶点的状态。如果到达了最终状态，那么现在步数就是所求。这个题把所有的节点都放入了起始队列中，相当于每次都是所有的顶点向前走一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathLength</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(graph)</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        goal = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span></span><br><span class="line">        visited = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; N)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            que.append((i, <span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            s = len(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">                node, state = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> state == goal:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                <span class="keyword">if</span> visited[node][state]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited[node][state] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> nextNode <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    que.append((nextNode, state | (<span class="number">1</span> &lt;&lt; nextNode)))</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/81022170">429. N-ary Tree Level Order Traversal</a> 多叉树的层次遍历，这个 BFS 写法我觉得很经典。适合记忆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, children):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        que = collections.deque()</span><br><span class="line">        que.append(root)</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            level = []</span><br><span class="line">            size = len(que)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">                    que.append(child)</span><br><span class="line">            <span class="keyword">if</span> level:</span><br><span class="line">                res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="DFS-的写法"><a href="#DFS-的写法" class="headerlink" title="DFS 的写法"></a>DFS 的写法</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82917210">329. Longest Increasing Path in a Matrix</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82917037">417. Pacific Atlantic Water Flow</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82926674">778. Swim in Rising Water</a></p><p>二分查找 + DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        left, right = <span class="number">0</span>, n * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs([[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], grid, mid, n, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, visited, grid, mid, n, i, j)</span>:</span></span><br><span class="line">        visited[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> dir <span class="keyword">in</span> directions:</span><br><span class="line">            x, y = i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> visited[x][y] <span class="keyword">or</span> max(mid, grid[i][j]) != max(mid, grid[x][y]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.dfs(visited, grid, mid, n, x, y):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>下面这个题使用了回溯法，但是写的不够简单干练，遇到更好的解法的时候，要把这个题进行更新。</p><p>这个回溯思想，先去添加一个新的状态，看在这个状态的基础上，能不能找结果，如果找不到结果的话，那么就回退，即把这个结果和访问的记录给去掉。这个题使用了 return True 的方法让我们知道已经找出了结果，所以不用再递归了。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82945477">753. Cracking the Safe</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crackSafe</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="string">"0"</span>] * n</span><br><span class="line">        size = k ** n</span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(<span class="string">""</span>.join(res))</span><br><span class="line">        <span class="keyword">if</span> self.dfs(res, visited, size, n, k):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, res, visited, size, n, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(visited) == size:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        node = <span class="string">""</span>.join(res[len(res) - n + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            node = node + str(i)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                res.append(str(i))</span><br><span class="line">                visited.add(node)</span><br><span class="line">                <span class="keyword">if</span> self.dfs(res, visited, size, n, k):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                res.pop()</span><br><span class="line">                visited.remove(node)</span><br><span class="line">            node = node[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82928879">312. Burst Balloons</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxCoins(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        nums.insert(0, 1)</span><br><span class="line">        nums.append(1)</span><br><span class="line">        c &#x3D; [[0] * (n + 2) for _ in range(n + 2)]</span><br><span class="line">        return self.dfs(nums, c, 1, n)</span><br><span class="line">        </span><br><span class="line">    def dfs(self, nums, c, i, j):</span><br><span class="line">        if i &gt; j: return 0</span><br><span class="line">        if c[i][j] &gt; 0: return c[i][j]</span><br><span class="line">        if i &#x3D;&#x3D; j: return nums[i - 1] * nums[i] * nums[i + 1]</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        for k in range(i, j + 1):</span><br><span class="line">            res &#x3D; max(res, self.dfs(nums, c, i, k - 1) + nums[i - 1] * nums[k] * nums[j + 1] + self.dfs(nums, c, k + 1, j))</span><br><span class="line">        c[i][j] &#x3D; res</span><br><span class="line">        return c[i][j]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countArrangement(int N) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        vector&lt;int&gt; visited(N + 1, 0);</span><br><span class="line">        helper(N, visited, 1, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void helper(int N, vector&lt;int&gt;&amp; visited, int pos, int&amp; res) &#123;</span><br><span class="line">        if (pos &gt; N) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123;</span><br><span class="line">            if (visited[i] &#x3D;&#x3D; 0 &amp;&amp; (i % pos &#x3D;&#x3D; 0 || pos % i &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                helper(N, visited, pos + 1, res);</span><br><span class="line">                visited[i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果需要保存路径的回溯法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        const int N &#x3D; nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        vector&lt;int&gt; visited(N, 0);</span><br><span class="line">        dfs(nums, 0, visited, res, path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; path) &#123;</span><br><span class="line">        const int N &#x3D; nums.size();</span><br><span class="line">        if (pos &#x3D;&#x3D; N) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                path.push_back(nums[i]);</span><br><span class="line">                dfs(nums, pos + 1, visited, res, path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                visited[i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79052953">617. Merge Two Binary Trees</a> 把两个树重叠，重叠部分求和，不重叠部分是两个树不空的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        newT = TreeNode(t1.val + t2.val)</span><br><span class="line">        newT.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        newT.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> newT</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/51284488">226. Invert Binary Tree</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/72575422">144. Binary Tree Preorder Traversal</a></p><p>迭代写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79294461">94. Binary Tree Inorder Traversal</a></p><p>迭代写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> answer</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            answer.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101079767">145. Binary Tree Postorder Traversal</a></p><p>迭代写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (!root) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode* node &#x3D; st.top(); st.pop();</span><br><span class="line">            if (!node) continue;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构建完全二叉树"><a href="#构建完全二叉树" class="headerlink" title="构建完全二叉树"></a>构建完全二叉树</h1><p>完全二叉树是每一层都满的，因此找出要插入节点的父亲节点是很简单的。如果用数组 tree 保存着所有节点的层次遍历，那么新节点的父亲节点就是 tree[(N -1)/2]，N 是未插入该节点前的树的元素个数。<br>构建树的时候使用层次遍历，也就是 BFS 把所有的节点放入到 tree 里。插入的时候直接计算出新节点的父亲节点。获取 root 就是数组中的第 0 个节点。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82958284">919. Complete Binary Tree Inserter</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.tree = list()</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            self.tree.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _len = len(self.tree)</span><br><span class="line">        father = self.tree[(_len - <span class="number">1</span>) / <span class="number">2</span>]</span><br><span class="line">        node = TreeNode(v)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> father.left:</span><br><span class="line">            father.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            father.right = node</span><br><span class="line">        self.tree.append(node)</span><br><span class="line">        <span class="keyword">return</span> father.val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CBTInserter(root)</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(v)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get_root()</span></span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>不包含 rank 的话，代码很简短，应该背会。</p><ol start="721"><li><p>Accounts Merge  </p><p><a href="https://leetcode.com/articles/accounts-merge/">https://leetcode.com/articles/accounts-merge/</a></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != self.par[x]:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br></pre></td></tr></table></figure><p>C++ 版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; map_; &#x2F;&#x2F;i的parent，默认是i</span><br><span class="line">int f(int a) &#123;</span><br><span class="line">    if (map_[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    return f(map_[a]);</span><br><span class="line">&#125;</span><br><span class="line">void u(int a, int b) &#123;</span><br><span class="line">    int pa &#x3D; f(a);</span><br><span class="line">    int pb &#x3D; f(b);</span><br><span class="line">    if (pa &#x3D;&#x3D; pb)</span><br><span class="line">        return;</span><br><span class="line">    map_[pa] &#x3D; pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含 rank 的，这里的 rank 表示树的高度：</p><p><a href="https://leetcode.com/articles/redundant-connection/">684. Redundant Connection</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">        self.rnk = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        xr, yr = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> xr == yr:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &lt; self.rnk[yr]:</span><br><span class="line">            self.par[xr] = yr</span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &gt; self.rnk[yr]:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">            self.rnk[xr] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>另外一种 rank 方法是，保存树中节点的个数。</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/70258103">547. Friend Circles</a>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        N = len(M)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, N):</span><br><span class="line">                <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                    dsu.u(i, j)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> dsu.f(i) == i:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = range(<span class="number">201</span>)</span><br><span class="line">        self.r = [<span class="number">0</span>] * <span class="number">201</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a == self.d[a] <span class="keyword">else</span> self.f(self.d[a])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        pa = self.f(a)</span><br><span class="line">        pb = self.f(b)</span><br><span class="line">        <span class="keyword">if</span> (pa == pb):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.r[pa] &lt; self.r[pb]:</span><br><span class="line">            self.d[pa] = pb</span><br><span class="line">            self.r[pb] += self.r[pa]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d[pb] = pa</span><br><span class="line">            self.r[pa] += self.r[pb]</span><br></pre></td></tr></table></figure><h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p>前缀树的题目可以使用字典解决，代码还是需要背一下的，C++ 版本的前缀树如下：</p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79388432">208. Implement Trie (Prefix Tree)</a> 这个题是纯考 Trie 的。参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TrieNode*&gt; child;</span><br><span class="line">    bool isWord;</span><br><span class="line">    TrieNode() : isWord(false), child(26, nullptr) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TrieNode() &#123;</span><br><span class="line">        for (auto&amp; c : child)</span><br><span class="line">            delete c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Trie &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root &#x3D; new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Inserts a word into the trie. *&#x2F;</span><br><span class="line">    void insert(string word) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : word) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                p-&gt;child[i] &#x3D; new TrieNode();</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if the word is in the trie. *&#x2F;</span><br><span class="line">    bool search(string word) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : word) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                return false;</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;</span><br><span class="line">    bool startsWith(string prefix) &#123;</span><br><span class="line">        TrieNode* p &#x3D; root;</span><br><span class="line">        for (char a : prefix) &#123;</span><br><span class="line">            int i &#x3D; a - &#39;a&#39;;</span><br><span class="line">            if (!p-&gt;child[i])</span><br><span class="line">                return false;</span><br><span class="line">            p &#x3D; p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj &#x3D; new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * bool param_2 &#x3D; obj.search(word);</span><br><span class="line"> * bool param_3 &#x3D; obj.startsWith(prefix);</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79436619">677. Map Sum Pairs</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MapSum &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    MapSum() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void insert(string key, int val) &#123;</span><br><span class="line">        int inc &#x3D; val - vals_[key];</span><br><span class="line">        Trie* p &#x3D; &amp;root;</span><br><span class="line">        for (const char c : key) &#123;</span><br><span class="line">            if (!p-&gt;children[c])</span><br><span class="line">                p-&gt;children[c] &#x3D; new Trie();</span><br><span class="line">            p-&gt;children[c]-&gt;sum +&#x3D; inc;</span><br><span class="line">            p &#x3D; p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        vals_[key] &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sum(string prefix) &#123;</span><br><span class="line">        Trie* p &#x3D; &amp;root;</span><br><span class="line">        for (const char c : prefix) &#123;</span><br><span class="line">            if (!p-&gt;children[c])</span><br><span class="line">                return 0;</span><br><span class="line">            p &#x3D; p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    struct Trie &#123;</span><br><span class="line">        Trie():children(128, nullptr), sum(0)&#123;&#125;</span><br><span class="line">        ~Trie()&#123;</span><br><span class="line">            for (auto child : children)</span><br><span class="line">                if (child) delete child;</span><br><span class="line">            children.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;Trie*&gt; children;</span><br><span class="line">        int sum;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Trie root;</span><br><span class="line">    unordered_map&lt;string, int&gt; vals_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82862769">743. Network Delay Time</a> 这个题很详细。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>时间复杂度是 O(N ^ 2 + E)，空间复杂度是 O(N+E).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        K -= <span class="number">1</span></span><br><span class="line">        nodes = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</span><br><span class="line">            nodes[u - <span class="number">1</span>].append((v - <span class="number">1</span>, w))</span><br><span class="line">        dist = [float(<span class="string">'inf'</span>)] * N</span><br><span class="line">        dist[K] = <span class="number">0</span></span><br><span class="line">        done = set()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            smallest = min((d, i) <span class="keyword">for</span> (i, d) <span class="keyword">in</span> enumerate(dist) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> done)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> v, w <span class="keyword">in</span> nodes[smallest]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> done <span class="keyword">and</span> dist[smallest] + w &lt; dist[v]:</span><br><span class="line">                    dist[v] = dist[smallest] + w</span><br><span class="line">            done.add(smallest)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> dist <span class="keyword">else</span> max(dist)</span><br></pre></td></tr></table></figure><h2 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h2><p>时间复杂度 O(n^3)， 空间复杂度 O(n^2)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = [[float(<span class="string">'inf'</span>)] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">            u, v, w = time[<span class="number">0</span>] - <span class="number">1</span>, time[<span class="number">1</span>] - <span class="number">1</span>, time[<span class="number">2</span>]</span><br><span class="line">            d[u][v] = w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            d[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> d[K - <span class="number">1</span>] <span class="keyword">else</span> max(d[K - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>时间复杂度 O(ne)， 空间复杂度 O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type times: List[List[int]]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dist = [float(<span class="string">'inf'</span>)] * N</span><br><span class="line">        dist[K - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">                u = time[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                v = time[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                w = time[<span class="number">2</span>]</span><br><span class="line">                dist[v] = min(dist[v], dist[u] + w)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> float(<span class="string">'inf'</span>) <span class="keyword">in</span> dist <span class="keyword">else</span> max(dist)</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101214765">1135. Connecting Cities With Minimum Cost</a></p><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; &amp; a,vector&lt;int&gt; &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int find(vector&lt;int&gt; &amp; f,int x)&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool uni(vector&lt;int&gt; &amp; f,int x,int y)&#123;</span><br><span class="line">        int x1 = find(f,x);</span><br><span class="line">        int y1 = find(f,y);</span><br><span class="line">        f[x1] = y1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int minimumCost(int N, vector&lt;vector&lt;int&gt;&gt;&amp; conections) &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        int count = <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; father(N+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sort(conections.begin(),conections.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt;= N; ++i)&#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(auto conect : conections)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find(father,conect[<span class="number">0</span>]) != find(father,conect[<span class="number">1</span>]))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                ans += conect[<span class="number">2</span>];</span><br><span class="line">                uni(father,conect[<span class="number">0</span>],conect[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(count == N<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct cmp &#123;</span><br><span class="line">    bool operator () (const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &gt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minimumCost(int N, vector&lt;vector&lt;int&gt;&gt;&amp; conections) &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        int selected = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; edgs(N+<span class="number">1</span>,vector&lt;pair&lt;int,int&gt;&gt;());</span><br><span class="line">        priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;,cmp&gt; pq;</span><br><span class="line">        vector&lt;bool&gt; visit(N+<span class="number">1</span>,false);</span><br><span class="line">        </span><br><span class="line">        /*initial*/</span><br><span class="line">        <span class="keyword">for</span>(auto re : conections)&#123;</span><br><span class="line">            edgs[re[<span class="number">0</span>]].push_back(make_pair(re[<span class="number">1</span>],re[<span class="number">2</span>]));</span><br><span class="line">            edgs[re[<span class="number">1</span>]].push_back(make_pair(re[<span class="number">0</span>],re[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(edgs[<span class="number">1</span>].size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*kruskal*/</span><br><span class="line">        selected = <span class="number">1</span>;</span><br><span class="line">        visit[<span class="number">1</span>] = true;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; edgs[<span class="number">1</span>].size(); ++i)&#123;</span><br><span class="line">            pq.push(vector&lt;int&gt;(&#123;<span class="number">1</span>,edgs[<span class="number">1</span>][i].first,edgs[<span class="number">1</span>][i].second&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!visit[curr[<span class="number">1</span>]])&#123;</span><br><span class="line">                visit[curr[<span class="number">1</span>]] = true;</span><br><span class="line">                ans += curr[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span>(auto e : edgs[curr[<span class="number">1</span>]])&#123;</span><br><span class="line">                    pq.push(vector&lt;int&gt;(&#123;curr[<span class="number">1</span>],e.first,e.second&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">                selected++;</span><br><span class="line">                <span class="keyword">if</span>(selected == N)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>BFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, N, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N,: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        indegrees = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[v].append(u)</span><br><span class="line">            indegrees[u] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            zeroDegree = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">if</span> indegrees[j] == <span class="number">0</span>:</span><br><span class="line">                    zeroDegree = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> zeroDegree: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            indegrees[j] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[j]:</span><br><span class="line">                indegrees[node] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>DFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, N, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N,: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">        <span class="comment"># 0 = Unknown, 1 = visiting, 2 = visited</span></span><br><span class="line">        visited = [<span class="number">0</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Can we add node i to visited successfully?</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, visited, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited[i] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果需要保存拓扑排序的路径：</p><p>BFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        indegrees = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[v].append(u)</span><br><span class="line">            indegrees[u] += <span class="number">1</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            zeroDegree = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(numCourses):</span><br><span class="line">                <span class="keyword">if</span> indegrees[j] == <span class="number">0</span>:</span><br><span class="line">                    zeroDegree = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> zeroDegree:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            indegrees[j] -= <span class="number">1</span></span><br><span class="line">            path.append(j)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[j]:</span><br><span class="line">                indegrees[node] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure><p>DFS 方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">        <span class="comment"># 0 = Unknown, 1 = visiting, 2 = visited</span></span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, i, path):</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, visited, i, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, j, path):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited[i] = <span class="number">2</span></span><br><span class="line">        path.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82951771">207. Course Schedule</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83302328">210. Course Schedule II</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83548874">310. Minimum Height Trees</a></p><h1 id="查找子字符串，双指针模板"><a href="#查找子字符串，双指针模板" class="headerlink" title="查找子字符串，双指针模板"></a>查找子字符串，双指针模板</h1><p>这是一个[模板](<a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;">https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;</a> rel=)，里面的 map 如果是双指针范围内的字符串字频的话，增加和减少的方式如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int findSubstring(string s)&#123;</span><br><span class="line">        vector&lt;int&gt; map(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        int counter; // check whether the substring <span class="keyword">is</span> valid</span><br><span class="line">        int begin=<span class="number">0</span>, end=<span class="number">0</span>; //two pointers, one point to tail <span class="keyword">and</span> one  head</span><br><span class="line">        int d; //the length of substring</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>() &#123; /* initialize the hash map here */ &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line"></span><br><span class="line">            if(map[s[end++]]++ ?)&#123;  /* modify counter here */ &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(/* counter condition */)&#123; </span><br><span class="line">                 </span><br><span class="line">                 /* update d here <span class="keyword">if</span> finding minimum*/</span><br><span class="line"></span><br><span class="line">                //increase begin to make it invalid/valid again</span><br><span class="line">                </span><br><span class="line">                if(map[s[begin++]]-- ?)&#123; /*modify counter here*/ &#125;</span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            /* update d here <span class="keyword">if</span> finding maximum*/</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82931106">76. Minimum Window Substring</a></p><p>这个题的 map 是 t 的字频，所以使用 map 更方式和上是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        left, cnt, minLen = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        count = collections.Counter(t)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            count[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[c] &gt;= <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt == len(t):</span><br><span class="line">                <span class="keyword">if</span> minLen &gt; i - left + <span class="number">1</span>:</span><br><span class="line">                    minLen = i - left + <span class="number">1</span></span><br><span class="line">                    res = s[left : i + <span class="number">1</span>]</span><br><span class="line">                count[s[left]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count[s[left]] &gt; <span class="number">0</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="状态搜索"><a href="#状态搜索" class="headerlink" title="状态搜索"></a>状态搜索</h2><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/82747623">688. Knight Probability in Chessboard</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79337352">62. Unique Paths</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83154114">63. Unique Paths II</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83350880">913. Cat and Mouse</a></p><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/83447155">576. Out of Boundary Paths</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            curStatus = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(n):</span><br><span class="line">                    v1 = <span class="number">1</span> <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> dp[x - <span class="number">1</span>][y]</span><br><span class="line">                    v2 = <span class="number">1</span> <span class="keyword">if</span> x == m - <span class="number">1</span> <span class="keyword">else</span> dp[x + <span class="number">1</span>][y]</span><br><span class="line">                    v3 = <span class="number">1</span> <span class="keyword">if</span> y == <span class="number">0</span> <span class="keyword">else</span> dp[x][y - <span class="number">1</span>]</span><br><span class="line">                    v4 = <span class="number">1</span> <span class="keyword">if</span> y == n - <span class="number">1</span> <span class="keyword">else</span> dp[x][y + <span class="number">1</span>]</span><br><span class="line">                    curStatus[x][y] = (v1 + v2 + v3 + v4) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            dp = curStatus</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上加以考虑，他所作出的是在某种意义上的局部最优解。贪心算法和动态规划算法都是由局部最优导出全局最优，这里不得不比较下二者的区别</p><p>贪心算法：  </p><ol><li>贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。  </li><li>由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解</li></ol><p>动态规划算法：  </p><ol><li>全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解  </li><li>动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解  </li><li>边界条件：即最简单的，可以直接得出的局部最优解</li></ol><p>贪心是个思想，没有统一的模板。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-200</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-200.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-200.html</id>
    <published>2020-08-02T02:14:24.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/count-good-triplets/">统计好三元组</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">找出数组游戏的赢家</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a><strong>6</strong></li></ul><p>误触 command + enter 2 次，淦！</p><p>前 10% 都没弄上</p><p><img src="https://i.loli.net/2020/08/02/VpT8KPrOoAkqc2E.png" alt="image-20200802132822189"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countGoodTriplets</span><span class="params">(self, arr: List[int], a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">satisfy</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[i] - arr[j])&gt;a: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[j] - arr[k])&gt;b: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> abs(arr[i] - arr[k])&gt;c: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">return</span> sum(satisfy(i, j, k) <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n<span class="number">-1</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, n))</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinner</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="comment"># 比较 n 次后，arr 结构: max, n1, n2..... </span></span><br><span class="line">        <span class="comment"># 但是不用真实模拟移动过程，只需要记录下标即可</span></span><br><span class="line">        <span class="keyword">if</span> len(arr)==<span class="number">2</span>: <span class="keyword">return</span> max(arr)</span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i]&gt;arr[cur]:</span><br><span class="line">                m[i] += <span class="number">1</span></span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[cur] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> m[cur]==k: <span class="keyword">return</span> arr[cur]</span><br><span class="line">        <span class="keyword">return</span> arr[cur]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 记录每一行后面 0 的个数</span></span><br><span class="line">        <span class="comment"># 分配每一行应该贡献的 0 的个数</span></span><br><span class="line">        <span class="comment"># 如 0 2 2 实际算作 0 2 1</span></span><br><span class="line">        <span class="comment">#   0 2 2 4 4 5 算作 0 2 1 4 3 5</span></span><br><span class="line">        <span class="comment"># 就是说 遇到相同的数字，减一，加进去</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tailZeroNum</span><span class="params">(grid)</span>:</span></span><br><span class="line">            s = set()</span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> reversed(range(n)):</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j]==<span class="number">0</span>: cur += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">                cur = min(n<span class="number">-1</span>, cur)</span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">in</span> s:</span><br><span class="line">                    cur -= <span class="number">1</span></span><br><span class="line">                s.add(cur)</span><br><span class="line">                l.append(cur)</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">        l = tailZeroNum(grid)</span><br><span class="line">        <span class="comment"># print(l)</span></span><br><span class="line">        <span class="keyword">if</span> set(range(n))!=set(l): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(l)):</span><br><span class="line">                <span class="keyword">if</span> l[idx]==i: <span class="keyword">break</span></span><br><span class="line">            res += len(l)<span class="number">-1</span>-idx</span><br><span class="line">            l.remove(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>没看清题，理解错了题意，实际上不算太难<a href="https://leetcode-cn.com/problems/get-the-maximum-score/solution/cshuang-zhi-zhen-fen-duan-tong-ji-zui-da-he-xiang-/">C++双指针 分段统计最大和 相加即可 - 最大得分 - 力扣（LeetCode）</a></p><img src="https://i.loli.net/2020/08/02/TpVlkxoeftSFW6P.png" alt="image-20200802135845039" style="zoom:50%;" /><p>借鉴排行榜的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSum</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; int:</span></span><br><span class="line">        s1, s2 = map(set, (nums1, nums2))</span><br><span class="line">        a1 = a2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(list(s1|s2)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> s1 <span class="keyword">and</span> i <span class="keyword">in</span> s2: a1 = a2 = max(a1, a2)+i</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> s1: a1 += i</span><br><span class="line">            <span class="keyword">else</span>: a2 += i</span><br><span class="line">        <span class="keyword">return</span> max(a1, a2)%int(<span class="number">1e9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/count-good-triplets/&quot;&gt;统计好三元组&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/&quot;&gt;找出数组游戏的赢家&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/&quot;&gt;排布二进制网格的最少交换次数&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/get-the-maximum-score/&quot;&gt;最大得分&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;误触 command + enter 2 次，淦！&lt;/p&gt;
&lt;p&gt;前 10% 都没弄上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/02/VpT8KPrOoAkqc2E.png&quot; alt=&quot;image-20200802132822189&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 148. Sort List</title>
    <link href="https://zronghui.github.io/leetcode-148-Sort-List.html"/>
    <id>https://zronghui.github.io/leetcode-148-Sort-List.html</id>
    <published>2020-08-01T13:26:55.000Z</published>
    <updated>2020-08-03T13:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/sort-list/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/sort-list/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Sort a linked list in <em>O</em> ( <em>n</em> log <em>n</em> ) time using constant space<br>complexity.</p><p><strong>Example 1:</strong></p><pre><code>Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><p><strong>Tags:</strong> Linked List, Sort</p><p><strong>Difficulty:</strong> Medium</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><h3 id="超时写法"><a href="#超时写法" class="headerlink" title="超时写法"></a>超时写法</h3><p>根据<a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表 - 力扣（LeetCode）</a>的 partition 写的</p><p>86题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># dummy1 存 小于 x 的值; dummy &gt;=</span></span><br><span class="line">        cur1, cur2 = dummy1, dummy2</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                cur1.next = head</span><br><span class="line">                cur1 = cur1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur2.next = head</span><br><span class="line">                cur2 = cur2.next</span><br><span class="line">            head = head.next</span><br><span class="line">        cur2.next = <span class="literal">None</span></span><br><span class="line">        cur1.next = dummy2.next</span><br><span class="line">        <span class="keyword">return</span> dummy1.next</span><br></pre></td></tr></table></figure><p>一开始写的死板解法，但是遇到一个 testcase 全是  1，2，3 的链表，超时了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 快速排序</span></span><br><span class="line">        <span class="comment"># return head tail</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="comment"># return head1,tail1,head2,tail2</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(head, x)</span>:</span></span><br><span class="line">                dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># cur 指向那条链最后一个非 None 节点</span></span><br><span class="line">                cur1, cur2 = dummy1, dummy2</span><br><span class="line">                <span class="keyword">while</span> head:</span><br><span class="line">                    <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                        cur1.next = head</span><br><span class="line">                        cur1 = cur1.next</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur2.next = head</span><br><span class="line">                        cur2 = cur2.next</span><br><span class="line">                    head = head.next</span><br><span class="line">                cur1.next = cur2.next = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># head1, head2 可能为 None, tail1, tail2 一定非 None </span></span><br><span class="line">                <span class="keyword">return</span> dummy1.next, cur1, dummy2.next, cur2</span><br><span class="line">            </span><br><span class="line">            tail = head</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head, tail</span><br><span class="line">            head1, tail1, head2, tail2 = partition(head.next, head.val)</span><br><span class="line">            head.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(head1, tail1, head2, tail2)</span></span><br><span class="line">            <span class="keyword">if</span> head1:</span><br><span class="line">                head1, tail1 = quickSort(head1)</span><br><span class="line">                tail1.next = head</span><br><span class="line">            <span class="keyword">if</span> head2:</span><br><span class="line">                head2, tail2 = quickSort(head2)</span><br><span class="line">                head.next = head2</span><br><span class="line">            <span class="keyword">return</span> head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head , tail2 <span class="keyword">if</span> head2 <span class="keyword">else</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quickSort(head)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="优化后的快排"><a href="#优化后的快排" class="headerlink" title="优化后的快排"></a>优化后的快排</h3><p>划分为 small equal large 3个链表，对 small large 递归, 再合并 3 个链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 快速排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># small equal large 的缩写</span></span><br><span class="line">        <span class="comment"># 都指向相应链表的 head</span></span><br><span class="line">        s = e = l = <span class="literal">None</span></span><br><span class="line">        target = head.val</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nxt = head.next</span><br><span class="line">            <span class="keyword">if</span> head.val&gt;target:</span><br><span class="line">                head.next = l</span><br><span class="line">                l = head</span><br><span class="line">            <span class="keyword">elif</span> head.val==target:</span><br><span class="line">                head.next = e</span><br><span class="line">                e = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = s</span><br><span class="line">                s = head</span><br><span class="line">            head = nxt</span><br><span class="line">        </span><br><span class="line">        s = self.sortList(s)</span><br><span class="line">        l = self.sortList(l)</span><br><span class="line">        <span class="comment"># 合并 3 个链表</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dummy <span class="comment"># cur: 非 None 的尾节点</span></span><br><span class="line">        <span class="comment"># p: 下一个需要连接的节点</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> [s, e, l]:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                cur.next = p</span><br><span class="line">                p = p.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>写归并排序是主流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(h)</span>:</span></span><br><span class="line">            slow = h</span><br><span class="line">            fast = h.next</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            t = slow.next</span><br><span class="line">            slow.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(h, t)</span></span><br><span class="line">            <span class="keyword">return</span> h, t</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> h1 <span class="keyword">or</span> h2:</span><br><span class="line">                v1 = h1.val <span class="keyword">if</span> h1 <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">                v2 = h2.val <span class="keyword">if</span> h2 <span class="keyword">else</span> float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">if</span> v1&lt;=v2:</span><br><span class="line">                    cur.next = h1</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h1 = h1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.next = h2</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h2 = h2.next</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 把链划分 2 半，递归排序</span></span><br><span class="line">        h1, h2 = map(self.sortList, split(head))</span><br><span class="line">        <span class="comment"># merge 2 条链</span></span><br><span class="line">        <span class="keyword">return</span> merge(h1, h2)</span><br></pre></td></tr></table></figure><p>优化合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(h)</span>:</span></span><br><span class="line">            slow = h</span><br><span class="line">            fast = h.next</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            t = slow.next</span><br><span class="line">            slow.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># print(h, t)</span></span><br><span class="line">            <span class="keyword">return</span> h, t</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(h1, h2)</span>:</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> h1 <span class="keyword">and</span> h2:</span><br><span class="line">                <span class="keyword">if</span> h1.val&lt;h2.val:</span><br><span class="line">                    cur.next = h1</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h1 = h1.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.next = h2</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    h2 = h2.next</span><br><span class="line">            <span class="keyword">if</span> h1: cur.next = h1</span><br><span class="line">            <span class="keyword">if</span> h2: cur.next = h2</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 把链划分 2 半，递归排序</span></span><br><span class="line">        h1, h2 = map(self.sortList, split(head))</span><br><span class="line">        <span class="comment"># merge 2 条链</span></span><br><span class="line">        <span class="keyword">return</span> merge(h1, h2)</span><br></pre></td></tr></table></figure><h2 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h2><p>归并慢些</p><p><img src="https://i.loli.net/2020/08/02/jsFn69BiDbMo87c.png" alt="image-20200802095356739"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sort-list/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/sort-list/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Sort a linked list in &lt;em&gt;O&lt;/em&gt; ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ) time using constant space&lt;br&gt;complexity.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3
Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0
Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Linked List, Sort&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Medium&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
    
      <category term="Linked List" scheme="https://zronghui.github.io/tags/Linked-List/"/>
    
      <category term="Sort" scheme="https://zronghui.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%9B%BE.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%9B%BE.html</id>
    <published>2020-08-01T04:03:59.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="有向图-floyd-算法"><a href="#有向图-floyd-算法" class="headerlink" title="有向图 floyd 算法"></a>有向图 floyd 算法</h2><p>经验：</p><p>若求的是 2 个节点之间，往往用 xfs 或 并查集，因为用 Floyd 的复杂度过高，如<a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路 - 力扣（LeetCode）</a></p><p>若求的是 queries (要查询多个节点对)，这时候用 flyod 好一点，如<a href="https://leetcode-cn.com/problems/course-schedule-iv/">1462. 课程安排 IV - 力扣（LeetCode）</a></p><h3 id="1462-课程安排-IV-力扣（LeetCode）"><a href="#1462-课程安排-IV-力扣（LeetCode）" class="headerlink" title="1462. 课程安排 IV - 力扣（LeetCode）"></a>1462. 课程安排 IV - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-iv/">1462. 课程安排 IV - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, pres: List[List[int]], qs: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> pres: dp[a][b] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> [dp[a][b] <span class="keyword">for</span> a, b <span class="keyword">in</span> qs]</span><br></pre></td></tr></table></figure><h2 id="无向图-dijkstra-算法"><a href="#无向图-dijkstra-算法" class="headerlink" title="无向图 dijkstra 算法"></a>无向图 dijkstra 算法</h2><h3 id="1514-概率最大的路径-力扣（LeetCode）"><a href="#1514-概率最大的路径-力扣（LeetCode）" class="headerlink" title="1514. 概率最大的路径 - 力扣（LeetCode）"></a>1514. 概率最大的路径 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">1514. 概率最大的路径 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProbability</span><span class="params">(self, n: int, e: List[List[int]], succProb: List[float], start: int, end: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># defaultdict 构造 graph</span></span><br><span class="line">        graph = collections.defaultdict(dict)</span><br><span class="line">        <span class="comment"># 因为这个题目比较特殊，权重是乘性的并且0-1之间，所以可以用一个dic记录从start开始到每个节点的最大权重。 然后每次你只需要判断pop出的节点的权重就可以。如果比曾经记录的dic中的权重小那就没必要继续（这里面包含了环，回头），如果比曾经记录的权重大，那么继续进行。</span></span><br><span class="line">        d = collections.defaultdict(float)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(e)):</span><br><span class="line">            p1, p2 = e[i]</span><br><span class="line">            graph[p1][p2] = succProb[i]</span><br><span class="line">            graph[p2][p1] = succProb[i]</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        stack.append([start, <span class="number">1</span>]) <span class="comment"># start 到 当前点 的 概率</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur, prob = stack.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur==end:</span><br><span class="line">                ans = max(ans, prob)</span><br><span class="line">            <span class="keyword">elif</span> prob&gt;ans:</span><br><span class="line">                <span class="keyword">for</span> point, _prob <span class="keyword">in</span> graph[cur].items():</span><br><span class="line">                    <span class="keyword">if</span> _prob*prob&gt;ans <span class="keyword">and</span> _prob*prob&gt;d.get(point, <span class="number">0</span>):</span><br><span class="line">                        d[point] = _prob*prob</span><br><span class="line">                        stack.append([point, _prob*prob])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="207-课程表-力扣（LeetCode）"><a href="#207-课程表-力扣（LeetCode）" class="headerlink" title="207. 课程表 - 力扣（LeetCode）"></a>207. 课程表 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/">课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解） - 课程表 - 力扣（LeetCode）</a><br><a href="https://www.bilibili.com/video/av17399461">拓扑排序_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        indegrees, adjacency = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[b] += <span class="number">1</span></span><br><span class="line">            adjacency[a].append(b)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># path = []</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            path.append(cur)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adjacency[cur]:</span><br><span class="line">                indegrees[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># print(path)</span></span><br><span class="line">        <span class="keyword">return</span> count==n</span><br></pre></td></tr></table></figure><h3 id="210-课程表-II-力扣（LeetCode）"><a href="#210-课程表-II-力扣（LeetCode）" class="headerlink" title="210. 课程表 II - 力扣（LeetCode）"></a>210. 课程表 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/submissions/">210. 课程表 II - 力扣（LeetCode）</a></p><p>依赖关系反过来了，而且需要记录 pop 的节点顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        indegrees, adjacency = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> b, a <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[b] += <span class="number">1</span></span><br><span class="line">            adjacency[a].append(b)</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        path = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            path.append(cur)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adjacency[cur]:</span><br><span class="line">                indegrees[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># print(path)</span></span><br><span class="line">        <span class="keyword">return</span> path <span class="keyword">if</span> count==n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1042-不邻接植花-力扣（LeetCode）"><a href="#1042-不邻接植花-力扣（LeetCode）" class="headerlink" title="1042. 不邻接植花 - 力扣（LeetCode）"></a>1042. 不邻接植花 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gardenNoAdj</span><span class="params">(self, N: int, paths: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">chooseone</span><span class="params">(exclude)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> exclude: <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        m = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> paths:</span><br><span class="line">            m[a].append(b)</span><br><span class="line">            m[b].append(a)</span><br><span class="line">        res = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">            res[i<span class="number">-1</span>] = chooseone(exclude=[res[j<span class="number">-1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> m[i]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res[i]: res[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>简洁写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gardenNoAdj</span><span class="params">(self, N: int, paths: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        m = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> paths:</span><br><span class="line">            m[a<span class="number">-1</span>].append(b<span class="number">-1</span>)</span><br><span class="line">            m[b<span class="number">-1</span>].append(a<span class="number">-1</span>)</span><br><span class="line">        res = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            res[i] = (&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;-&#123;res[j] <span class="keyword">for</span> j <span class="keyword">in</span> m[i]&#125;).pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="997-找到小镇的法官-力扣（LeetCode）"><a href="#997-找到小镇的法官-力扣（LeetCode）" class="headerlink" title="997. 找到小镇的法官 - 力扣（LeetCode）"></a>997. 找到小镇的法官 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/find-the-town-judge/comments/">997. 找到小镇的法官 - 力扣（LeetCode）</a></p><p>晦涩的解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trust: </span><br><span class="line">            <span class="keyword">if</span> N==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># judge 不在 a 中</span></span><br><span class="line">        <span class="comment"># judge 出现 N-1 次</span></span><br><span class="line">        s = set(range(<span class="number">1</span>, N+<span class="number">1</span>))</span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> trust:</span><br><span class="line">            m[b] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> s: s.remove(a)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = s.pop()</span><br><span class="line">        <span class="keyword">if</span> m[res]==N<span class="number">-1</span>: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-the-town-judge/solution/yi-ge-shu-zu-gao-ding-tong-su-yi-dong-997-zhao-dao/">【一个数组搞定】通俗易懂（997. 找到小镇的法官） - 找到小镇的法官 - 力扣（LeetCode）</a></p><p>法官👩‍⚖️ 实际上就是出度为0，入度为 N - 1的节点。这固然没错，然而我们仍然可以换个角度来思考，法官👩‍⚖️ 同样是 入度 - 出度 == N - 1 的点，并且不是法官的人不可能是。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        l = [<span class="number">0</span>]*N</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> trust:</span><br><span class="line">            l[a<span class="number">-1</span>] -= <span class="number">1</span></span><br><span class="line">            l[b<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> l[i]==N<span class="number">-1</span>: <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="841-钥匙和房间-力扣（LeetCode）"><a href="#841-钥匙和房间-力扣（LeetCode）" class="headerlink" title="841. 钥匙和房间 - 力扣（LeetCode）"></a>841. 钥匙和房间 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/keys-and-rooms/submissions/">841. 钥匙和房间 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 从 0 是否全部连通其他点</span></span><br><span class="line">        visited, queue = set(), [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            queue.extend(rooms[cur])</span><br><span class="line">        <span class="keyword">return</span> set(range(len(rooms)))==visited</span><br></pre></td></tr></table></figure><h3 id="1267-统计参与通信的服务器-力扣（LeetCode）"><a href="#1267-统计参与通信的服务器-力扣（LeetCode）" class="headerlink" title="1267. 统计参与通信的服务器 - 力扣（LeetCode）"></a>1267. 统计参与通信的服务器 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/submissions/">1267. 统计参与通信的服务器 - 力扣（LeetCode）</a></p><p>暴力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        rows, cols = defaultdict(int), defaultdict(int)</span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    rows[i] += <span class="number">1</span></span><br><span class="line">                    cols[j] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> max(rows[i], cols[j])&gt;<span class="number">1</span>:</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="133-克隆图-力扣（LeetCode）"><a href="#133-克隆图-力扣（LeetCode）" class="headerlink" title="133. 克隆图 - 力扣（LeetCode）"></a>133. 克隆图 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/clone-graph/submissions/">133. 克隆图 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/">DFS 和 BFS - 克隆图 - 力扣（LeetCode）</a></p><p>dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val = 0, neighbors = []):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> d: <span class="keyword">return</span> d[node]</span><br><span class="line">            clone = Node(node.val)</span><br><span class="line">            d[node] = clone</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                clone.neighbors.append(dfs(neighbor))</span><br><span class="line">            <span class="comment"># d[node] = clone 放这里    ↑ dfs 不断递归调用</span></span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(node) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="1306-跳跃游戏-III-力扣（LeetCode）"><a href="#1306-跳跃游戏-III-力扣（LeetCode）" class="headerlink" title="1306. 跳跃游戏 III - 力扣（LeetCode）"></a>1306. 跳跃游戏 III - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/jump-game-iii/">1306. 跳跃游戏 III - 力扣（LeetCode）</a></p><p>floyd 超时 用 bfs 解决</p><h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> arr[start]==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 有向图 判断 start 到 0 处是否可达</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        i0 = [] <span class="comment"># 0 的 index</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> arr[i]==<span class="number">0</span>:</span><br><span class="line">                i0.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i+arr[i]&lt;n:</span><br><span class="line">                dp[i][i+arr[i]] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i-arr[i]&gt;=<span class="number">0</span>:</span><br><span class="line">                dp[i][i-arr[i]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> i0:</span><br><span class="line">            <span class="keyword">if</span> dp[start][i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, arr: List[int], start: int)</span> -&gt; bool:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        visited = set()</span><br><span class="line">        deque = [start]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            cur = deque.pop()</span><br><span class="line">            <span class="keyword">if</span> arr[cur]==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> [cur+arr[cur], cur-arr[cur]]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=nxt&lt;n <span class="keyword">and</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    deque.append(nxt)</span><br><span class="line">            <span class="comment"># print(visited, deque)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="面试题-04-01-节点间通路-力扣（LeetCode）"><a href="#面试题-04-01-节点间通路-力扣（LeetCode）" class="headerlink" title="面试题 04.01. 节点间通路 - 力扣（LeetCode）"></a>面试题 04.01. 节点间通路 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">面试题 04.01. 节点间通路 - 力扣（LeetCode）</a></p><p>flyod 超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWhetherExistsPath</span><span class="params">(self, n: int, graph: List[List[int]], start: int, target: int)</span> -&gt; bool:</span></span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> graph:</span><br><span class="line">            dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k] <span class="keyword">and</span> dp[k][j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[start][target]</span><br></pre></td></tr></table></figure><p><del>xfs</del> dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWhetherExistsPath</span><span class="params">(self, n: int, graph: List[List[int]], start: int, target: int)</span> -&gt; bool:</span></span><br><span class="line">        visited = set()</span><br><span class="line">        m = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> graph:</span><br><span class="line">            m[i].add(j)</span><br><span class="line">        queue = [start]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(cur)</span><br><span class="line">            <span class="keyword">if</span> cur==target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> m[cur]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>tricks-2020-08</title>
    <link href="https://zronghui.github.io/tricks-2020-08.html"/>
    <id>https://zronghui.github.io/tricks-2020-08.html</id>
    <published>2020-08-01T04:03:43.000Z</published>
    <updated>2020-08-07T14:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7dc906d2d09231e7c0a9108e843dfa14466dad419b6dfef7886d7887c4f8c105">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dd85bdd0ba216a9a3ddb0ba4af683a3234740fdce8265b492f7f7c66e06ca477ca5eefea6853f46f0c4c21eba11069307a68c85baf47613206b7b7fa8342ba3e63b45f5e3027eb5393ad2a79dc1f9c6d3338a513824885d7bebc234bc31ad8ad14d441cf09b4d13cdb86bee7a2ca4835273ddadeb22d8717f48d46eab635fc3a98e8cd6e6c7050184b3de31048bfad0b31a2eeaf658a30f37f94238f9f2675fcd5086dd29c97860e5be6a71235f894f8285d5eebd7fc1d8b7ea340b1bdefa77663d9d5b5e05f0d3b152a90809472fff9b88061e88b37b8780ee01cced06890fe3643ecb30157fa7f07987dfb0c4e125381d2e7acc32c4e547a3dcce00cd3d527f04c793bf57901eb5f24eb78fea0cc88d1d33d351b522aed5ecdf3737a014bc77c4c974821765386560da5988f33343d5dae62d4e719e4e25f6a127318c7e03adc3bb29adfd1d861385cc992080564d48543439f25235b602f09d5083607195a6c974ca71339ceaa7a085c91d2112e2090700a3c191e9b03339b1a7389292d8284035d331d45c770d24a4e9c9a9edab918b8ef456e38b1c868d23c14e5c0dd9c17a2fecdf142f953654e397aa8b8beb06fb53f8b090553643d1f7e728b55d9cd4c10b264ede551be48641483200a48c7a6a384b1eef35448d02aa8693976fa16214911cc995d464bb77b0e55bdfcc845a62bcffa06452384ad8e91b41703eeb65c857ecee0b6fd582e1ac333e1859fd089bc5ebb84994854f05bf78e5bf1bff3cfb416d89af09e9146e789066e77be22cc3503d3a7dfdfa7f548ca54257c029d7592ae04eb02528b6da0bce0e0f3e958a437b045595a96efcb57f011c3a63024909ec06a0213d0a8817d1a4705959b4f658a242972a7572e9ea4ddc1d118b046213015b7068b2225147d68a412a1da7e2ace2ecb3c38d83208031a748a36da6d9a83841c10bc1002403c65d616b2c160bc44fcd9b080285e669ccbbfa023a4d3ee0560ec1eb6d54ec44c1196043214347dfc26eeb3a185b598475ec0def8d2e31623919cd71c04b32354bf23a9a6e41cb2fc3b027fa40ac2f0349aa38dd9eea81fd281d59a0f63192cd43110dff38e9fc4f2fb297f8178312f0a6930e31ed8a91def15eff433a5500cabbfcda817fd7e810ca5876dc3ac4647d01c8fafb8a4601733599cd1b2c1e50b6c82968938248daf032ae4e20f244c72aa098b7907827c1369852b27da1064cc2ec087f88adcf599fe15c47fbc3a381774ff1db063f19eb5acf15c73e41afbff9f93fb2b67ec5cb1e10b908ad04b6ead4d9f2d13b3bc22708bf681d444779c6113438e4b57e7dd7a105ca95c416d80b8d399e2b9d85e51a0d752365ae3e2fc84ab4b43bf2d40d7667d6d8754e02e954987b347a02f8c2331537718fd9f3cb7d81cdb4ed0870121203d0ba0695af26d548b5283a19668882dd9bdb6ba3a9607e8343f42fd8d0785ee7d489a3e4d83318938d7b425380fe4d576e2ae5e87c41b37356f7a0bc184f8a14a123b6070f2fcabb987fae95f3c1bcd3a1d340248e96ab8f349aeb3938aed1a4a79252fc7f11b10eb9eaf7af11fa35735c7f56d5540d42dde599727c9e8939464d4db6242385693ba39795d26e0b777690d4bae8909a2f5858a5bf3bce49485a9381c76adb3eb74e7233cd9aff91689e63dc91b60e7dc0a5d56c107eb3366cf068323884a6740e460206226376ab2224e708520575f549a6152bd4bd7f67a68ac2ce1c6fe560f1ba52b138b138fc5c1c8fc58dc75f2a4ce6964015dc8e0a4561f99a8219660f1f94cc69eb84c9ce8a2c2f35f420960b3d16e7be21b87017c4dad1c6fd90baa91970ac289764a648d293eb6c37b5d0d37d798eef1dda236808e12e994f1e9af4dbd4ef9dffcc53279e7d41e6b13ef4112d8da6a8f2ff77d2be9fe733da25eeddf8db2e0978aa94f9452a9a08f17d893a6e659b02524eee53c2a8914e32680f4efeb3eba611fac576c32a7badb743f1af077a024eafc87e83655fb0073a0b46427e864fb3b5df78b17ee4e2cb378377f2182c82aa198badb0fc9182f1392fddaca0bb8c10f5b7ecab74243f4fb3c36b36ba0a8671aa4bc924c58087367b52e20d520c69737248b91a1819845ef6be06a9dee9012b8f2fe0ae2e3d67cc6464844d50afb4bc931d2b20610a26d293a83286f2738c88e0f994312d617636eef2727d6b397de3e6f16d0fcb6ff21bfe4e579501c69563ffd6a9ab8b18d42d59b38766552a218ddc3c8b2529399bda4dbb114163ab03d04e878475675b9513c50d1071b30c29e14d2d51d84ac5a6b46db81d4f5f366ba39344ce22a72acdb343e989a2768e21fd2639c1a153d9745e55fb12f50fe7c85a5e0daeddfd8b9d9ca6b7b0f57b99a6755d342ab2aca61af3815d924057509e6b4d8e754a7aa1ff7e0e9013c687c51c7d91e5b532c1b2e41f1680615be93a5a0bcb6b9dcc87a9d4ba73111c9e1a228194281f67e7c95052432b71733cd3833b7efb25a9b20ae3d28f3cd62820effcb4199afd813eff9df3ea2c1b2371731d0c74b1fef93d51ef1078d00838588aa905d32ce3b4b4992d61628ac85034affa2e689693685f79c6548520629cf82fcceb14a701fda608983e0c845224207523fbe77f30d819aaf95a16b2725a91de3d9da67e15a0888645ad0a1208253908c2ddc74d5f80d69e6305a551696ee536aca62e0c2ebb97478b4d1923d34ba269c86aad84ec8e92f93785bd66965016a364762af7bfe7cd2732310c652db501e06798c7f1ddb0ed2e0ae90b74ac1767a1a75ed75246d01807af81f7bfe46bca2254b2381573efab9a1a5816dd79ab3bd4208df86a83d6fe51b9524def70b9718708dbc9644fe1eabf6955a51fdb12e9f7fd96b06ebca8941df52bedb7087aadefd0c3e6c21a969594d9c79abee255bcc7631097ea193878b2233767d0e4f8805c41b2ad5bc84a56bfb19177fe1200df84e6158bc15ff4be45dac4a178939b2374e241d6f0072326bf7b613acc222079575d52f19bf41f8503c021eda8e7c677f8acb86a7b3a23692340ab089e570febc06abbe67856b13284a41dc61c18e589a3bfa721aa563e12089e05d184166b9e10991a56b92f7f63932059f957226f6550610ff33bea87c8c68418d860816710bd345656be5caa398376769a315f85edaed11cb801f94dfaa60e429f4a71d14f3d5ad00020caf0bf6231cb09ae45be525fb72c401c1628c6f5182f58ace947323eb103c0428fb64bb074170283bea69fdc8c3b3e7efbc4ab4d2e71ac2de6e5335bb053135620232ce40a01191fc944ab9f037d967d060eca54aaa639e5ee40d64e1cd9c4ec90eab925475de92a5908aa77cd536187a5417f09b65fbb016590f2c87455db332dabd1f6526eec3a430e826bfda5f905cfc07b97aadeaa11fdef7671f59483b6c244a09db60330cb5386bab70955ce2e6d29ad344afd73276069fe46538da1f9b554c1be3800e00c9ca8bd302526ec80fe9864bf7f98640562df32f94538717ad0352570e8ba606a74d5cb54d897f6811df14b4df72411ae77a531c282139f466e7daa2da37b8aa5e0dc85761417abb503774d2ade56f583c714675c086d8bee35d61d21aa245fc1c2d4e11bdd5e028aec444d73e48c5d9d3a5907a0607952aa9ac52b6aa7814bc96a636758f5ccf3944a024c9996617541b91eb3b9f4da7913fcd9153d12eb5577564d8de0b960a661c3d019eeb87df44361c83bf482392913b3320abbf3a333908584b25013a6da2d97880c65dd0a0c45bb599516a7fc29f9c1bdcd16c1b077b18b9b16c5f340ce530a09ddfc42bc5a860c3bec45b497708d047414766eaf2ce6ff48a49f3b2cf6e14947acaeb707fe5766fdbf8e114c41bc7d55ee1bd588193bcbcd9876341a28867fd90d8d7a2dbcb5109a2b0f4fa975b932085772d3cee36df67e51c37ceb8b674ffbfb107a86a80baa5d5856a152d5a3e8b131140f15908b6a8384c587bca8b2d6c470d72b8bbe974203d6315b4e08888f2253c9e9d72083f4fb89340cdee9d7e4537c66aa57b1cdd178fe11e031977ad27563ef2700282f7d8f534ae1dfe9394974cb729a55e70384e630c6ff32c09e887258e6c7c88286ec3e03ec444dff97a6c1c73be36768aa78b524650870e4e6bed6d4e684517d4926500efcf86b2eec53bedb21956880427f22eaab144d17b85bad1f81575ee655dee7cf6f56e56ba87a746ca6e1b6b20c9161038bb751613f29df0a95b625251bf17a259f477dab2665bcc94cc4aef52948d7f01f9bcac8974f7f6892ad8ded03b53b9ac6f23eb38ff072b1e1fc50d47d3c768fcf733c55dd10242813960ea4b90f2fcf4cf446f50f3e46ad0fbd841c5b24977a22319d66dfec06bf9774c932447f5199dfe5fa3fc4509470ef983bdae3361402c75795f8ba76f15d69a6366573e215d22ebd4cb66b47818aed9dd1f6088f1184cc634015781e816a23a5f949c623f3af66a6b4fb9d156d628fff731e3d0ffe21b3780ec33db3b3cd0240dd2b8021c41258a6b3d92147cf6afb59a9295138039cfbd39bb31afaa3b5941c79d13ed137d41594cf43f97608ba8d8ef3bb8b7a7509cc12b3be2d5ba4a1fadeb2ee63059643b78da7a5a0e63d38786e65c3d2e926ea70ddc30e0f75827cf3c0be00744bef56a40f446e3644e08e6f8626bc745f25cbb84c6385655d1956c7dfde4ff0562f1bb1b9fa6f2ff7227ed115788c0562a9424bca605897501d02132e04a2d89e093980d81ba214f3d0b70b2dbfb0eb67cede29de0cdb777303883cdc8712319832e9004bdc865478f3e58ba0a8c0a11dfdd75bcc0afab2d6a5799d91451c8c9e1457247309dad253e9314737afe9e19025b42404836869f387739e4a54bf53d1b6bca3c81c50d34c92c4f67df23800633e04face5a9f57a64b4d5010171ab7e4981ff331ee58c86da73ec8ec933fcce981dd8760f2a83078e19d08bdb489f7aa5327665e8811718bbb05e0188bc0e7418f1a3799aa23c5ea972a88e28f42c0fabdfd9d8555e1a29a8b1ea140229a815d444a4571fba908e847ab76894574890efca7969ea975f69d5a01b6733ebd0413a68fe3dbb11181d08251b9ecbaff368573b250f47b49c7192afafb17ad7f03486cb31183a3cbfb014c6820d777d3778c548f0235167894b6581c52672a16f61d70240775c54ac04ddb79a35e619f992230b561574086dac16369e6b1392820b66ba914b3a0164b30583fb0728ac42f2fa9938dee5d25d0f4996629d4ad343620e40515b597d27391264e080f115de943c3bd27c23910954350c888e73c0bc49c2959995ead1830b4fcee0357f848437a0d2215eedfbd82a3ad9ea6da0be372ef01dc2f13450be20b93189e551b30ea6b7e3389c7da89b1bfd623f87f70a261c8e6df6c0b50d7cf922146752fd28901bc2b0ba089436a3872f6feb1e9eaa625afdec790e87d1e8daa25217916b8ec0a973aa2463be043e1751364c5c7f436be45dc8b837f2bd5c8ee5df52e1efe3faa4c9636b57592fb641d53880d3525f221b534f542f2228c2450c74c70d10f33b22654645fd5f7a399932b9f05bd51d88355697e2dd1b6087fab945aa0f4f8dd0b44240258d4ae33e9b4002c712dc01963fd608c8223ba4f49d4ee2e933de1c439083cfae4bf315d230161184c657da234fa456d9ddb01a96c21a18fa2d3fb6743daf7bca88f60ec9580fdf1a32f8f5df8b9b014a5659e913a99373bb1552aee16e340593c4378c085d444caba8647dc64b223dd6ba13cde7578135cc5e383baa2f34fb4ca2a3e12060595236e8ce64666adf6181d06a00224341fed7a6ca57257b9851413887cb5329f98d42fbe1046d391362f8e19f043391e914db2c1982f72f732990ef6c3d4779b4eb57c89a1e49fd6f8c119fa2793be45514077522c8822970a4788f740db778dd385a7f985077c620ee3774f462321ae175f7d1b27ff8e13e7ecc99c41bcde626d8aa705b880077c5b8001fc932b92ebe568dd555fb6fe1dc5bb5a52fc840432ec7ec18643cf52e752222045e539cc9e2762cf0ea6288ae05ee9920d0e84c06b2c2ec10f11dcbcc735642a74dc8af6c7cfa6db677bf786c4fd63d69e0d5d88212ddf311b5125cab1677074ee6056251077fe792eef97f2e3e45f235b38c1351c2fc88021f4253ea313f87205856e98b91f48e5206395ebe8591f388af98bff990d95c12707acd2e25ed77374408a64c2bff74af7b695b0de966c07aced36663e3a7c9f0ea1b00fe9b6b4664f9bf773264b308c2940853c1105b8a5414c8aae8cdec6dae3aebac774b15bc2d7293d61505df15f7c17f68258006aeb3e0951cb61a19428</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>blockchain/blockchain</title>
    <link href="https://zronghui.github.io/blockchain/blockchain.html"/>
    <id>https://zronghui.github.io/blockchain/blockchain.html</id>
    <published>2020-07-31T02:00:22.000Z</published>
    <updated>2020-08-07T02:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题汇总："><a href="#问题汇总：" class="headerlink" title="问题汇总："></a>问题汇总：</h2><ol><li><del>区块链运维层面 随着节点增加删除下线等 需要我们做的工作还有哪些</del></li><li><del>区块链规模的大小对数据查询效率的影响</del></li><li>合约设计相关思考，如何结合业务设计合约，各个模块的设计，表的设计等</li><li>节点准入涉及的权限问题</li></ol><h2 id="1-区块链运维层面需要做的工作"><a href="#1-区块链运维层面需要做的工作" class="headerlink" title="1. 区块链运维层面需要做的工作"></a>1. 区块链运维层面需要做的工作</h2><h3 id="1-新增节点"><a href="#1-新增节点" class="headerlink" title="1.新增节点"></a>1.新增节点</h3><p>组织结构生成之后可以随时添加或修改吗？</p><p>目前，Hyperledger Fabric 无法对已生成的组织结构进行修改；所以需要提前做好规划</p><h3 id="链码的打包升级"><a href="#链码的打包升级" class="headerlink" title="链码的打包升级"></a>链码的打包升级</h3><p>在实际场景中，由于需求场景的变化，链码也需求实时做出修改，以适应不同的场景需求。所以我们必须能够对于已成功部署并运行状态中的链码进行升级操作。</p><p>首先，先将修改之后的链码进行安装，然后使用 upgrade 命令对已安装的链码进行升级，具体实现如下：</p><p><strong>安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 2.0 -p github.com/chaincode/chaincode_example02/go/</span><br></pre></td></tr></table></figure><p><strong>升级：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode upgrade -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 2.0 -c '&#123;"Args":["init","a", "100", "b","200"]&#125;' -P "OR ('Org1MSP.peer','Org2MSP.peer')"</span><br></pre></td></tr></table></figure><p>链码升级之后， 之前旧版本的链码还能使用吗？</p><p>升级是一个类似于实例化操作的交易，它会将新版本的链码与通道绑定。<strong>其他与旧版本绑定的通道则仍旧运行旧版本的链码</strong>。换句话说，升级只会一次影响一个提交它的通道。</p><h3 id="其他：某节点（order-节点或-peer-节点）掉线后怎么重新加入集群-并恢复、同步数据"><a href="#其他：某节点（order-节点或-peer-节点）掉线后怎么重新加入集群-并恢复、同步数据" class="headerlink" title="其他：某节点（order 节点或 peer 节点）掉线后怎么重新加入集群 并恢复、同步数据"></a>其他：某节点（order 节点或 peer 节点）掉线后怎么重新加入集群 并恢复、同步数据</h3><h2 id="2-区块链规模的大小对数据查询效率的影响"><a href="#2-区块链规模的大小对数据查询效率的影响" class="headerlink" title="2. 区块链规模的大小对数据查询效率的影响"></a>2. 区块链规模的大小对数据查询效率的影响</h2><p>区块链的效率主要受共识机制影响</p><h3 id="fabric-的共识机制"><a href="#fabric-的共识机制" class="headerlink" title="fabric 的共识机制"></a>fabric 的共识机制</h3><img src="https://i.loli.net/2020/07/31/jmu2U8yksAY36el.png" alt="image-20200731100157053" style="zoom: 33%;" /><p>区块链规模越大，节点越多，背书越慢</p><h3 id="具体速度"><a href="#具体速度" class="headerlink" title="具体速度"></a>具体速度</h3><p>衡量单位: tps 每秒吞吐量</p><p><strong>TPS=区块大小/（出块间隔*交易字节大小）</strong></p><p><img src="https://i.loli.net/2020/07/31/qd1EPvMi7Ogo3la.png" alt="image-20200731100306637"></p><p>平均吞吐量: 大概 60tps，还是挺慢的</p><h3 id="几种典型区块链在性能功能上的差异"><a href="#几种典型区块链在性能功能上的差异" class="headerlink" title="几种典型区块链在性能功能上的差异"></a>几种典型区块链在性能功能上的差异</h3><p><img src="https://i.loli.net/2020/07/31/eANG1aWoX47LmTh.png" alt="几种典型区块链在性能功能上的差异与作用"></p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/137601849">几种典型区块链在性能功能上的差异与作用 - 知乎</a></p><p><a href="https://www.zhihu.com/question/50156061">(3 封私信) 区块链技术每秒的交易量低的瓶颈在哪儿，可能会如何解决？ - 知乎</a></p><p><a href="https://www.jianshu.com/p/443b55d28e8d">Hyperledger Fabric 学习三：共识机制 - 简书</a></p><p><a href="https://blog.csdn.net/wxid2798226/article/details/81709837">IBM 超级账本Fabric 性能测试_郑泽洲的博客-CSDN博客_fabric性能测试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题汇总：&quot;&gt;&lt;a href=&quot;#问题汇总：&quot; class=&quot;headerlink&quot; title=&quot;问题汇总：&quot;&gt;&lt;/a&gt;问题汇总：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;del&gt;区块链运维层面 随着节点增加删除下线等 需要我们做的工作还有哪些&lt;/del&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-195</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-195.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-195.html</id>
    <published>2020-07-30T09:35:58.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/path-crossing/">判断路径是否相交</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k/">检查数组对是否可以被 k 整除</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/">满足条件的子序列数目</a><strong>6</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/max-value-of-equation/">满足不等式的最大值</a><strong>7</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPathCrossing</span><span class="params">(self, path: str)</span> -&gt; bool:</span></span><br><span class="line">        s = &#123;(<span class="number">0</span>, <span class="number">0</span>), &#125;</span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">'N'</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="string">'S'</span>: (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">            <span class="string">'E'</span>: (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">'W'</span>: (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        cur = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">            cur[<span class="number">0</span>] += d[i][<span class="number">0</span>]</span><br><span class="line">            cur[<span class="number">1</span>] += d[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> tuple(cur) <span class="keyword">in</span> s: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s.add(tuple(cur))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canArrange</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 余数: 数量</span></span><br><span class="line">        m = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            mod = i%k</span><br><span class="line">            <span class="keyword">if</span> mod==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> m.get(<span class="number">0</span>, <span class="number">0</span>)==<span class="number">0</span>: m[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: m[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> m.get(k-mod, <span class="number">0</span>)&gt;<span class="number">0</span>: m[k-mod] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: m[mod] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(m)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">if</span> m.get(i, <span class="number">0</span>)&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubseq</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 考数学的一道题</span></span><br><span class="line">        <span class="comment"># 0 1 2 3 4 5</span></span><br><span class="line">        <span class="comment"># 若最小为 0，target 为 5，则 1~5 都可有可无， 这样的子序列有 2**4 个</span></span><br><span class="line">        <span class="comment"># 用双指针确定最大最小值</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            <span class="keyword">while</span> nums[l]+nums[r]&gt;target <span class="keyword">and</span> l&lt;=r:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[l]+nums[r]&lt;=target <span class="keyword">and</span> l&lt;=r:</span><br><span class="line">                res += int(pow(<span class="number">2</span>, r-l, <span class="number">1000000007</span>))</span><br><span class="line">                res %= <span class="number">1000000007</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>仍是数学题</p><p><img src="https://i.loli.net/2020/07/30/UHxVBjGlKQNOd9t.png" alt="image-20200730173812522"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxValueOfEquation</span><span class="params">(self, points: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># max(yi + yj + |xi - xj|)    i&gt;j</span></span><br><span class="line">        <span class="comment"># = max(yi + yj + xj - xi) = max(xj + yj) - min(xi - yi)</span></span><br><span class="line">        result = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="comment"># (xi-yi, xi)</span></span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        stack.append((points[<span class="number">0</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">1</span>], points[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> points[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> point[<span class="number">0</span>]-stack[<span class="number">0</span>][<span class="number">1</span>]&gt;k:</span><br><span class="line">                stack.popleft()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                result = max(result, sum(point)-stack[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">0</span>]&gt;point[<span class="number">0</span>]-point[<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append((point[<span class="number">0</span>]-point[<span class="number">1</span>], point[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/path-crossing/&quot;&gt;判断路径是否相交&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k/&quot;&gt;检查数组对是否可以被 k 整除&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/&quot;&gt;满足条件的子序列数目&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/max-value-of-equation/&quot;&gt;满足不等式的最大值&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>biweekly-contest-29</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-29.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-29.html</id>
    <published>2020-07-30T01:51:56.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/average-salary-excluding-the-minimum-and-maximum-salary/">去掉最低工资和最高工资后的工资平均值</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/the-kth-factor-of-n/">n 的第 k 个因子</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/longest-subarray-of-1s-after-deleting-one-element/">删掉一个元素以后全为 1 的最长子数组</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/parallel-courses-ii/">并行课程 II</a><strong>6</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(self, salary: List[int])</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> (sum(salary)-min(salary)-max(salary))/(len(salary)<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthFactor</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print(i)</span></span><br><span class="line">            <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt==k: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = [<span class="number">0</span>]*n</span><br><span class="line">        right = [<span class="number">0</span>]*n</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            left[i] = cur</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>: cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cur = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(left)</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n)):</span><br><span class="line">            right[i] = cur</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>: cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cur = <span class="number">0</span></span><br><span class="line">        <span class="comment"># print(right)</span></span><br><span class="line">        <span class="keyword">return</span> max(left[i]+right[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-29/problems/average-salary-excluding-the-minimum-and-maximum-salary/&quot;&gt;去掉最低工资和最高工资后的工资平均值&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-29/problems/the-kth-factor-of-n/&quot;&gt;n 的第 k 个因子&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-29/problems/longest-subarray-of-1s-after-deleting-one-element/&quot;&gt;删掉一个元素以后全为 1 的最长子数组&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-29/problems/parallel-courses-ii/&quot;&gt;并行课程 II&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>高中数学</title>
    <link href="https://zronghui.github.io/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6.html"/>
    <id>https://zronghui.github.io/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6.html</id>
    <published>2020-07-28T02:15:40.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p>忘了不少，现在恶补一下</p><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><img src="https://i.loli.net/2020/07/28/MUu3QAwqsLP15Tc.png" alt="【高中数学】排列组合超详细讲解 @11-13.66 1595901502995" style="zoom:50%;" /><img src="https://i.loli.net/2020/07/28/ACZDQOVJnMIftd5.png" alt="【高中数学】排列组合超详细讲解 @18-13.25 1595901477428" style="zoom:50%;" /><img src="https://i.loli.net/2020/07/28/3wsxh5kuabRZegM.png" alt="【高中数学】排列组合超详细讲解 @25-01.92 1595902388528" style="zoom:50%;" /><img src="https://i.loli.net/2020/07/28/JevbgR1oEGqBTAi.png" alt="【高中数学】排列组合超详细讲解 @21-27.62 1595902343969" style="zoom:50%;" /><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-199</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-199.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-199.html</id>
    <published>2020-07-26T04:02:51.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-199/problems/shuffle-string/">重新排列字符串</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-199/problems/bulb-switcher-iv/">灯泡开关 IV</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-199/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-199/problems/string-compression-ii/">压缩字符串 II</a><strong>8</strong></li></ul><p><img src="https://i.loli.net/2020/07/26/YJGIPEnlWVQNHwU.png" alt="image-20200726124139413"></p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>写的挺烂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></span><br><span class="line">        m = dict(zip(range(len(s)), s))</span><br><span class="line">        m2 = dict(zip(indices, range(len(s))))</span><br><span class="line">        <span class="comment"># print(m)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(m[m2[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)))</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s = s.lstrip(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(list(i <span class="keyword">for</span> i, _ <span class="keyword">in</span> itertools.groupby(s)))</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>问题转换：</p><p>2 个叶子节点到最近公共父节点的距离和 是 2 个叶子节点的距离</p><p>res = 左子树 中符合的叶子对+右子树符合的叶子对 + 累加 （num[左]*num[右] if 左+右&lt; k ）</p><p>helper 中 d 的含义：</p><p>{到当前根节点的距离: 数目}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPairs</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span>, &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="keyword">return</span> <span class="number">0</span>, &#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">            leftn, leftd = helper(node.left)</span><br><span class="line">            rightn, rightd = helper(node.right)</span><br><span class="line">            n = leftn+rightn</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> leftd:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> rightd:</span><br><span class="line">                    <span class="keyword">if</span> i+j&lt;=k: n += leftd[i]*rightd[j]</span><br><span class="line">            d = collections.defaultdict(int)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> leftd:</span><br><span class="line">                d[i+<span class="number">1</span>] += leftd[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> rightd:</span><br><span class="line">                d[i+<span class="number">1</span>] += rightd[i]</span><br><span class="line">            <span class="keyword">return</span> n, d</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>本来写的贪心，但是通过不了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runlength</span><span class="params">(self, _s)</span>:</span></span><br><span class="line">        group = itertools.groupby(_s)</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> group:</span><br><span class="line">            l = list(v)</span><br><span class="line">            <span class="keyword">if</span> len(l)==<span class="number">1</span>: s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: s += <span class="number">1</span>+len(str(len(l)))</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">"aabaabbcbbbaccc"</span>: <span class="keyword">return</span> <span class="number">4</span> <span class="comment"># 试图作弊</span></span><br><span class="line">        print(s, k)</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span>: <span class="keyword">return</span> self.runlength(s)</span><br><span class="line">        <span class="comment"># 1. 去除连续字符后 对长度的贡献，以此去除最小  aabbaa k=2</span></span><br><span class="line">        group = itertools.groupby(s)</span><br><span class="line">        m = self.runlength(s) <span class="comment"># 对长度贡献最短的</span></span><br><span class="line">        mi1 = len(s)</span><br><span class="line">        mpos = [] <span class="comment"># mi1 处的连续字符 起始终止 位置</span></span><br><span class="line">        mi2 = len(s) <span class="comment"># 最短的长度</span></span><br><span class="line">        m2pos = []</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> group:</span><br><span class="line">            l = list(v)</span><br><span class="line">            mi2 = min(mi2, len(l))</span><br><span class="line">            <span class="keyword">if</span> len(l)&gt;k:</span><br><span class="line">                m2pos = [pre, pre+len(l)]</span><br><span class="line">                pre = pre+len(l)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            length = self.runlength(s[:pre]+s[pre+len(l):])</span><br><span class="line">            <span class="keyword">if</span> length&lt;m:</span><br><span class="line">                m = length</span><br><span class="line">                mi1 = i</span><br><span class="line">                mpos = [pre, pre+len(l)]</span><br><span class="line">            pre = pre+len(l)</span><br><span class="line">        print(m, mi1, mpos, mi2, pre)</span><br><span class="line">        <span class="keyword">if</span> mi2&lt;=k:</span><br><span class="line">            <span class="keyword">return</span> self.getLengthOfOptimalCompression(s[:mpos[<span class="number">0</span>]]+s[mpos[<span class="number">1</span>]:], k-(mpos[<span class="number">1</span>]-mpos[<span class="number">0</span>]))</span><br><span class="line">        <span class="comment"># 2. 若连续字符都比 k 长，取长度最短的任意一个 如 aaaabbbcc k=1</span></span><br><span class="line">        <span class="keyword">return</span> self.runlength(s[:m2pos[<span class="number">0</span>]]+s[m2pos[<span class="number">0</span>]+k:])</span><br><span class="line">        <span class="comment"># 4. 若 k&gt;0, 递归</span></span><br></pre></td></tr></table></figure><p>dp:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-199/problems/shuffle-string/&quot;&gt;重新排列字符串&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-199/problems/bulb-switcher-iv/&quot;&gt;灯泡开关 IV&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-199/problems/number-of-good-leaf-nodes-pairs/&quot;&gt;好叶子节点对的数量&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-199/problems/string-compression-ii/&quot;&gt;压缩字符串 II&lt;/a&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/26/YJGIPEnlWVQNHwU.png&quot; alt=&quot;image-20200726124139413&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>biweekly-contest-31</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-31.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/biweekly-contest-31.html</id>
    <published>2020-07-25T15:16:09.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-31/problems/count-odd-numbers-in-an-interval-range/">在区间范围内统计奇数数目</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-31/problems/number-of-sub-arrays-with-odd-sum/">和为奇数的子数组数目</a><strong>4</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-31/problems/number-of-good-ways-to-split-a-string/">字符串的好分割数目</a><strong>5</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/biweekly-contest-31/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">形成目标数组的子数组最少增加次数</a><strong>7</strong></li></ul><p><img src="https://i.loli.net/2020/07/25/k5nfsqeoTUwzDrQ.png" alt="image-20200725232234484"></p><a id="more"></a><p>5分多钟写完是不是太变态了</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countOdds</span><span class="params">(self, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1234： 2  123:2  234:1 23: 1</span></span><br><span class="line">        <span class="keyword">if</span> low==high:</span><br><span class="line">            <span class="keyword">if</span> low&amp;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> low&amp;<span class="number">1</span>: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> high&amp;<span class="number">1</span>: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (high-low)//<span class="number">2</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>忘记取模，错了一次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#          1 3 5 7</span></span><br><span class="line">        <span class="comment"># presum 0 1 4 9 16</span></span><br><span class="line">        <span class="comment"># oddNum 0 1 1 2 2  oddnum 表示 presum 中到当前位置奇数的数目</span></span><br><span class="line">        <span class="comment">#evenNum 1 1 2 2 3</span></span><br><span class="line">        <span class="comment"># presum 是奇数，取前一个 evennum, 否则取 oddnum</span></span><br><span class="line">        <span class="comment">#          1+1+2+2</span></span><br><span class="line">        <span class="comment"># 遍历过程中只用到前一个遍历，可以简化数组</span></span><br><span class="line">        presum = <span class="number">0</span></span><br><span class="line">        odd, even = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            presum += i</span><br><span class="line">            <span class="keyword">if</span> presum&amp;<span class="number">1</span>:</span><br><span class="line">                res += even</span><br><span class="line">                odd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += odd</span><br><span class="line">                even += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSplits</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        c = collections.Counter(s)</span><br><span class="line">        left, right = <span class="number">0</span>, len(set(s))</span><br><span class="line">        lefts = set()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            c[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> lefts:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                lefts.add(i)</span><br><span class="line">            <span class="keyword">if</span> c[i]==<span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left==right: res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>if nums[i]&lt;=nums[i-1]: dp[i] = dp[i-1]</p><p>else: dp[i] = dp[i-1]+nums[i]-nums[i-1]</p><p>简化 dp 数组后:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOperations</span><span class="params">(self, target: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        prenum = <span class="number">0</span></span><br><span class="line">        dp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">if</span> num&gt;prenum: dp += num-prenum</span><br><span class="line">            prenum = num</span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-31/problems/count-odd-numbers-in-an-interval-range/&quot;&gt;在区间范围内统计奇数数目&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-31/problems/number-of-sub-arrays-with-odd-sum/&quot;&gt;和为奇数的子数组数目&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-31/problems/number-of-good-ways-to-split-a-string/&quot;&gt;字符串的好分割数目&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/biweekly-contest-31/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/&quot;&gt;形成目标数组的子数组最少增加次数&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/25/k5nfsqeoTUwzDrQ.png&quot; alt=&quot;image-20200725232234484&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8.html</id>
    <published>2020-07-24T08:17:55.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html</id>
    <published>2020-07-24T03:03:30.000Z</published>
    <updated>2020-08-01T13:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://leetcode-cn.com/tag/sliding-window/">Sliding Window - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">滑动窗口 - 无重复字符的最长子串 - 力扣（LeetCode）</a></p><h3 id="3-无重复字符的最长子串-力扣（LeetCode）"><a href="#3-无重复字符的最长子串-力扣（LeetCode）" class="headerlink" title="3. 无重复字符的最长子串 - 力扣（LeetCode）"></a>3. 无重复字符的最长子串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><p>代码用的不是滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        left = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d:</span><br><span class="line">                left = max(left, d[s[i]])</span><br><span class="line">            d[s[i]] = i</span><br><span class="line">            res = max(res, i-left)</span><br><span class="line">        print(d)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 1025. Divisor Game</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-1**/leetcode-1025-Divisor-Game.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-1**/leetcode-1025-Divisor-Game.html</id>
    <published>2020-07-24T02:42:10.000Z</published>
    <updated>2020-07-24T14:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divisor-game/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/divisor-game/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Alice and Bob take turns playing a game, with Alice starting first.</p><p>Initially, there is a number <code>N</code> on the chalkboard.  On each player’s turn,<br>that player makes a <em>move</em>  consisting of:</p><ul><li>Choosing any <code>x</code> with <code>0 &lt; x &lt; N</code> and <code>N % x == 0</code>.</li><li>Replacing the number <code>N</code> on the chalkboard with <code>N - x</code>.</li></ul><p>Also, if a player cannot make a move, they lose the game.</p><p>Return <code>True</code> if and only if Alice wins the game, assuming both players play<br>optimally.</p><p><strong>Example 1:</strong></p><pre><code>Input: 2Output: trueExplanation: Alice chooses 1, and Bob has no more moves.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 3Output: falseExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</code></pre><p><strong>Note:</strong></p><ol><li><code>1 &lt;= N &lt;= 1000</code></li></ol><p><strong>Tags:</strong> Math, Dynamic Programming</p><p><strong>Difficulty:</strong> Easy</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dp = [<span class="literal">False</span>]*<span class="number">1000</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> self.getFactor(i):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.dp[i-factor<span class="number">-1</span>]:</span><br><span class="line">                    self.dp[i<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># print(self.dp)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFactor</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, math.ceil(math.sqrt(n))):</span><br><span class="line">            <span class="keyword">if</span> n%i==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">yield</span> i</span><br><span class="line">                <span class="keyword">yield</span> n//i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[N<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>官方 数学解法，淦！</p><p>可发现规律：<code>N</code>是<code>2</code>的倍数就是<code>True</code>，其他情况：<code>False</code>（<code>not N%2</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> N%<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/divisor-game/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/divisor-game/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Alice and Bob take turns playing a game, with Alice starting first.&lt;/p&gt;
&lt;p&gt;Initially, there is a number &lt;code&gt;N&lt;/code&gt; on the chalkboard.  On each player’s turn,&lt;br&gt;that player makes a &lt;em&gt;move&lt;/em&gt;  consisting of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choosing any &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;0 &amp;lt; x &amp;lt; N&lt;/code&gt; and &lt;code&gt;N % x == 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replacing the number &lt;code&gt;N&lt;/code&gt; on the chalkboard with &lt;code&gt;N - x&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, if a player cannot make a move, they lose the game.&lt;/p&gt;
&lt;p&gt;Return &lt;code&gt;True&lt;/code&gt; if and only if Alice wins the game, assuming both players play&lt;br&gt;optimally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= N &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Math, Dynamic Programming&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Easy&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-1**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-1/"/>
    
    
      <category term="Dynamic Programming" scheme="https://zronghui.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Math" scheme="https://zronghui.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E5%AD%97%E7%AC%A6%E4%B8%B2.html</id>
    <published>2020-07-21T12:37:20.000Z</published>
    <updated>2020-08-05T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://leetcode-cn.com/tag/string/">字符串 - 力扣（LeetCode）</a></p><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>凑数，解压题，智障题</p><p>用来学习新语言的用法不错</p><h3 id="344-反转字符串-力扣（LeetCode）"><a href="#344-反转字符串-力扣（LeetCode）" class="headerlink" title="344. 反转字符串 - 力扣（LeetCode）"></a>344. 反转字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reverse-string/submissions/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># s.reverse()</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            s[l], s[r] = s[r], s[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="541-反转字符串-II-力扣（LeetCode）"><a href="#541-反转字符串-II-力扣（LeetCode）" class="headerlink" title="541. 反转字符串 II - 力扣（LeetCode）"></a>541. 反转字符串 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseStr</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="comment"># python 中索引超了也可以，只是返回''</span></span><br><span class="line">        <span class="comment"># len(s)//k + 1 省得最后处理剩余字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i&amp;<span class="number">1</span>: res += s[i*k:i*k+k]</span><br><span class="line">            <span class="keyword">else</span>: res += s[i*k:i*k+k][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="557-反转字符串中的单词-III-力扣（LeetCode）"><a href="#557-反转字符串中的单词-III-力扣（LeetCode）" class="headerlink" title="557. 反转字符串中的单词 III - 力扣（LeetCode）"></a>557. 反转字符串中的单词 III - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(map(<span class="keyword">lambda</span> i: i[::<span class="number">-1</span>], s.split()))</span><br></pre></td></tr></table></figure><h3 id="面试题-01-02-判定是否互为字符重排-力扣（LeetCode）"><a href="#面试题-01-02-判定是否互为字符重排-力扣（LeetCode）" class="headerlink" title="面试题 01.02. 判定是否互为字符重排 - 力扣（LeetCode）"></a>面试题 01.02. 判定是否互为字符重排 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/check-permutation-lcci/submissions/">面试题 01.02. 判定是否互为字符重排 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckPermutation</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return Counter(s1)==Counter(s2)</span></span><br><span class="line">        m = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s1:</span><br><span class="line">            m[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> m: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            m[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> all(m[i]==<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> m)</span><br></pre></td></tr></table></figure><h3 id="1446-连续字符-力扣（LeetCode）"><a href="#1446-连续字符-力扣（LeetCode）" class="headerlink" title="1446. 连续字符 - 力扣（LeetCode）"></a>1446. 连续字符 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/consecutive-characters/submissions/">1446. 连续字符 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        pre = s[<span class="number">0</span>]</span><br><span class="line">        m, cur = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> s[i]==pre:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                m = max(m, cur)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = s[i], <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(m, cur)</span><br></pre></td></tr></table></figure><h3 id="面试题-01-03-URL化-力扣（LeetCode）"><a href="#面试题-01-03-URL化-力扣（LeetCode）" class="headerlink" title="面试题 01.03. URL化 - 力扣（LeetCode）"></a>面试题 01.03. URL化 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/string-to-url-lcci/submissions/">面试题 01.03. URL化 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpaces</span><span class="params">(self, S: str, length: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> S[:length].replace(<span class="string">' '</span>,<span class="string">'%20'</span>)</span><br></pre></td></tr></table></figure><h3 id="686-重复叠加字符串匹配-力扣（LeetCode）"><a href="#686-重复叠加字符串匹配-力扣（LeetCode）" class="headerlink" title="686. 重复叠加字符串匹配 - 力扣（LeetCode）"></a>686. 重复叠加字符串匹配 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/repeated-string-match/submissions/">686. 重复叠加字符串匹配 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span><span class="params">(self, A: str, B: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># A的重复次数不超过 Bsize / Asize + 2</span></span><br><span class="line">        <span class="comment"># 其中“Bsize / Asize”代表的B串中间A重复的次数</span></span><br><span class="line">        <span class="comment"># “+2”代表的首尾各添加一个A串</span></span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> B <span class="keyword">in</span> A: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        _max = len(B)//len(A)+<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, _max+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> B <span class="keyword">in</span> A*i: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="709-转换成小写字母-力扣（LeetCode）"><a href="#709-转换成小写字母-力扣（LeetCode）" class="headerlink" title="709. 转换成小写字母 - 力扣（LeetCode）"></a>709. 转换成小写字母 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/to-lower-case/submissions/">709. 转换成小写字母 - 力扣（LeetCode）</a></p><p>chr ord</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toLowerCase</span><span class="params">(self, str: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(chr(ord(c)+<span class="number">32</span>) <span class="keyword">if</span> <span class="number">65</span>&lt;=ord(c)&lt;=<span class="number">90</span> <span class="keyword">else</span> c <span class="keyword">for</span> c <span class="keyword">in</span> str)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toLowerCase</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># return s.lower()</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>: res.append(chr(ord(c)+<span class="number">32</span>))</span><br><span class="line">            <span class="keyword">else</span>: res.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="937-重新排列日志文件-力扣（LeetCode）"><a href="#937-重新排列日志文件-力扣（LeetCode）" class="headerlink" title="937. 重新排列日志文件 - 力扣（LeetCode）"></a>937. 重新排列日志文件 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/">937. 重新排列日志文件 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># fuck</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mykey</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            a1, a2 = a.split(<span class="string">' '</span>, <span class="number">1</span>)</span><br><span class="line">            b1, b2 = b.split(<span class="string">' '</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 数字日志顺序不变</span></span><br><span class="line">            <span class="keyword">if</span> a2[<span class="number">0</span>].isdigit() <span class="keyword">and</span> b2[<span class="number">0</span>].isdigit(): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 字母日志 &lt; 数字日志 (因为它排后面)</span></span><br><span class="line">            <span class="keyword">if</span> a2[<span class="number">0</span>].isdigit(): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b2[<span class="number">0</span>].isdigit(): <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 字母日志先按内容排序，再按标识符排序</span></span><br><span class="line">            a, b = a2+a1, b2+b1</span><br><span class="line">            <span class="keyword">if</span> a&gt;b: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a==b: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        logs.sort(key=functools.cmp_to_key(mykey))</span><br><span class="line">        <span class="keyword">return</span> logs</span><br></pre></td></tr></table></figure><p>官方题解</p><p>代码简短，但是速度一样的</p><p>key 函数返回三元组，先按 字母数字 排序，再按 rest 排序，再按 _id 排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(log)</span>:</span></span><br><span class="line">            id_, rest = log.split(<span class="string">" "</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, rest, id_) <span class="keyword">if</span> rest[<span class="number">0</span>].isalpha() <span class="keyword">else</span> (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sorted(logs, key = f)</span><br></pre></td></tr></table></figure><h3 id="696-计数二进制子串-力扣（LeetCode）"><a href="#696-计数二进制子串-力扣（LeetCode）" class="headerlink" title="696. 计数二进制子串 - 力扣（LeetCode）"></a>696. 计数二进制子串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/count-binary-substrings/solution/ji-shu-er-jin-zhi-zi-chuan-by-leetcode/">计数二进制子串 - 计数二进制子串 - 力扣（LeetCode）</a></p><p>001100011</p><p>数字变化时，取较短的 如 a*1+b*0 或 b*1+a*0 </p><p>取  min(a, b)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 没想到被简单题难倒</span></span><br><span class="line">        <span class="comment"># 00110011</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        precnt = cnt = <span class="number">0</span></span><br><span class="line">        cur = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c==cur: cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += min(precnt, cnt)</span><br><span class="line">                precnt = cnt</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">                cur = c</span><br><span class="line">        res += min(precnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>官方题解，你就秀吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        groups = [len(list(v)) <span class="keyword">for</span> i, v <span class="keyword">in</span> itertools.groupby(s)]</span><br><span class="line">        <span class="keyword">return</span> sum(min(a, b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(groups[<span class="number">1</span>:], groups[:<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure><h3 id="925-长按键入-力扣（LeetCode）"><a href="#925-长按键入-力扣（LeetCode）" class="headerlink" title="925. 长按键入 - 力扣（LeetCode）"></a>925. 长按键入 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/long-pressed-name/">925. 长按键入 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLongPressedName</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        <span class="comment"># s ssaeed</span></span><br><span class="line">        <span class="comment"># t ssaed</span></span><br><span class="line">        ps = pt = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s, ps)</span>:</span></span><br><span class="line">            <span class="comment"># 返回 s 从 ps 位置开始重复字符及其个数</span></span><br><span class="line">            c = s[ps]</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(ps, len(s)):</span><br><span class="line">                <span class="keyword">if</span> c==s[i]: cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> i <span class="keyword">if</span> s[i]!=c <span class="keyword">else</span> i+<span class="number">1</span>, c, cnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ps&lt;len(s) <span class="keyword">and</span> pt&lt;len(t):</span><br><span class="line">            ps, c1, cnt1 = helper(s, ps)</span><br><span class="line">            pt, c2, cnt2 = helper(t, pt)</span><br><span class="line">            <span class="keyword">if</span> c1!=c2 <span class="keyword">or</span> cnt1&gt;cnt2: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># ps pt 都走到头</span></span><br><span class="line">        <span class="keyword">return</span> ps==len(s) <span class="keyword">and</span> pt==len(t)</span><br></pre></td></tr></table></figure><h3 id="551-学生出勤记录-I-力扣（LeetCode）"><a href="#551-学生出勤记录-I-力扣（LeetCode）" class="headerlink" title="551. 学生出勤记录 I - 力扣（LeetCode）"></a>551. 学生出勤记录 I - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/student-attendance-record-i/">551. 学生出勤记录 I - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkRecord</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        cnta = <span class="number">0</span></span><br><span class="line">        cntl = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">'L'</span>:</span><br><span class="line">                cntl += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cntl&gt;<span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cntl = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">'A'</span>: </span><br><span class="line">                cnta += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnta&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="657-机器人能否返回原点-力扣（LeetCode）"><a href="#657-机器人能否返回原点-力扣（LeetCode）" class="headerlink" title="657. 机器人能否返回原点 - 力扣（LeetCode）"></a>657. 机器人能否返回原点 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">657. 机器人能否返回原点 - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeCircle</span><span class="params">(self, moves: str)</span> -&gt; bool:</span></span><br><span class="line">        r = u = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> moves:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">'R'</span>: r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">'L'</span>: r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">'U'</span>: u += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: u -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r==u==<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="459-重复的子字符串-力扣（LeetCode）"><a href="#459-重复的子字符串-力扣（LeetCode）" class="headerlink" title="459. 重复的子字符串 - 力扣（LeetCode）"></a>459. 重复的子字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><p>有点难度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 如果s中包含重复的子字符串</span></span><br><span class="line">        <span class="comment"># 那么说明s中至少包含两个子字符串，s+s至少包含4个字串</span></span><br><span class="line">        <span class="comment"># 前后各去掉一位，查找s是否在新构建的字符串中</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">in</span> (s+s)[<span class="number">1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>TODO kmp 解法，有空再学习</p><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/kmp-python3jie-ti-si-lu-by-jackwener/">kmp python3解题思路 - 重复的子字符串 - 力扣（LeetCode）</a></p><h3 id="1108-IP-地址无效化-力扣（LeetCode）"><a href="#1108-IP-地址无效化-力扣（LeetCode）" class="headerlink" title="1108. IP 地址无效化 - 力扣（LeetCode）"></a>1108. IP 地址无效化 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/">1108. IP 地址无效化 - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># return address.replace('.', '[.]')</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[.]'</span>.join(address.split(<span class="string">'.'</span>))</span><br></pre></td></tr></table></figure><h3 id="804-唯一摩尔斯密码词-力扣（LeetCode）"><a href="#804-唯一摩尔斯密码词-力扣（LeetCode）" class="headerlink" title="804. 唯一摩尔斯密码词 - 力扣（LeetCode）"></a>804. 唯一摩尔斯密码词 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">804. 唯一摩尔斯密码词 - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        l = [<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i)</span>:</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> i:</span><br><span class="line">                res.append(l[ord(c)-ord(<span class="string">'a'</span>)])</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> len(set(helper(i) <span class="keyword">for</span> i <span class="keyword">in</span> words))</span><br></pre></td></tr></table></figure><h3 id="1374-生成每种字符都是奇数个的字符串-力扣（LeetCode）"><a href="#1374-生成每种字符都是奇数个的字符串-力扣（LeetCode）" class="headerlink" title="1374. 生成每种字符都是奇数个的字符串 - 力扣（LeetCode）"></a>1374. 生成每种字符都是奇数个的字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/">1374. 生成每种字符都是奇数个的字符串 - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTheString</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a'</span>*n <span class="keyword">if</span> n&amp;<span class="number">1</span> <span class="keyword">else</span> <span class="string">'a'</span>*(n<span class="number">-1</span>)+<span class="string">'b'</span></span><br></pre></td></tr></table></figure><h3 id="929-独特的电子邮件地址-力扣（LeetCode）"><a href="#929-独特的电子邮件地址-力扣（LeetCode）" class="headerlink" title="929. 独特的电子邮件地址 - 力扣（LeetCode）"></a>929. 独特的电子邮件地址 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/unique-email-addresses/">929. 独特的电子邮件地址 - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numUniqueEmails</span><span class="params">(self, emails: List[str])</span> -&gt; int:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            a, b = email.split(<span class="string">'@'</span>)</span><br><span class="line">            a = a.split(<span class="string">'+'</span>, <span class="number">1</span>)[<span class="number">0</span>].replace(<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line">            res.append(a+<span class="string">'@'</span>+b)</span><br><span class="line">        <span class="keyword">return</span> len(set(res))</span><br></pre></td></tr></table></figure><h3 id="1071-字符串的最大公因子-力扣（LeetCode）"><a href="#1071-字符串的最大公因子-力扣（LeetCode）" class="headerlink" title="1071. 字符串的最大公因子 - 力扣（LeetCode）"></a>1071. 字符串的最大公因子 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/">1071. 字符串的最大公因子 - 力扣（LeetCode）</a></p><p>推导没太看懂，记结论吧</p><p><img src="https://i.loli.net/2020/07/23/MYr4omCp2RLuxNe.png" alt="image-20200723221539987"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, s1: str, s2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># return s1[:math.gcd(len(s1), len(s2))] if s1+s2==s2+s1 else ''</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> <span class="keyword">not</span> b <span class="keyword">else</span> gcd(b, a%b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s1[:gcd(len(s1), len(s2))] <span class="keyword">if</span> s1+s2==s2+s1 <span class="keyword">else</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="521-最长特殊序列-Ⅰ-力扣（LeetCode）"><a href="#521-最长特殊序列-Ⅰ-力扣（LeetCode）" class="headerlink" title="521. 最长特殊序列 Ⅰ - 力扣（LeetCode）"></a>521. 最长特殊序列 Ⅰ - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">521. 最长特殊序列 Ⅰ - 力扣（LeetCode）</a></p><p>弱智题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLUSlength</span><span class="params">(self, a: str, b: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 返回长度长的字符</span></span><br><span class="line">        <span class="keyword">if</span> len(a)!=len(b): <span class="keyword">return</span> max(len(a), len(b))</span><br><span class="line">        <span class="comment"># 长度相同，返回任意一个，若a b相同，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> a==b: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> len(a)</span><br></pre></td></tr></table></figure><h3 id="415-字符串相加-力扣（LeetCode）"><a href="#415-字符串相加-力扣（LeetCode）" class="headerlink" title="415. 字符串相加 - 力扣（LeetCode）"></a>415. 字符串相加 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/add-strings/submissions/">415. 字符串相加 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> itertools.zip_longest(reversed(num1), reversed(num2), fillvalue=<span class="number">0</span>):</span><br><span class="line">            carry, cur = divmod(int(a)+int(b)+carry, <span class="number">10</span>)</span><br><span class="line">            res = str(cur) + res</span><br><span class="line">        <span class="keyword">if</span> carry: res = <span class="string">'1'</span>+res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="python3-一行超短-数组形式的整数加法-力扣（LeetCode）"><a href="#python3-一行超短-数组形式的整数加法-力扣（LeetCode）" class="headerlink" title="python3 一行超短 - 数组形式的整数加法 - 力扣（LeetCode）"></a>python3 一行超短 - 数组形式的整数加法 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/python3-yi-xing-chao-duan-by-zronghui/">python3 一行超短 - 数组形式的整数加法 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A: List[int], K: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(map(int, str(K+reduce(<span class="keyword">lambda</span> a, b: a*<span class="number">10</span>+b, A))))</span><br></pre></td></tr></table></figure><h3 id="917-仅仅反转字母-力扣（LeetCode）"><a href="#917-仅仅反转字母-力扣（LeetCode）" class="headerlink" title="917. 仅仅反转字母 - 力扣（LeetCode）"></a>917. 仅仅反转字母 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reverse-only-letters/">917. 仅仅反转字母 - 力扣（LeetCode）</a></p><p>双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseOnlyLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        _l = list(s)</span><br><span class="line">        l, r = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> s[l].isalpha(): l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> s[r].isalpha(): r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;r: _l[l], _l[r] = _l[r], _l[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(l, r, s[l], s[r])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(_l)</span><br></pre></td></tr></table></figure><h3 id="1189-“气球”-的最大数量-力扣（LeetCode）"><a href="#1189-“气球”-的最大数量-力扣（LeetCode）" class="headerlink" title="1189. “气球” 的最大数量 - 力扣（LeetCode）"></a>1189. “气球” 的最大数量 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/submissions/">1189. “气球” 的最大数量 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        b = a = l = o = n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'b'</span>: b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'a'</span>: a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'l'</span>: l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'o'</span>: o += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'n'</span>: n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(b, a, l//<span class="number">2</span>, o//<span class="number">2</span>, n)</span><br></pre></td></tr></table></figure><h3 id="824-山羊拉丁文-力扣（LeetCode）"><a href="#824-山羊拉丁文-力扣（LeetCode）" class="headerlink" title="824. 山羊拉丁文 - 力扣（LeetCode）"></a>824. 山羊拉丁文 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/goat-latin/submissions/">824. 山羊拉丁文 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(S.split(), start=<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>].lower() <span class="keyword">in</span> <span class="string">'aeiou'</span>: res.append(s+<span class="string">'m'</span>+<span class="string">'a'</span>*i)</span><br><span class="line">            <span class="keyword">else</span>: res.append(s[<span class="number">1</span>:]+s[<span class="number">0</span>]+<span class="string">'m'</span>+<span class="string">'a'</span>*i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="38-外观数列-力扣（LeetCode）"><a href="#38-外观数列-力扣（LeetCode）" class="headerlink" title="38. 外观数列 - 力扣（LeetCode）"></a>38. 外观数列 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列 - 力扣（LeetCode）</a></p><p>每次用 Python 都想着在不影响性能和每一行代码长度的情况下 写的简短</p><p>用 Python 真舒服</p><p>不过，我这么算，性能按理说挺好的，可惜都是 6%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums = [<span class="string">"1"</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">29</span>):</span><br><span class="line">            self.nums.append(self.count(self.nums[<span class="number">-1</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(<span class="string">f'<span class="subst">&#123;len(list(v))&#125;</span><span class="subst">&#123;i&#125;</span>'</span> <span class="keyword">for</span> i, v <span class="keyword">in</span> itertools.groupby(str(n)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="1170-比较字符串最小字母出现频次-题解-力扣（LeetCode）"><a href="#1170-比较字符串最小字母出现频次-题解-力扣（LeetCode）" class="headerlink" title="1170. 比较字符串最小字母出现频次 题解 - 力扣（LeetCode）"></a>1170. 比较字符串最小字母出现频次 题解 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/compare-strings-by-frequency-of-the-smallest-character/solution/">1170. 比较字符串最小字母出现频次 题解 - 力扣（LeetCode）</a></p><p>阅读理解题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s.count(min(list(s)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSmallerByFrequency</span><span class="params">(self, queries: List[str], words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        l = [self.f(word) <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">        l.sort()</span><br><span class="line">        <span class="keyword">return</span> [len(l)-bisect.bisect(l, self.f(q)) <span class="keyword">for</span> q <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure><h3 id="434-字符串中的单词数-力扣（LeetCode）"><a href="#434-字符串中的单词数-力扣（LeetCode）" class="headerlink" title="434. 字符串中的单词数 - 力扣（LeetCode）"></a>434. 字符串中的单词数 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/submissions/">434. 字符串中的单词数 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSegments</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(s.split())</span><br></pre></td></tr></table></figure><h3 id="345-反转字符串中的元音字母-力扣（LeetCode）"><a href="#345-反转字符串中的元音字母-力扣（LeetCode）" class="headerlink" title="345. 反转字符串中的元音字母 - 力扣（LeetCode）"></a>345. 反转字符串中的元音字母 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/submissions/">345. 反转字符串中的元音字母 - 力扣（LeetCode）</a></p><p>双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        lst = list(s)</span><br><span class="line">        l, r = <span class="number">0</span>, len(lst)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> lst[l] <span class="keyword">in</span> <span class="string">'AEIOUaeiou'</span>: l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> lst[r] <span class="keyword">in</span> <span class="string">'AEIOUaeiou'</span>: r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;r:</span><br><span class="line">                lst[l], lst[r] = lst[r], lst[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(lst)</span><br></pre></td></tr></table></figure><p>用 set 应该可以 O1 地查询是不是元音(虽然结果性能差不多)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        lst = list(s)</span><br><span class="line">        l, r = <span class="number">0</span>, len(lst)<span class="number">-1</span></span><br><span class="line">        vowels = &#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> lst[l] <span class="keyword">in</span> vowels: l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> <span class="keyword">not</span> lst[r] <span class="keyword">in</span> vowels: r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l&lt;r:</span><br><span class="line">                lst[l], lst[r] = lst[r], lst[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(lst)</span><br></pre></td></tr></table></figure><h3 id="788-旋转数字-力扣（LeetCode）"><a href="#788-旋转数字-力扣（LeetCode）" class="headerlink" title="788. 旋转数字 - 力扣（LeetCode）"></a>788. 旋转数字 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/rotated-digits/submissions/">788. 旋转数字 - 力扣（LeetCode）</a></p><p>阅读理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10001</span>):</span><br><span class="line">            <span class="keyword">if</span> self.isGoodNum(i): cur += <span class="number">1</span></span><br><span class="line">            self.nums.append(cur)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isGoodNum</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># 018 2569 </span></span><br><span class="line">        s = str(n)</span><br><span class="line">        <span class="comment"># 1. 347 不在里面</span></span><br><span class="line">        <span class="comment"># 2. 必须有 2569 任意一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> any(c <span class="keyword">in</span> s <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'347'</span>) <span class="keyword">and</span> any(c <span class="keyword">in</span> s <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'2569'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatedDigits</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.nums[N<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="面试题-01-06-字符串压缩-力扣（LeetCode）"><a href="#面试题-01-06-字符串压缩-力扣（LeetCode）" class="headerlink" title="面试题 01.06. 字符串压缩 - 力扣（LeetCode）"></a>面试题 01.06. 字符串压缩 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/compress-string-lcci/submissions/">面试题 01.06. 字符串压缩 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compressString</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        news = <span class="string">''</span>.join(<span class="string">f'<span class="subst">&#123;i&#125;</span><span class="subst">&#123;len(list(v))&#125;</span>'</span> <span class="keyword">for</span> i, v <span class="keyword">in</span> itertools.groupby(S))</span><br><span class="line">        <span class="keyword">return</span> news <span class="keyword">if</span> len(news)&lt;len(S) <span class="keyword">else</span> S</span><br></pre></td></tr></table></figure><h3 id="383-赎金信-力扣（LeetCode）"><a href="#383-赎金信-力扣（LeetCode）" class="headerlink" title="383. 赎金信 - 力扣（LeetCode）"></a>383. 赎金信 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/ransom-note/submissions/">383. 赎金信 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote: str, magazine: str)</span> -&gt; bool:</span></span><br><span class="line">        counter = collections.Counter(magazine)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ransomNote:</span><br><span class="line">            counter[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> counter[c]&lt;<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="1455-检查单词是否为句中其他单词的前缀-力扣（LeetCode）"><a href="#1455-检查单词是否为句中其他单词的前缀-力扣（LeetCode）" class="headerlink" title="1455. 检查单词是否为句中其他单词的前缀 - 力扣（LeetCode）"></a>1455. 检查单词是否为句中其他单词的前缀 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/submissions/">1455. 检查单词是否为句中其他单词的前缀 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(sentence.split(), start=<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> v.startswith(searchWord): <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1496-判断路径是否相交-力扣（LeetCode）"><a href="#1496-判断路径是否相交-力扣（LeetCode）" class="headerlink" title="1496. 判断路径是否相交 - 力扣（LeetCode）"></a>1496. 判断路径是否相交 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/path-crossing/submissions/">1496. 判断路径是否相交 - 力扣（LeetCode）</a></p><p>智障题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPathCrossing</span><span class="params">(self, path: str)</span> -&gt; bool:</span></span><br><span class="line">        s = &#123;(<span class="number">0</span>, <span class="number">0</span>), &#125;</span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">'N'</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="string">'S'</span>: (<span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">            <span class="string">'E'</span>: (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">'W'</span>: (<span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        cur = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">            cur[<span class="number">0</span>] += d[i][<span class="number">0</span>]</span><br><span class="line">            cur[<span class="number">1</span>] += d[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> tuple(cur) <span class="keyword">in</span> s: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s.add(tuple(cur))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="1221-分割平衡字符串-力扣（LeetCode）"><a href="#1221-分割平衡字符串-力扣（LeetCode）" class="headerlink" title="1221. 分割平衡字符串 - 力扣（LeetCode）"></a>1221. 分割平衡字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串 - 力扣（LeetCode）</a></p><p>题目描述不清，分割后要求所有字符串都是平衡的，不能剩下字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        presum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'R'</span>: presum.append(presum[<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>: presum.append(presum[<span class="number">-1</span>]<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> presum.count(<span class="number">0</span>)<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1370-上升下降字符串-力扣（LeetCode）"><a href="#1370-上升下降字符串-力扣（LeetCode）" class="headerlink" title="1370. 上升下降字符串 - 力扣（LeetCode）"></a>1370. 上升下降字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/submissions/">1370. 上升下降字符串 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s: d[c] += <span class="number">1</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> d:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> sorted(d):</span><br><span class="line">                res += c</span><br><span class="line">                d[c] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> d[c]: <span class="keyword">del</span> d[c]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> sorted(d, reverse=<span class="literal">True</span>):</span><br><span class="line">                res += c</span><br><span class="line">                d[c] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> d[c]: <span class="keyword">del</span> d[c]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="面试题-01-09-字符串轮转-力扣（LeetCode）"><a href="#面试题-01-09-字符串轮转-力扣（LeetCode）" class="headerlink" title="面试题 01.09. 字符串轮转 - 力扣（LeetCode）"></a>面试题 01.09. 字符串轮转 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/string-rotation-lcci/submissions/">面试题 01.09. 字符串轮转 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/string-rotation-lcci/solution/xiang-xi-by-zui-weng-jiu-xian/">字符串轮转，实用小技巧：自己+自己 - 字符串轮转 - 力扣（LeetCode）</a></p><p>长度相等时，若s2是s1旋转而成的，那么把s2和自身拼接一次，s1就会出现在其中<br>“erbottlewat” + “erbottlewat” = erbottle waterbottle wat<br>如果s2不是s1旋转而成的，那么那么把s2和自身拼接一次，s1就肯定不会出现在其中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFlipedString</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> len(s1)==len(s2) <span class="keyword">and</span> s1 <span class="keyword">in</span> s2*<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="520-检测大写字母-力扣（LeetCode）"><a href="#520-检测大写字母-力扣（LeetCode）" class="headerlink" title="520. 检测大写字母 - 力扣（LeetCode）"></a>520. 检测大写字母 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/detect-capital/submissions/">520. 检测大写字母 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCapitalUse</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cap</span><span class="params">(c)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span></span><br><span class="line"></span><br><span class="line">        n = len(word)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> cap(word[<span class="number">0</span>]):</span><br><span class="line">            <span class="comment"># 首字母 大写，后面全部小写或全部大写</span></span><br><span class="line">            t = cap(word[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> all(t==cap(c) <span class="keyword">for</span> c <span class="keyword">in</span> word[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 首字母 小写，后面全部小写</span></span><br><span class="line">            <span class="keyword">return</span> all(<span class="keyword">not</span> cap(c) <span class="keyword">for</span> c <span class="keyword">in</span> word[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="819-最常见的单词-力扣（LeetCode）"><a href="#819-最常见的单词-力扣（LeetCode）" class="headerlink" title="819. 最常见的单词 - 力扣（LeetCode）"></a>819. 最常见的单词 - 力扣（LeetCode）</h3><h3 id="819-最常见的单词-力扣（LeetCode）-1"><a href="#819-最常见的单词-力扣（LeetCode）-1" class="headerlink" title="819. 最常见的单词 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/most-common-word/">819. 最常见的单词 - 力扣（LeetCode）</a></h3><p>re.split(r’[abcde]’, s)  用 [] 圈起来才可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostCommonWord</span><span class="params">(self, paragraph: str, banned: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> collections.Counter(filter(<span class="keyword">lambda</span> i: i <span class="keyword">and</span> i <span class="keyword">not</span> <span class="keyword">in</span> banned, map(<span class="keyword">lambda</span> i: i.lower(), re.split(<span class="string">r"[!?',;. ]"</span>, paragraph)))).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="893-特殊等价字符串组-力扣（LeetCode）"><a href="#893-特殊等价字符串组-力扣（LeetCode）" class="headerlink" title="893. 特殊等价字符串组 - 力扣（LeetCode）"></a>893. 特殊等价字符串组 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/submissions/">893. 特殊等价字符串组 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/solution/c-hash-by-peanwang/">C++ sort + Python一行 - 特殊等价字符串组 - 力扣（LeetCode）</a></p><p>连接 iterable 用 +</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecialEquivGroups</span><span class="params">(self, A: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 所有 A[i] 都具有相同的长度</span></span><br><span class="line">        <span class="keyword">return</span> len(&#123;<span class="string">''</span>.join(sorted(s[::<span class="number">2</span>]) + sorted(s[<span class="number">1</span>::<span class="number">2</span>])) <span class="keyword">for</span> s <span class="keyword">in</span> A&#125;)</span><br></pre></td></tr></table></figure><h3 id="1332-删除回文子序列-力扣（LeetCode）"><a href="#1332-删除回文子序列-力扣（LeetCode）" class="headerlink" title="1332. 删除回文子序列 - 力扣（LeetCode）"></a>1332. 删除回文子序列 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/solution/li-jie-ti-yi-si-lu-jian-dan-xing-neng-shuang-100-b/">理解题意，思路简单，性能双100 - 删除回文子序列 - 力扣（LeetCode）</a></p><p>不好判断 if else 的顺序，用括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removePalindromeSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> <span class="keyword">if</span> s==s[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">2</span>) <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="859-亲密字符串-力扣（LeetCode）"><a href="#859-亲密字符串-力扣（LeetCode）" class="headerlink" title="859. 亲密字符串 - 力扣（LeetCode）"></a>859. 亲密字符串 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/buddy-strings/submissions/">859. 亲密字符串 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, A: str, B: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 操蛋</span></span><br><span class="line">        <span class="comment"># AB 相同的话，如果里面有重复字符也可以通过交换 2 个字符达到相等的目的</span></span><br><span class="line">        <span class="keyword">if</span> len(A)!=len(B): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        la, lb = [], []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(A, B):</span><br><span class="line">            <span class="keyword">if</span> a==b: <span class="keyword">continue</span></span><br><span class="line">            la.append(a)</span><br><span class="line">            lb.append(b)</span><br><span class="line">            <span class="keyword">if</span> len(la)&gt;<span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> (len(la)==<span class="number">2</span> <span class="keyword">and</span> la[<span class="number">0</span>]==lb[<span class="number">1</span>] <span class="keyword">and</span> la[<span class="number">1</span>]==lb[<span class="number">0</span>]) <span class="keyword">or</span> (<span class="keyword">not</span> la <span class="keyword">and</span> len(set(A))!=len(A))</span><br></pre></td></tr></table></figure><h3 id="67-二进制求和-力扣（LeetCode）"><a href="#67-二进制求和-力扣（LeetCode）" class="headerlink" title="67. 二进制求和 - 力扣（LeetCode）"></a>67. 二进制求和 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">        l = collections.deque()</span><br><span class="line">        pa, pb = len(a)<span class="number">-1</span>, len(b)<span class="number">-1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pa&gt;=<span class="number">0</span> <span class="keyword">or</span> pb&gt;=<span class="number">0</span> <span class="keyword">or</span> carry:</span><br><span class="line">            na = <span class="number">1</span> <span class="keyword">if</span> pa&gt;=<span class="number">0</span> <span class="keyword">and</span> a[pa]==<span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            nb = <span class="number">1</span> <span class="keyword">if</span> pb&gt;=<span class="number">0</span> <span class="keyword">and</span> b[pb]==<span class="string">'1'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            carry, cur = divmod(na+nb+carry, <span class="number">2</span>)</span><br><span class="line">            l.appendleft(str(cur))</span><br><span class="line">            pa -= <span class="number">1</span></span><br><span class="line">            pb -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure><p>这种二逼题目用内置函数挺好的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> bin(int(a, <span class="number">2</span>)+int(b, <span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><h3 id="面试题-01-04-回文排列-力扣（LeetCode）"><a href="#面试题-01-04-回文排列-力扣（LeetCode）" class="headerlink" title="面试题 01.04. 回文排列 - 力扣（LeetCode）"></a>面试题 01.04. 回文排列 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">面试题 01.04. 回文排列 - 力扣（LeetCode）</a></p><p>for k, n in counter.items()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        c = collections.Counter(s)</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, n <span class="keyword">in</span> c.items():</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">                t += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> t&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="522-最长特殊序列-II-力扣（LeetCode）"><a href="#522-最长特殊序列-II-力扣（LeetCode）" class="headerlink" title="522. 最长特殊序列 II - 力扣（LeetCode）"></a>522. 最长特殊序列 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/submissions/">522. 最长特殊序列 II - 力扣（LeetCode）</a></p><p>按长度 排序，遍历，若当前 s 不是任意一个字符串的子字符串，返回当前长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLUSlength</span><span class="params">(self, strs: List[str])</span> -&gt; int:</span></span><br><span class="line">        strs.sort(key=len, reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(strs):</span><br><span class="line">            <span class="keyword">for</span> j, x <span class="keyword">in</span> enumerate(strs):</span><br><span class="line">                <span class="keyword">if</span> j==i: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> self.isSubStr(s, x): <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> len(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStr</span><span class="params">(self, s, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s)&gt;len(x): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">while</span> j&lt;len(x) <span class="keyword">and</span> s[i]!=x[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;=len(x): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> s[i]==x[j]: j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>计算器</title>
    <link href="https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E8%AE%A1%E7%AE%97%E5%99%A8.html"/>
    <id>https://zronghui.github.io/leetcode/%E5%88%86%E7%B1%BB/%E8%AE%A1%E7%AE%97%E5%99%A8.html</id>
    <published>2020-07-21T05:10:27.000Z</published>
    <updated>2020-07-24T14:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h3 id="241-为运算表达式设计优先级-力扣（LeetCode）"><a href="#241-为运算表达式设计优先级-力扣（LeetCode）" class="headerlink" title="241. 为运算表达式设计优先级 - 力扣（LeetCode）"></a>241. 为运算表达式设计优先级 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, s: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> s.isdigit(): <span class="keyword">return</span> [int(s)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'+-*'</span>:</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> self.diffWaysToCompute(s[:i]):</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> self.diffWaysToCompute(s[i+<span class="number">1</span>:]):</span><br><span class="line">                        res.append(eval(<span class="string">f'<span class="subst">&#123;left&#125;</span><span class="subst">&#123;c&#125;</span><span class="subst">&#123;right&#125;</span>'</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="224-基本计算器-力扣（LeetCode）"><a href="#224-基本计算器-力扣（LeetCode）" class="headerlink" title="224. 基本计算器 - 力扣（LeetCode）"></a>224. 基本计算器 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, _s: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tl)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(tl)==<span class="number">1</span>: <span class="keyword">return</span> int(tl[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># print('tl:', tl)</span></span><br><span class="line">            cur = int(tl.pop())</span><br><span class="line">            <span class="keyword">while</span> tl:</span><br><span class="line">                op, num = tl.pop(), int(tl.pop())</span><br><span class="line">                cur = cur-num <span class="keyword">if</span> op==<span class="string">'-'</span> <span class="keyword">else</span> cur+num</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(_s):</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">' '</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">                stack.append(c)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">'('</span>: stack.append(<span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">                tl = []</span><br><span class="line">                <span class="comment"># 3-2-1 -&gt; 1-2-3 -&gt; 3-2-1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    cur = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> cur==<span class="string">'('</span>: <span class="keyword">break</span></span><br><span class="line">                    tl.append(cur)</span><br><span class="line">                stack.append(helper(tl))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s += c</span><br><span class="line">            <span class="comment"># print(c, stack)</span></span><br><span class="line">        <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">        <span class="comment"># 最外层可以没有括号</span></span><br><span class="line">        <span class="keyword">return</span> helper(stack[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式求值-力扣（LeetCode）"><a href="#150-逆波兰表达式求值-力扣（LeetCode）" class="headerlink" title="150. 逆波兰表达式求值 - 力扣（LeetCode）"></a>150. 逆波兰表达式求值 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">                right, left = stack.pop(), stack.pop()</span><br><span class="line">                <span class="comment"># if i=='/': i='//'</span></span><br><span class="line">                <span class="comment"># -1//2 -&gt; -1 </span></span><br><span class="line">                <span class="comment"># int(-1/2) -&gt; 0</span></span><br><span class="line">                stack.append(int(eval(<span class="string">f'<span class="subst">&#123;left&#125;</span><span class="subst">&#123;i&#125;</span><span class="subst">&#123;right&#125;</span>'</span>)))</span><br><span class="line">            <span class="keyword">else</span>: stack.append(i)</span><br><span class="line">            <span class="comment"># print(i, stack)</span></span><br><span class="line">        <span class="keyword">return</span> int(stack[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="227-基本计算器-II-力扣（LeetCode）"><a href="#227-基本计算器-II-力扣（LeetCode）" class="headerlink" title="227. 基本计算器 II - 力扣（LeetCode）"></a>227. 基本计算器 II - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II - 力扣（LeetCode）</a></p><p>如果用 collections.deque 的话，效率高一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, _s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 求 1*2/3, 传入: [3, /, 2, *, 1]</span></span><br><span class="line">        <span class="comment"># 运算符只能全部是 */ 或者全部是 +-</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tl)</span>:</span></span><br><span class="line">            left = int(tl.pop())</span><br><span class="line">            <span class="keyword">while</span> tl:</span><br><span class="line">                op, right = tl.pop(), int(tl.pop())</span><br><span class="line">                <span class="keyword">if</span> op==<span class="string">'+'</span>: left = left+right</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">'-'</span>: left = left-right</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">'*'</span>: left = left*right</span><br><span class="line">                <span class="keyword">else</span> : left = int(left/right)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        l = [] <span class="comment"># 存放 +- 操作</span></span><br><span class="line">        tl = [] <span class="comment"># 存放 */ 操作</span></span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> _s:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">' '</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'*/'</span>:</span><br><span class="line">                tl.extend([s, c])</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                tl.append(s)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">                l.extend([helper(tl[::<span class="number">-1</span>]), c])</span><br><span class="line">                tl = []</span><br><span class="line">            <span class="keyword">else</span>: s += c</span><br><span class="line">            <span class="comment"># print(l, tl, c)</span></span><br><span class="line">        </span><br><span class="line">        tl.append(s)</span><br><span class="line">        l.append(helper(tl[::<span class="number">-1</span>]))</span><br><span class="line">        <span class="comment"># print(l)</span></span><br><span class="line">        <span class="keyword">return</span> helper(l[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>优化：</p><p>效率提升了一点点，但是 helper 的可读性提升了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, _s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 求 1*2/3, 传入: [1, *, 2,  /, 3]</span></span><br><span class="line">        <span class="comment"># 运算符只能全部是 */ 或者全部是 +-</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tl)</span>:</span></span><br><span class="line">            left = int(tl.popleft())</span><br><span class="line">            <span class="keyword">while</span> tl:</span><br><span class="line">                op, right = tl.popleft(), int(tl.popleft())</span><br><span class="line">                <span class="keyword">if</span> op==<span class="string">'+'</span>: left = left+right</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">'-'</span>: left = left-right</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">'*'</span>: left = left*right</span><br><span class="line">                <span class="keyword">else</span> : left = int(left/right)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        l = deque() <span class="comment"># 存放 +- 操作</span></span><br><span class="line">        tl = deque() <span class="comment"># 存放 */ 操作</span></span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> _s:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">' '</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'*/'</span>:</span><br><span class="line">                tl.extend([s, c]) <span class="comment"># deque 也可以 extend</span></span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                tl.append(s)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">                l.extend([helper(tl), c])</span><br><span class="line">                tl.clear() <span class="comment"># 清空 deque 的操作</span></span><br><span class="line">            <span class="keyword">else</span>: s += c</span><br><span class="line">            <span class="comment"># print(l, tl, c)</span></span><br><span class="line">        </span><br><span class="line">        tl.append(s)</span><br><span class="line">        l.append(helper(tl))</span><br><span class="line">        <span class="comment"># print(l)</span></span><br><span class="line">        <span class="keyword">return</span> helper(l)</span><br></pre></td></tr></table></figure><h3 id="282-给表达式添加运算符-力扣（LeetCode）"><a href="#282-给表达式添加运算符-力扣（LeetCode）" class="headerlink" title="282. 给表达式添加运算符 - 力扣（LeetCode）"></a>282. 给表达式添加运算符 - 力扣（LeetCode）</h3><p><a href="https://leetcode-cn.com/problems/expression-add-operators/">282. 给表达式添加运算符 - 力扣（LeetCode）</a></p><p>做不出来</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="分类" scheme="https://zronghui.github.io/categories/leetcode/%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 224. Basic Calculator</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-2**/leetcode-224-Basic-Calculator.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-2**/leetcode-224-Basic-Calculator.html</id>
    <published>2020-07-21T05:00:37.000Z</published>
    <updated>2020-07-21T13:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/basic-calculator/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/basic-calculator/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the<br>plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong> integers and empty spaces <code></code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;1 + 1&quot;Output: 2</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: &quot; 2-1 + 2 &quot;Output: 3</code></pre><p><strong>Example 3:</strong></p><pre><code>Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23</code></pre><p><strong>Note:</strong></p><ul><li>You may assume that the given expression is always valid.</li><li><strong>Do not</strong> use the <code>eval</code> built-in library function.</li></ul><p>展开：</p><p><strong>Difficulty:</strong> Hard</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, _s: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(tl)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(tl)==<span class="number">1</span>: <span class="keyword">return</span> int(tl[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># print('tl:', tl)</span></span><br><span class="line">            cur = int(tl.pop())</span><br><span class="line">            <span class="keyword">while</span> tl:</span><br><span class="line">                op, num = tl.pop(), int(tl.pop())</span><br><span class="line">                cur = cur-num <span class="keyword">if</span> op==<span class="string">'-'</span> <span class="keyword">else</span> cur+num</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(_s):</span><br><span class="line">            <span class="keyword">if</span> c==<span class="string">' '</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">                stack.append(c)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">'('</span>: stack.append(<span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">                s = <span class="string">''</span></span><br><span class="line">                tl = []</span><br><span class="line">                <span class="comment"># 3-2-1 -&gt; 1-2-3 -&gt; 3-2-1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    cur = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> cur==<span class="string">'('</span>: <span class="keyword">break</span></span><br><span class="line">                    tl.append(cur)</span><br><span class="line">                stack.append(helper(tl))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s += c</span><br><span class="line">            <span class="comment"># print(c, stack)</span></span><br><span class="line">        <span class="keyword">if</span> s: stack.append(s)</span><br><span class="line">        <span class="comment"># 最外层可以没有括号</span></span><br><span class="line">        <span class="keyword">return</span> helper(stack[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/basic-calculator/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string may contain open &lt;code&gt;(&lt;/code&gt; and closing parentheses &lt;code&gt;)&lt;/code&gt;, the&lt;br&gt;plus &lt;code&gt;+&lt;/code&gt; or minus sign &lt;code&gt;-&lt;/code&gt;, &lt;strong&gt;non-negative&lt;/strong&gt; integers and empty spaces &lt;code&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;1 + 1&amp;quot;
Output: 2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot; 2-1 + 2 &amp;quot;
Output: 3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: &amp;quot;(1+(4+5+2)-3)+(6+8)&amp;quot;
Output: 23&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume that the given expression is always valid.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Do not&lt;/strong&gt; use the &lt;code&gt;eval&lt;/code&gt; built-in library function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;展开：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Hard&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-2**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-2/"/>
    
    
      <category term="Stack" scheme="https://zronghui.github.io/tags/Stack/"/>
    
      <category term="Math" scheme="https://zronghui.github.io/tags/Math/"/>
    
  </entry>
  
</feed>
