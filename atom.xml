<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zronghui的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zronghui.github.io/"/>
  <updated>2020-05-05T12:43:05.000Z</updated>
  <id>https://zronghui.github.io/</id>
  
  <author>
    <name>zronghui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 387. First Unique Character in a String</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-3**/leetcode-387-First-Unique-Character-in-a-String%20(copy).html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-3**/leetcode-387-First-Unique-Character-in-a-String%20(copy).html</id>
    <published>2020-05-05T12:42:43.000Z</published>
    <updated>2020-05-05T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/first-unique-character-in-a-string/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/first-unique-character-in-a-string/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string, find the first non-repeating character in it and return it’s<br>index. If it doesn’t exist, return -1.</p><p><strong>Examples:</strong></p><pre><code>s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2.</code></pre><p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p><p><strong>Tags:</strong> Hash Table, String</p><p><strong>Difficulty:</strong> Easy</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    <span class="function">def <span class="title">firstUniqChar</span><span class="params">(self, ss: str)</span> -&gt; <span class="keyword">int</span>:</span></span><br><span class="line"><span class="function">        # 添加未重复的 字母：index</span></span><br><span class="line"><span class="function">        m </span>= &#123;&#125;</span><br><span class="line">        # 重复的字母</span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> i, <span class="function">c in <span class="title">enumerate</span><span class="params">(ss)</span>:</span></span><br><span class="line"><span class="function">            <span class="keyword">if</span> c in s:</span></span><br><span class="line"><span class="function">                <span class="keyword">continue</span></span></span><br><span class="line"><span class="function">            <span class="keyword">if</span> c in m:</span></span><br><span class="line"><span class="function">                del m[c]</span></span><br><span class="line"><span class="function">                s.<span class="title">add</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span>:</span></span><br><span class="line"><span class="function">                m[c] </span>= i</span><br><span class="line">        <span class="keyword">return</span> min(m.items(), key=lambda i:i[<span class="number">1</span>])[<span class="number">1</span>] <span class="keyword">if</span> m <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/first-unique-character-in-a-string/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/first-unique-character-in-a-string/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s&lt;br&gt;index. If it doesn’t exist, return -1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;leetcode&amp;quot;
return 0.

s = &amp;quot;loveleetcode&amp;quot;,
return 2.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may assume the string contain only lowercase letters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Hash Table, String&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Easy&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-3**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-3/"/>
    
    
      <category term="Hash Table" scheme="https://zronghui.github.io/tags/Hash-Table/"/>
    
      <category term="String" scheme="https://zronghui.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 278. First Bad Version</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-2**/leetcode-278-First-Bad-Version%20(copy).html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-2**/leetcode-278-First-Bad-Version%20(copy).html</id>
    <published>2020-05-05T02:26:02.000Z</published>
    <updated>2020-05-05T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/first-bad-version/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/first-bad-version/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are a product manager and currently leading a team to develop a new<br>product. Unfortunately, the latest version of your product fails the quality<br>check. Since each version is developed based on the previous version, all the<br>versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the<br>first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether<br><code>version</code> is bad. Implement a function to find the first bad version. You<br>should minimize the number of calls to the API.</p><p><strong>Example:</strong></p><pre><code>Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. </code></pre><p><strong>Tags:</strong> Binary Search</p><p><strong>Difficulty:</strong> Easy</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 最后 left right 都指向第一个 badVersion</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/first-bad-version/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/first-bad-version/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;You are a product manager and currently leading a team to develop a new&lt;br&gt;product. Unfortunately, the latest version of your product fails the quality&lt;br&gt;check. Since each version is developed based on the previous version, all the&lt;br&gt;versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have &lt;code&gt;n&lt;/code&gt; versions &lt;code&gt;[1, 2, ..., n]&lt;/code&gt; and you want to find out the&lt;br&gt;first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;bool isBadVersion(version)&lt;/code&gt; which will return whether&lt;br&gt;&lt;code&gt;version&lt;/code&gt; is bad. Implement a function to find the first bad version. You&lt;br&gt;should minimize the number of calls to the API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -&amp;gt; false
call isBadVersion(5) -&amp;gt; true
call isBadVersion(4) -&amp;gt; true

Then 4 is the first bad version. &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Binary Search&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Easy&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-2**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-2/"/>
    
    
      <category term="Binary Search" scheme="https://zronghui.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>2020-05</title>
    <link href="https://zronghui.github.io/private/2020/05/2020-05.html"/>
    <id>https://zronghui.github.io/private/2020/05/2020-05.html</id>
    <published>2020-05-05T02:07:05.000Z</published>
    <updated>2020-05-05T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://github.com/huihut/interview#-problems">huihut/interview: 📚 C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。</a></p><p><a href="https://github.com/topics/interview-preparation?utm_campaign=explore-email&utm_medium=email&utm_source=newsletter&utm_term=daily">interview-preparation · GitHub Topics</a></p><ul><li><input disabled="" type="checkbox"> 1.再次实现排序</li><li><input disabled="" type="checkbox"> 2.操作系统</li><li><input disabled="" type="checkbox"> 3.计算机网络</li><li><input disabled="" type="checkbox"> 4.玩 docker</li><li><input disabled="" type="checkbox"> 5.玩 k8s</li><li><input disabled="" type="checkbox"> 6.玩 Redis</li><li><input disabled="" type="checkbox"> 7.区块链</li><li><input disabled="" type="checkbox"> 8.信息系统</li><li><input disabled="" type="checkbox"> 9.软件测试实训</li><li><input disabled="" type="checkbox"> 10.银行还贷款</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="private" scheme="https://zronghui.github.io/categories/private/"/>
    
      <category term="2020" scheme="https://zronghui.github.io/categories/private/2020/"/>
    
      <category term="5" scheme="https://zronghui.github.io/categories/private/2020/5/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-05-05</title>
    <link href="https://zronghui.github.io/private/2020/05/2020-05-05.html"/>
    <id>https://zronghui.github.io/private/2020/05/2020-05-05.html</id>
    <published>2020-05-05T02:06:00.000Z</published>
    <updated>2020-05-05T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c6fdee03a31f1972030588bbeded09afe489b456162d92da280d4572a0727bde">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dec0bab702e62ec40be4bd40d33dd8011ba51f8d43c98b9d5bc1629306176c05577d8355c1beaf3cd461fc88eb2faf0341dcf59de272fed2aba653dff2fe249ba70a664e958658d9c25bad99b53b312a4784912b3d4d824b393d3a9bf39c7fdbd9a91353baa205adaf325e03ecaed45d28078a69f9cf2ccacd2f2aa11e354b3559c4ac979673b198b7b92de870cc798d808bc2baaf32ef42c4f4b04b743fa6613d524a3eb63642c92dc881d7484bf501849da260d78b35a97bd4f01df208b423e66b6cc5c20122a10e7d2f50b4a85217932c5af0ed34d2756766311258d19f0b0af3245a5f26b60bca23e36f84f048ddb59bdcc24daccff4d5853c21ae445eb3fd6e2ae4463ae56fa26ec4a5a822d06d7a597a2a1a659ded102fc1a53a5f25d89fe02f6e87c1f824084dc3c241b64ee13c62c879cc15a8627f934f422cd0b61965b82681e801533a1b5cb8599151819e81eb12c8cd4cf65a523fd091ce62dcbf49b84dc75c7a40066910deaf2748b838eb6dbef845bedf40b3de049706f0f7ede967f57e50907efee0b650861e28ed50cede324ebe88037c45402142058248f6ad9842dfe695fa34bec04d2539612dc48d17d5eae997b0e4b21aef75df9711a6e4002bfa74682c1edb7f9dd2668d14dafcc3b8195a3c34f5864fa57d750c457293c8fa084e3501c8f2a4077fde390b73f668da3c48f7888f220a942b975d43bcf4c61346dd7fbbd4b14e5a18148615703a6fed7d0c854bc85969ecb5ac9f9b63bf1a931483ce1a707eb049d991334ad9233f22f8ccc9748501b29b1358af172d391527b4c06f13b60bdee64af9f5b91407c5622ca27fc5ba4850a454019f99726422fcad94f751a51a6029b37b926f66bc960613afbf90d3ebf065000c226d8fbc286a977e81584d4695e2a8e080cc36993e110657aa26b2fe3a76d146511f96dbf9d0a0bdada5827f82c733799d19c981729828f25a4b564399262a3e66b70f551cbc7ad24859d587bbfeadfcac4621e7f9a3030fd91579eef2a04bbd0e1487eb19d5840f2d42376df67af56ad6f5ce2b4ead08cef7fe08d88e37cd70c323cfa0dc23fa4b66578f8a59e3d0dfd91af127992173db69f9541dbdad37730db9cb84355cf582888fb50ab08f9ca111b24ee20d488cd7d1787f8a65c99b55f826720d845d29f641ca4d0f41e571bb343ab16241695d4d78e3606d0b400de4601d38a4dbb431b4db8dca4aaaf5458c84bce760c242f21546018b1344e420f5fcc00837e457c09806b5a665fc06a2cff4d457e661fa29888784df2b60e57f3a2d24e4aed2825738964271a53b99425ce228904aafd5e48b5dacd52a46bb4fa137e5ff503450508dcda278b151a199ccaca456c2eb77cce14d92356f31d615415e53941408b9d3caa28142fd13b9f400a678351133d9afeb380eef1665ba6b49f5995bb28cc2e92b78854a94a8546aff84752efdb0818863bbb6957e84f2809b46a1f47357dbc58fdd06538e03dbc0aeea88ee2d470762417895b444eced375bb16721d4b5a505a91d3561edd9e4dd53efb7fc64f44f9ae1aabb0889407f2b076788ff3b982864edb9f841b13609f3d903cbb4f6c34200b4bd7563992e42ff89e3c371d7367adda9e6b5e758e6b582e12d4c33064b77a4ff415196171d9173b06d4601bab25bed6d8742bcc981af90e0e5ba3ad4aa219f9b6336821adc9fec577b6fd2860c6595c328d24e5442ca18e453569c8cbc75a90a5a1c647f3c82f5b9f1e65ce45661850821c9ce9fadfffea216a88f625800500d5df9e3278b73f26129f51d0ab9a1b2023641e64c3e1d353cfc252355ea0bebe39c906d6d1c630ea32d69d83bab792d121e9f6f2d4535f46d0f59791ba4e05d93bf029f303f1f72c2783e82d8ab03794912b41b51c2b8a2d12f5cd167884abfc3e4ca4e0af1870b22a15edef</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://zronghui.github.io/categories/private/"/>
    
      <category term="2020" scheme="https://zronghui.github.io/categories/private/2020/"/>
    
      <category term="5" scheme="https://zronghui.github.io/categories/private/2020/5/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-187</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-187.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-187.html</id>
    <published>2020-05-04T12:52:25.000Z</published>
    <updated>2020-05-05T01:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/destination-city/">旅行终点站</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/">是否所有 1 都至少相隔 k 个元素</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">绝对差不超过限制的最长连续子数组</a><strong>5</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">有序矩阵中的第 k 个最小数组和</a><strong>7</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destCity</span><span class="params">(self, paths: List[List[str]])</span> -&gt; str:</span></span><br><span class="line">        res = paths[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> paths[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> s==res:</span><br><span class="line">                res = e</span><br><span class="line">                <span class="keyword">while</span> res <span class="keyword">in</span> m:</span><br><span class="line">                    res = m.get(res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[s] = e</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kLengthApart</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            last = nums.index(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(last+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> i-last&lt;k+<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                last = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, mat: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(mat)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(mat)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> mat[<span class="number">0</span>]</span><br><span class="line">            la = mat.pop()</span><br><span class="line">            lb = mat.pop()</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> la:</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> lb:</span><br><span class="line">                    res.append(a+b)</span><br><span class="line">            res.sort()</span><br><span class="line">            mat.append(res[:k])</span><br><span class="line">            <span class="keyword">return</span> helper(mat)</span><br><span class="line">        </span><br><span class="line">        mat = helper(mat)</span><br><span class="line">        mat.sort()</span><br><span class="line">        <span class="keyword">return</span> mat[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/destination-city/&quot;&gt;旅行终点站&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/&quot;&gt;是否所有 1 都至少相隔 k 个元素&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/&quot;&gt;绝对差不超过限制的最长连续子数组&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/&quot;&gt;有序矩阵中的第 k 个最小数组和&lt;/a&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>tricks-2020-05</title>
    <link href="https://zronghui.github.io/tricks/tricks-2020-05.html"/>
    <id>https://zronghui.github.io/tricks/tricks-2020-05.html</id>
    <published>2020-05-01T00:08:33.000Z</published>
    <updated>2020-05-05T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="网页速度分析及优化"><a href="#网页速度分析及优化" class="headerlink" title="网页速度分析及优化"></a>网页速度分析及优化</h2><p><a href="https://developers.google.com/speed/pagespeed/insights/?url=http%3A%2F%2F47.93.53.47%2Fsearch%3Fq%3D%25E4%25BD%2599%25E6%25AC%25A2%25E6%25B0%25B4">PageSpeed Insights</a><br><a href="https://www.17ce.com/">http://47.93.53.47/search?q=%E4%BD%99%E6%AC%A2%E6%B0%B4 GET测试结果 网站速度测试 17CE</a></p><p><a href="https://putong.one/speed-test.html">常用国内外网站测速及性能分析工具 - 普通玩家</a></p><h2 id="快捷键-配置"><a href="#快捷键-配置" class="headerlink" title="*快捷键 配置"></a>*快捷键 配置</h2><h3 id="配置-Caps-键为-command-control-option-shift"><a href="#配置-Caps-键为-command-control-option-shift" class="headerlink" title="配置 Caps 键为 command+control+option+shift"></a>配置 Caps 键为 command+control+option+shift</h3><p><a href="https://karabiner-elements.pqrs.org/docs/manual/configuration/configure-complex-modifications/">Use more complex rules | Karabiner-Elements</a></p><img src="https://i.loli.net/2020/05/01/jlGkExbi46spwdQ.png" alt="jlGkExbi46spwdQ" style="zoom:50%;" /><img src="https://i.loli.net/2020/05/01/NOulVPBkaCsJEZ6.png" alt="NOulVPBkaCsJEZ6" style="zoom:50%;" /><h3 id="设置服务快捷键"><a href="#设置服务快捷键" class="headerlink" title="设置服务快捷键"></a>设置服务快捷键</h3><p>caps + d: 用 Downie3 下载</p><p>caps + o: 打开 URL</p><p>caps + t: 谷歌翻译</p><img src="https://i.loli.net/2020/05/01/wI26dunWlhQBe3X.png" alt="wI26dunWlhQBe3X" style="zoom:50%;" /><img src="https://i.loli.net/2020/05/01/DfFPZiEAuI175O2.png" alt="DfFPZiEAuI175O2" style="zoom:50%;" /><h3 id="听写"><a href="#听写" class="headerlink" title="听写"></a>听写</h3><img src="https://i.loli.net/2020/05/01/65Q3A2cEuFax8J7.png" alt="65Q3A2cEuFax8J7" style="zoom:50%;" /><h3 id="workona"><a href="#workona" class="headerlink" title="workona"></a>workona</h3><img src="https://i.loli.net/2020/05/01/4mzO1gfbdEnoc5N.png" alt="4mzO1gfbdEnoc5N" style="zoom:50%;" /><p><a href="https://mp.weixin.qq.com/s/hCZWQEfHrCAxTiO0h8ukJw">小悦记</a></p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/84141/1588212597876-e5987568-1032-4756-9548-21f72a9571cc.jpeg" alt="img" style="zoom:50%;" /><p>Chrome 浏览器插件，可以一键导出微信读书笔记。</p><p><a href="https://github.com/syscolabs/kasaya">kasaya</a></p><p>一个命令行的浏览器自动化脚本执行器。</p><p><a href="https://github.com/edraobdu/printy">edraobdu/printy: Printy is lite and cross-platform library that extends the functionalities of the built-in functions print() and input()</a></p><p><a href="https://github.com/bannyvishwas2020/MyhandWriting">bannyvishwas2020/MyHandWriting: Convert text to your own hand writing</a></p><h2 id="使用脚本批量替换文本内容"><a href="#使用脚本批量替换文本内容" class="headerlink" title="使用脚本批量替换文本内容"></a>使用脚本批量替换文本内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$1</span> search_keyword</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$2</span> replace_original</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$3</span> replace_destination</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$4</span> search file <span class="built_in">type</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find ./ -type f -name "*.$4" -exec grep -l "$1" &#123;&#125; \; | xargs sed -i "" -e "s/$2/$3/g"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceText.sh "FD" "FD" "文件描述符" "markdown"</span><br></pre></td></tr></table></figure><p><a href="https://github.com/crawlab-team/crawlab/blob/master/README-zh.md">crawlab/README-zh.md at master · crawlab-team/crawlab</a><br><a href="http://concurrent.redspider.group/">本书简介 · 深入浅出Java多线程</a><br><a href="https://hollischuang.github.io/toBeTopJavaer/#/menu">Java工程师成神之路</a><br><a href="https://github.com/emeryberger/scalene">emeryberger/scalene: a high-performance, high-precision CPU and memory profiler for Python</a><br><a href="https://github.com/shibing624/pycorrector">shibing624/pycorrector: pycorrector is a toolkit for text error correction. It was developed to facilitate the designing, comparing, and sharing of deep text error correction models.</a></p><p><a href="https://github.com/bansal-io/pattern.css">bansal-io/pattern.css: CSS only library to fill empty background with beautiful patterns.</a><br><a href="https://bansal.io/pattern-css">pattern.css - Background Patterns in CSS</a></p><h2 id="谷歌搜索黑名单"><a href="#谷歌搜索黑名单" class="headerlink" title="谷歌搜索黑名单"></a>谷歌搜索黑名单</h2><p><a href="https://github.com/cobaltdisco/Google-Chinese-Results-Blocklist">cobaltdisco/Google-Chinese-Results-Blocklist: 他妈的我终于能用谷歌搜中文了</a></p><p><a href="https://www.jianshu.com/p/14f0c9dd1b70">[Mac重装系统]升级10.15需格式化为APFS？ - 简书</a></p><p><a href="https://github.com/xufqing/rest_xops">xufqing/rest_xops: Python3 采用vue + drf 的运维自动化系统 （开发中）django rest framework、channels</a></p><p><a href="https://github.com/0voice/from_coder_to_expert">0voice/from_coder_to_expert: 2019年最新总结，从程序员到CTO，从专业走向卓越，分享大牛企业内部pdf与PPT</a></p><p><a href="https://macflow.net/p/1489.html">10 款最佳 Mac 动态壁纸，都为你准备好了！ | MacFlow</a></p><p>已经保存至奶牛</p><h2 id="视频网站去水印"><a href="#视频网站去水印" class="headerlink" title="视频网站去水印"></a>视频网站去水印</h2><p><a href="http://beijixs.cn/">北极XS 视频解析</a></p><p><a href="https://www.52pojie.cn/thread-1169884-1-1.html">优酷 爱奇艺 腾讯视频 去水印脚本 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h2 id="局域网文件传输"><a href="#局域网文件传输" class="headerlink" title="局域网文件传输"></a>局域网文件传输</h2><p><a href="https://www.52pojie.cn/thread-1169261-1-1.html">小米互传PC版-智慧互联1.1.0.453 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a><br><a href="https://langenius.gitee.io/#tag_android">局域网精灵 - 局域网传文件利器 !</a></p><h3 id="联通米粉卡扫号"><a href="#联通米粉卡扫号" class="headerlink" title="联通米粉卡扫号"></a>联通米粉卡扫号</h3><p>我看好像六安都卖完了。而且相较于校园卡不是特别优惠。只能说适合于找靓号</p><p><a href="https://www.52pojie.cn/thread-1170557-1-1.html">安徽地区联通米粉卡扫号软件 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p>蓝奏：<a href="https://lanzous.com/ic6z46d">https://lanzous.com/ic6z46d</a></p><p>打不开可能是系统默认浏览器原因吧<br>下单链接:<a href="http://mall.10010.com/goodsdetail/301904268051.html">http://mall.10010.com/goodsdetail/301904268051.html</a></p><img src="https://i.loli.net/2020/05/05/JAFUWP7r6k8cioS.jpg" alt="JAFUWP7r6k8cioS" style="zoom: 67%;" /><p><a href="https://i.hyys.me/">花样影视</a></p><h2 id="网站体验优化油猴脚本"><a href="#网站体验优化油猴脚本" class="headerlink" title="*网站体验优化油猴脚本"></a>*网站体验优化油猴脚本</h2><p><strong>丨网页体验ENH丨观影ENH丨CSS#丨</strong></p><p><a href="https://www.52pojie.cn/thread-1169884-1-1.html">优酷 爱奇艺 腾讯视频 去水印脚本 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><ol><li>去视频水印</li><li>自动填写博客验证码</li><li>点击文本，‘链接文本’变真链接</li><li>自由的选择链接中的文本</li><li>H5视频离开暂停</li></ol><h2 id="将智能手机虚拟成电脑的网络摄像头"><a href="#将智能手机虚拟成电脑的网络摄像头" class="headerlink" title="将智能手机虚拟成电脑的网络摄像头"></a>将智能手机虚拟成电脑的网络摄像头</h2><p><a href="https://www.appinn.com/faxian-05001/">小众软件《发现频道周报》2020年5月第1期 - 小众软件</a></p><p>pc:iVCam</p><p>mac:</p><p><a href="https://meta.appinn.net/t/obs-obs-camera/15782">OBS 和OBS Camera</a></p><p>OBS 全称 <a href="https://www.appinn.com/open-broadcaster-software/">Open Broadcaster Software</a>，是一款开源直播软件，支持Win/macOS/l=Linux。OBS Camera 是一个OBS插件，支持 Win/macOS。</p><p>上面提到那个 iVCam 可以用手机做网络摄像头，这个需求同样可以用 OBS Camera 配合它的 iOS 应用来实现。</p><p><a href="https://github.com/pdown2020/pdown">pdown2020/pdown: 2020</a></p><h2 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h2><p><a href="https://meta.appinn.net/t/http/14290">【推荐】一秒变http服务器，轻松传资源 - 发现频道 - 小众软件官方论坛</a><br><a href="https://www.appinn.com/web-server-for-chrome/">Web Server for Chrome - 用 Chrome 充当临时 HTTP 服务器 - 小众软件</a><br><a href="https://rubygems.org/gems/asdf/">asdf | RubyGems.org | Ruby 社区 Gem 托管</a></p><p>Mac 向 安卓传送文件</p><p><a href="https://github.com/deskangel/DaFileShare">deskangel/DaFileShare: A file share app for macos</a></p><p><a href="https://github.com/iSoron/uhabits">iSoron/uhabits: Loop Habit Tracker, a mobile app for creating and maintaining long-term positive habits</a></p><p><a href="https://app.everyday.app/">everyday</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="tricks" scheme="https://zronghui.github.io/categories/tricks/"/>
    
    
  </entry>
  
  <entry>
    <title>blockchain-04</title>
    <link href="https://zronghui.github.io/blockchain/blockchain-04.html"/>
    <id>https://zronghui.github.io/blockchain/blockchain-04.html</id>
    <published>2020-04-30T06:37:19.000Z</published>
    <updated>2020-05-01T11:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="P4-04-BTC-协议"><a href="#P4-04-BTC-协议" class="headerlink" title="P4. 04-BTC-协议"></a>P4. 04-BTC-协议</h2><p>数字货币和纸质货币区别是可以复制，叫作双花攻击  即double spending attack。<br>去中心化货币要解决两个问题:①数字货币的发行②怎么验证交易的有效性，防止double spending attack。   </p><p>答案:①比特币的发行是由挖矿决定的<br>②依靠区块链的数据结构<br>比特币的发行者A拥有铸币权(createcoin) 假如发行10个比特币  A(10)分别给B和C各五个  → B(5)C(5) 该交易需要有A的签名，证明经A同意。(designed by A)同时还要说明花掉的10个比特币从哪来的。<br><strong>参考拍的图四</strong>  第二个方框中的钱是从第一个框内铸币交易中来的。</p><p>比特币系统中每个交易都包含输入和输出两部分。输入部分要说明币的来源，输出部分要给出收款人公钥的哈希。<br>有的交易部分比较复杂，如C的货币来源是第二第三个方框，要标识清楚。</p><p>图四就构成了一个小型的区块链，这里有两种哈希指针，一种哈希指针是连接在各个区块之间的，把它们串起来构成一个链表，前面学的就是这种哈希指针。而在该图中还有第二种哈希指针，是指向前面某个交易的指针，用来指明币的来源。为什么要说明币的来源:证明币不是凭空捏造的是有记录的，同时也是防范double spending。</p><p>现在来看第二个方框里A向B的转账，该交易需要A的签名和B的地址。比特币系统里收款的地址是通过公钥推算出来的。比如B的地址就是B的公钥取哈希然后经过一些转换得到的。</p><p>A如何知道B的地址?比特币系统中没有查询对方地址的功能，必须通过其他渠道。比如某个电商网站，接受比特币支付，就可以公开它的地址或公钥。</p><p>A需要知道B的地址，B需要知道A的什么信息吗?B其实也要知道A的公钥，这代表A的身份。不仅是B，所有节点都需要知道A的公钥。而签名是用私钥签名公钥验证(注意不要跟前面知识弄混了，加密是用接收人的公钥加密私钥解密)，所以区块链上每个节点都要独立验证。</p><p>那如何才能知道A的公钥?实际上交易里就包含了。输入时不仅要输入币的来源，还要输入公钥。那就存在了安全漏洞，假如B的同伙伪造了这次交易呢?其实第一个方框里铸币交易的输出就有A的公钥的哈希，所以第二个方框交易里A的公钥要跟前面哈希对的上。</p><p>在比特币系统当中，前面这些验证过程，是通过执行脚本来实现的。每个交易的输入提一段脚本，包括给出公钥的过程，公钥也是在输入的脚本里指定的。每个交易的输出也是一段脚本，验证其的合法性，就需要把当前交易的输入脚本跟前面交易(提供币来源的交易)的输出脚本拼在一起，然后看看能不能顺利执行，如果能执行说明是合法的。比特币脚本(BitCoin Script)。</p><p>该图对交易系统进行了简化，实际上每个区块(对应图中的每个方框)可以有很多交易，这些交易就组成merkle tree。每个区块分为块头和块身。</p><p>块头包含的是区块的宏观信息，比如:用的是比特币哪个版本(version)的协议，区块链当中指向前一个区块的指针(hash of previous block header)，整颗merkle tree 的根哈希值(merkle root hash)，还有两个域是跟挖矿相关的，一个是挖矿的难度目标预值(target)，另一个是随机数nonce。</p><p>这里的target，就是前面讲到的，整个块头的哈希要小于这个预值，即H(block header)≤target。block header里存的就是这个目标预值的编码(nBits)。这里需要注意，前一个区块的哈希只算的是前一个区块的块头，所以前面画的，一个区块引出一个剪头指向另一个区块中间，是不正确的，所以有的书剪头是指向一个区块的上面。取哈希时是把块头的所有部分都取哈希。</p><p>块身里面有交易列表(transaction list)。</p><p>前面还有一个内容讲的时候简化了:每个节点都需要验证所有的交易，实际上系统中的节点分全节点(full node)和轻节点(light node)，全节点是保存区块链所有的信息的，验证每一个交易，所以全节点又叫fully validating node。轻节点只保存block header的信息，一般来说轻节点没法独立验证交易的合法性。</p><p>比如一个交易是不是double spending，轻节点没有存以前的交易信息所以它没法验证。系统中大多数节点是轻节点，这节课内容主要针对全节点，因为轻节点没有参与区块链的构造和维护，只是利用了区块链的一些信息做一些查询。</p><p>区块链里的内容是如何写到区块链里面的呢:每个节点，每个账户都可以发布交易，交易是广播给所有节点的。有些交易是合法的，有些是非法的。谁来决定哪些交易应该被写入下一个区块中呢?按照什么顺序写呢?如果每个节点自己决定可以吗?如果每个人在本地维护一个区块链，那区块链的统一性得不到保证，而账本的内容是要取得分布式的共识(distributed consensus)。</p><p>下面的笔记跟比特币的应用关系不大，可以作为了解:<br>分布式的共识一个简单的例子就是分布式的哈希表(distributed hash table)，比如系统里有很多台机器，共同维护一个全局的哈希表。</p><p>这里需要取得共识的内容是什么？哈希表中包含了哪些键值对key valve pair。假如有人在自己电脑上插入一个键值对，’xiao’这个pair对应的是12345，即’xiao’→12345。那么别人在另一台读的时候也要能把这个读出来，这就叫一个全局的哈希表。</p><p>关于分布式系统有很多不可能结论(impossibility result)，其中最著名的是FLP。这三个字母是三个专家的名字缩写，他们的结论是:在一个异步的(asynchronous)系统里，(网络传输迟延没有上限就叫异步系统)，即使只有一个成员是有问题的(faulty)，也不可能取得共识。</p><p>还有一个著名结论:CAP Theorem。(CAP是指分布式系统的三个我们想要的性质，Consistency【系统状态的一致性】  Availability【别人都可以用】 Partition tolerance)。该理论内容是:任何一个分布式系统，比如分布式哈希表，这三个性质中，最多只能满足两个，假如想要前两个性质，那么就不会得到第三个性质。</p><p>分布式共识一个著名的协议是Paxos，该协议能够保证一致性，即第一个性质。如果该协议打成了共识，那么这个共识一定是一致的，即每个成员所认为的共识都是相同的。但是，某些情况下，该协议可能永远无法达成共识，这种可能性比较小但是客观存在的。</p><p>比特币中的共识协议(consensus in BitCoin):<br>比特币中共识要解决的一个问题是，有些节点可能是有恶意的。我们假设系统中大多数节点是好的，那么该如何取得共识协议?</p><p>第一种方案是投票，首先应该确定哪些区块有投票权，有些membership是有严格要求的，这种情况下基于投票的方案是可行的。但比特币系统创建账户是很容易的，甚至一个人产生了公私钥对别人都无法得知，只有转账时别人才知道。所以有些人可以不停的创建账户，当超过账户总数的一半时就有了控制权，这种称为女巫攻击(sybil attack)。因此投票方法不可取。</p><p>比特币账户巧妙的解决了这个问题，不是按照账户数目投票，而是按照计算力来投票。每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放在里面，然后开始尝试各种nonce值(占4 byte)，看哪一个能满足不等式H(block header)≤target的要求。如果某个节点找到了符合要求的nonce，它就获得了记账权。</p><p>所谓的记账权，就是往比特币账本里写入下一个区块的权利。只有找到这个nonce，获得记账权的节点才有权利发布下一个区块。其他节点收到这个区块之后，要验证这个区块的合法性。</p><p>比如括号里block header的内容填的对不对；block header里面有一个域，叫nBits域，实际上它是目标预值的一个编码检查一下nBits域设置的是不是符合比特币协议中规定的难度要求；该不等式是否成立。假设都符合要求，然后检查block body 里面的交易列表，验证一下每个交易都是合法的:①要有合法的签名②以前没有被花过。如果有一项不符合要求，这个区块就是不能被接受的。如果所有条件都符合，也不一定接受。</p><p>假如生成了一个新区块，怎么知道新区块插在了哪里呢?根据生成区块的指针。有可能就存在一个问题，如图5(第四个视频第65分钟) ，这两个交易指A转账给B，以及A转账给自己。这种情况不是double spending，判断一个交易是不是double spending ，是看这个区块所在的分支上币又没有被花掉。如图，一直到第三个区块，币都没有花过，所以这个交易是合法的。虽然该交易是合法的，但是它不在最长合法链(longest valid chain)上。这种称为分叉攻击(forking attack)。所以接收的区块应该是扩展最长合法链。</p><p>区块链在正常情况下也可能出现分叉:两个节点同时获得记账权。每个节点在本地自己组装一个它认为合适的区块，然后去试各种nonce，如果两个节点在差不多同一个时间找到了符合要求的nonce，就都可以把区块发布，这时会出现两个等长的分叉。这两条都是最长合法链，那该接受那条呢?比特币协议当中，在缺省(默认的意思)情况下，每个节点是接受它最早收到的那个。所以不同节点根据在网络上的位置不同，有的节点先听到新生成的其中一个区块，那就接受这个区块；有些节点先听到另一个区块，那就接受另一个区块。</p><p>如何判断接收了一个区块?比特币协议中用到了implicit consign，如果沿着这个区块往下继续扩展，就算认可了这个发布的区块。比如在新生成的其中一个区块后面又拓展一个区块，表明就认可了这个新区块。</p><p>等长的临时性的分叉会维持一段时间，直到一个分叉胜出。也就是哪一个链抢先一步生成了新的区块，哪一条就是最长合法链。另一个作废的就叫orphan block。这两个新区块有可能会各自拉拢，两个区块链看谁的算力强，有时候也是看谁的运气好，就会胜出。</p><p>竞争记账权的好处:首先获得记账权的节点本身有一定的权力，可以决定哪些交易写到下一个区块里。但这些不应该被设定为竞争记账权的动力，所以巧妙地建立了一个机制:区块奖励(block reward)。</p><p>比特币协议中规定获得记账权的节点在发布的区块里可以有一个特殊的交易:铸币交易。在这个交易里可以发布一定数量的比特币。</p><p>这里要回到前面的问题①，谁来决定货币的发行?coinbase transaction币基交易是比特币系统中发行新的比特币的唯一方法，后面的交易都是比特币的转移。这个交易不用指出币的来源。</p><p>那么能造多少币呢?开始时比特币刚上线的时候，每一个发布的区块可以产生50BTC(BTC就是比特币的符号)。协议中规定，21万个区块以后，初块奖励就要减半，就变成了25BTC。再过21万个区块，又要减半。</p><p>因此当一个区块胜出后，另一个作废的区块得到的比特币是没有作用的，其他诚实的区块是不会承认的。</p><p>比特币系统中要取得什么共识?去中心化的账本要取得共识。谁又能决定账本的内容呢?只有获得记账权的节点才能写东西。怎么获得记账权呢?就是解pow(挖矿)。按照算力记票，算力可以用每秒能试多少nonce数值表示。那怎样防范女巫攻击呢?按算力记票，即使创建再多的账户，也无法使算力增强。</p><p>比特币争夺记账权的过程叫作挖矿(mining)，比特币被称为数字黄金(digital gold)，争夺记账权的节点被称为矿工(miner)。</p><h2 id="P5-05-BTC-实现"><a href="#P5-05-BTC-实现" class="headerlink" title="P5. 05-BTC-实现"></a>P5. 05-BTC-实现</h2><p>第五节课程  第一部分</p><p>第五节  </p><p>比特币系统的实现</p><p>区块链是去中心化的账本，比特币使用的是基于交易的这种账本模式(transaction【交易】-based ledger【账本】)。系统当中并不会显示每个账户有多少钱。</p><p>比特币系统的全节点要维护一个叫UTXO(unspent transaction output)(还没有被花出去的交易的输出)的数据结构。区块链上有很多交易，有些交易的输出可能已经被花掉，有些还没有被花掉。所有没有被花掉的输出的集合就叫做UTXO。</p><p>一个交易可能有多个输出。假如A给B5个比特币，B花掉了。A也给了C3个比特币，C没有花掉。这时5个比特币就不算UTXO，而3个比特币算。UTXO集合当中的每个元素要给出产生输出的交易的哈希值，以及它在这个交易里是第几个输出。这两个信息就可以定位到UTXO中的输出。</p><p>要UTXO集合有什么作用?<br>为了检测double spending。即检测新发布的交易是否合法。因此全节点要在内存中维护UTXO这样一个数据结构，以便快速检测double spending。</p><p>每个交易要消耗掉一部分输出，也会产生新的输出。还看上面的例子，B花掉的5个比特币虽然不在UTXO里面，但如果他转账给D，而D没有花掉，那么这5个比特币又要保存在UTXO里面。如果D始终不花，那么这个信息要永久保存在UTXO里面。有可能是不想花，也有可能是把密钥丢了。</p><p>每个交易可以有多个输入，也可以有多个输出，所有输入金额之和要等于输出金额之和。即total inputs=total outputs。因此一个交易可能来自多个地址，可能有多个签名。</p><p>有些交易total inputs略微大于total outputs。<br>假如输入1比特币，输出0.99比特币，另外0.01比特币作为交易费给获得记账权发布区块的节点。</p><p>区块奖励也不能完全作为挖矿的奖励，发布区块的节点为什么一定要把你的交易打包在区块呢?他们还要验证你的交易的合法性，如果交易较多占用的带宽会比较大，网络传播速度也会更慢。所以只有区块奖励是不够的。</p><p>因此比特币系统设计了第二个激励机制:交易费(transaction fee)。也就是你把我的交易打包在区块里，我给你一些小费。交易费一般很小，也有一些简单的交易没有交易费。<br>2020-01-26 06:28<br>回复</p><p>苦艾酒_bitter<br>第五节课程  第二部分</p><p>21万个区块大概要挖多长时间呢?大约是4年。比特币系统设计的平均出块时间是10分钟，就是整个系统平均10分钟会产生一个新的区块。</p><p>除了比特币这种基于交易的模式，与之对应的还有基于账户的模式(account-based ledger)，比如以太坊系统。在这种模式中，系统是要显示的记录每个账户上有多少币。</p><p>比特币基于交易的模式，隐私保护性较好。缺点是比特币当中的转账交易要说明币的来源，而基于账户的模式就不用。</p><p>如图⑥(第五节视频  16分钟处)<br>一个区块的例子<br>第一行表明:该区块包含了686个交易<br>第二行:总输出XXX个比特币<br>第四行:总交易费(686个交易的交易费之和)<br>最下面一行:区块奖励(矿工挖矿的主要动力)<br>第五行:区块的序号<br>第六行:区块的时间戳<br>第九行:挖矿的难度(每隔2016个区块要调整挖矿的难度，保持出块时间在10分钟左右)<br>倒数第二行:挖矿时尝试的随机数</p><p>右边:第一行:该区块块头的哈希值<br>第二行:前一个区块块头的哈希值<br>(注意:计算哈希值只算块头)<br>两个哈希值的共同点:前面都有一串0。是因为，设置的目标预值，表示成16进制，就是前面一长串的0。所以凡是符合难度要求的区块，块头的哈希值算出来都是要有一长串的0。<br>第四行:merkle root 是该区块中包含的那些交易构成的merkle tree的根哈希值。</p><p>如图⑥(见第五节视频 第20分钟)块头的数据结构<br>最后一行:是32位的无符号整数。nonce只有2的32次方个可能的取值。按照比特币现在的挖矿情况来说，很可能把2的32次方个取值都验了一遍也找不到合适的。那怎么办呢?block header 的数据结构里还有哪些域是可以调整的呢?</p><p>如图⑦ 块头里各个域的描述(见第五个视频 第21分钟)<br>第一行:比特币协议的版本号(无法更改的)<br>第二行:前一个区块的块头的哈希值(无法更改)<br>第三行:merkle tree的根哈希值(可以更改)<br>第四行:区块产生的时间(可以调整)比特币系统不要求特别精确的时间，可以在一定范围内调整。<br>第五行:目标预值(编码后的版本)(只能按协议中的要求定期调整)<br>第六行:随机数</p><p>挖矿时只改随机数不够，还可以更改根哈希值。<br>2020-01-26 06:28<br>回复</p><p>苦艾酒_bitter<br>第五节课程  第三部分</p><p>如图⑧(见第五节视频 第23分钟)<br>铸币交易没有输入，它有一个coinbase，可以写入任何的内容。也可以把digital commitment里的commit的哈希值写入里面。也可以把第一节讲到的预测股市的内容写入里面，coinbase的内容是没有人会检查的，甚至可以写你的心情。</p><p>那这个域对我们有什么用呢?</p><p>如图⑨(见第五节视频 第24分钟)<br>对应的是最后一个block header里的根哈希值对应的merkle tree，左下角的交易是coinbase，把它的域改了之后，其上的哈希值就发生了变化，然后沿着merkle tree的结构往上传递。最后导致block header里的根哈希值发生变化(merkle root是block header的一部分)。块头里4个字节的nonce不够用，还有其他字节可以用，比如coinbase域的前八个字节当做extra nonce来用，这样子搜索空间就增大到了2的96次方。</p><p>所以真正挖矿的时候只有两层循环，外层循环调整coinbase域的extra nonce。算出block header里的根哈希值之后，内层循环再调整header里的nonce。</p><p>如图⑩ 普通的转账交易的例子(见第五节视频 第26分钟)<br>该交易有两个输入和两个输出。<br>左上角:这里的output其实是输入，指的是之前交易的output。<br>右上角:这里的output都是unspent，都没有被花掉，会保存在UTXO里面。<br>右边表格第一行:输入的总金额。<br>依次往下:输出总金额、两者之间的差值。<br>两表格下面:可以看出输入和输出都是用脚本的形式来指定的。</p><p>比特币系统中验证交易的合法性，就是把input scripts和output script配对后执行来完成的。注意:不是把图中的input scripts<br>和output scripts配对，因为这两个脚本是一个交易中的脚本。不是把同一个交易里的输入脚本和输出脚本配对，而是把这里的输入脚本和前面提供币来源的交易的输出脚本配对。如果输入输出脚本拼接在一起，能顺利执行不出现错误，那么该交易就是合法的。<br>2020-01-26 06:29<br>回复</p><p>2020-01-26 06:36<br>1<br>回复</p><p>苦艾酒_bitter<br>第五节课程  第四部分</p><p>如图十一，是在求解puzzle的过程。<br>注意:求哈希时只用到了block header的内容，而交易的具体信息在block header里面是没有的。block header里面只有merkle tree 的根哈希值，这个就已经能保证交易是没有被篡改的。</p><p>挖矿过程每次尝试一个nonce可以看作是一个Bernoulli trial(伯努利实验)。每一个随机的伯努利实验就构成了一个伯努利过程。它的一个性质是:无记忆性。</p><p>每尝试一个nonce成功的概率是很小的，要进行大量的实验。这时可以用泊松过程来代替伯努利过程。我们真正关心的是系统出块时间，出块时间是服从指数分布。可以画出一个坐标轴，纵轴表示概率密度，横轴表示出块时间(整个系统的出块时间，并不是每个矿工的出块时间)。具体到每一个矿工，他能挖到下一个区块的时间取决于矿工的算力占系统算力的百分比。</p><p>假如一个人的算力占系统总算力的1%，那么系统出100个区块，就有一个区块是这个人挖的。</p><p>指数分布也是无记忆性的。因为概率分布曲线的特点是:随便从一个地方截断，剩下一部分曲线跟原来是一样的。比如:已经等十分钟了，还没有人找到合法的区块，那么还需要等多久呢?仍然参考概率密度函数分布 ，平均仍然要等十分钟。将来还要挖多长时间，跟过去已经挖了多长时间是没有关系的。这个过程也叫:progress free。</p><p>如果没有progress free ，会出现什么现象:算力强的矿工会有不成比例的优势。因为算力强的矿工过去做的工作是更多的，过去尝试了那么多不成功的nonce之后，后面nonce成功的概率就会增大。以此progress free 是挖矿公平性的保证。</p><p>出块奖励是系统中产生新的比特币的唯一途径。产生的比特币构成的一个几何序列。21万＊50+21万＊25+21万＊12.5+……=21万＊50＊(1+1/2+1/4+……)=2100万</p><p>比特币求解的puzzle，除了比拼算力之外，没有其他实际意义。比特币的稀缺性是人为造成的。</p><p>虽然挖矿求解puzzle本身没有实际意义，但是挖矿的过程对于维护比特币系统的安全性是至关重要的。挖矿提供一种凭借算力投票的有效手段，只要大部分算力是掌握在诚实的节点手里，系统的安全性就能够得到保证。</p><p>第五节课程  第五部分</p><p>虽然挖矿奖励越来越小，难度越来越大，但这几年挖矿的竞争是越来越激烈的，因为比特币的价格是飙升的。最终区块奖励为0了，是不是就没有动力挖矿了呢?不是的，因为还有交易费激励机制。</p><p>假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证?能不能保证写入区块链的交易都是合法的。挖矿给出的只是概率上的保证，只能说有比较大的概率下一个区块是由诚实的矿工发布的，但是不能保证记账权不会落到有恶意的节点手里。</p><p>比如好的矿工占90%的算力，坏的矿工占10%的算力。那么10%的概率下记账权会落在有恶意的矿工手里，这时候会出现什么情况?</p><p>先考虑第一个问题:他能不能偷币?能不能把别人账上的钱转给自己?不能，因为他没有办法伪造别人的签名。</p><p>假设M是有恶意的，他想把A账上的钱转走，所以他发布一个A转给M的交易，但这个交易需要有A的签名，M虽然获得记账权，但他不知道A的私钥，所以伪造不了签名。</p><p>如果M把交易硬写在区块链上，诚实的节点不会接受这个区块，因为它包含有非法的交易。所以诚实的节点会继续沿前一个区块挖，生成新的区块代替非法的区块，其他诚实的区块会沿着这个合法的区块继续挖。比特币要求是扩展正常合法链，M生成的不是合法区块，所以该区块作废。这对他造成的代价是很大的，因为没有了区块奖励，又没有偷到钱。</p><p>第二个问题:他能不能把已经花了的币再花一遍(即double spending)?假如他把M→A的交易写在了一个区块里面，现在他获得了记账权，他又发布另一个交易，把这个钱转回给自己，即M→M’。同样，这很明显是double spending，只要是诚实的节点都不会接受这个区块。</p><p>他如果想发布这个区块，只能连在写了M→A交易区块的前一个区块。注意:区块插在哪个位置，在刚挖矿时就是要决定的，因为设置的block header里要填上前一个block header的哈希。所以他想插到那个区块的话，一开始就要认定，而不是等获得记账权以后再认定。<br>2020-01-26 15:39<br>回复</p><p>苦艾酒_bitter<br>第五节课程  第六部分</p><p>这样生成的两条区块链，都是合法的。参考图十二(第五节视频  第56分钟处)。要看其他节点沿着哪一个链往下扩展，最后一个胜出一个作废。</p><p>这种攻击的目的是什么?如果M→A的交易，产生了某种不可逆的外部效果，然后M→M’再把M→A的交易回滚了，那么M就可以从中不当获利。</p><p>比如:网上购物时，M购买一些商品，然后该网站接受比特币支付，M发起一个交易把账转给网站。网站监听到交易写入了区块链里，以为支付成功了，所以就把商品给了M。M拿到商品之后，又发起一个交易，把支出的钱转给自己，然后把下面的链拓展成最长合法链。这样的结果是:既得到了商品，又收回了花掉的钱，就达到了double spending的目的。</p><p>如何防范这种攻击呢?如果M→A的交易所在的区块不是最后一个区块，那么这种攻击的难度就会大大增加。要是想回滚M→A的交易，还是要插在它之前的一个区块，然后想办法成为最长合法链。这个难度是很大的。因为诚实的节点，不会沿着它生成的区块往下扩展，因为它不是最长合法链。因此防范这种攻击的方法就是多等几个区块，或者叫多等几个确认confirmation。</p><p>M→A交易刚刚写入区块里时，我们把它叫作one confirmation。这时后面加的区块，依次叫two confirmation、three confirmation…比特币协议当中，缺省(系统默认)的是要等六个confirmation。有了六个confirmation，才认定M→A的交易是不可篡改的。这需要等多长时间呢?平均出块时间是10分钟，因此要等一个小时。</p><p>区块链是不可篡改的账本，那是不是意味着凡是写入区块链中的内容就永远改不了呢?经上述分析可以看出，这种分析只是一种概率上的保证。刚刚写入区块链的内容，还是比较容易被改动的。经过一段等待时间之后，或者后面几个区块被确认之后，被篡改的概率就大幅度下降(指数级别的下降)。</p><p>其实还有一种，叫零确认(其具体位置可见第五节视频  第62分第26秒)。意思是说，这个转账交易发布出去了，但还没又被写入区块链里。即M→A的交易已经发布，但下面包含M→M’的区块还没有被挖出来。</p><p>这个概念相当于电商购物的例子中，在支付时你发布一个转账交易，告诉电商自己已经转过钱了。<br>2020-01-26 15:43<br>回复</p><p>苦艾酒_bitter<br>第五节课程  第七部分<br>电商运行一个全节点或委托一个全节点监听区块链上的交易，他收到转账交易之后要验证该交易的合法性(有合法的签名，以前没有被花过)，甚至不用等到该交易写入区块链里。这种操作听起来风险很大，交易刚发布出去，都没往区块链里写呢。其实，零确认在实际当中，用的还是比较普遍的。为什么呢?</p><p>这其中有两个原因:①比特币协议缺省的设置是节点接收最先听到的那个交易。所以在零确认的位置，M→A的节点收到后，再发M→M’的交易，有比较大的概率诚实的节点是不会接受的。<br>②很多购物网站，从支付成功，到发货，是有一定的时间间隔的，即有一定的处理时间。</p><p>回到前面的问题:假设某个有恶意的节点获得记账权，它还能做什么坏事?能不能故意不把某些合法的交易写入区块链里?即发布的区块故意不包含某些交易。这是可以的。</p><p>比特币协议并没有规定获得记账权的节点一定要把那些交易发布到区块里。但出现这种情况问题也不大，因为这些合法的交易一定会被写入下一个区块里，总有诚实的节点愿意发布这些交易。</p><p>其实，区块链在正常工作下，也会出现合法的交易没有被包含进去的情况，可能就是这段时间交易的数目太多了。比特币协议中规定，每个区块的大小是有限制的，最多不能超过一兆字节。所以如果交易的数目太多了，那么有些交易可能就只能等到下一个区块再发布。</p><p>会不会出现这种情况?M→M’的交易所在的区块所在的链条虽然短，但是先偷偷的生成比上面更多的区块，然后等上面的链条公布后再公布，就能够胜过上面的几个区块了?这种方法叫作selfish mining。</p><p>正常情况下挖到一个区块马上就发布，原因是你不发布别人可能就发布了，那样就拿不到区块奖励了。而selfish mining是先藏着不急着发布，这是分叉工具的一种手段。</p><p>但这样成功的概率并不大，因为有恶意的节点本来算力占比就不高，还要生成更多的区块，就非常困难。</p><p>以上是selfish mining的其中一个目的，它还有另一个目的。假如A挖了两个区块都没有发布，而在B挖到一个区块公布后立马公布，这样B挖的区块就作废了。这样的好处就是减少竞争，因为A在挖第二个区块时，别人还在挖第一个区块(前提是A算力足够强)。</p><p>但这样也有不好的地方，假如A挖出一个区块，A以为他能赶在别人面前再挖一个区块，结果这时有人挖出了第一个区块，那这样的话A就要在别人发布之后立马发布，去争取区块奖励。</p><h2 id="P6-06-BTC-网络"><a href="#P6-06-BTC-网络" class="headerlink" title="P6. 06-BTC-网络"></a>P6. 06-BTC-网络</h2><p>第六节课程    第一部分</p><p>比特币网络<br>比特币工作在应用层(application layer:Bitcoin block chain)，它的底层是一个网络层(network layer:P2P overlay network)。</p><p>比特币的P2P网络是非常简单的，所有节点都是对等的。不像有的P2P网络有所谓的超级节点、纸节点。</p><p>要加入P2P网络首先得知道至少有一个种子节点，然后你要跟种子节点联系，它会告诉你它所知道的网络中的其他节点，节点之间是通过TCP通信的，这样有利于穿透防火墙。当你要离开时不需要做任何操作，不用通知其他节点，退出应用程序就行了。别的节点没有听到你的信息，过一段时间之后就会把你删掉。</p><p>比特币网络的设计原则是:简单、鲁棒，而不是高效。每个节点维护一个零度节点的集合，消息传播在网络中采取flooding的方式。节点第一次听到某个消息的时候，把它传播给去他所有的零度节点，同时记录一下这个消息我已经收到过了。下次再收到这个消息的时候，就不用转发给零度节点了。</p><p>零度节点的选取是随机的，没有考虑底层的拓扑结构。比如一个在加利福尼亚的节点，它选的零度节点可能是在阿根廷的。这样设计的好处是增强鲁棒性，它没有考虑底层的拓扑结构，但是牺牲的是效率，你向身边的人转账和向美国的人转账速度是差不多的。</p><p>比特币系统中，每个节点要维护一个等待上链的交易的集合。假如一个集合的交易都是等待写入区块链里的，那么第一次听到某个交易的时候，把这个交易加入这个集合，并且转发这个交易给节点，以后再收到这个交易就不用转发了，这样避免交易会在网络上无线的传播下去。转发的前提是该交易是合法的。</p><p>这里有冲突的情况，有可能你会有两个有冲突的交易，差不多同时被广播到网络上。比如说A→B和A→C，这两个如果同时广播在网络上，那么每个节点根据在网络中的位置的不同，收到两个交易的先后顺序不同。</p><p>比如一个人先收到第一个交易，就写入到集合里，再收到第二个交易的时候就不会写入集合，因为跟上一个交易有冲突，就认定是非法的。假设这两个交易花的是同一个币，那么写入集合的交易就会被删掉。<br>2020-01-26 17:37<br>回复</p><p>苦艾酒_bitter<br>第六节课程    第二部分</p><p>比如说节点听到一个新发布的区块，里面包含了A→B的交易，那么这个交易就可以删掉了，因为已经写入到了区块链里。如果节点又听到了A→C的交易，该怎么办?这时候也要把A→B删掉。因为A→C如果已经被写入到了区块里，那么A→B就变成了非法交易，就变成了double spending，这就是冲突的情况。可能某个先收到A→C的节点，抢先挖到了矿，发布了区块。</p><p>新发布的区块在网络上的传播有很多方式，跟新发布的交易是类似的。每个节点除了要检查区块的内容合法性之外，还要查它是不是在最长合法链里。越是大的区块，在网络上传播速度越慢。</p><p>比特币协议对区块的大小有1M字节的限制。比特币系统采用的传播方式是非常耗费带宽的，带宽是瓶颈。按1M的区块大小限制来算的话，一个新发布的区块有可能需要几十秒，才能传输到网络大部分境地，这已经是挺长时间了，所以这个限制值不算小。</p><p>还需要注意的一点:我们讲的比特币网络的传播属于best effort 。一个交易发布到比特币网络上，不一定所以的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的。网络传播存在延迟，而且这个延迟有的时候可能会很长，有的节点也不一定按照比特币协议的要求进行转发。</p><p>可能有的该转发的不转发，导致某些合法的交易收不到，也有的节点可能转发一些不该转发发的消息，比如说有些不合法的交易也被转发了。这就是我们面临的一个实际问题。<br>2020-01-26 17:38<br>回复</p><h2 id="P7-07-BTC-挖矿难度"><a href="#P7-07-BTC-挖矿难度" class="headerlink" title="P7. 07-BTC-挖矿难度"></a>P7. 07-BTC-挖矿难度</h2><p>第七节课程    第一部分</p><p>第七节</p><p>比特币的挖矿难度调整</p><p>目标预值越小，挖矿的难度越大。调整挖矿的难度就是调整目标空间在整个输出空间中所占的比例。</p><p>比特币用的哈希算法是SHA-256，这个产生的哈希值是256位。所以整个输出空间是2的256次方。调整这个比例，即目标空间占输出空间的比例，通俗的说，就是哈希值前面要有多少个0。比如说256位的哈希值，要是合法的区块，要求算出来的哈希，前面至少有70个0。当然这只是通俗的说法，因为这个目标预值，并不是说前面都是0，从某一个位置开始，后面都变成了1。</p><p>挖矿的难度跟目标预值是成反比的，公式是:difficulty=difficulty 1 target / target。上面是指挖矿难度等于1的时候所对应的目标预值，挖矿难度最小就是1，这个时候对应的目标预值是个非常大的数。</p><p>即target越大，挖矿是越容易的。所以公式里很大的一个数，除以当前的目标预值，得到的就是当前的挖矿难度。所以difficulty和target大小是成反比的。</p><p>为什么要调整挖矿难度呢?如果不调会有什么问题呢?系统里的总算力越来越强，挖矿难度保持不变的话，出块时间是越来越短的。</p><p>出块时间越来越短，会有什么问题吗?<br>比如说不到一秒就出一个区块，区块在网络上传播的时间可能需要几十秒，底层的比特币网络可能需要几十秒才能让其他节点都收到。别的节点没有收到这个区块之前还是继续沿着已有的区块链往下扩展。如果有两个节点同时都发布一个区块，这个时候就会出现分叉。</p><p>出块时间如果越来越短的话，这种分叉会成为常态，而且不仅会出现二分叉，可能会出现很多的分叉。比如10个区块同时被挖出来，系统可能会出现10分叉。</p><p>分叉如果过多，对于系统达成共识是没有好处的，而且危害了系统的安全性。比特币协议是假设大部分算力掌握在诚实的矿工手里。系统当中的总算力越强，安全性就越好，因为有恶意的节点想掌控51%的算力就越难。如果掌握了51%的算力，它就可以干很多坏事，比如分叉攻击。</p><p>如果后面分叉多的话，前面某个区块里的某个交易，很可能就遭受分叉攻击，恶意节点会试图回滚。因为后面分叉多，算力就会分散，恶意节点得逞的概率更大。这个时候恶意节点就不需要51%的算力了，可能10%的算力就够了，因此出块时间不是越短越好。<br>2020-01-27 22:52<br>回复</p><p>苦艾酒_bitter<br>第七节课程   第二部分</p><p>那10分钟的出块时间是不是最优的呢?不一定。改成其他值也可以，有间隔只是说应该有个常数范围。以太坊系统出块时间就降低到了15s，所以以太坊的出块速度是比特币的40倍。</p><p>出块时间大幅度下降之后，以太坊就要设计新的协议，叫ghost。在该协议中，这些分叉，产生的orphan block(即产生最长合法链后另一个要被丢弃的区块)就不能丢弃掉了，而是也要给它们一些奖励，这叫uncle reward。以太坊也要调整挖矿难度，使出块时间保持在15s。</p><p>讲完了为什么要调整挖矿难度，现在讲一下怎么调整挖矿难度。比特币协议中规定，每2016个区块后就要调整目标预值，这大概是每两个星期调整一次。</p><p>具体的调整公式:target =target×(actual time/expected time)。actual time指产生2016个区块实际花费的时间，expected time指产生2016个区块应用的时间，即2016×10min。</p><p>如果实际花费时间超过了两周，即平均出块时间超过了10min。那么这时候挖矿难度要调的低一点，应该让出块更容易。因此该公式算出来的target会变大，则难度会下降。</p><p>实际上，上调和下调都有四倍的限制。假如实际时间超过了8个星期，那么我们计算公式时也只能按4倍算，目标预值增大最多只能增大4倍。</p><p>那怎么才能让所有的矿工同时调整目标预值呢?计算target的方法写在比特币系统的代码里，每挖到2016个区块会自动进行调整。如果有有恶意的节点故意不调，会怎么样?</p><p>如果一个节点不调，将区块发布出去，诚实的节点是不会认的。nBits是target一个编码的版本，在block header里没有直接存储target的域，因为target的域是256位，直接存target的话要32个字节。nBits在header里只有四个字节，所以可以认为是它的一个压缩编码。</p><p>如果遇到有恶意的矿工，该调的时候不调，这时检查区块的合法性就通不过。因为每个节点要独立的验证发布的区块的合法性。检查的内容就包括:nBits，目标预值设的对不对。如果投机取巧设计一个过大的目标预值，使得你自己挖矿容易了，但这个区块是不会被接受的。<br>2020-01-27 22:53<br>回复</p><p>苦艾酒_bitter<br>第七节课程   第三部分</p><p>如图(第七节视频  第26分钟)显示的是比特币系统中总算力的变化情况。在比特币没有流行前，有很长一段时间，算力没有太明显的增长，前面这些年的hash rate几乎是0。其实这些年算力也是增长的，只是后面这些年算力增长的太快了，所以前面部分看上去像是一条直线。去年是涨得非常猛的一年，这也体现在了hash rate 的增长上，算力呈现出指数级的增长。即使在这段黄金时期，算力也不是单调递增的，中间也是有很多波动。</p><p>如图(第七节视频  第27分钟)是挖矿难度的变化情况，跟算力的增长基本上是同步的，这也符合难度调整的设计目标。通过调整挖矿难度，使得出块时间保持稳定。注意这个图显示的是挖矿难度，不是目标预值。</p><p>如图(第七节视频 第27分第27秒)是最近半年的难度调整曲线，可以看出很明显是一段一段的。每隔两个星期，难度上一个台阶，说明挖矿的人越来越多，用的设备越来越先进，反应出大家对比特币的热情越来越高。如果出现相反的情况，比如某个加密货币的挖矿难度越调越小，说明挖矿变得越来越容易了。但这不是好事，说明大家对币的热情是逐渐减小的。持续出现这种情况说明这个币将被淘汰。</p><p>如图(第七节视频 第28分第13秒)显示的是每天的出块时间。可以看出，总的来说出块时间稳定在10分钟上下振动。</p><p>如图(第七节视频 第28分第36秒)显示最近半年的出块时间，也是维持在10分钟左右。</p><p>挖矿难度的公式:下一个难度=前一个难度＊两周/挖前2016个区块用的时间(注意:前面的公式是目标预值的公式，不要混淆了)<br>2020-01-27 22:53<br>回复</p><h2 id="P8-08-BTC-挖矿"><a href="#P8-08-BTC-挖矿" class="headerlink" title="P8. 08-BTC-挖矿"></a>P8. 08-BTC-挖矿</h2><p>苦艾酒_bitter<br>第八节课程  第二部分</p><p>挖矿的设备:挖矿设备演化趋势是越来越趋于专业化，最早的时候用的是普通的CPU挖矿，像家里计算机、笔记本电脑。但如果买一台计算机专门用来挖矿是非常不划算的，计算机当中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，CPU当中的大部分部件也是闲置的，因为挖矿当中计算哈希值的操作只用到了通用CPU当中的很少一部分指令。硬盘和其他很多资源也都是闲置的，所以随着比特币挖矿难度的提高，用CPU挖矿，用通用计算机挖矿显得性价比太低。</p><p>所以挖矿转入第二代设备:GPU。GPU效率相比CPU提高了很多，主要用于大规模的并行计算。但GPU用来挖矿还是有点浪费了，GPU是用于通用并行计算而设计的，用来挖矿的话有很多部件仍然是出于闲置状态，比如说用于浮点数计算的部件。这些部件对于深度学习来说是很重要的，但比特币的操作只用到了整数挖矿。所以GPU虽然效率提高了很多但仍然有不小的浪费。这些年GPU价格涨得很快，有些人归因于深度学习的火热，其实有很多GPU是用来挖矿的。不过有一个好消息，随着比特币挖矿难度的提升，用GPU挖矿已经划不来了，已经超过了GPU的算力范围，所以GPU现在可以更多的用于深度学习、游戏应用的服务。</p><p>有一些新开发的加密货币有的还在用GPU挖矿，而现在更多用ASIC芯片挖矿，这是专门为了挖矿而设计的芯片，上面没有多余的电动逻辑，整个芯片就是为了比特币挖矿、计算哈希值的操作而设计的。它的性价比是最高的，这个芯片除了挖矿什么事都干不了，而且为某一种加密货币设计的ASIC芯片，只能挖这一种加密货币。除非这两个加密货币用同一个mining puzzle。</p><p>有些加密货币刚发行的时候，为了解决能启动问题，会故意用一个已有的加密货币的mining puzzle，比如说跟比特币一样的mining puzzle，这样可以吸引更多的人来挖矿，这种情况叫merge mining。除了这种情况，其他都是一个芯片只能为一个加密货币挖矿。ASIC芯片生产周期需要一年，但跟其他通用芯片相比，ASIC芯片研发速度已经是非常快的了。</p><p>在这么长的生产周期里面，如果比特币价格出现剧烈变化的话，前期投入的研发费用可能就打水漂了。从历史上看，比特币的价格变化是比较剧烈的。曾经发生好几次，比特币的价格在几个月之内，下跌了80%，然后又慢慢恢复。<br>2020-01-30 01:17<br>回复</p><p>苦艾酒_bitter<br>第八节课程  第三部分</p><p>如果比特币价格大幅度下降的话，挖矿可能是赔本的，可能还抵不上电费。即使在比特币发展的黄金时期，价格不断上涨，这时挖矿是有利可图的。但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了。一款ASIC矿机刚上市的时候大部分的利润是在它上市的前两个月获得的，因为这个时候它的算力在同类产品中是最强的。再往后随着更强的矿机出现，它就可能被淘汰掉。所以购买ASIC矿机的时机很重要，现在都是要提前预定的。有些不良厂商，ASIC矿机生产出来之后，不是立即提供给消费者，而是自己先用来挖矿一段时间，赚取比特币，等到最赚钱的黄金时间即这前两个月过去之后，再把矿机发给用户。当比特币系统中算力突然有一个很大的提升，就说明某个大公司生产出了新一款的ASIC矿机。所以在挖矿热潮中真正赚钱的不一定是挖矿的用户，而可能是卖矿机的大厂商。</p><p>挖矿机的变化趋势，是从通用变得越来越专用，CPU是通用计算，GPU是通用并行计算，ASIC是专用计算。ASIC一旦过时就作废了，不像CPU和GPU还能做其他工作。很多人觉得这是不好的，是跟去中心化的理念是不相符的，也违背了比特币设计的初衷。最民主的情况是，大家都用家里的CPU计算机挖矿。后来改为GPU噪音是很大的。而有些新的加密货币设计的是Alternative mining puzzle。而设计它的出发点是asic resistance(抗asic芯片化)，目的是让通用的计算机也能参与挖矿的过程。</p><p>挖矿的另一个趋势是大型矿池的出现，单个矿工即使用了ASIC芯片，挖矿从平均收益上看是有利可图的，但是收入是非常不稳定的。比特币系统中平均每10分钟出一个区块，这是说比特币系统中所有的矿工做一个整体来看平均10min会产生一个区块。但如果具体到某一个矿工来说，他可能要挖很长时间，如果他用一个矿机可能要挖一两年。这样子就好像是买彩票，挖到了就是中了一个大奖。单矿工还有其他问题，他除了挖矿之外还要承担全节点的其他责任(就是这节课最开始介绍的那些)。</p><p>第八节课程  第四部分</p><p>所以要引入矿池，所谓的矿池，就是把这些矿工组织起来，作为一个整体，矿池的架构一般是一个全节点会驱动很多矿机，一个矿池有一个矿主，叫pool manager。下面连了很多矿工，这些矿工只负责计算哈希值，全节点的其他职责都由矿主来承担。他负责监听网上的交易，把这些交易组织打包成区块，同时要看一看有没有其他的节点抢先发布区块，如果有的话看怎样进行调整…..</p><p>ASIC芯片只能负责计算哈希值，它不能干全节点的其他功能。矿池的出现还为了解决另一个问题:收入不稳定。单个矿工的收入是不稳定的，所以大家一起干，有了收益再进行分配。</p><p>那么收益该如何分配?矿池一般有两种组织形式，一种是像大型数据中心那样，有的互联网公司，有成千上万个服务器，大的矿池里面也有成千上万的矿机，这些矿机如果是属于同一个机构的话，那么收入怎么分配就不重要了。</p><p>但也有矿机是来自不同机构的，即第二种组织方式:分布式的。矿工和矿主不在同一个地方，可能分散在世界各地，那么矿工要加入一个矿池，就是按照矿池规定的通讯协议跟矿主进行联系。矿主把计算哈希值的任务分配给他，矿工计算完之后，把结果反馈给矿主，将来获得出块奖励时一起分配。</p><p>如果矿工是来自五湖四海的，不是属于同一个机构的，那么利益该怎么分配?平均分配行不行?比如每个矿工挖到一个区块，得到了出块奖励，然后平分给其他矿工，这样行吗?不行，因为会有矿工偷懒。因此要按矿工的贡献大小进行分配，也就是这里同样需要工作量证明。那该怎么证明每个矿工做了多少工作呢？<br>2020-01-30 01:18<br>回复</p><p>苦艾酒_bitter<br>第八节课程  第五部分</p><p>为什么矿工的收入不稳定，因为挖矿太难了，如果把挖矿的难度降低之后，挖矿就会变得稳定了。怎么降低难度呢?以前的要求是，矿工要找到一个nonce，用nonce计算block header 的哈希值，前面至少有70个0才是合法的区块。降低挖矿难度之后，比如说前面只要有60个0就行了，这样挖到的叫作一个share，这个share叫做almost valid block。矿工挖到share或almost valid block之后，把它提交给矿主。矿主拿到这个区块有什么用呢？用来证明矿工所做的工作量，而没有其他用途。矿主无法得到区块奖励以及任何好处。所以矿主就统计每个矿工提交了多少这样的share，将来等到某个矿工真正挖到了合法的区块之后，再将出块奖励按照每个矿工所做的工作量，提交的share数目进行分配。</p><p>这样做为什么是可行的?每个矿工挖到矿的概率取决于他尝试的nonce数目，尝试的nonce越多，能找到的share就越多。</p><p>有没有可能一个矿工挖到一个合法的区块之后，不把它提交给矿主，而是自己偷偷摸摸发布出去，得到出块奖励?即平时挖到的share提交，但挖到了合法区块就不提交?不可能，因为每个矿工的任务是由矿主分配的，矿主负责组装好一个区块，然后交给矿工去尝试各种nonce，而且挖矿仅仅调nonce是不够的，还需要调整coinbase parameter。所以矿主会把不同的coinbase parameter所对应的nonce值的范围交给不同的矿工去尝试。那么这个区块里包含什么?coinbase transaction里面有收款人的地址，这个地址填的是矿主的地址，即pool manager的地址，所以矿工挖到区块之后，如果他不提交给矿主自己发不出去是没有用的。里面的收款地址是矿主的，他取不出钱来。所以只要是当初按矿主给分配的任务进行挖矿的，就不可能偷区块奖励。</p><p>如果他一开始就不管矿主的任务，自己组装一个区块，偷偷把收款地址改成自己地址，会怎样?那样他提交share给矿主的话，矿主是不认的，因为里面交易列表被改过了，coinbase transaction里面的内容发生了变化，算出的merkle tree 的根哈希值也是不一样的。这种情况下矿主是不会给他工作量证明的。那就相当于矿工一开始就单干，跟矿池是没关系的。<br>2020-01-30 01:19<br>回复</p><p>苦艾酒_bitter<br>第八节课程  第六部分</p><p>虽然不可能偷区块奖励，但会不会有人捣乱，比如平时挖到一个share，提交给矿主，作为工作量证明。等他挖到一个真正合法的区块之后，把它扔掉。这是有可能的，虽然没有经济好处，但有可能是别的矿池派来的卧底，不想让这个矿池得到区块奖励。这些矿工还是会分红，分的是别的矿工挖出来的区块奖励。</p><p>如图(第八节视频  第38分处 )是矿池在各个国家的分布比例，中国矿池占世界81%，远远超过其他国家，所以按矿池比例来看的话，中国的总算力是有绝对优势的。</p><p>如图(第八节视频 第38分第24秒)如果按照单个矿池来看，在2014年，曾经有叫GHash.IO的矿池，这个矿池的算力，占到了全球算力的一半以上。在当时曾引起一些恐慌，这一个矿石的算力就已经足以发动51%的攻击了。这个事情公布之后，该矿池主动把算力占比大幅度的减少，以免动摇大家对比特币的信心。</p><p>如图(第八节视频  第38分第56秒)是2018年的各矿池的算力分布，看上去没有那么集中了，GHash.IO矿池早已停止运营。当然，挖矿集中化的程度仍然是比较大的，几个大型矿池占了相当大的比重，但没有矿池占50%以上。这样看算比较安全了，但可能只是一个表面现象。假如一个机构有一半以上的算力，他不一定要把算力集中在一个矿池里，而可以把算力分散隐藏在很多矿池里，真正需要发动攻击的时候再集中起来发动攻击。</p><p>矿工转换矿池是很容易的，加入一个矿池就是按照这个矿池的协议跟这个矿主联系，矿池把组装好的区块信息发给矿工，矿工来尝试各种nonce值就可以了。</p><p>所以这就是矿池带来的危害，如果没有矿池，想要发动51%的攻击，攻击者要投入大量的成本来购买到足够的矿机，能够达到系统中半数以上的算力。有了矿池之后，他可能只占很小一部分比例的算力，只要能够吸引到足够多的矿工，足够多的不明真相的群众加入到他的矿池里来就行了。</p><p>一般来说，矿池的矿主要收取一定比例的出块奖励作为管理费。矿主也要按照比例收取管理费，有的是按照出块奖励的比例，也有的是抽取交易费。有的一些有恶意的矿池在发动攻击之前，可能故意把管理费降得特别低，甚至是赔本赚吆喝，吸引足够多的矿工加入之后就可以发动攻击了。这是大型矿池的一个弊端，使得51%的攻击更加容易了。<br>2020-01-30 01:21<br>回复</p><p>苦艾酒_bitter<br>第八节课程  第七部分</p><p>假如某个矿池占到了半数以上的算力，他具体能够发动哪些攻击呢?一个最常见的就是分叉攻击。假如一个区块链，其中一个区块包含了一个大笔的交易，又等了几个确认区块之后，自认为已经安全了。然后这时就可能有人在该交易前面的区块发动分叉攻击。</p><p>看上去好像追赶的道路是很漫长的，但如果拥有51%的算力，最终还是可以成功攻击。另外，不要把51%当成绝对的门槛，有可能不到51%就可以。算力都是估计的，而且算力还在不断变化。</p><p>攻击者还能做什么坏事?还可以做boycott(封锁境域)。比如说攻击者不喜欢某个账户，怀疑某个账户参与非法交易，想把这个账户封锁掉，所有跟这个账户相关的交易都不让上链。假如A把某个交易A→B发布到区块链上，攻击者就会马上进行分叉，产生一个不包含这个交易的区块，所有跟A有关的交易也都不包含进去。</p><p>这种攻击跟分叉攻击区别是什么?他没必要等后面几个确认区块。这时候如果攻击者等待确认区块，是为了让B放心，B以为后面有六个确认区块，已经没事了，然后攻击者再发动分叉攻击。而如果目的是为了boycott的话，就没有必要等后面区块生成。A→B交易一上链马上进行分叉，越早越好，因为攻击者是希望别人沿着他的链往下挖的。</p><p>前面讲过，有些有恶意的节点故意不把某些交易写入区块里，是可以的。但没有关系，后面的区块还是会包含的。但是如果这个坏人拥有51%的算力的话，他可能仗着自己算力强，公开抵制他想抵制的交易。这样别的矿工也不敢随便把交易打包进去了。</p><p>那么攻击者有没有可能掌握51%的算力后，把别人账上的钱转走。这是不可能的。因为他没有别人账户的私钥，没有办法伪造签名。如果他仗着算力强，强行把一个没有合法签名的交易发布到区块链上，会有什么样的结果?会造成分叉。因为诚实的矿工会沿着另外一个分叉去挖，不会沿着他发布的区块往下挖。所以盗币是不可能的。</p><p>总结:矿池的出现减轻了矿工的负担，矿工只需要挖矿，计算哈希值就行了，别的事情都由矿主来完成。矿工的收入分配也更加稳定。但矿池的出现也有危害，发动51%的攻击变得容易了。他不一定自己有这么强的算力，只要动员召集这些算力就可以了。</p><p>这有点类似于云计算中的on demand computing。平时不需要维护很大的计算机群，需要用的时候可以随时召回来。而矿池的情况，是on demand mining。</p><h2 id="P9-09-BTC-比特币脚本"><a href="#P9-09-BTC-比特币脚本" class="headerlink" title="P9. 09-BTC-比特币脚本"></a>P9. 09-BTC-比特币脚本</h2><p>苦艾酒_bitter<br>第九节课程  第一部分</p><p>第九节</p><p>比特币使用的脚本与原理</p><p>如图(第15秒)是比特币的一个交易实例。该交易有一个输入两个输出。左上角写着output，其实是这个交易的输入。右边两个输出，上面unspent即没有花出，下面spent表示已花出。该交易已经收到了23个确认，所以回滚的可能性很小了。</p><p>下面是这个交易的输入输出脚本，输入脚本包含两个操作，分别把两个很长的数压入栈里。比特币使用的脚本语言是非常简单的，唯一能访问的内存空间就是一个堆栈。不像通用的编程语言，像C语言C++那样有全局变量、局部变量、动态分配的内存空间，它这里就是一个栈，所以叫做基于栈的语言。这里输出脚本有两行，分别对应上面的两个输出。每个输出有自己单独的一段脚本。</p><p>如图(第1分第40秒)是交易的具体内容。首先看交易的一些宏观信息。第一行:transaction ID，第二行hash，该交易的哈希值。第三行:使用的比特币协议的版本。第四行:该交易的大小。第五行:用来设定交易的生效时间。此处的0表示立即生效。绝大多数情况下，locktime都是0。如果是非零值，那么该交易要过一段时间才能生效。比如要等10个区块以后才能被写入区块链里。第六行第七行的vin、vout是输入输出部分，后面会详细讲解。第八行是这个交易所在区块的哈希值。第九行:该交易已经有多少个确认信息。第十行是交易产生的时间，第十一行是这个区块产生的时间。(time 和block time都是指很早的一个时间到现在过了多少秒)</p><p>如图(第3分第32秒)是交易的输入结构。一个交易可以有多个输入，在这个例子中只有一个输入。每个输入都要说明该输入花的币是来自之前哪个交易的输出，所以前两行给出输出币的来源。第一行:之前交易的哈希值。vout表示这个交易里的第几个输出。所以这里表示花的币来自于哈希值为c0cb…c57b的交易中第0个输出。接下来是输入脚本，输入脚本最简单的形式就是给出signification就行了，证明你有权利花这个钱。(后面的PPT中scriptsig就写成input script输入脚本)。如果一个交易有多个输入，每个输入都要说明币的来源，并且要给出签名，也就是说比特币中的一个交易可能需要多个签名。<br>2020-02-06 19:09<br>回复</p><p>苦艾酒_bitter<br>第九节课程   第二部分</p><p>如图(第5分)是交易的输出，也是一个数组结构。该例子中有两个输出，value是输出的金额，就是给对方转多少钱，单位是比特币，即0.22684个比特币。还有的单位是satoshi(一聪)，是比特币中最小的单位。1比特币=10的8次方聪。n是序号，表示这是这个交易里的第几个输出。</p><p>scriptpubkey是输出脚本，后面都写成output script。输出脚本最简单的形式就是给出一个pubkey。下面asm是输出脚本的内容，里面包含一系列的操作，在后面会详细解释。require sigs表示这个输出需要多少个签名才能兑现，这两个例子中都是只需要一个签名。type是输出的类型，这两个例子类型都是pubkeyhash，是公钥的哈希。addresses是输出的地址。</p><p>如图(第6分 第36秒)是展示输入和输出脚本是怎样执行的。在区块链第二个区块里有A→B的转账交易，B收到转来的钱后，又隔了两个区块，把币又转给了C。所以B→C交易的txid、vout是指向A→B交易的输出。而要验证交易的合法性，是要把B→C的输入脚本，跟A→B交易的输出脚本拼接在一起执行。</p><p>如图(第7分 第40秒)这里有个交叉，前面交易的输出脚本放在后面，后面交易的输入脚本放在前面。在早期的比特币实践中，这两个脚本是拼接在一起，从头到尾执行一遍。后来出于安全因素的考虑，这两个脚本改为分别执行。首先执行输入脚本，如果没有出错就再执行输出脚本。如果能顺利执行，最后栈顶的结果为非零值，也就是true，那么验证通过，这个交易就是合法的。如果执行过程中出现任何错误，这个交易就是非法的。如果一个交易有多个输入的话，那么每个输入脚本都要和所对应的交易的输出脚本匹配之后来进行验证。全都验证通过了，这个交易才是合法的。</p><p>如图(第8分第45秒)是输入、输出脚本的几种形式。一种最简单的形式就是P2PK(pay to public key)。输出脚本里直接给出收款人的公钥，下面一行checksig，是检查签名的操作。在输入脚本里，直接给出签名就行了。这个签名是用私钥对输入脚本所在的整个交易的签名。这种形式是最简单的，因为公钥是直接在输出脚本里给出的。<br>2020-02-06 19:10<br>回复</p><p>苦艾酒_bitter<br>第九节课程   第三课程</p><p>如图(第9分第18秒)是脚本的实际执行情况。这三行是把输入脚本和输出脚本拼接起来之后的结果。第一行来自输入脚本，后两行来自输出脚本。注意，实际代码中出于安全考虑，这两个脚本实际上是分别执行的。第一行:把输入脚本提供的签名压入栈，第二条把输出里提供的公钥压入栈，第三条checksig是把栈顶的这两个元素弹出来。用公钥检查一下这个签名是否正确。如果正确，返回true，说明验证通过。否则，执行出错，这个交易就是非法的。</p><p>如图(第10分第24秒)是P2PK的一个实例。上面交易的输入脚本就是把签名压入栈，下面交易是上面交易输入的币的来源。它的输出有两行，第一行是把公钥压入栈，第二行就是checksig。这是第一种形式。</p><p>如图(第10分第52秒)是第二种形式P2PKH(pay to public key hash)，跟第一种区别是输出脚本里没有直接给出收款人的公钥，给出的是公钥的哈希。公钥是在输入脚本里给出的。输入脚本既要给出签名，也要给出公钥。输出脚本里还有一些其他操作，DUP、HASH160等等，这些操作都是为了验证签名的正确性。P2PKH是最常用的形式。</p><p>如图(第11分第37秒)是脚本的执行结果，这个是把上一页的输入脚本和输出脚本拼接之后得到的，前两条语句来自输入脚本，后面的语句来自输出脚本，还是从上往下执行。第一条语句先把签名压入栈，第二条语句把公钥压入栈。第三条语句是把栈顶的元素复制一遍，所以栈顶又多了一个公钥。HASH160是把栈顶元素弹出来，取哈希，然后把得到的哈希值再压入栈。所以栈顶变成了公钥的哈希值。<br>2020-02-06 19:11<br>回复</p><p>苦艾酒_bitter<br>第九节课程  第四部分</p><p>第五行是把输出脚本里提供的公钥的哈希值压入栈。这个时候栈顶有两个哈希值，上面的哈希值是输出脚本里面提供的，收款人公钥的哈希，即我发布交易时，转账的钱是转给谁的，在输出脚本里提供一个收款人的公钥的哈希。下面的哈希是指你要花这个钱时在输入脚本里给出的公钥，然后前面的操作HASH160是取哈希后得到的。倒数第二行操作的作用是弹出栈顶的两个元素，比较是否相等，即比较其哈希值是否相等。这样做的目的是防止有人莫名顶替，用自己的公钥冒充收款人的公钥。假设两个哈希是相等的，那么就从栈顶消失了。最后一条作用是用公钥检查弹出栈顶的元素是否正确。假设签名是正确的，整个脚本就顺利运行结束，栈顶留下的是true。如果执行过程任何一个环节发生错误，比如输入里给出的公钥跟输出里给出的哈希值对不上，或者是输入里给出的签名跟给出的公钥对不上，那么这个交易就是非法的。</p><p>P2PKH是最常用的脚本信息，该实例(第14分第20秒)用的就是这种脚本。输入脚本就是把签名压入栈，把公钥压入栈。下面的输出脚本复制栈顶元素，然后取哈希值，hash160。然后把公钥的哈希压入栈，最后比较栈顶的两个哈希值，检查签名。</p><p>最后一种如图(第15分第25秒)，也是最复杂的一种脚本形式，是Pay to Script Hash。这种形式的输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的一个脚本的哈希，这个脚本叫redeemscript，赎回脚本。将来花这个钱时输入脚本里要给出redeemscript(这个赎回脚本的具体内容)，同时还要给出让赎回脚本能够正确运行所需要的签名。</p><p>验证时分为两部(如图第15分第40秒)，第一步验证输入脚本里给出的赎回脚本是不是跟输出脚本里给出的哈希值匹配，如果不匹配说明给出的赎回脚本是不对的，就类似于刚才讲的pay to public key hash里面给出的公钥不对一样。匹配不上说明给出的赎回脚本是不对的，那么验证就失败了。如果输入里给出的赎回脚本是正确的，那么第二步还要把赎回脚本的内容当做操作指令来执行一遍，看看最后能不能顺利执行。如果两步验证都通过了，那么这个交易才是合法的。听上去有点抽象，那么下面看一个具体的例子。<br>2020-02-06 19:12<br>回复</p><p>苦艾酒_bitter<br>第九节课程  第五部分</p><p>(如图第16分第47秒)用pay to script hash实现pay to public key 的功能。这里的输入脚本就是给出签名，再给出序列化的赎回脚本，赎回脚本的内容就是给出公钥，然后用checksig检查签名。下面这个输出脚本是用来验证输入脚本里给出的赎回脚本是否正确。</p><p>如图(第17分第13秒)看一下pay to script hash的执行过程。开始也是把输入脚本和输出脚本拼接在一起，前两行来自输入脚本，后面三行来自输出脚本。首先把输入脚本的签名压入栈，然后把赎回脚本压入栈，然后是取哈希的操作，得到赎回脚本的哈希。这里RSH是指redeem script hash，赎回脚本的哈希值。接下来还要把输出脚本里给出的哈希值压入栈，这时栈里就有两个哈希值了。最后用equal比较这两个哈希值是否相等，如果不等就失败了。假设相等，那这两个哈希值就从栈顶消失了，到这里第一阶段的验证就算结束了，接下来还要进行第二个阶段的验证。</p><p>如图(第18分第28秒)第二个阶段首先要把输入脚本提供的序列化的赎回脚本进行反序列化，这个反序列化的操作在PPT上并没有展现出来，这是每个节点自己要完成的。然后执行赎回脚本，首先把public key压入栈，然后用checksig验证输入脚本里给出的签名的正确性。验证痛过之后，整个pay to script hash才算执行完成。</p><p>有人可能会问:干脆用pay to public key就行了，搞这么复杂干嘛?为什么非要把这些功能嵌入到赎回脚本里面?对于这个简单的例子来说确实是复杂了，但pay to script hash它的常见的应用场景是对多重签名的支持。</p><p>比特币系统中一个输出可能要求多个签名才能把钱取出来，比如某个公司的账户，可能要求五个合伙人中任意三个人签名才能把公司账户上的钱取走，这样为私钥的泄露提供了一些安全的保护。</p><p>比如说有某个合伙人私钥泄露出去了，那么问题也不大，因为还需要两个人的签名才能把钱取走。这同时也为私钥的丢失提供了一些冗余，即使有两个人把私钥忘掉了，省下的三个人依然可以把钱取出来，然后转到某一个安全的账户。</p><p>第九节课程   第六部分</p><p>以上的功能是通过check multisig来实现的。<br>如图(第21分)，输出脚本里给出N个公钥，同时指定一个预值M。输入脚本只要提供接N个公钥对应的签名中任意M个合法的签名就能通过验证。</p><p>比如刚才举的例子中，N=5，M=3，五个合伙人中任意三个的签名都可以，输入脚本的第一行有一个红色的“✘”，这是什么意思呢?</p><p>比特币中check multisig的实现，有一个bug，执行的时候会从堆栈上多弹出一个元素，这个就是它的代码实现的一个bug。这个bug现在已经没有办法改了，因为这是个去中心化的系统，要想通过软件升级的方法去修复这个bug代价是很大的，要改的话需要硬分叉。所以实际采用的解决方案，是在输入脚本里，往栈上多压进去一个没用的元素，第一行的“✘”就是没用的多余的元素。另外需要注意给出的M个签名的相对顺序，要跟它们在N个公钥中的相对顺序是一致的才行。</p><p>如图(第22分第48秒)是check multisig的执行过程。这个例子假设三个签名中给出两个就行。图中可以看到这两个签名给出的相对顺序也是跟它们在公钥中的顺序是一样的。在公钥当中，第一个公钥排在第二个公钥前面。那么给出这两个签名的时候也是第一个签名排在第二个的前面。</p><p>第一行的false就是前面说的多余的元素。首先把多余的元素压入栈里，然后把两个签名依次压入栈，这个时候输入脚本就执行完了。接下来的输出脚本里把M的值，即预值M压入栈。然后把三个公钥压入栈，接着把N的值压入栈，最后执行check multisig，看看堆栈里是不是包含了这三个签名中的两个，如果是那么验证通过。</p><p>注意:这个过程中并没有用到pay to script hash。就是用比特币脚本中原生的check multisig来实现的。这么实现有什么问题吗？<br>早期的多重签名就是这样实现的，在实际的应用当中，有一些不是很方便的地方。<br>2020-02-06 19:14<br>回复</p><p>苦艾酒_bitter<br>第九节课程   第七部分</p><p>比如:网上购物。某个电商用multi签名，要求有五个合伙人中任意三个人的签名才能把钱取出来，要求网上购物的用户在支付的时候生成的转账交易里给出这五个合伙人的公钥，同时要给出N和M值。在这个例子中，N=5，M=3，这些都是用户在网上购物的时候生成转账交易时输出脚本里要给出的信息，给出这五个公钥，给出N和M值。</p><p>那么用户怎么知道这些信息呢?需要购物网站在网上公布出来，比如网上可以公布我们用了多重签名，我们用的五个签名中要给出三个，这是五个公钥，然后用户生成这个转账交易的时候，就把这些信息填进去。那么不同的电商采用的多重签名的规则是不一样的。有的电商可能是五个签名中要任意三个，有的可能要四个。这就给用户生成转账交易带来了一些不方便的地方，因为这些复杂性都暴露给用户了。</p><p>那么该如何解决?这里就要用到pay to script hash。<br>如图(第26分第39秒)是用pay to script hash实现的多重签名，它的本质是把复杂度从输出脚本转移到了输入脚本。现在这个输出脚本变得非常简单，只有这三行。原来的复杂度被转移到redeemscript赎回脚本里。输出脚本只要给出这个赎回脚本的哈希值就可以了。赎回脚本里要给出这N个公钥，还有N和M的值，这个赎回脚本是在输入脚本里提供的，也就是说是由收款人提供的。</p><p>像前面网上购物的例子，收款人是电商，他只要在网站上公布赎回脚本的哈希值，然后用户生成转账交易的时候把这个哈希值包含在输出脚本里就行了。至于这个电商用什么样的多重签名规则，对用户来说是不可见的，用户没必要知道。从用户的角度来看采用这种支付方式跟采用pay to public key hash没有多大区别，只不过把公钥的哈希值换成了赎回脚本的哈希值。当然，输出脚本的写法上也有一些区别，但不是本质性的。这个输入脚本是电商在花掉这笔输出的时候提供的，其中包含赎回脚本的序列化版本，同时还包含让这个赎回脚本验证通过所需的M个签名。将来如果这个电商改变了所采用的多重签名规则，比如由五个里选三个变成三个里选两个，那么只要改变输入脚本和赎回脚本的内容，然后把新的哈希值公布出去就行了。对用户来说，只不过是付款的时候，要包含的哈希值发生了变化，其他的变化没有必要知道。<br>2020-02-06 19:15<br>回复</p><p>苦艾酒_bitter<br>第九节课程   第八部分</p><p>如图(第29分第14秒)是具体的执行过程。这是把输入脚本和输出脚本拼接在一起后的情况，第一行的FALSE就是为了应付check multisig的bug而准备的一个没用的元素，执行的时候先把它压入栈，然后依次把两个签名压入栈，接下来是序列化的赎回脚本，目前只是把它作为数据压入栈，到这里输入脚本就执行完了。下面是输出脚本，取哈希，然后把输出脚本里提供的哈希值压入栈顶。最后判断两个哈希值是否相等，到这里第一阶段的验证就完成了。</p><p>如图(第30分第18秒)开始第二阶段的验证，把赎回脚本展开后执行。先把M压入栈，然后把三个公钥压入栈，把N压入栈，最后检查多重签名的正确性，三个里面有两个是正确的。第二阶段的验证过程跟前面直接使用check multisig的情况是类似的。</p><p>如图(第30分第52秒)是网上使用pay to script hash来做多重签名的一个实例。上面输入脚本的最后一个就是序列化的赎回脚本，反序列化之后得到的就是三个里面取两个的多重签名脚本。下面这个输出脚本的内容，跟前面讲的是一样的。现在的多重签名，一般都是采用这种pay to script hash的形式。</p><p>如图(第31分第25秒)这种脚本格式是比较特殊的，这种格式的输出脚本开头是return的操作，后面可以跟任意的内容。return操作的作用，是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证，执行到return语句，就会出错，然后执行就终止了，后面跟的内容根本没有机会执行。</p><p>为什么要设计这样的输出脚本呢？这样的输出岂不是永远花不出去吗？无论输入脚本写的是什么内容，执行到输出的return语句，它就会报错，那么这里的钱永远都花不出去。确实如此，这个脚本是销毁比特币的一种方法。</p><p>为什么要销毁比特币呢？这个一般有两种应用场景:<br>①有些小的币种要求销毁一定数量的比特币才能够得到这个币种，有时候把这种小币种称为AltCoin(Alternative coin)。除了比特币之外的其他小的加密货币都可以认为是Alternative Coin。比如有的小币种要求销毁一个比特币可以得到1000个小币，也就是说要用上述的方法证明已经付出了一定的代价才能够得到这个小币种。<br>2020-02-06 19:16<br>回复</p><p>苦艾酒_bitter<br>第九节课程   第九部分</p><p>②往区块链里写入一些内容。区块链是个不可篡改的账本，有人就利用这个特性往里面添加一些需要永久保存的内容，比如第一节课讲的digital commitment。要证明在某个时间，知道某些事情。比如涉及知识产权保护的，把某项知识产权的内容取哈希之后，把哈希值放到return语句的后面，其后面的内容反正是永远不会执行的，往里面写什么都没关系。而且放在这里的是一个哈希值，不会占太大的地方，而且也没有泄露出来你知识产权的具体内容。将来如果出现了纠纷，像知识产权的一些专利诉讼，再把具体的哈希值的输入内容公布出去，证明你在某个时间点已经知道某个知识了。</p><p>这个应用场景和coinbase域相似。coinbase transaction里面有个coinbase域，在这个域里写什么内容同样是没人管的，那这里为什么不用coinbase的方法呢？coinbase还不用销毁比特币，就可以直接往里写。</p><p>coinbase的方法只有获得记账权的那个节点才能用。如果是一个全节点，挖矿挖到了，然后发布一个区块，可以往coinbase transaction 里的coinbase域写入一些内容，这是可以的。</p><p>而我们说的上述方法，是所有节点都可以用的，甚至不一定是个节点，可能就是一个普通的比特币上的一个用户，任何人都可以用这种方法去写入一些内容。发布交易不需要有记账权，发布区块才需要有记账权。任何用户都可以用这种方法销毁很少的比特币，比如0.0000001个比特币，换取往区块链里面写入一些内容的机会。其实有些交易根本没有销毁比特币，只不过支付了交易费。</p><p>下面看两个实例<br>如图(第37分第44秒)是一个coinbase transaction。这个交易有两个输出，第一个输出的脚本是正常的pay to public key hash，输出的金额就是得到的block reward加上transaction fee。第二个输出的金额是0，输出脚本就是刚才提到的格式:开头是return，后面跟了一些乱七八糟的内容，第二个输出的目的就是为了往区块链里写一些东西。<br>2020-02-06 19:17<br>回复</p><p>苦艾酒_bitter<br>第九节课程  第十部分</p><p>这种形式的脚本的一个好处是:矿工看到这种脚本的时候知道它里面的输出永远不可能兑现，所以就没必要把它保存在UTXO里面，这样对全节点是比较友好的。还有一点要说明:这个PPT当中涉及到比特币脚本的操作为了简单起见都没有加上OP前缀。比如CHECKSIG，实际上应该写成OP_CHECKSIG，CHECKMULTISIG、DUP也是如此。</p><p>比特币系统中用到的这种脚本语言是非常简单的，甚至连专门的名字都没有，它就叫比特币脚本语言(bitcoin scripting language)。后面可以看到，以太坊当中用的智能合约的语言比这个要复杂的多。比如说比特币的脚本语言不支持循环，所以有很多功能这个语言是实现不了的，这样的设计是有其用意的，不支持循环就不会有死循环，就不用担心停机问题。以太坊当中智能合约的语言表达能力很强，所以就要靠汽油费的机制来防止程序陷入死循环。</p><p>另外一方面，这个语言虽然在某些方面功能是很有限的，但是在另外一些方面它的功能却很强大，比如跟密码学相关的功能。如checkmultisig，检查多重签名用一条语句就能够完成，这个比很多通用的编程语言要方便的多。所以比特币的脚本语言虽然看上去很简单，但其实针对比特币的应用场景做了很好的优化。</p><h2 id="P10-10-BTC-分叉"><a href="#P10-10-BTC-分叉" class="headerlink" title="P10. 10-BTC-分叉"></a>P10. 10-BTC-分叉</h2><p>第十节课程  第一部分</p><p>第十节</p><p>比特币分叉</p><p>区块链由一条链变为两条链就叫分叉。分叉可能是多种原因造成的，比如挖矿的时候，两个节点差不多同一个时候挖到了矿，就会出现一个临时性的分叉，我们把这个分叉叫作state fork，是由于对比特币区块链当前的状态有意见分歧而导致的分叉。</p><p>前面还讲过分叉攻击(forking attack)，它也属于state fork，也是属于对比特币这个区块链当前的状态产生的意见分歧，只不过这个意见分歧是故意造成的，人为造成的，所以我们又叫它deliberate fork。</p><p>除了这种state fork 之外，还有一种产生分叉的情况是，比特币的协议发生了改变，要修改比特币系统需要软件升级。在一个去中心化的系统里，升级软件的时候没有办法保证所有的节点同时都升级软件。</p><p>假设大部分节点升级了软件，少数节点因为种种原因可能没有升级，有可能是还没来得及升级，也可能是不同意对这个协议的修改。即假如你想把协议改成某个样子社区中可能是有人不支持的，这个时候也会出现分叉，这种分叉叫protocol fork(协议分叉)。因为对比特币协议产生了分歧，用不同版本的协议造成的分叉，我们称作protocol fork。</p><p>根据对协议修改的内容的不同，我们又可以进一步分成硬分叉和软分叉。出现硬分叉的情况:如果对比特币协议增加一些新的特性，扩展一些新的功能，这些时候那些没有升级软件的这些旧的节点，它是不认可这些新特性的，认为这些特性是非法的，这就属于对比特币协议内容产生了意见分歧，所以会导致分叉。</p><p>硬分叉的一个例子就是比特币中的区块大小限制(block size limit)。比特币系统规定每个区块最多是1M字节，有些人认为1M的限制太小了，也增加了交易的延迟。可以计算一下:1M=1百万  一个交易大概认为是250个字节 1百万/250=4000  一个区块大概是4000个交易  平均10分钟出现一个区块 4000/(60×10)=7  大概每秒钟产生7笔交易即7tx/sec 这个传输速度是非常低的。<br>2020-02-07 15:23<br>回复</p><p>苦艾酒_bitter<br>第十节课程  第二部分</p><p>有人发布一个软件更新，把block size limit从1M增加到4M。假设大多数节点更新这个软件，把block size limit更新到4M，少数节点没有更新。这里的大多数节点和少数节点不是按照账户数目来算的，而是按照算力，即系统中拥有大多数哈希算力的节点都更新了软件。新节点认为区块大小限制是4M，旧节点认为是1M。</p><p>如图(第11分第40秒)这时运行系统，会有什么结果?假如一个新节点挖出一个区块，这个区块比较大，但旧节点不认可，它忽略大区块的存在会继续沿着它的前一个小区块接着挖。而旧节点如果挖出了区块新节点是认可的，因为4M的限制指不能超过4M，比4M小是可以的。</p><p>那为什么会产生分岔呢?大区块挖出之后，因为大多数区块是更新了的，是认可新的大区块的，所以会沿着它继续挖。只有少数旧节点会接着下面链往下挖，这时新节点认为上下两条链都是合法的，但上面那条是最长合法链，所以会沿着上面一条挖。而且算力足够大会使上面那条链越来越长。而旧节点认为上面的链无论多长都是非法的，它们只会沿着下面的链挖。当然上面的链也可能出现小区块，因为新节点也可能挖出大小不到1M的区块，虽然这种是新旧节点都认可的，但这是没有用的，因为这条链上它们认为有非法的区块。所以这种分叉是永久性的，只要旧节点不更新软件，分叉就不会消失，所以才叫它硬结点。</p><p>比特币社区当中有些人是比较保守的，提高block size limit有些人就是不同意。而且区块的大小也不是越大越好，比特币底层系统是个P2P overlay network，它的传播主要采用flooding的方式，所以对带宽的消耗是很大的，带宽是瓶颈。</p><p>那么旧节点挖出的小的区块还有没有出块奖励呢？出现hard fork后出现了两条平行运行的链，平行运行链彼此之间有各自的加密货币。下面链的出块奖励在下面链里是认的。而分叉之前的币按道理应该是上下两条链都认可，所以会拆成两部分。<br>2020-02-07 15:24<br>回复</p><p>苦艾酒_bitter<br>第十节课程   第三部分</p><p>曾经出现过这样的问题:分叉前有A→B的交易，分叉后在上面链出现了B→C，下面链也出现了B→C，因为账户，私钥都是一样的。既然如此，就会有人利用这个特性，想收到上下两条链的转账。但如果没有人转账给他怎么办？</p><p>可以这样做:比如说B去购物，花一笔钱，给了C。后来B要退货，要取消这笔交易，C又把钱交给B。然后B又在下面一条链进行回放，就赚了一笔钱。那么在开始B转给C的交易在下面链会不会回放呢？所以这样做也是有风险的。为了解决这个问题，就让这两条链各带一个chain ID，所以现在以太坊的分叉已经没有问题了，就是两条独立运行的链了。</p><p>soft fork:<br>软分叉出现的情况是什么?如果对比特币协议加一些限制，加入限制之后原来合法的交易或区块在新的协议当中有可能变的不是合法了，这就引起软分叉。</p><p>假设有人发布一个软件更新，把这个区块大小变小了。调整区块大小不止是改变一个参数那么简单。一个去中心化的系统，改变一个参数，就可能导致分叉，而且取决于这个参数是怎么改的。有可能是硬分叉，有可能是软分叉。这里把区块大小变小只是为了解释软分叉这个概念，实际中是不会这么做的。</p><p>假设新节点把区块大小改为0.5M，旧节点依然以1M为准，这时候会出现什么情况？假如一个区块链开始分叉，新节点挖出小区块，这种区块旧节点也是认的。而旧节点挖出的大区块新节点是不认的。这样下去，旧节点看到上面链更长，而且是合法的之后，就会转去挖上面链。</p><p>所以为什么称这种分叉是软分叉?因为这种分叉是临时性的。所以旧节点如果不更新软件，它们挖的区块可能就白挖了。旧节点转向上面链挖的话，问题可能又会出现:它们可能又挖出了大区块。而新节点不认这个，新节点会继续沿着大区块前面一个小区块挖，如图(第29分第25秒)所示。</p><p>实际中可能出现软分叉的情况:给某些目前协议中没有规定的域增加一些新的含义，赋予它们一些新的规则，典型的例子就是coinbase域。前面讲过每一个发布的区块里可以有一个铸币交易(coinbase transaction)，coinbase transaction里有一个域叫coinbase域，这个域用来干什么是没人规定也没人检查的。<br>2020-02-07 15:25<br>回复</p><p>苦艾酒_bitter<br>第十节课程   第四部分</p><p>前面讲过coinbase域的一个用途:可以把它作为extra nonce。挖矿的时候要不断调整block header里的nonce，但block header里的nonce只有四个字节，最多只有2的32次方个可能性，所以实际中可以把coinbase前八个字节用来做extra nonce。两个合在一起就成了2的96次方，对于目前的挖矿难度，这个域已经是足够了。但coinbase域不止是八个字节，后面还有很多，剩下的字节有人就提议做UTXO集合的根哈希值。</p><p>目前这个集合只是每个全节点自己在内存中维护的，主要是为了快速查找、判断该交易是不是属于double spending，但这个集合的内容并没有写到区块链里，这跟前面讲到的merkle proof是不太一样的。</p><p>merkle proof能证明什么？证明某个交易是不是在给定的区块里。比如一个轻节点，没有维护整个区块的内容，只知道block header。轻节点问一个全节点:该交易是不是在这个区块里?全节点返回一个merkle proof作为证明，轻节点就可以验证是否属实。但如果是另外一种情况，想要证明某个账户上有多少钱，这个目前在比特币系统中是证不出来的。如果是全节点还可以算一下，方法如下:想要知道A账户有多少钱，就看一下A在UTXO里对应的输出总共收到多少个币，就是该账户上有多少钱。</p><p>对于全节点是可以算出来的，但如果是区块链钱包、有的手机上的APP，它不可能在手机上维护一个完整的区块链，它实际上是个轻节点，它想要知道账户的余额需要询问全节点。全节点返回一个结果，怎么知道这个结果是否属实呢？现在是证不出来的。如果你自己不维护一个UTXO集合，就没法用merkle proof 证出来。</p><p>有人提议把UTXO集合当中的内容也组织成一颗merkle tree，这个merkle tree有一个根哈希值，根哈希值写在coinbase域里面。因为block header没法再改了，改block header动静就太大了，coinbase域正好是没人用的，所以就写入UTXO的根哈希值。coinbase域当中的内容最终往上传递的时候会传递到block header里的根哈希值里。所以改coinbase域的内容，根哈希值会跟着改。<br>2020-02-07 15:28<br>回复</p><p>苦艾酒_bitter<br>第十节课程   第五部分</p><p>因此这个提案就是说把UTXO集合的内容组织成merkle tree，算出一个根哈希值来，写入coinbase域里某个位置。coinbase域的内容本身也会算哈希，算到block header里的根哈希值，这样就可以用merkle proof证出来了。</p><p>假设有人发布一个软件更新，规定coinbase域要按照这个要求来填写，大多数节点都升级了软件，少数节点没有更新，这属于软分叉，因为新节点发布的区块旧节点认为是合法的，因为旧节点不管新节点写什么内容。但旧节点发布的区块新节点可能是不认的，因为如果coinbase域不按要求写它是不认的，所以属于软分叉。</p><p>比特币历史上比较著名的软分叉的例子是pay to script hash。P2SH这个功能在最初的比特币版本里是没有的，它是后来通过软分叉的功能给加进去的。这是什么意思呢?你支付的时候不是付给一个public key的哈希，而是付给一个赎回脚本的哈希。花钱的时候要把这个交易的输入脚本跟前面币的来源的交易的输出脚本拼接在一起执行。执行的时候验证分为两步，第一步是要验证输入脚本中给出的redeem script跟前面那个输出脚本给出的script的哈希值是对的上的，证明输入脚本里提供的script是正确的。第二步再执行redeem script，来验证输入脚本里给出的签名是合法的。</p><p>对于旧节点来说，它不知道P2SH的特性，只会做第一阶段的验证，即验证redeem script是否正确。新节点才会做第二阶段的验证，所以旧节点认为合法的交易新节点可能认为是非法的(如果第二阶段的验证通不过的话)。而新节点认为合法的交易旧节点肯定认为是合法的，因为旧节点只验证第一阶段。</p><p>总结:soft fork是什么?只要系统中拥有半数以上算力的节点更新了软件，那么系统就不会出现永久性的分叉，只可能有一些临时性的分叉。hard fork特点是什么？必须是所有的节点都要更新软件，系统才不会出现永久性的分叉，如果有小部分节点不愿意更新，那么系统就会分成两条链。</p><h2 id="P11-11-BTC-问答"><a href="#P11-11-BTC-问答" class="headerlink" title="P11. 11-BTC-问答"></a>P11. 11-BTC-问答</h2><h2 id="P12-12-BTC-匿名性"><a href="#P12-12-BTC-匿名性" class="headerlink" title="P12. 12-BTC-匿名性"></a>P12. 12-BTC-匿名性</h2><h2 id="P13-13-BTC-思考"><a href="#P13-13-BTC-思考" class="headerlink" title="P13. 13-BTC-思考"></a>P13. 13-BTC-思考</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="blockchain" scheme="https://zronghui.github.io/categories/blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>blockchain-03</title>
    <link href="https://zronghui.github.io/blockchain/blockchain-03.html"/>
    <id>https://zronghui.github.io/blockchain/blockchain-03.html</id>
    <published>2020-04-30T02:41:30.000Z</published>
    <updated>2020-05-01T11:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://www.bilibili.com/video/av37065233">北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><a id="more"></a><h2 id="P2-02-BTC-密码学原理"><a href="#P2-02-BTC-密码学原理" class="headerlink" title="P2. 02-BTC-密码学原理"></a>P2. 02-BTC-密码学原理</h2><p>比特币被称为加密货币crypto-currency<br>区块链上内容都是公开的，包括区块的地址，转账的金额。</p><p><strong>比特币主要用到了密码学中的两个功能:1.哈希2.签名</strong></p><h3 id="哈希的性质"><a href="#哈希的性质" class="headerlink" title="哈希的性质"></a>哈希的性质</h3><p>1.密码学中用到的哈希函数被称为cryptographic hash function:    它有<strong>两个重要的性质</strong>:<br>①<strong>collision(这里指哈希碰撞) resistance</strong>  :例如x≠y H(x)=H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解(brute-force)。<br>该性质的作用:对一个message求digest<br>比如message取m m的哈希值是H(m)=digest 如果有人想篡改m值而H(m)不变，则无法做到。<br>哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。<br>②<strong>hiding</strong> 哈希函数的计算过程是单向的，不可逆的。(从H(x)无法推导出x) </p><p>hiding性质前提是输入空间足够大，分布比较均匀。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。<br>该性质的作用:和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)<br>把预测结果作为输入x，算出一个哈希值，讲哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。</p><p>除了密码学中要求的这两个性质外，比特币中用到的哈希函数还有第三个性质:<br>③<strong>puzzle friendly</strong> 指哈希值的预算事先是不可预测的。假如哈希值是00…0XX…X，一样事先无法知道哪个值更容易算出这个结果，还是要一个一个带入。</p><p>比特币挖矿的过程中实际就是找一个nonce，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。</p><p><strong>puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。</strong><br>挖矿很难，验证很容易。(difficult to solve ,but easy to verify)</p><p>比特币中用的哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>2.<br>在比特币系统中开账户:<br>在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。</p><p>两人之间信息的交流可以利用密钥(encryption key)，A将信息加密后发给B，B收到后用密钥解密，因为加密和解密用的是同一个密钥，所以叫对称加密。前提是有渠道可以安全地把密钥分发给通讯的双方。因此<strong>对称加密的缺点就是密钥的分发不方便</strong>，因为在网络上很容易被窃听。非对称密钥是用一对密钥而不是一个，<strong>加密用公钥，解密用私钥</strong>，<strong>加密和解密用的都是接收方的公钥和私钥</strong>。公钥是不用保密的，私钥要保密但是私钥只要保存在本地就行，不用传给对方。公钥相当于银行账号，别人转账只要知道公钥就行，私钥相当于账户密码，知道私钥可以把账户上钱转走。<strong>公钥和私钥是用来签名</strong>。</p><p>假如A想向B转10个比特币，A把交易放在区块链上，别人怎么知道这笔交易是A发起的呢?这就需要A要用自己的私钥给交易签名，其他人收到这笔交易后，要用A的公钥去验证签名。<strong>签名用私钥，验证用公钥</strong>，用的仍然是同一个人的。创建账户产生相同公私钥的可能性微乎其微，所以大量创建账户来窃取其他人账户是不可行的。</p><p>我们假设产生公私钥时有一个好的随机源(a good source of randomness)，产生公私钥是随机的，如果随机源不好，就有可能产生相同的公私钥。比特币中用的签名算法，不仅是生成公私钥的时候要有好的随机源，之后每一次签名时也要有好的随机源。只要有一次签名用的随机源不好的话，就有可能泄露私钥。</p><h2 id="P3-03-BTC-数据结构"><a href="#P3-03-BTC-数据结构" class="headerlink" title="P3. 03-BTC-数据结构"></a>P3. 03-BTC-数据结构</h2><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>普通指针存储的是某个结构体在内存中的地址。假如P是指向一结构体的指针，那么P里面存放的就是该结构体在内存中的起始位置。而<strong>哈希指针除了要存地址之外，还要保存该结构体的哈希值H()</strong>。好处是:从哈希值这个哈希指针，不仅可以找到该结构体的位置，同时还能够检测出该结构体的内容有没有被篡改，因为我们保存了它的哈希值。</p><p>比特币中最基本的结构就是区块链，区块链就是一个一个区块组成的链表。区块链和普通的链表相比有什么区别:<br>①用哈希指针代替了普通指针(B block chain is a linked list using hash pointers)</p><p>区块链第一个区块叫作创世纪块(genesis block) 最后一个区块 是最近产生的区块(most recent block) 每一个区块都包含指向前一个区块的哈希指针<br><strong>一个区块的哈希指针</strong>怎么算:是<strong>把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值</strong>。通过这种结构，可以实现tamper-evident log。如果有人改变了一个区块的内容，后面一个区块的哈希指针就对不上，因为后一个区块哈希指针是根据前一个区块的内容算出来的，所以后一个哈希指针也得改，以此类推，我们保留的是最后一个哈希值也会变化。</p><p>②普通链表可以改变任意一个元素，对链表中其他元素是没有影响的。而区块链是牵一发而动全身，因为只需要保存最后一个哈希值，就可以判断区块链有没有改变，在哪里改变了。<br>因此<strong>比特币没有必要保存所有区块的内容，可以只保留最近的几千个区块</strong>。如果要用到以前的区块，可以向系统中其他节点要这个区块。有些节点是有恶意的，怎么判断?这里要用到哈希值一个性质，如下:<br>其他节点给你一个区块，如何判断它是正确的?算出它的哈希值，与保留的区块的哈希值对比，即可。</p><p><img src="https://i.loli.net/2020/04/30/NleqyYaMCPGwkQi.png" alt="NleqyYaMCPGwkQi"></p><h3 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h3><p><img src="https://i.loli.net/2020/04/30/N7cPSxBIbafMOer.png" alt="N7cPSxBIbafMOer"></p><p>比特币中的另外一个结构是:Merkle tree。(其中最下面一层是数据块(data blocks)，上面三层内部节点都是哈希指针(hash pointers)，第一层是根节点，根节点的区块也可以取个哈希，叫根哈希(root hash))<br>另外一个概念:binary tree。</p><p>这种结构的好处:<strong>只要记住根哈希值，就能检测出对树中任何部位的修改</strong>。<br>它们的区别:①用哈希指针代替了普通指针。</p><p>比特币当中各区块之间用哈希指针连接在一起，每个区块所包含的交易组织成一个merkle tree的形式，最下面一行data blocks每个区块实际上是一个交易，每个区块分为两部分，分别是块头和块身(block header ,block body)。块头里面有根哈希值，每个区块所包含的所有交易组成的merkle tree的根哈希值存在于区块的块头里面，但是，块头里没有交易的具体内容，只有一个根哈希值，块身里面是有交易的列表的。</p><p>merkle tree 的作用:</p><p>①提供merkle proof<br>比特币中的节点分为两类:全节点(保存整个区块的内容，即块头块身都有，有交易的具体信息)和轻节点(例如手机上的比特币钱包)(只有块头)</p><p>这时存在一个问题:<strong>如何向一个轻节点证明某个交易是写入区块链</strong>的?<br>这时需要用到merkle proof :找到交易所在的位置(最底行的其中一个区块)，这时该区块一直往上到根节点的路径就叫merkle proof。</p><p><img src="https://i.loli.net/2020/04/30/3ZtyJeNPQXLDgOm.png" alt="3ZtyJeNPQXLDgOm"></p><p>最上面一行是小型的区块链，该图展现的是一个区块的merkle tree，最下面一行是包含的交易。假设某个轻节点想知道图中黄色的交易，是否包含在了merkle tree里面。该轻节点没有包含交易列表，没有这颗merkle tree的具体内容，只有一个根哈希值。这时轻节点向一个全节点发出请求，请求证明黄色的交易被包含在这颗merkle tree里面的merkle proof。全节点收到这个请求之后，只需要将图中标为红色的这三个哈希值发给轻节点即可。有了这些哈希值之后，轻节点可以在本地计算出图中标为绿色三个哈希值。首先算出黄色交易的哈希值，即它正上方的那个绿的哈希值，然后跟旁边红色的哈希值拼接起来，可以算出上层节点绿色的哈希值。然后再拼接，再算出上层绿色哈希值，再拼接，就可以算出整棵树的根哈希值。轻节点把这个根哈希值和block header里的根哈希值比较一下，就能知道黄色的交易是否在这颗merkle tree里。</p><p>全节点在merkle proof里提供的这几个哈希值，就是从黄色的交易所在的节点的位置到树根的路径上用到的这些哈希值。轻节点收到这样一个merkle proof之后，只要从下往上验证，沿途的哈希值都是正确的即可。(验证时只能验证该路径的哈希值，其他路径是验证不了的，即该图中红色的哈希值是验证不了的)</p><p>这样是否不安全呢?假如黄色交易被篡改，它的哈希值发生了变化，那能不能调整旁边红色的哈希值，使得它们拼接起来的哈希值是不变的呢?不行，根据collision resistance，这是不可行的。</p><p>merkle proof可以证明merkle tree里面包含了某个交易，所以这种证明又叫proof of membership或 proof of inclusion。<br>对于一个轻节点来说，<strong>验证一个merkle proof 复杂度</strong>是多少?假设最底层有n个交易，则merkle proof 复杂程度是<strong>θ(log(n))</strong></p><p><strong>如何证明merkle tree里面没有包含某个交易</strong>?即proof of non-membership。可以把整棵树传给轻节点，轻节点收到后验证树的构造都是对的，每一层用到的哈希值都是正确的，说明树里只有这些叶节点，要找的交易不在里面，就证明了proof of non-membership。问题在于，它的复杂度是线性的θ(n)，是比较笨的方法。</p><p>如果对叶节点的排列顺序做一些要求，比如<strong>按照交易的哈希值排序</strong>。每一个叶节点都是一次交易，对交易的内容取一次哈希，按照哈希值从小到大排列。要查的交易先算出一个哈希值，看看如果它在里面该是哪个位置。比如说在第三个第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。<strong>比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明</strong>。</p><p>这节讲了比特币中两种最基本的结构:区块链和merkle tree，都是用哈希指针来构造的。除了这两种之外，哈希指针还能用另一个方面。</p><p>只要一个数据结构是无环的(非循环链表)，都能用哈希指针代替普通指针。有环的话存在一个问题，他们的哈希值没法计算</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av37065233&quot;&gt;北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="blockchain" scheme="https://zronghui.github.io/categories/blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-04-28</title>
    <link href="https://zronghui.github.io/private/2020/04/2020-04-28.html"/>
    <id>https://zronghui.github.io/private/2020/04/2020-04-28.html</id>
    <published>2020-04-27T14:35:35.000Z</published>
    <updated>2020-05-05T01:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5ce8f69c5a7facaf2a3ab9e4450b6a7362f5862b98bc8759091daec3f4311599">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dec0bab702e62ec40be4bd40d33dd8011ba51f8d43c98b9d5bc1629306176c05577d8355c1beaf3cd461fc88eb2faf0341dcf59de272fed2aba653dff2fe249ba70a664e958658d9c25bad99b53b312a4784912b3d4d824b393d3a9bf39c7fdbd9a91353baa205adaf325e03ecaed45d28078a69f9cf2ccacd2f2aa11e354b3559c4ac979673b198b7b92de870cc798d808bc2baaf32ef42c4f4b04b743fa6613d524a3eb63642c92dc881d7484bf501849da260d78b35a97bd4f01df208b423e66b6cc5c20122a10e7d2f50b4a8521792c77f9e5daf58bf40859309482a95c772f70caf3a4d7098f22e8c4189ee4f861e2d2c5078cd4e37b9f8590da2fc0c3839315554091cdffeec1fa19d9869bbc950d3eb086250d304d7d4ef19f9360125743bfe07f71de1e4587911f9c65e0cd503b4cfe671d3536ce1986a83e6e35b4a7ace7bbc313c42d939a17eea672a64bb692c74a87886fe8cafa60711b626da7c8b743c3917f966b391ef66df4e77bc4e4a53f9b76c8f86ba92c239607a69f7ee075a308fb7097f68be1114b8397ebd154c7e80949457ef1697a14869cb1c27dd98ae65f609c753f9852b56784270784382dad13d28cedf0ce78500de829fa5ca97df505924994c9e98ab448f9483f0507b42a3d9124bdd75c476dd6d73abb4e0b0ed8eb9484c015ddb4b12d619882b8d80ba40254d3f0dc4f5bfb4c91ef34c54bcc06373223aa16f549e1fdbaf5e86220b8d75bebc9b3132647c7d733f11c31b6b43304850b3e7c25df4127a8d426129aec3b902d553cac9f1d481339a882b76b75e051135267aef183e359d9b0590251170cc5692b00d274e043f0504864472bfdb260ef646530a4da019a78af00d45b732ee79e991ff56c78baa06c1d2be4edaf900c54c648516716aebb202b80a1b931d9e449fa134aafdf882d4c70e24c50a0d90ae00ce950ead1d57b3ee330fe4465d1f9996d6a66341649c481f9e861ab767f4b8b3e53140ce137d419a64641a0bc38c6f959163457fdfa715bf00265210cac86a3ea3cbc82f7d2347eefde0974704a78e4a2523976b0eada09727c6ab56ec7a246378b8c5fc672841ea11e500892162af396111436d91246f4475683967597fa9e9aab596b0d6e080fbfda64564c33b637879cbe71daa55cbe6a411a702fa487ed4e975f34228a742762dc6e4929cf63dbb45cf429bb8c9e1cac5e3967d4125da9804458c624374407292875acbfe3cded2012f4f734950ec58eb5e9102eb4d0eb64d8517156351af7dce2c0a2040b161df326fdc5745c70912f363021c7166df95bcc53f9e3be237a457915b99e7ad1e3dcbf389dbdd804ae53d90edab5d8a8111c66bdb5dacc4cdb66c9f09cc7012697b6abbbf9bd55647ff54798fb181fdae81b76b81870eed0e49d19000258cb5c9880ea6bcc526c079e72514cc2cd63c17e2d0ba0eea675d6ae0956930ab5a720662d9d3260abfdfb79daf32aad9a39e98669d32962e5a5fe90f9fce003e497993e7523560e95af352eafc6ce023d7156c239e15f25866388f6f0908c0b854805c7fea276029513bd1a4b985bd76a14145c47c1df48fdb4dfc04c44225d0c97be695d53199d23fa057b5c5f08f2f91f3d6875a118972d4b887d214afff3bafc0f7c820e6873025b495696adf0a808505ec670ea2b9d0d6fad8858bb08fb4c76e5b9e3e9f57e10f6d07a1aa541981528947fc28a565384ea30c3e9b591bf34a5bb9771d3c033ee9442ba7412c85dba1582f382acf08a850d8e85ff8b578e84dc5d12cf6ec6f4c02911ec295d247af97ec8293b13f6c823556d0221fbf59e37eda8d18a3b83ba57cb34408c116152698e4d803f34f6f86ab8f8104e1cefc8a4c2b3981851e74593bc1197c13e223e63715b80146740e4872ea8b765ce319a527e2768e765000952f2b51a4b038520e2b35e9ea311c375959433a41c7037be4a4fb56174cd984682e74bbfc6cc7ff92f554ff61a88677ae84add037f4e3ecf66a7b1a9acd3e89c162c2d2386b41fd68008e4f665587d3011313d237f7575e02a16f7098e63f06944b446963787f7c89b3b1368ca4150671bd9ce6c95b87500b12a6e83ae0af7547289287dc48a7f0ed4cf430689c28a8fa063e020a0501a8f0969613c67914473830fdd5c46a07ab36bb2564869b0a99b7fbdc42788a58742b2906e6932e85f3e92d10995849d124763462a2af1f6a0204474d1dcf637ab0ff7ddafbd00820bf405d101ec997af0d5d878f03823af1712c39f4f00d23c2c8b527f0dbced8bce7ab480a2d579e500ca3cdc5bdb2157e94a06d39037ab4a6c00</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://zronghui.github.io/categories/private/"/>
    
      <category term="2020" scheme="https://zronghui.github.io/categories/private/2020/"/>
    
      <category term="4" scheme="https://zronghui.github.io/categories/private/2020/4/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-185</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-185.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-185.html</id>
    <published>2020-04-27T07:16:00.000Z</published>
    <updated>2020-04-27T14:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformat</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        ss = []</span><br><span class="line">        nn = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span>&lt;=i&lt;=<span class="string">'9'</span>:</span><br><span class="line">                nn.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(i)</span><br><span class="line">        <span class="keyword">if</span> abs(len(ss)-len(nn))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">if</span> len(ss) &lt; len(nn):</span><br><span class="line">            ss, nn = nn, ss</span><br><span class="line">        <span class="keyword">while</span> nn:</span><br><span class="line">            s.append(ss.pop())</span><br><span class="line">            s.append(nn.pop())</span><br><span class="line">        <span class="keyword">if</span> ss:</span><br><span class="line">            s.append(ss[<span class="number">0</span>]) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">displayTable</span><span class="params">(self, orders: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 所有的菜，最后用来排序</span></span><br><span class="line">        foodl = []</span><br><span class="line">        <span class="comment"># &#123;table:&#123;food: n, ...&#125;&#125;</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, table, food <span class="keyword">in</span> orders:</span><br><span class="line">            <span class="keyword">if</span> food <span class="keyword">not</span> <span class="keyword">in</span> foodl:</span><br><span class="line">                foodl.append(food)</span><br><span class="line">            <span class="keyword">if</span> table <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[table] = &#123;food: <span class="number">1</span>&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[table][food] = d[table].get(food, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        foodl.sort()</span><br><span class="line">        </span><br><span class="line">        head = [<span class="string">"Table"</span>]</span><br><span class="line">        head.extend(foodl)</span><br><span class="line">        res.append(head)</span><br><span class="line">        </span><br><span class="line">        t = []</span><br><span class="line">        <span class="keyword">for</span> table <span class="keyword">in</span> sorted(d.keys(), key=<span class="keyword">lambda</span> i: int(i)):</span><br><span class="line">            t.append(str(table))</span><br><span class="line">            <span class="keyword">for</span> food <span class="keyword">in</span> foodl:</span><br><span class="line">                t.append(str(d[table].get(food, <span class="number">0</span>)))</span><br><span class="line">            res.append(t)</span><br><span class="line">            t = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>我的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        d1 = &#123;</span><br><span class="line">            <span class="string">'r'</span>: <span class="string">'c'</span>, </span><br><span class="line">            <span class="string">'o'</span>: <span class="string">'cr'</span>, </span><br><span class="line">            <span class="string">'a'</span>: <span class="string">'cro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        d2 = &#123;</span><br><span class="line">            <span class="string">'c'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'cr'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'cro'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'croa'</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 最多的青蛙</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前的青蛙数</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            key = d1.get(i, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'c'</span>:</span><br><span class="line">                d2[i] += <span class="number">1</span></span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'k'</span>:</span><br><span class="line">                <span class="keyword">if</span> d2[<span class="string">'croa'</span>]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d2[<span class="string">'croa'</span>] -= <span class="number">1</span></span><br><span class="line">                    n -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> d2[key]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                d2[key] -= <span class="number">1</span></span><br><span class="line">                d2[key+i] += <span class="number">1</span></span><br><span class="line">            m = max(m, n)</span><br><span class="line">            <span class="comment">#print(m, n)</span></span><br><span class="line">        <span class="keyword">return</span> m <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>其他人的解法：</p><p><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/ji-lu-dang-qian-qing-wa-ge-shu-de-zui-da-zhi-by-qi/">记录当前青蛙个数的最大值 - 数青蛙 - 力扣（LeetCode）</a></p><p>c,r,o,a,k分别表示遍历到当前位置时这几个字母出现的次数。<br>每次遍历过程中当且仅当c&gt;=r&gt;=o&gt;=a&gt;=k时才符合要求。<br>now表示当前存在的青蛙个数，即遇到c时加一，叫完以后(遇到k)减一。<br>遍历完后now应为0表示每次叫声都有头有尾，记录now的最大值即为答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        c=r=o=a=k=<span class="number">0</span></span><br><span class="line">        now=<span class="number">0</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'c'</span>:</span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">                now+=<span class="number">1</span></span><br><span class="line">                res=max(res,now)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'r'</span>:</span><br><span class="line">                r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'o'</span>:</span><br><span class="line">                o+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'a'</span>:</span><br><span class="line">                a+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'k'</span>:</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">                now-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c&gt;=r&gt;=o&gt;=a&gt;=k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> now==<span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>可以改进↓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        c=r=o=a=k=<span class="number">0</span></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">'c'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'r'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'o'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'a'</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">'k'</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        now=<span class="number">0</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            d[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'c'</span>:</span><br><span class="line">                now+=<span class="number">1</span></span><br><span class="line">                res=max(res,now)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">'k'</span>:</span><br><span class="line">                now-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d[<span class="string">'c'</span>]&gt;=d[<span class="string">'r'</span>]&gt;=d[<span class="string">'o'</span>]&gt;=d[<span class="string">'a'</span>]&gt;=d[<span class="string">'k'</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> now==<span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution/jian-dan-san-wei-dong-tai-gui-hua-by-coldme-2/">超简单的（？）三维动态规划 - 生成数组 - 力扣（LeetCode）</a></p><p>学不来学不来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>weekly-contest-186</title>
    <link href="https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-186.html"/>
    <id>https://zronghui.github.io/Leetcode%20weekly%20contest/weekly-contest-186.html</id>
    <published>2020-04-27T01:26:01.000Z</published>
    <updated>2020-04-27T14:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/">分割字符串的最大得分</a><strong>3</strong></li><li><input checked="" disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a><strong>4</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/">对角线遍历 II</a><strong>5</strong></li><li><input disabled="" type="checkbox"> <a href="https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subset-sum/">带限制的子序列和</a><strong>6</strong></li></ul><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1 的总个数</span></span><br><span class="line">        n1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">'1'</span>:</span><br><span class="line">                n1 += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最大值</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前 0 的个数</span></span><br><span class="line">        n0 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">'0'</span>:</span><br><span class="line">                n0 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n1 -= <span class="number">1</span></span><br><span class="line">            m = max(n0+n1, m)</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 问题简化：nums 两边共 k 个数总共最大和是多少</span></span><br><span class="line">        m = sum(nums[:k])</span><br><span class="line">        n = len(nums)</span><br><span class="line">        lastsum = m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(k)):</span><br><span class="line">            j = k-i</span><br><span class="line">            <span class="comment"># print('j', j, nums[n-j])</span></span><br><span class="line">            <span class="comment"># print('i', i, nums[i])</span></span><br><span class="line">            lastsum = lastsum-nums[i]+nums[n-j]</span><br><span class="line">            m = max(m, lastsum)</span><br><span class="line">            print(m)</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/solution/mei-ge-shu-zu-yuan-su-de-wei-zhi-jue-ding-liao-ta-/">每个数组元素的位置决定了它在最后结果的位置 - 对角线遍历 II - 力扣（LeetCode）</a></p><p>优先从机器角度考虑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 便于机器内存切换</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, nums: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 总共对角线数量</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            m = max(m, i+len(nums[i]))</span><br><span class="line">        res = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums[i])):</span><br><span class="line">                res[i+j].append(nums[i][j])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            result.extend(i[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 超时：便于人类思考</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder1</span><span class="params">(self, nums: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 总共对角线数量</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        length_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            length_map[i] = len(nums[i])</span><br><span class="line">            m = max(m, i+length_map[i])</span><br><span class="line">        <span class="comment"># 第 j 条对角线</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="comment"># 第 i 个数字</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>):</span><br><span class="line">                _j = j-i</span><br><span class="line">                <span class="keyword">if</span> _j&gt;=n <span class="keyword">or</span> i&gt;=length_map[_j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res.append(nums[_j][i])</span><br><span class="line">                <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p><a href="https://leetcode-cn.com/problems/constrained-subset-sum/solution/dpdan-diao-zhan-you-hua-xiang-jie-by-wangdh15/">DP+单调栈优化 详解 - 带限制的子序列和 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constrainedSubsetSum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1. 定义状态dp[i]为以i结尾的的最大子序和，那么当考虑第i+1个的时候，由于向量两个小标差距不大于k且非空，所以有以下状态转移方程</span></span><br><span class="line">        <span class="comment"># for j in range(k):</span></span><br><span class="line">        <span class="comment">#    dp[i+1] = max(dp[i+1], nums[i+1]+dp[i+1-j], nums[i+1])</span></span><br><span class="line">        <span class="comment"># 2. 优化：维护前 k 个 dp 的最大值</span></span><br><span class="line">        <span class="comment"># https://leetcode-cn.com/problems/sliding-window-maximum/</span></span><br><span class="line">        <span class="comment"># dp[i+1] = max( max(dp[i+1-j] for j in range(k)), 0 )+nums[i+1]</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        res = dp[<span class="number">0</span>]</span><br><span class="line">        s = [(dp[<span class="number">0</span>], <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i] = max(nums[i], nums[i]+s[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[<span class="number">-1</span>][<span class="number">0</span>]&lt;=dp[i]:</span><br><span class="line">                s.pop()</span><br><span class="line">            s.append((dp[i], i))</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>][<span class="number">1</span>]&lt;=i-k:</span><br><span class="line">                s.pop(<span class="number">0</span>)</span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-score-after-splitting-a-string/&quot;&gt;分割字符串的最大得分&lt;/a&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-186/problems/maximum-points-you-can-obtain-from-cards/&quot;&gt;可获得的最大点数&lt;/a&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-186/problems/diagonal-traverse-ii/&quot;&gt;对角线遍历 II&lt;/a&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-186/problems/constrained-subset-sum/&quot;&gt;带限制的子序列和&lt;/a&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode weekly contest" scheme="https://zronghui.github.io/categories/Leetcode-weekly-contest/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-04-27</title>
    <link href="https://zronghui.github.io/private/2020/04/2020-04-27.html"/>
    <id>https://zronghui.github.io/private/2020/04/2020-04-27.html</id>
    <published>2020-04-26T13:11:45.000Z</published>
    <updated>2020-04-27T14:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3ae3e45ff69686aa2d7a5d80b3da7033ab8cc8c87fb2f2a93059dea0987609fd">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879dec0bab702e62ec40be4bd40d33dd8011ba51f8d43c98b9d5bc1629306176c05577d8355c1beaf3cd461fc88eb2faf0341dcf59de272fed2aba653dff2fe249ba70a664e958658d9c25bad99b53b312a4784912b3d4d824b393d3a9bf39c7fdbd9a91353baa205adaf325e03ecaed45d28078a69f9cf2ccacd2f2aa11e354b3559c4ac979673b198b7b92de870cc798d808bc2baaf32ef42c4f4b04b743fa6613d524a3eb63642c92dc881d7484bf501849da260d78b35a97bd4f01df208b423e66b6cc5c20122a10e7d2f50b4a85217932c5af0ed34d2756766311258d19f0b0af3245a5f26b60bca23e36f84f048ddb7ee5c038551bad76c9363a50468dff08154e61383bde85a6a10cd57a2ab38a1902e48eb0135ead3e20a583bb430549950305163b4c2504373d99192233403b6bb073f51ca5c990a8ff2ffdf74a7f24e5aa84c9918a6c2a4f5e95c389b5d9d3161afd00bb46e9d9740cece104e6b70b9bcc579ee425531663e49a70abeda8721547ac32c970af9a68cf6dfcac07d35e1ab15a64ee9be3ae6a9f8b4a0bab5f10f258e89ef9eb87c688d05df77c49cd06ab261399fbc18c0adfad35f97db46185ba6e6fa0fa2190f0283217de46878485f6dbda4b9487fee05b2bec9387f2719b1ba74401c9cafc2ed31b9c4fdafaa938d5a5434e6b36d05b92bba1c3d6e36eaafa3e9e883937e3f4af86120241c186c7586628e690621a970dd698a1d213f962d843455c040c68c72a5fa93710175223219ee6a39c703d883448d3018e69294cfcf21edd49e69ff39d6e07431a574ca9266b561ef1b834b386d5b71adfc553b159f460067bcf073df722201dabe1ee2ff08f45a41c25d7dfc0f36260556801e9971173d7c160e061359c9c0985cff84917cfe615cff07c3d23b83f77b8c49f40147855ad1489f8146bd84a9795fce9a488bd38546ed59462bb1b5efc368896867378515ccafe787482fe1ef5565568adc4e05eb927fd2c5b6a9b6db2b8ca65c7d4f634b06c148cd3b34e01822637b5c0b86d869f95bf94f5a5eaeff1d117daaaaf034f088279300230744d22f02c7bfe0dd4fb3d941d5e88ec5cf2a6121a7fa1d8a9c74197025f3f2d3f1afbd444a403223a104785289d8c8dc6c1945a417ff27789a254437c909ffb336fe86a1f5cf547e7eea9bbd62abd5177c674775963f50f597fb9242161b501a459632e4c615f84201917a7d72f38f950852aad1f8a4f2a74fa79f454f0c889845cd53e00213de935b5adc966fe965de5e2575f17c744728004a8d665c9159f13c94c17ce5cd59715ff93cf7fb35c9f2df625c75eccdae3343b904ea2d33947a84ea7075001a5d9ab07d84d34288257d1e670ffb535a92923465c053482d268cbac7ec06edd1fa566ad1206b92033297de3df26a9d428c11d6ee991d75ade94d09507c496970bba5be6d2425b6b9b4f559f930fe86b8fc896901bbe75183fddb55144466009edb4d181dc8ced8ed2a5d5af078caa1e0013cee8054ebdc07260d876a4bc77cf34d6677d632df8474757da606b6ec30f3bc2c2bcfed8a7b16add9b5c4ad4aaa1bd653a3b84115927e71e533a3a4cde77bf867da0a120c99b9e25816b1215d3859c0a567bb7b87567de9f84e6d389c2ec46ef7aa370590d5802f60a62b029e7a0062a18de66bd7ccc15eb47835af70b5b20da7d9bf9d91c5a860cd4b40484112878938b91a44f6e5d9e2782308c7d83a96dab37e2bb08f3b56c6eef80792ab4dd7757c52618250b65029f3f69d0ed96d5329708f835948d541f6476a07ec0a554c765cc6e1e1acdf9530b917067bc2dd71d6c7022475bd38c3b4e6a7ba6286683a6280ccbd2fcb4de83670c9db8771ea6c7f21d648149b6a8c3cd433bf0c2d2ce46596c03e36a1f036a9ec5c6899f26f0da41bc5be67dba65ca1ccd959de0442d7e493dd65610659f3bfe9e46c0c596834d824d7ee68562c70c726455e8634b6472b78823407d07ac47134b7f94c655749ca62bf163ba1dedbac7046442ce4596e21123eef6ed8e77d2b165f7b0c7e2648e2dbd250c6b6f96d3fb1fb997ea9b8a6468052e3df55a2fa0bc62b8a63db7fa9f69afe15da029380b6eba3bb854f7274394ee3f77dcd35a46945d09e2dacc320dad3b1091d7f6f1e9b408009a56cf556668975b249aace4d5d0dcdbc1d401af4d0934772e044bb13daaf299d3e2d786005191fef35da0140657887ddc1527746ca872dc98caddd7bf383bf1898b94b27246c1d64a363f5e7f80a5871e6736fbb3aee06be51174332e7e6b5821aecb69c652d6eea8f3459953ac217808fdb0f175ce011bb1454c62252f03da9fb3d8437c667749b6fa67160066f58e13f6369285b5095e6d35ed5fd1f7997b010a0f5b5b72cfa787f5d5276153c5fe7fa492f7603960682990d851dacaf54f4ecd0af02d4baa9af3a137336092e3896a20049397dc49399bed6f2ffdfbe20ab7a2af575341d44cb4720e03468f9646393b289b54c65d52dfd38b183702486e5f909dbfb3924d04f364dfc6731477549fef9b36d032af8ab1e7a68f64a4572479197b16e6f3f3ffc0e32429ca3a786f1bde746f6cb527cc2a4c14e9ac4283325f45738857333303d5656524aae0673c0e5482198af85ab657253f19ba414b4905488bdbf71e2ac70465ca24cbcbce8c54a382d362a5f675e68004d80ded476d0602225c7bd85e0ab7bc9457aa5c228bc47a88cc07c8775265e62bc053bdbecc45a11ac7bcb8f7cbb898dc7270974eec1aaa5b17903cd81e691967b9126e8564e042bbe9af4fd98c81f7baaa3849c25363381ea3f643c1609ce563d625c4293b67f46f32a029fe7a3ebf865282712c6a64a8d55f43a35fec3f75510bd29ee0a886d9a724578f7bb3ab089561662ccf8e4cf008b631377f8b890674532132a3253b99611f11a89968ddba4f53bf5d8d7f6d8c8ba58ae87c0b8c8a2b9e32af9eeaa5732bc163bf472c105474510f5ec7ef22258afe582137aa94da5e0f8087cee3b69a2dae2fbf0da1095a2ccd2f0d5d638756bf7cbcc8623da73f66df852b5bdb129d255b85c0e631087e31b5eb319352b79f61b8eceae757db5e85745546cdd22ddab7df7b119ff0cb678678ca771a081314f07d671ef04913f13e08bc401eff2f0349bd28e91dc15ea28186a6a7113076c98724274d7b231410624d6628f8277d347fdca34f66fd07168915efca4987bf2511f4a5c07901cac1a2904a185bff2fccc18642a4af4c13f2d6be1560f574913f92dd1feb10f0200c50d15475323a609290918bfa27565e582ef3fbe0fd3a0fc9e3a97083e90767b7961e2455b51caaab5633e5c51de202e5f773b8e2bc849501e5c449380aa8304504dbd3c1f1c267c710b37bebe69941a91c942739a5fee024c431856c69028c373ccea5da165eac2946caa32c221bb54da3863de47cb156dbb6e15de1ad1e2f0df9c3bf1eb5cc070b87d232df8dc11b35b8dfc0e972d90f2073b2c52e223cebcecaa11a0caf297195061b49378f96c5156431b41d7d0db52333a9109c4f68a93b6519a8b47f08448e62f9449b2c88a04a45d4841cf6881e18e41d121d232c2d9ece6b44bc270dba5b084ff996b844dec1f06c900cb86afc773f4e5238ae3697c01321a3b202da2fa79f54a71645f09f6ea86bc9bac033498f8b0d18f5dde08e98dbc4feb298fdb79092e8528712eaeb675541b6beb333e9353653aa226771b6431767ce60962a854788be7bf3f945915353aaee856cd19dad4709f66d79de2b418d122691cf22b45ccc9e20bfb2c6ebf13cc43e73a3b3a33732baafde9e007c6fb74a76b64e1487bda23b828969a272e265152aafdd5c95b5fe6c16dab0e72190be786e59b88db60a2a19826332e353db28e38a00de83e15db93a9299d4f1dc64debb5a4d9f477b3e0e9afc91eb6458461ddfce076a21f1c462869145536a7fbf9056c27a86a71bc179e6531b8dac43d82d03be5a95d0c2a616f7a4227d43b244acada748ed40e1c1e1beb9522302888fbde345cf16e4fb0558ab306b8f95789a71a51597a0f985c90301b2e66c2a04e37afb0c97951e97155dbd170ded75121a83659ebc9451c63b39b92e418d4f7a7bdf43a0217d901f1a6dfea4bf4300e78402cc7073c9fadc0acb722f896c06fff03248199e448d5d6926c8af54979e4eee2adc286d4f474232fb4b47796a1fffcf18ed745cda9041460f3e0919a6d5db3835b7849d02abc0b4a64826fd0dc9e206aaf9ca87f810991e8c0654af56668cb0678ad6cb210cc7b40444180dc135ed7a270ed095b1eef1215a2d68b4704d9771d9b0ea7859e00eb9adde9d4e5917f788349bbd078b6307e0511ca87e83df87202fe3a2c7bbc34f6791b8de1bf31d06741816fc282c59658a4b6d56750162e5e45264d8719a8e2ce52acda392f8f1094aa9c0b39c79212b8e067dcdf5b195cea067d7c9e1e9bf2dda5b0b7880a4930adc9942f076fda7f9f3d78edb63d86cda70caa3b14aae015b062e37455abf04326b696a2424e5c2d9a7d679135c8e2342d4949a300d26b90308bd27fa388864b98bc781ef5a49f9aee60f3d44d7894f2f6ca21cbfe719fef0b0f2de32469e4ae241c0850ac4dcf2a922eb49772deabd8d3ab85c1b253f024ea38fe821c0da094de0c31fdcb3f87949a7b73197bacab6f8038218d28f5545ff5a626dec7f1d86c421d14eb404155e6fa153b55d2d438258faf541d657721511cec9de3d61e595014ce309f8cb4a234a1788d012821c54cd1309736212b8aebb5e16bb655d7797390869487036872f1425beccbfc5ccaf705bdffc60ec8296c72bdf473e0d44b1bd46aa00344ded1ad9c6786d60a98e7d63ed07bb4c4f8ecb56fd37e6031c5a4542678f283c67543cca4d00c0c2253b1679732a0f17cfe8586f49e6aba50435f8c89dc56ab7e7e871a92dd7ed970fe08f0b59c92caff27bd5d85031328d63</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://zronghui.github.io/categories/private/"/>
    
      <category term="2020" scheme="https://zronghui.github.io/categories/private/2020/"/>
    
      <category term="4" scheme="https://zronghui.github.io/categories/private/2020/4/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-04-26</title>
    <link href="https://zronghui.github.io/private/2020/04/2020-04-26.html"/>
    <id>https://zronghui.github.io/private/2020/04/2020-04-26.html</id>
    <published>2020-04-26T12:49:06.000Z</published>
    <updated>2020-04-26T13:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="463e988d386ee5930ad26d73f689cc0388885ff3534443996305fbb02692f413">d4ddde657b62ae9d724a3e00dfabc05a45fdaf36a8bc4373ea59463028fb879df3385b5aa616ef27884fe3774c4023a9f1eed75171bfa1c728f8656a50179f9d93ca024c3031f1e68166aae0629e18bebf76bfe8f8cf24e39f6770abe1ba7cff87c2130409ac0aa6b021b630b1f4b827cc3a90f58a0f306bc9e20ca5ada39766c3dce3bbe2f3e52a7ffec5723b8b63c99dbe54ecf5157085d5b906ffe0ea17f75f933aa7a944ecb8e5c1864ea6f662cc5120cf1f72c93942e0bd10fc692bc1bd20687ddaee40d171464f121c4da1af20c1f83fb05a86f36f3c6aee69dc27f4d2037df904568f8e2202b6e7ff88cf9978b84cec5394b3f1c584cc0e0783a99a597f1db06b3f4633e59eb4939cab264cd90d12982f3be71287d2f473715bbc789ef7c5eebf4fa1d55be0ef3da4408164cc8e5d407dd035f171af6716be6c899fd4f9f4758e6a8236894a2d73ad407135c6d67e49492731440dc940ef622a8bcd2b83730f8ed6265ce29b773399ff0d8c122e25316647b55add608e267499fb40336bdf1fa3e5456bc26273bf477f565fc0591d7228d41693aa5fec8618031dea1ca893f52e3ecdd683c64bccc98a27e4c048bb6a139afd0dd20cce4fa76248aa6bb431d8bb9f26353b9212d8ebb5b61f933a0779c177b288d6f41d5c32b0c1fd35dec1718bc73114f99e1de766c93c1ab145820639369a729013d77196f7ad0e1203d003faf4e2ac23088eeee9d827c307a8edd1031184f132c9b3e8685a3f46fc2343545ec8cd6d4f2204b35340cb83bd708ff37aed312712f4d22f358a7a63b5a204c2bcc449dec12468718002c8f38d314d78c1766e7c8bf5c8641edc268b402684a908891e0e97470d9aa5a5dc9a7f4f0a03cb329a87fc8569628f62f5313b6176d81a0ead2eda70aff13b9f980f0035852a0e2fe473551c617f5eb4f2a77aa82b8ecb4cc4bce38bf036858743f62f57d34ebb16b6af39fdcdf262c245a07475af1a2ea763ad7fd5d6db94767cc84feaef8f39eb92d74206c804ed44a9c8af</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="private" scheme="https://zronghui.github.io/categories/private/"/>
    
      <category term="2020" scheme="https://zronghui.github.io/categories/private/2020/"/>
    
      <category term="4" scheme="https://zronghui.github.io/categories/private/2020/4/"/>
    
    
  </entry>
  
  <entry>
    <title>08-KDE Connector</title>
    <link href="https://zronghui.github.io/Mac/08-KDE-Connector.html"/>
    <id>https://zronghui.github.io/Mac/08-KDE-Connector.html</id>
    <published>2020-04-23T09:13:32.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><p><a href="https://kde.inoki.cc/2019/09/01/KDE-Connect-macOS-GSoC-Final-Release/">KDE Connect macOS Release | Inoki in KDE</a><br><a href="https://github.com/Inokinoki/kde-blog/releases">Releases · Inokinoki/kde-blog</a></p><p>官方发行Mac 版本</p><p><a href="https://binary-factory.kde.org/view/MacOS/job/kdeconnect-kde_Release_macos/">kdeconnect-kde_Release_macos [Jenkins]</a></p><p><a href="https://github.com/KDE/kdeconnect-kde">KDE/kdeconnect-kde: KDE Connect adds communication between KDE and your smartphone.</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://zronghui.github.io/categories/Mac/"/>
    
    
  </entry>
  
  <entry>
    <title>blockchain-02</title>
    <link href="https://zronghui.github.io/blockchain/blockchain-02.html"/>
    <id>https://zronghui.github.io/blockchain/blockchain-02.html</id>
    <published>2020-04-23T08:39:38.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="非文本文件如何存储-、数据是存储在哪里的、分布式存储在第三方机构和传统方式有何区别"><a href="#非文本文件如何存储-、数据是存储在哪里的、分布式存储在第三方机构和传统方式有何区别" class="headerlink" title="非文本文件如何存储 、数据是存储在哪里的、分布式存储在第三方机构和传统方式有何区别"></a>非文本文件如何存储 、数据是存储在哪里的、分布式存储在第三方机构和传统方式有何区别</h2><p>按照区块链专家 Wulf Kaal 教授的说法，去中心化的存储选项有这些：</p><ul><li>把一切都存储在区块链中</li><li>对等文件系统（Peer to peer file system），如 IPFS</li><li>去中心化云文件存储，如 Storj，Sia，Ethereum，Swarm 等等</li><li>分布式数据库，如 Apache Cassandra，Rethink DB 等等</li><li>巨链数据库（BigChainDB）</li><li>Ties DB， 分布式结构化数据存储的第一个公共数据库</li></ul><h3 id="1-把一切都存储在区块链中"><a href="#1-把一切都存储在区块链中" class="headerlink" title="1.把一切都存储在区块链中"></a>1.把一切都存储在区块链中</h3><p><strong>优点</strong>：</p><p>最简单</p><p><strong>缺点</strong>：</p><p>区块链交易确认缓慢【对于汇款来说，它似乎很快（每个人都可以等），但是，对于丰富的应用程序数据流来说，它实在是太慢了】</p><p>不可变【不可变性是区块链的优势，它给了区块链高稳健性，但是对于数据存储来说却是个弱点，造成了容量问题】</p><p>总结：</p><p>因此，在区块链中存储数据对于丰富的去中心化应用程序来说，不是个好选择</p><p>一般在块上记录交易数据/日志</p><h3 id="2-对等文件系统（Peer-to-peer-file-system），如-IPFS"><a href="#2-对等文件系统（Peer-to-peer-file-system），如-IPFS" class="headerlink" title="2.对等文件系统（Peer to peer file system），如 IPFS"></a>2.对等文件系统（Peer to peer file system），如 IPFS</h3><p><strong>数据存放在任何人的主机上</strong></p><p>这个技术建立在 BitTorrent 协议和分布式哈希表（Distributed Hash Table）的基础之上</p><p><strong>优点</strong>：速度快</p><p><strong>缺点</strong>：如果你要分享文件，就得保持在线；一旦上传，它们就不能被修改或删除；不能通过其有意义的内容来搜索它们</p><h3 id="3-去中心化云文件存储，如-Storj，Sia，Ethereum，Swarm-等等"><a href="#3-去中心化云文件存储，如-Storj，Sia，Ethereum，Swarm-等等" class="headerlink" title="3.去中心化云文件存储，如 Storj，Sia，Ethereum，Swarm 等等"></a>3.去中心化云文件存储，如 Storj，Sia，Ethereum，Swarm 等等</h3><p>用户出租硬盘空间，<strong>数据是托管在用户的计算机上</strong></p><p>从用户的角度来看，这些存储就是像 Dropbox 那样的云存储</p><p><strong>优点</strong>：你不再需要保持在线就能分享你的文件，<strong>只需上传文件，就可以在云中使用</strong>了；这些存储非常<strong>可靠，速度快，容量大</strong>。但是它们只提供静态文件，也<strong>没有内容搜索</strong>，</p><p><strong>缺点</strong>：还因为它们都是建立在租用的硬件上，所以不是免费的。</p><h3 id="4-分布式数据库，如-Apache-Cassandra，Rethink-DB-等等"><a href="#4-分布式数据库，如-Apache-Cassandra，Rethink-DB-等等" class="headerlink" title="4.分布式数据库，如 Apache Cassandra，Rethink DB 等等"></a>4.分布式数据库，如 Apache Cassandra，Rethink DB 等等</h3><p><strong>优点</strong>：速度快、可扩展、容错、支持丰富的查询语言</p><p><strong>缺点</strong>：不是拜占庭证明（集群中的所有节点相互之间完全信任。因此，任何一个恶意节点就能毁掉整个数据库）</p><h3 id="5-巨链数据库（BigChainDB）"><a href="#5-巨链数据库（BigChainDB）" class="headerlink" title="5.巨链数据库（BigChainDB）"></a>5.巨链数据库（BigChainDB）</h3><p><strong>优点</strong>：可以解决数据存储和交易速度问题、拥有巨大的数据容量和非常快的交易</p><p><strong>缺点</strong>：不是拜占庭证明</p><p>巨链数据库可能对私有区块链很有用（足够信任自己内部的节点）</p><h3 id="6-Ties-DB，-分布式结构化数据存储的第一个公共数据库"><a href="#6-Ties-DB，-分布式结构化数据存储的第一个公共数据库" class="headerlink" title="6.Ties DB， 分布式结构化数据存储的第一个公共数据库"></a>6.Ties DB， 分布式结构化数据存储的第一个公共数据库</h3><p>这是目前最好的公共数据库的可选项</p><p><strong>优点</strong>：任何用户都有数据库写入权限。但是，用户由他们的公钥识别，同时，所有的请求有签名。创建之后，记录记住它的创建者，创建者则成为记录的所有者。之后，<strong>记录只能被记录所有者修改</strong>。每个人都可以阅读所有的记录，因为<strong>数据库是公开的</strong>。根据请求和复制检查所有的权限。额外的权限可以通过智能合约管理。</p><h3 id="其他信息："><a href="#其他信息：" class="headerlink" title="其他信息："></a>其他信息：</h3><p>区块链的成本高，因此尽可能保持你的区块链最小化是非常重要的</p><p>采用区块链技术的主要驱动力一直是安全性</p><p>区块链中，数据透明，可能引发隐私问题，另一方面便于分析 客户/用户 的行为模式</p><p>尽管现在数据库很便宜，但在考虑各方面的问题后，商业和金融领域是最适合用死贵的区块链来存储数据的</p><p>智能合约是指在某些触发条件下自动执行的迷你程序。在区块链世界中，某些区块链技术，特别是以太坊，支持在插入新事务时执行代码</p><h2 id="数据治理的应用场景"><a href="#数据治理的应用场景" class="headerlink" title="数据治理的应用场景"></a>数据治理的应用场景</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数据治理：是对数据资产管理行使权力和控制的活动集合</p><p>ITSS WG1认为数据治理包含以下几方面内容<br>（1）确保信息利益相关者的需要评估，以达成一致的企业目标，这些企业目标需要通过对信息资源的获取和管理实现；<br>（2）确保有效助力业务的决策机制和方向；<br>（3）确保绩效和合规进行监督。</p><p>从目的来讲，数据治理就是要<strong>对数据的获取、处理、使用进行监管</strong>（监管就是我们在执行层面对信息系统的负反馈），而监管的职能主要通过以下五个方面的执行力来保证——发现、监督、控制、沟通、整合。</p><p><strong>个人理解</strong>：企业收集并管理数据；企业分析数据，用来辅助决策；企业监管、监督数据，确保安全性</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2ODQzNzAyNQ==&mid=2247483817&idx=1&sn=65651edc7ac6508d65c5eecd2da0d928&chksm=fc8cb1e7cbfb38f1fbb9af73f0470c14d758344a28aba613f96476d322a4122657299abf4c04&scene=27#wechat_redirect">数据库那么便宜，为何还要死贵的区块链来存储数据？</a></p><p><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86">数据治理_百度百科</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&mid=2649968514&idx=1&sn=4f0734265a897e0ca2441139af3d99a3&chksm=beca3f8489bdb6923e4e3736a2e9798e0992ebde1aac0479356713ccb5575b9efc179a89d9f9&scene=27#wechat_redirect">区块链存储，现在的做法可能都错了！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="blockchain" scheme="https://zronghui.github.io/categories/blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>fe-tricks</title>
    <link href="https://zronghui.github.io/frontEnd/fe-tricks.html"/>
    <id>https://zronghui.github.io/frontEnd/fe-tricks.html</id>
    <published>2020-04-23T04:31:25.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="值得每日学习的-fe-资源"><a href="#值得每日学习的-fe-资源" class="headerlink" title="值得每日学习的 fe 资源"></a>值得每日学习的 fe 资源</h2><p><a href="https://github.com/haizlin/fe-interview">haizlin/fe-interview: 前端面试每日 3+1，以面试题来驱动学习，提倡每日学习与思考，每天进步一点！每天早上5点纯手工发布面试题（死磕自己，愉悦大家）</a><br><a href="https://github.com/haizlin/fe-interview/blob/master/category/skill.md">fe-interview/skill.md at master · haizlin/fe-interview</a></p><h3 id="响应式和自适应"><a href="#响应式和自适应" class="headerlink" title="响应式和自适应"></a>响应式和自适应</h3><p><a href="https://juejin.im/entry/58b6414a128fe1006421bfa7">响应式和自适应的区别 - 前端 - 掘金</a><br><a href="https://segmentfault.com/a/1190000015759719">(12) 自适应页面的实现方式 - 前端开发 - SegmentFault 思否</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">800px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.search_engines</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">25%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">20%</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完 CSS 后，需要重命名css, 如 moon.m.0001.css  0001 是版本号，这样可以让浏览器强制加载新的 CSS</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="frontEnd" scheme="https://zronghui.github.io/categories/frontEnd/"/>
    
    
  </entry>
  
  <entry>
    <title>信息系统实训-中期PPT</title>
    <link href="https://zronghui.github.io/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD/%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD-%E4%B8%AD%E6%9C%9FPPT.html"/>
    <id>https://zronghui.github.io/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD/%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD-%E4%B8%AD%E6%9C%9FPPT.html</id>
    <published>2020-04-20T04:40:09.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><hr><p>theme: gaia<br>_class: lead<br>paginate: true<br>backgroundColor: #fff<br>backgroundImage: url(‘<a href="https://marp.app/assets/hero-background.jpg&#39;">https://marp.app/assets/hero-background.jpg&#39;</a>)<br>marp: true</p><hr><h1 id="书籍搜索引擎"><a href="#书籍搜索引擎" class="headerlink" title="书籍搜索引擎"></a>书籍搜索引擎</h1><p>by 张荣辉-2019140740</p><hr><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><table><thead><tr><th>网站</th><th>类型</th><th>爬取条数（共 18w 条）</th></tr></thead><tbody><tr><td><a href="http://www.zxcs.me/">知轩藏书</a></td><td>网络小说</td><td>9976</td></tr><tr><td><a href="http://www.java1234.com/">Java知识分享网</a></td><td>计算机书籍</td><td>9441</td></tr><tr><td><a href="https://www.shudan.vip/">书单网</a></td><td>各种书籍</td><td>159335</td></tr><tr><td><a href="http://slfswh.xiangzhan.com/">读书皮</a></td><td>畅销流行书籍</td><td>899</td></tr><tr><td><a href="https://volmoe.com/">Vol.moe</a></td><td>漫画</td><td>8482</td></tr></tbody></table><hr><h1 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h1><img src="https://i.loli.net/2020/04/20/AoV5KxGqwUO1CWl.png" alt="AoV5KxGqwUO1CWl" style="zoom:33%;" /><hr><h1 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h1><p><img src="https://i.loli.net/2020/04/20/kUVtjuwmRXqS8xs.png" alt="kUVtjuwmRXqS8xs"></p><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><input disabled="" type="checkbox"> 来源网站过滤</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="研究生课程" scheme="https://zronghui.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="信息系统实训" scheme="https://zronghui.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD/"/>
    
      <category term="提交作业" scheme="https://zronghui.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%AE%AD/%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>斐讯K2路由刷机</title>
    <link href="https://zronghui.github.io/other/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7%E6%9C%BA.html"/>
    <id>https://zronghui.github.io/other/%E6%96%90%E8%AE%AFK2%E8%B7%AF%E7%94%B1%E5%88%B7%E6%9C%BA.html</id>
    <published>2020-04-20T00:03:32.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><ol><li>手机上连接无线网，查看无线网详情，可以看到路由器配置地址</li><li>手动更新 刷V22.6.526.199官方固件</li><li>刷入Breed</li><li>刷入第三方固件 </li></ol><p><a href="http://www.upantool.com/gujian/phicomm/14035.html">斐讯K2 V22.6.526.199官方固件-刷机备用下载-斐讯固件-U盘量产网</a></p><p><a href="https://tbvv.net/posts/0101-breed.html">斐讯K1、K2、K2P 刷机、刷入Breed 辅助工具 | tb</a></p><p><a href="https://github.com/moonjoin/k2-firmware">moonjoin/k2-firmware: 斐讯K2刷机，固件，breed</a></p><img src="https://i.loli.net/2020/04/20/bTgrHKL3CG8sZjy.png" alt="bTgrHKL3CG8sZjy" style="zoom:50%;" /><h3 id="桥接设置"><a href="#桥接设置" class="headerlink" title="桥接设置"></a>桥接设置</h3><p><img src="https://i.loli.net/2020/04/20/OUWHJBLTlC37ndN.png" alt="OUWHJBLTlC37ndN"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://zronghui.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>biweekly-contest-24</title>
    <link href="https://zronghui.github.io/biweekly-contest-24.html"/>
    <id>https://zronghui.github.io/biweekly-contest-24.html</id>
    <published>2020-04-19T01:56:34.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 64. Minimum Path Sum</title>
    <link href="https://zronghui.github.io/leetcode/leetcode-6**/leetcode-64-Minimum-Path-Sum.html"/>
    <id>https://zronghui.github.io/leetcode/leetcode-6**/leetcode-64-Minimum-Path-Sum.html</id>
    <published>2020-04-18T10:29:46.000Z</published>
    <updated>2020-04-25T16:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-path-sum/">leetcode</a><br><a href="https://www.jiuzhang.com/solution/minimum-path-sum/">九章</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top<br>left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p><p><strong>Example:</strong></p><pre><code>Input:[  [1,3,1],  [1,5,1],  [4,2,1]]Output: 7Explanation: Because the path 1-&gt;3-&gt;1-&gt;1-&gt;1 minimizes the sum.</code></pre><p><strong>Tags:</strong> Array, Dynamic Programming</p><p><strong>Difficulty:</strong> Medium</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 3. dp</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j==<span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">#  1. 简单的递归</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum1</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(grid, n, m, i, j)</span>:</span></span><br><span class="line">            res = grid[i][j]</span><br><span class="line">            <span class="keyword">if</span> i==n<span class="number">-1</span> <span class="keyword">and</span> j==m<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res + helper(grid, n, m, i, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> j==m<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res + helper(grid, n, m, i+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">return</span> res + min(helper(grid, n, m, i, j+<span class="number">1</span>), helper(grid, n, m, i+<span class="number">1</span>, j))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> helper(grid, len(grid), len(grid[<span class="number">0</span>]), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 递归 + 存储 递归过程值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum2</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]<span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(grid, n, m, i, j)</span>:</span></span><br><span class="line">            res = grid[i][j]</span><br><span class="line">            <span class="keyword">if</span> i==n<span class="number">-1</span> <span class="keyword">and</span> j==m<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> i==n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> cache[i][j+<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> res+cache[i][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t = helper(grid, n, m, i, j+<span class="number">1</span>)</span><br><span class="line">                    cache[i][j+<span class="number">1</span>] = t</span><br><span class="line">                    <span class="keyword">return</span> res + t</span><br><span class="line">            <span class="keyword">elif</span> j==m<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> cache[i+<span class="number">1</span>][j]:</span><br><span class="line">                    <span class="keyword">return</span> res+cache[i+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t = helper(grid, n, m, i+<span class="number">1</span>, j)</span><br><span class="line">                    cache[i+<span class="number">1</span>][j] = t</span><br><span class="line">                    <span class="keyword">return</span> res + t</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> cache[i][j+<span class="number">1</span>]:</span><br><span class="line">                t1 = cache[i][j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t1 = helper(grid, n, m, i, j+<span class="number">1</span>)</span><br><span class="line">                cache[i][j+<span class="number">1</span>] = t1</span><br><span class="line">            <span class="keyword">if</span> cache[i+<span class="number">1</span>][j]:</span><br><span class="line">                t2 = cache[i+<span class="number">1</span>][j] </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t2 = helper(grid, n, m, i+<span class="number">1</span>, j)</span><br><span class="line">                cache[i+<span class="number">1</span>][j] = t2</span><br><span class="line">            <span class="keyword">return</span> res + min(t1, t2)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> helper(grid, n, m, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-path-sum/&quot;&gt;leetcode&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jiuzhang.com/solution/minimum-path-sum/&quot;&gt;九章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Given a &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; grid filled with non-negative numbers, find a path from top&lt;br&gt;left to bottom right which &lt;em&gt;minimizes&lt;/em&gt; the sum of all numbers along its path.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You can only move either down or right at any point in time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1-&amp;gt;3-&amp;gt;1-&amp;gt;1-&amp;gt;1 minimizes the sum.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tags:&lt;/strong&gt; Array, Dynamic Programming&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Difficulty:&lt;/strong&gt; Medium&lt;/p&gt;
&lt;h2 id=&quot;答案&quot;&gt;&lt;a href=&quot;#答案&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zronghui.github.io/categories/leetcode/"/>
    
      <category term="leetcode-6**" scheme="https://zronghui.github.io/categories/leetcode/leetcode-6/"/>
    
    
      <category term="Array" scheme="https://zronghui.github.io/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://zronghui.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
